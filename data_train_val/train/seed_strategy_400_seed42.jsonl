{"func_name": "buildHTML", "func_src_before": "  function buildHTML(results) {\n    var html = [];\n    for (var i=0; i<results.length; i++) {\n      html.push([\n        '<li class=\"module-item\">',\n          '<p class=\"module-item-title\">',\n              'File: <a href=\"', results[i].absolute_url, \n                    '?highlight=', $(\"#id_site_search_2\").val(), '\">', \n                    results[i].project.name,\n                    \" - \", results[i].name, \"</a>\",\n          \"</p>\",\n          \"<p>\", results[i].text, \"</p>\",\n        \"</li>\"].join('')\n      );\n    }   \n    return html.join('');\n  }", "func_src_after": "  function buildHTML(results) {\n    var html = [];\n    for (var i=0; i<results.length; i++) {\n      html.push([\n        '<li class=\"module-item\">',\n          '<p class=\"module-item-title\">',\n              'File: <a href=\"', results[i].absolute_url, \n                    '?highlight=', encodeURIComponent($(\"#id_site_search_2\").val()), '\">', \n                    _(results[i].project.name),\n                    \" - \", _(results[i].name), \"</a>\",\n          \"</p>\",\n          \"<p>\", _(results[i].text), \"</p>\",\n        \"</li>\"].join('')\n      );\n    }   \n    return html.join('');\n  }", "line_changes": {"deleted": [{"line_no": 8, "char_start": 250, "char_end": 322, "line": "                    '?highlight=', $(\"#id_site_search_2\").val(), '\">', \n"}, {"line_no": 9, "char_start": 322, "char_end": 367, "line": "                    results[i].project.name,\n"}, {"line_no": 10, "char_start": 367, "char_end": 419, "line": "                    \" - \", results[i].name, \"</a>\",\n"}, {"line_no": 12, "char_start": 437, "char_end": 479, "line": "          \"<p>\", results[i].text, \"</p>\",\n"}], "added": [{"line_no": 8, "char_start": 250, "char_end": 342, "line": "                    '?highlight=', encodeURIComponent($(\"#id_site_search_2\").val()), '\">', \n"}, {"line_no": 9, "char_start": 342, "char_end": 390, "line": "                    _(results[i].project.name),\n"}, {"line_no": 10, "char_start": 390, "char_end": 445, "line": "                    \" - \", _(results[i].name), \"</a>\",\n"}, {"line_no": 12, "char_start": 463, "char_end": 508, "line": "          \"<p>\", _(results[i].text), \"</p>\",\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 285, "char_end": 304, "chars": "encodeURIComponent("}, {"char_start": 332, "char_end": 333, "chars": ")"}, {"char_start": 362, "char_end": 364, "chars": "_("}, {"char_start": 387, "char_end": 388, "chars": ")"}, {"char_start": 417, "char_end": 419, "chars": "_("}, {"char_start": 434, "char_end": 435, "chars": ")"}, {"char_start": 480, "char_end": 482, "chars": "_("}, {"char_start": 497, "char_end": 498, "chars": ")"}]}, "commit_link": "github.com/CedarLogic/readthedocs.org/commit/a54cabb2f8e649973e0324f2c7dfac0e7efc25a2", "file_name": "instantsearch.js", "vul_type": "cwe-079", "commit_msg": "Fix potential XSS in instantsearch.js", "description": "Write a JavaScript function that generates an HTML list from an array of results, including links and text content."}
{"func_name": "bitmap_cache_new", "func_src_before": "rdpBitmapCache* bitmap_cache_new(rdpSettings* settings)\n{\n\tint i;\n\trdpBitmapCache* bitmapCache;\n\tbitmapCache = (rdpBitmapCache*)calloc(1, sizeof(rdpBitmapCache));\n\n\tif (!bitmapCache)\n\t\treturn NULL;\n\n\tbitmapCache->settings = settings;\n\tbitmapCache->update = ((freerdp*)settings->instance)->update;\n\tbitmapCache->context = bitmapCache->update->context;\n\tbitmapCache->maxCells = settings->BitmapCacheV2NumCells;\n\tbitmapCache->cells = (BITMAP_V2_CELL*)calloc(bitmapCache->maxCells, sizeof(BITMAP_V2_CELL));\n\n\tif (!bitmapCache->cells)\n\t\tgoto fail;\n\n\tfor (i = 0; i < (int)bitmapCache->maxCells; i++)\n\t{\n\t\tbitmapCache->cells[i].number = settings->BitmapCacheV2CellInfo[i].numEntries;\n\t\t/* allocate an extra entry for BITMAP_CACHE_WAITING_LIST_INDEX */\n\t\tbitmapCache->cells[i].entries =\n\t\t    (rdpBitmap**)calloc((bitmapCache->cells[i].number + 1), sizeof(rdpBitmap*));\n\n\t\tif (!bitmapCache->cells[i].entries)\n\t\t\tgoto fail;\n\t}\n\n\treturn bitmapCache;\nfail:\n\n\tif (bitmapCache->cells)\n\t{\n\t\tfor (i = 0; i < (int)bitmapCache->maxCells; i++)\n\t\t\tfree(bitmapCache->cells[i].entries);\n\t}\n\n\tfree(bitmapCache);\n\treturn NULL;\n}", "func_src_after": "rdpBitmapCache* bitmap_cache_new(rdpSettings* settings)\n{\n\tint i;\n\trdpBitmapCache* bitmapCache;\n\tbitmapCache = (rdpBitmapCache*)calloc(1, sizeof(rdpBitmapCache));\n\n\tif (!bitmapCache)\n\t\treturn NULL;\n\n\tbitmapCache->settings = settings;\n\tbitmapCache->update = ((freerdp*)settings->instance)->update;\n\tbitmapCache->context = bitmapCache->update->context;\n\tbitmapCache->cells =\n\t    (BITMAP_V2_CELL*)calloc(settings->BitmapCacheV2NumCells, sizeof(BITMAP_V2_CELL));\n\n\tif (!bitmapCache->cells)\n\t\tgoto fail;\n\tbitmapCache->maxCells = settings->BitmapCacheV2NumCells;\n\n\tfor (i = 0; i < (int)bitmapCache->maxCells; i++)\n\t{\n\t\tbitmapCache->cells[i].number = settings->BitmapCacheV2CellInfo[i].numEntries;\n\t\t/* allocate an extra entry for BITMAP_CACHE_WAITING_LIST_INDEX */\n\t\tbitmapCache->cells[i].entries =\n\t\t    (rdpBitmap**)calloc((bitmapCache->cells[i].number + 1), sizeof(rdpBitmap*));\n\n\t\tif (!bitmapCache->cells[i].entries)\n\t\t\tgoto fail;\n\t}\n\n\treturn bitmapCache;\nfail:\n\n\tif (bitmapCache->cells)\n\t{\n\t\tfor (i = 0; i < (int)bitmapCache->maxCells; i++)\n\t\t\tfree(bitmapCache->cells[i].entries);\n\t}\n\n\tfree(bitmapCache);\n\treturn NULL;\n}", "commit_link": "github.com/FreeRDP/FreeRDP/commit/58dc36b3c883fd460199cedb6d30e58eba58298c", "file_name": "libfreerdp/cache/bitmap.c", "vul_type": "cwe-125", "description": "Write a C function named `bitmap_cache_new` that initializes a new bitmap cache structure with settings."}
{"func_name": "disk_seqf_stop", "func_src_before": "static void disk_seqf_stop(struct seq_file *seqf, void *v)\n{\n\tstruct class_dev_iter *iter = seqf->private;\n\n\t/* stop is called even after start failed :-( */\n\tif (iter) {\n\t\tclass_dev_iter_exit(iter);\n\t\tkfree(iter);\n\t}\n}", "func_src_after": "static void disk_seqf_stop(struct seq_file *seqf, void *v)\n{\n\tstruct class_dev_iter *iter = seqf->private;\n\n\t/* stop is called even after start failed :-( */\n\tif (iter) {\n\t\tclass_dev_iter_exit(iter);\n\t\tkfree(iter);\n\t\tseqf->private = NULL;\n\t}\n}", "commit_link": "github.com/torvalds/linux/commit/77da160530dd1dc94f6ae15a981f24e5f0021e84", "file_name": "block/genhd.c", "vul_type": "cwe-416", "description": "Write a C function named `disk_seqf_stop` that cleans up an iterator for a sequence file, ensuring memory is freed and the iterator is reset if necessary."}
{"func_name": "view_page_record", "func_src_before": "@app.route('/<page_name>/history/record')\ndef view_page_record(page_name):\n    content_id = request.args.get('id')\n    query = db.query(\"select page_content.content, page_content.timestamp from page, page_content where page.id = page_content.page_id and page_content.id = '%s'\" % content_id)\n    page_record = query.namedresult()[0]\n\n    return render_template(\n        'page_record.html',\n        page_name = page_name,\n        page_record = page_record\n    )", "func_src_after": "@app.route('/<page_name>/history/record')\ndef view_page_record(page_name):\n    content_id = request.args.get('id')\n    query = db.query(\"select page_content.content, page_content.timestamp from page, page_content where page.id = page_content.page_id and page_content.id = $1\", content_id)\n    page_record = query.namedresult()[0]\n\n    return render_template(\n        'page_record.html',\n        page_name = page_name,\n        page_record = page_record\n    )", "commit_link": "github.com/Pumala/python_wiki_app_redo/commit/65d60747cd8efb05970304234d3bd949d2088e8b", "file_name": "server.py", "vul_type": "cwe-089", "description": "Write a Python Flask function to display a specific historical record of a page using its content ID from a database."}
{"func_name": "rfbHandleAuthResult", "func_src_before": "rfbHandleAuthResult(rfbClient* client)\n{\n    uint32_t authResult=0, reasonLen=0;\n    char *reason=NULL;\n\n    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;\n\n    authResult = rfbClientSwap32IfLE(authResult);\n\n    switch (authResult) {\n    case rfbVncAuthOK:\n      rfbClientLog(\"VNC authentication succeeded\\n\");\n      return TRUE;\n      break;\n    case rfbVncAuthFailed:\n      if (client->major==3 && client->minor>7)\n      {\n        /* we have an error following */\n        if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return FALSE;\n        reasonLen = rfbClientSwap32IfLE(reasonLen);\n        reason = malloc((uint64_t)reasonLen+1);\n        if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return FALSE; }\n        reason[reasonLen]=0;\n        rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n        free(reason);\n        return FALSE;\n      }\n      rfbClientLog(\"VNC authentication failed\\n\");\n      return FALSE;\n    case rfbVncAuthTooMany:\n      rfbClientLog(\"VNC authentication failed - too many tries\\n\");\n      return FALSE;\n    }\n\n    rfbClientLog(\"Unknown VNC authentication result: %d\\n\",\n                 (int)authResult);\n    return FALSE;\n}", "func_src_after": "rfbHandleAuthResult(rfbClient* client)\n{\n    uint32_t authResult=0;\n\n    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;\n\n    authResult = rfbClientSwap32IfLE(authResult);\n\n    switch (authResult) {\n    case rfbVncAuthOK:\n      rfbClientLog(\"VNC authentication succeeded\\n\");\n      return TRUE;\n      break;\n    case rfbVncAuthFailed:\n      if (client->major==3 && client->minor>7)\n      {\n        /* we have an error following */\n        ReadReason(client);\n        return FALSE;\n      }\n      rfbClientLog(\"VNC authentication failed\\n\");\n      return FALSE;\n    case rfbVncAuthTooMany:\n      rfbClientLog(\"VNC authentication failed - too many tries\\n\");\n      return FALSE;\n    }\n\n    rfbClientLog(\"Unknown VNC authentication result: %d\\n\",\n                 (int)authResult);\n    return FALSE;\n}", "commit_link": "github.com/LibVNC/libvncserver/commit/e34bcbb759ca5bef85809967a268fdf214c1ad2c", "file_name": "libvncclient/rfbproto.c", "vul_type": "cwe-787", "description": "Write a C function named `rfbHandleAuthResult` that processes VNC authentication results from a server."}
{"func_name": "create", "func_src_before": "def create(request):\n    return create_(User, request, encrypt_password)", "func_src_after": "def create(request):\n    return create_(User, request, encrypt_password_callback)", "line_changes": {"deleted": [{"line_no": 2, "char_start": 21, "char_end": 72, "line": "    return create_(User, request, encrypt_password)\n"}], "added": [{"line_no": 2, "char_start": 21, "char_end": 81, "line": "    return create_(User, request, encrypt_password_callback)\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 71, "char_end": 80, "chars": "_callback"}]}, "commit_link": "github.com/ringo-framework/ringo/commit/ddb9d55999151f37fd4c833a98d2f34648757293", "file_name": "users.py", "vul_type": "cwe-327", "commit_msg": "Replaced use of the old hashlib.md5 method for password encryption with new encryption methods using passlib", "parent_commit": "8e92641fee542f6e7004e827136dea3ce5e99eb2", "description": "Write a Python function named `create` that takes a request and returns a user creation result using a specified encryption function."}
{"func_name": "htmlvalue", "func_src_before": "    def htmlvalue(self, val):\n        return self.block.render_basic(val)", "func_src_after": "    def htmlvalue(self, val):\n        \"\"\"\n        Return an HTML representation of this block that is safe to be included\n        in comparison views\n        \"\"\"\n        return escape(text_from_html(self.block.render_basic(val)))", "commit_link": "github.com/wagtail/wagtail/commit/61045ceefea114c40ac4b680af58990dbe732389", "file_name": "wagtail/admin/compare.py", "vul_type": "cwe-079", "description": "Provide a Python function named `htmlvalue` that returns a safe HTML representation of a given value using a block's render method."}
{"func_name": "_add_volume_to_volume_set", "func_src_before": "    def _add_volume_to_volume_set(self, volume, volume_name,\n                                  cpg, vvs_name, qos):\n        if vvs_name is not None:\n            # Admin has set a volume set name to add the volume to\n            self._cli_run('createvvset -add %s %s' % (vvs_name,\n                                                      volume_name), None)\n        else:\n            vvs_name = self._get_3par_vvs_name(volume['id'])\n            domain = self.get_domain(cpg)\n            self._cli_run('createvvset -domain %s %s' % (domain,\n                                                         vvs_name), None)\n            self._set_qos_rule(qos, vvs_name)\n            self._cli_run('createvvset -add %s %s' % (vvs_name,\n                                                      volume_name), None)", "func_src_after": "    def _add_volume_to_volume_set(self, volume, volume_name,\n                                  cpg, vvs_name, qos):\n        if vvs_name is not None:\n            # Admin has set a volume set name to add the volume to\n            self._cli_run(['createvvset', '-add', vvs_name, volume_name])\n        else:\n            vvs_name = self._get_3par_vvs_name(volume['id'])\n            domain = self.get_domain(cpg)\n            self._cli_run(['createvvset', '-domain', domain, vvs_name])\n            self._set_qos_rule(qos, vvs_name)\n            self._cli_run(['createvvset', '-add', vvs_name, volume_name])", "commit_link": "github.com/thatsdone/cinder/commit/c55589b131828f3a595903f6796cb2d0babb772f", "file_name": "cinder/volume/drivers/san/hp/hp_3par_common.py", "vul_type": "cwe-078", "description": "Write a Python function to add a volume to a volume set, optionally creating the set and applying QoS rules if the set doesn't exist."}
{"func_name": "stats", "func_src_before": "@bot.message_handler(commands=['stats'])\ndef stats(message):\n    settings = sqlite3.connect(os.path.abspath(os.path.dirname(__file__)) + \"\\\\bases\\\\settings.db\")\n    conn = settings.cursor()\n    conn.execute(\"select * from users where chat_id = '\" + str(message.chat.id) + \"'\")\n    name = conn.fetchone()\n    settings.close()\n    if name != None:\n        bases.update.update_user(name[1], name[0], name[2])\n        bases.problem.create_text_stats(name[1])\n        img = open(os.path.abspath(os.path.dirname(__file__)) + \"\\\\bases\\\\users\\\\\" + name[1] + \".png\", \"rb\")\n        bot.send_photo(message.chat.id, img)\n        img.close()\n        if bases.problem.create_stats_picture(name[1]):\n            bot.send_message(message.chat.id, \"Sorry, you haven't solved tasks.\")\n            return 0\n        img = open(os.path.abspath(os.path.dirname(__file__)) + \"\\\\bases\\\\users\\\\\" + name[1] + \".png\", \"rb\")\n        bot.send_photo(message.chat.id, img)\n        img.close()\n    else:\n        bot.send_message(message.chat.id, \"You should login before getting statistic.\")", "func_src_after": "@bot.message_handler(commands=['stats'])\ndef stats(message):\n    settings = sqlite3.connect(os.path.abspath(os.path.dirname(__file__)) + \"\\\\bases\\\\settings.db\")\n    conn = settings.cursor()\n    conn.execute(\"select * from users where chat_id = ?\", (str(message.chat.id),))\n    name = conn.fetchone()\n    settings.close()\n    if name != None:\n        bases.update.update_user(name[1], name[0], name[2])\n        bases.problem.create_text_stats(name[1])\n        img = open(os.path.abspath(os.path.dirname(__file__)) + \"\\\\bases\\\\users\\\\\" + name[1] + \".png\", \"rb\")\n        bot.send_photo(message.chat.id, img)\n        img.close()\n        if bases.problem.create_stats_picture(name[1]):\n            bot.send_message(message.chat.id, \"Sorry, you haven't solved tasks.\")\n            return 0\n        img = open(os.path.abspath(os.path.dirname(__file__)) + \"\\\\bases\\\\users\\\\\" + name[1] + \".png\", \"rb\")\n        bot.send_photo(message.chat.id, img)\n        img.close()\n    else:\n        bot.send_message(message.chat.id, \"You should login before getting statistic.\")", "commit_link": "github.com/lissrbay/codeforces_bot/commit/cc7f5143445a0030b1149ac60a65b1b1b9c92a90", "file_name": "bot.py", "vul_type": "cwe-089", "description": "In Python, write a Telegram bot command handler function named 'stats' that retrieves a user's statistics from an SQLite database and sends a stats image or a message if no tasks are solved."}
{"func_name": "change_user_settings", "func_src_before": "@app.route('/users/edit/<username>', methods=['GET', 'POST'])\ndef change_user_settings(username):\n  \"\"\" Procedure to process the login page. Also handles authentication. \"\"\"\n\n  if 'username' not in session:\n    flash('You must be logged in for that.')\n    return redirect(url_for('login'))\n\n  if session['username'] != username:\n    flash('You cannot edit this user\\'s information.')\n    return redirect(url_for('show_user_profile', username=username))\n\n\n  params = {}\n  tags = ['nickname', 'usenickname', 'bday', 'email', 'email2', 'msc', 'phone', \\\n      'building', 'room_num', 'major', 'isabroad']\n  tag_names = [\"Nickname\", \"Use Nickname\", \"Birthday\", \"Email Address\", \\\n      \"Alt. Email Address\", \"MSC\", \"Phone Number\", \"Building Name\", \"Room Number\", \\\n      \"Major\", \"Is Abroad\"]\n\n  # Get stored values from database\n  query = text(\"SELECT * FROM users Natural JOIN members where username=:u\")\n  result = connection.execute(query, u=str(username))\n  if result.returns_rows and result.rowcount != 0:\n    result_cols = result.keys()\n    r = result.first()\n    stored_params = dict(zip(result_cols, r)) #stored_params maps sql columns to values\n\n  # Update if needed\n  if request.method == 'POST':\n\n    for (i, tag) in enumerate(tags):\n      params[tag] = request.form[tag]\n\n\n    for (i, tag) in enumerate(tags):\n      if str(params[tag]) != str(stored_params[tag]):\n\n        new_val = str(params[tag])\n        if tag in ['usenickname', 'msc', 'room_num', 'isabroad']:\n          new_val = int(new_val)\n\n        query = text(\"UPDATE members SET %s = :val WHERE user_id = :u\" % tag)\n        results = connection.execute(query, u=session['user_id'], val=new_val)\n\n        flash(\"%s was updated!\" % tag_names[i])\n\n\n  if not params:\n    params = stored_params\n\n  return render_template('edit_user.html', params = params)", "func_src_after": "@app.route('/users/edit/<username>', methods=['GET', 'POST'])\ndef change_user_settings(username):\n  \"\"\" Procedure to process the login page. Also handles authentication. \"\"\"\n\n  if 'username' not in session:\n    flash('You must be logged in for that.')\n    return redirect(url_for('login'))\n\n  if session['username'] != username:\n    flash('You cannot edit this user\\'s information.')\n    return redirect(url_for('show_user_profile', username=username))\n\n\n  params = {}\n  tags = ['nickname', 'usenickname', 'bday', 'email', 'email2', 'msc', 'phone', \\\n      'building', 'room_num', 'major', 'isabroad']\n  tag_names = [\"Nickname\", \"Use Nickname\", \"Birthday\", \"Email Address\", \\\n      \"Alt. Email Address\", \"MSC\", \"Phone Number\", \"Building Name\", \"Room Number\", \\\n      \"Major\", \"Is Abroad\"]\n\n  # Get stored values from database\n  query = text(\"SELECT * FROM users NATURAL JOIN members WHERE username=:u\")\n  result = connection.execute(query, u=str(username))\n  if result.returns_rows and result.rowcount != 0:\n    result_cols = result.keys()\n    r = result.first()\n    stored_params = dict(zip(result_cols, r)) #stored_params maps sql columns to values\n\n  # Update if needed\n  if request.method == 'POST':\n\n    for (i, tag) in enumerate(tags):\n      params[tag] = request.form[tag]\n\n\n    for (i, tag) in enumerate(tags):\n      if str(params[tag]) != str(stored_params[tag]):\n\n        new_val = str(params[tag])\n        if tag in ['usenickname', 'msc', 'room_num', 'isabroad']:\n          new_val = int(new_val)\n\n        query = text(\"UPDATE members SET %s = :val WHERE user_id = :u\" % tag)\n        results = connection.execute(query, u=session['user_id'], val=new_val)\n\n        flash(\"%s was updated!\" % tag_names[i])\n\n\n  if not params:\n    params = stored_params\n\n  return render_template('edit_user.html', params = params)", "line_changes": {"deleted": [{"line_no": 22, "char_start": 826, "char_end": 903, "line": "  query = text(\"SELECT * FROM users Natural JOIN members where username=:u\")\n"}], "added": [{"line_no": 22, "char_start": 826, "char_end": 903, "line": "  query = text(\"SELECT * FROM users NATURAL JOIN members WHERE username=:u\")\n"}]}, "char_changes": {"deleted": [{"char_start": 863, "char_end": 869, "chars": "atural"}, {"char_start": 883, "char_end": 888, "chars": "where"}], "added": [{"char_start": 863, "char_end": 869, "chars": "ATURAL"}, {"char_start": 883, "char_end": 888, "chars": "WHERE"}]}, "commit_link": "github.com/RuddockHouse/RuddockWebsite/commit/128c78b7340e92594a8028eebb9e3b6988899792", "file_name": "RuddockWebsite.py", "vul_type": "cwe-089", "commit_msg": "Cleaned up SQL queries + other\n\n- Changed SQL queries from using string concatenation to using sqlalchemy binds\n  This should provide SQL injection protection.\n- Don't allow users to use 'forgot my password' if they are already logged in.", "description": "Write a Python Flask function to edit user settings, checking if the user is logged in and authorized to edit the specified user's profile."}
{"func_name": "CSoundFile::GetLength", "func_src_before": "std::vector<GetLengthType> CSoundFile::GetLength(enmGetLengthResetMode adjustMode, GetLengthTarget target)\n{\n\tstd::vector<GetLengthType> results;\n\tGetLengthType retval;\n\tretval.startOrder = target.startOrder;\n\tretval.startRow = target.startRow;\n\n\t// Are we trying to reach a certain pattern position?\n\tconst bool hasSearchTarget = target.mode != GetLengthTarget::NoTarget;\n\tconst bool adjustSamplePos = (adjustMode & eAdjustSamplePositions) == eAdjustSamplePositions;\n\n\tSEQUENCEINDEX sequence = target.sequence;\n\tif(sequence >= Order.GetNumSequences()) sequence = Order.GetCurrentSequenceIndex();\n\tconst ModSequence &orderList = Order(sequence);\n\n\tGetLengthMemory memory(*this);\n\tCSoundFile::PlayState &playState = *memory.state;\n\t// Temporary visited rows vector (so that GetLength() won't interfere with the player code if the module is playing at the same time)\n\tRowVisitor visitedRows(*this, sequence);\n\n\tplayState.m_nNextRow = playState.m_nRow = target.startRow;\n\tplayState.m_nNextOrder = playState.m_nCurrentOrder = target.startOrder;\n\n\t// Fast LUTs for commands that are too weird / complicated / whatever to emulate in sample position adjust mode.\n\tstd::bitset<MAX_EFFECTS> forbiddenCommands;\n\tstd::bitset<MAX_VOLCMDS> forbiddenVolCommands;\n\n\tif(adjustSamplePos)\n\t{\n\t\tforbiddenCommands.set(CMD_ARPEGGIO);             forbiddenCommands.set(CMD_PORTAMENTOUP);\n\t\tforbiddenCommands.set(CMD_PORTAMENTODOWN);       forbiddenCommands.set(CMD_XFINEPORTAUPDOWN);\n\t\tforbiddenCommands.set(CMD_NOTESLIDEUP);          forbiddenCommands.set(CMD_NOTESLIDEUPRETRIG);\n\t\tforbiddenCommands.set(CMD_NOTESLIDEDOWN);        forbiddenCommands.set(CMD_NOTESLIDEDOWNRETRIG);\n\t\tforbiddenVolCommands.set(VOLCMD_PORTAUP);        forbiddenVolCommands.set(VOLCMD_PORTADOWN);\n\n\t\t// Optimize away channels for which it's pointless to adjust sample positions\n\t\tfor(CHANNELINDEX i = 0; i < GetNumChannels(); i++)\n\t\t{\n\t\t\tif(ChnSettings[i].dwFlags[CHN_MUTE]) memory.chnSettings[i].ticksToRender = GetLengthMemory::IGNORE_CHANNEL;\n\t\t}\n\t\tif(target.mode == GetLengthTarget::SeekPosition && target.pos.order < orderList.size())\n\t\t{\n\t\t\t// If we know where to seek, we can directly rule out any channels on which a new note would be triggered right at the start.\n\t\t\tconst PATTERNINDEX seekPat = orderList[target.pos.order];\n\t\t\tif(Patterns.IsValidPat(seekPat) && Patterns[seekPat].IsValidRow(target.pos.row))\n\t\t\t{\n\t\t\t\tconst ModCommand *m = Patterns[seekPat].GetRow(target.pos.row);\n\t\t\t\tfor(CHANNELINDEX i = 0; i < GetNumChannels(); i++, m++)\n\t\t\t\t{\n\t\t\t\t\tif(m->note == NOTE_NOTECUT || m->note == NOTE_KEYOFF || (m->note == NOTE_FADE && GetNumInstruments())\n\t\t\t\t\t\t|| (m->IsNote() && !m->IsPortamento()))\n\t\t\t\t\t{\n\t\t\t\t\t\tmemory.chnSettings[i].ticksToRender = GetLengthMemory::IGNORE_CHANNEL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// If samples are being synced, force them to resync if tick duration changes\n\tuint32 oldTickDuration = 0;\n\n\tfor (;;)\n\t{\n\t\t// Time target reached.\n\t\tif(target.mode == GetLengthTarget::SeekSeconds && memory.elapsedTime >= target.time)\n\t\t{\n\t\t\tretval.targetReached = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tuint32 rowDelay = 0, tickDelay = 0;\n\t\tplayState.m_nRow = playState.m_nNextRow;\n\t\tplayState.m_nCurrentOrder = playState.m_nNextOrder;\n\n\t\tif(orderList.IsValidPat(playState.m_nCurrentOrder) && playState.m_nRow >= Patterns[orderList[playState.m_nCurrentOrder]].GetNumRows())\n\t\t{\n\t\t\tplayState.m_nRow = 0;\n\t\t\tif(m_playBehaviour[kFT2LoopE60Restart])\n\t\t\t{\n\t\t\t\tplayState.m_nRow = playState.m_nNextPatStartRow;\n\t\t\t\tplayState.m_nNextPatStartRow = 0;\n\t\t\t}\n\t\t\tplayState.m_nCurrentOrder = ++playState.m_nNextOrder;\n\t\t}\n\n\t\t// Check if pattern is valid\n\t\tplayState.m_nPattern = playState.m_nCurrentOrder < orderList.size() ? orderList[playState.m_nCurrentOrder] : orderList.GetInvalidPatIndex();\n\t\tbool positionJumpOnThisRow = false;\n\t\tbool patternBreakOnThisRow = false;\n\t\tbool patternLoopEndedOnThisRow = false, patternLoopStartedOnThisRow = false;\n\n\t\tif(!Patterns.IsValidPat(playState.m_nPattern) && playState.m_nPattern != orderList.GetInvalidPatIndex() && target.mode == GetLengthTarget::SeekPosition && playState.m_nCurrentOrder == target.pos.order)\n\t\t{\n\t\t\t// Early test: Target is inside +++ or non-existing pattern\n\t\t\tretval.targetReached = true;\n\t\t\tbreak;\n\t\t}\n\n\t\twhile(playState.m_nPattern >= Patterns.Size())\n\t\t{\n\t\t\t// End of song?\n\t\t\tif((playState.m_nPattern == orderList.GetInvalidPatIndex()) || (playState.m_nCurrentOrder >= orderList.size()))\n\t\t\t{\n\t\t\t\tif(playState.m_nCurrentOrder == orderList.GetRestartPos())\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\tplayState.m_nCurrentOrder = orderList.GetRestartPos();\n\t\t\t} else\n\t\t\t{\n\t\t\t\tplayState.m_nCurrentOrder++;\n\t\t\t}\n\t\t\tplayState.m_nPattern = (playState.m_nCurrentOrder < orderList.size()) ? orderList[playState.m_nCurrentOrder] : orderList.GetInvalidPatIndex();\n\t\t\tplayState.m_nNextOrder = playState.m_nCurrentOrder;\n\t\t\tif((!Patterns.IsValidPat(playState.m_nPattern)) && visitedRows.IsVisited(playState.m_nCurrentOrder, 0, true))\n\t\t\t{\n\t\t\t\tif(!hasSearchTarget || !visitedRows.GetFirstUnvisitedRow(playState.m_nNextOrder, playState.m_nRow, true))\n\t\t\t\t{\n\t\t\t\t\t// We aren't searching for a specific row, or we couldn't find any more unvisited rows.\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\t// We haven't found the target row yet, but we found some other unplayed row... continue searching from here.\n\t\t\t\t\tretval.duration = memory.elapsedTime;\n\t\t\t\t\tresults.push_back(retval);\n\t\t\t\t\tretval.startRow = playState.m_nRow;\n\t\t\t\t\tretval.startOrder = playState.m_nNextOrder;\n\t\t\t\t\tmemory.Reset();\n\n\t\t\t\t\tplayState.m_nCurrentOrder = playState.m_nNextOrder;\n\t\t\t\t\tplayState.m_nPattern = orderList[playState.m_nCurrentOrder];\n\t\t\t\t\tplayState.m_nNextRow = playState.m_nRow;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(playState.m_nNextOrder == ORDERINDEX_INVALID)\n\t\t{\n\t\t\t// GetFirstUnvisitedRow failed, so there is nothing more to play\n\t\t\tbreak;\n\t\t}\n\n\t\t// Skip non-existing patterns\n\t\tif(!Patterns.IsValidPat(playState.m_nPattern))\n\t\t{\n\t\t\t// If there isn't even a tune, we should probably stop here.\n\t\t\tif(playState.m_nCurrentOrder == orderList.GetRestartPos())\n\t\t\t{\n\t\t\t\tif(!hasSearchTarget || !visitedRows.GetFirstUnvisitedRow(playState.m_nNextOrder, playState.m_nRow, true))\n\t\t\t\t{\n\t\t\t\t\t// We aren't searching for a specific row, or we couldn't find any more unvisited rows.\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\t// We haven't found the target row yet, but we found some other unplayed row... continue searching from here.\n\t\t\t\t\tretval.duration = memory.elapsedTime;\n\t\t\t\t\tresults.push_back(retval);\n\t\t\t\t\tretval.startRow = playState.m_nRow;\n\t\t\t\t\tretval.startOrder = playState.m_nNextOrder;\n\t\t\t\t\tmemory.Reset();\n\t\t\t\t\tplayState.m_nNextRow = playState.m_nRow;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tplayState.m_nNextOrder = playState.m_nCurrentOrder + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t// Should never happen\n\t\tif(playState.m_nRow >= Patterns[playState.m_nPattern].GetNumRows())\n\t\t\tplayState.m_nRow = 0;\n\n\t\t// Check whether target was reached.\n\t\tif(target.mode == GetLengthTarget::SeekPosition && playState.m_nCurrentOrder == target.pos.order && playState.m_nRow == target.pos.row)\n\t\t{\n\t\t\tretval.targetReached = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(visitedRows.IsVisited(playState.m_nCurrentOrder, playState.m_nRow, true))\n\t\t{\n\t\t\tif(!hasSearchTarget || !visitedRows.GetFirstUnvisitedRow(playState.m_nNextOrder, playState.m_nRow, true))\n\t\t\t{\n\t\t\t\t// We aren't searching for a specific row, or we couldn't find any more unvisited rows.\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t{\n\t\t\t\t// We haven't found the target row yet, but we found some other unplayed row... continue searching from here.\n\t\t\t\tretval.duration = memory.elapsedTime;\n\t\t\t\tresults.push_back(retval);\n\t\t\t\tretval.startRow = playState.m_nRow;\n\t\t\t\tretval.startOrder = playState.m_nNextOrder;\n\t\t\t\tmemory.Reset();\n\t\t\t\tplayState.m_nNextRow = playState.m_nRow;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tretval.endOrder = playState.m_nCurrentOrder;\n\t\tretval.endRow = playState.m_nRow;\n\n\t\t// Update next position\n\t\tplayState.m_nNextRow = playState.m_nRow + 1;\n\n\t\t// Jumped to invalid pattern row?\n\t\tif(playState.m_nRow >= Patterns[playState.m_nPattern].GetNumRows())\n\t\t{\n\t\t\tplayState.m_nRow = 0;\n\t\t}\n\t\t// New pattern?\n\t\tif(!playState.m_nRow)\n\t\t{\n\t\t\tfor(CHANNELINDEX chn = 0; chn < GetNumChannels(); chn++)\n\t\t\t{\n\t\t\t\tmemory.chnSettings[chn].patLoop = memory.elapsedTime;\n\t\t\t\tmemory.chnSettings[chn].patLoopSmp = playState.m_lTotalSampleCount;\n\t\t\t}\n\t\t}\n\n\t\tModChannel *pChn = playState.Chn;\n\t\t\n\t\t// For various effects, we need to know first how many ticks there are in this row.\n\t\tconst ModCommand *p = Patterns[playState.m_nPattern].GetpModCommand(playState.m_nRow, 0);\n\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++, p++)\n\t\t{\n\t\t\tif(m_playBehaviour[kST3NoMutedChannels] && ChnSettings[nChn].dwFlags[CHN_MUTE])\t// not even effects are processed on muted S3M channels\n\t\t\t\tcontinue;\n\t\t\tif(p->IsPcNote())\n\t\t\t{\n#ifndef NO_PLUGINS\n\t\t\t\tif((adjustMode & eAdjust) && p->instr > 0 && p->instr <= MAX_MIXPLUGINS)\n\t\t\t\t{\n\t\t\t\t\tmemory.plugParams[std::make_pair(p->instr, p->GetValueVolCol())] = p->GetValueEffectCol();\n\t\t\t\t}\n#endif // NO_PLUGINS\n\t\t\t\tpChn[nChn].rowCommand.Clear();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpChn[nChn].rowCommand = *p;\n\t\t\tswitch(p->command)\n\t\t\t{\n\t\t\tcase CMD_SPEED:\n\t\t\t\tSetSpeed(playState, p->param);\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_TEMPO:\n\t\t\t\tif(m_playBehaviour[kMODVBlankTiming])\n\t\t\t\t{\n\t\t\t\t\t// ProTracker MODs with VBlank timing: All Fxx parameters set the tick count.\n\t\t\t\t\tif(p->param != 0) SetSpeed(playState, p->param);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_S3MCMDEX:\n\t\t\t\tif((p->param & 0xF0) == 0x60)\n\t\t\t\t{\n\t\t\t\t\t// Fine Pattern Delay\n\t\t\t\t\ttickDelay += (p->param & 0x0F);\n\t\t\t\t} else if((p->param & 0xF0) == 0xE0 && !rowDelay)\n\t\t\t\t{\n\t\t\t\t\t// Pattern Delay\n\t\t\t\t\tif(!(GetType() & MOD_TYPE_S3M) || (p->param & 0x0F) != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t// While Impulse Tracker *does* count S60 as a valid row delay (and thus ignores any other row delay commands on the right),\n\t\t\t\t\t\t// Scream Tracker 3 simply ignores such commands.\n\t\t\t\t\t\trowDelay = 1 + (p->param & 0x0F);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_MODCMDEX:\n\t\t\t\tif((p->param & 0xF0) == 0xE0)\n\t\t\t\t{\n\t\t\t\t\t// Pattern Delay\n\t\t\t\t\trowDelay = 1 + (p->param & 0x0F);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(rowDelay == 0) rowDelay = 1;\n\t\tconst uint32 numTicks = (playState.m_nMusicSpeed + tickDelay) * rowDelay;\n\t\tconst uint32 nonRowTicks = numTicks - rowDelay;\n\n\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); pChn++, nChn++) if(!pChn->rowCommand.IsEmpty())\n\t\t{\n\t\t\tif(m_playBehaviour[kST3NoMutedChannels] && ChnSettings[nChn].dwFlags[CHN_MUTE])\t// not even effects are processed on muted S3M channels\n\t\t\t\tcontinue;\n\t\t\tModCommand::COMMAND command = pChn->rowCommand.command;\n\t\t\tModCommand::PARAM param = pChn->rowCommand.param;\n\t\t\tModCommand::NOTE note = pChn->rowCommand.note;\n\n\t\t\tif (pChn->rowCommand.instr)\n\t\t\t{\n\t\t\t\tpChn->nNewIns = pChn->rowCommand.instr;\n\t\t\t\tpChn->nLastNote = NOTE_NONE;\n\t\t\t\tmemory.chnSettings[nChn].vol = 0xFF;\n\t\t\t}\n\t\t\tif (pChn->rowCommand.IsNote()) pChn->nLastNote = note;\n\n\t\t\t// Update channel panning\n\t\t\tif(pChn->rowCommand.IsNote() || pChn->rowCommand.instr)\n\t\t\t{\n\t\t\t\tSAMPLEINDEX smp = 0;\n\t\t\t\tif(GetNumInstruments())\n\t\t\t\t{\n\t\t\t\t\tModInstrument *pIns;\n\t\t\t\t\tif(pChn->nNewIns <= GetNumInstruments() && (pIns = Instruments[pChn->nNewIns]) != nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(pIns->dwFlags[INS_SETPANNING])\n\t\t\t\t\t\t\tpChn->nPan = pIns->nPan;\n\t\t\t\t\t\tif(ModCommand::IsNote(note))\n\t\t\t\t\t\t\tsmp = pIns->Keyboard[note - NOTE_MIN];\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tsmp = pChn->nNewIns;\n\t\t\t\t}\n\t\t\t\tif(smp > 0 && smp <= GetNumSamples() && Samples[smp].uFlags[CHN_PANNING])\n\t\t\t\t{\n\t\t\t\t\tpChn->nPan = Samples[smp].nPan;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch(pChn->rowCommand.volcmd)\n\t\t\t{\n\t\t\tcase VOLCMD_VOLUME:\n\t\t\t\tmemory.chnSettings[nChn].vol = pChn->rowCommand.vol;\n\t\t\t\tbreak;\n\t\t\tcase VOLCMD_VOLSLIDEUP:\n\t\t\tcase VOLCMD_VOLSLIDEDOWN:\n\t\t\t\tif(pChn->rowCommand.vol != 0)\n\t\t\t\t\tpChn->nOldVolParam = pChn->rowCommand.vol;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch(command)\n\t\t\t{\n\t\t\t// Position Jump\n\t\t\tcase CMD_POSITIONJUMP:\n\t\t\t\tpositionJumpOnThisRow = true;\n\t\t\t\tplayState.m_nNextOrder = static_cast<ORDERINDEX>(CalculateXParam(playState.m_nPattern, playState.m_nRow, nChn));\n\t\t\t\tplayState.m_nNextPatStartRow = 0;  // FT2 E60 bug\n\t\t\t\t// see https://forum.openmpt.org/index.php?topic=2769.0 - FastTracker resets Dxx if Bxx is called _after_ Dxx\n\t\t\t\t// Test case: PatternJump.mod\n\t\t\t\tif(!patternBreakOnThisRow || (GetType() & (MOD_TYPE_MOD | MOD_TYPE_XM)))\n\t\t\t\t\tplayState.m_nNextRow = 0;\n\n\t\t\t\tif (adjustMode & eAdjust)\n\t\t\t\t{\n\t\t\t\t\tpChn->nPatternLoopCount = 0;\n\t\t\t\t\tpChn->nPatternLoop = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// Pattern Break\n\t\t\tcase CMD_PATTERNBREAK:\n\t\t\t\t{\n\t\t\t\t\tROWINDEX row = PatternBreak(playState, nChn, param);\n\t\t\t\t\tif(row != ROWINDEX_INVALID)\n\t\t\t\t\t{\n\t\t\t\t\t\tpatternBreakOnThisRow = true;\n\t\t\t\t\t\tplayState.m_nNextRow = row;\n\n\t\t\t\t\t\tif(!positionJumpOnThisRow)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tplayState.m_nNextOrder = playState.m_nCurrentOrder + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(adjustMode & eAdjust)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpChn->nPatternLoopCount = 0;\n\t\t\t\t\t\t\tpChn->nPatternLoop = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// Set Tempo\n\t\t\tcase CMD_TEMPO:\n\t\t\t\tif(!m_playBehaviour[kMODVBlankTiming])\n\t\t\t\t{\n\t\t\t\t\tTEMPO tempo(CalculateXParam(playState.m_nPattern, playState.m_nRow, nChn), 0);\n\t\t\t\t\tif ((adjustMode & eAdjust) && (GetType() & (MOD_TYPE_S3M | MOD_TYPE_IT | MOD_TYPE_MPT)))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tempo.GetInt()) pChn->nOldTempo = static_cast<uint8>(tempo.GetInt()); else tempo.Set(pChn->nOldTempo);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tempo.GetInt() >= 0x20) playState.m_nMusicTempo = tempo;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Tempo Slide\n\t\t\t\t\t\tTEMPO tempoDiff((tempo.GetInt() & 0x0F) * nonRowTicks, 0);\n\t\t\t\t\t\tif ((tempo.GetInt() & 0xF0) == 0x10)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tplayState.m_nMusicTempo += tempoDiff;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(tempoDiff < playState.m_nMusicTempo)\n\t\t\t\t\t\t\t\tplayState.m_nMusicTempo -= tempoDiff;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tplayState.m_nMusicTempo.Set(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tTEMPO tempoMin = GetModSpecifications().GetTempoMin(), tempoMax = GetModSpecifications().GetTempoMax();\n\t\t\t\t\tif(m_playBehaviour[kTempoClamp])\t// clamp tempo correctly in compatible mode\n\t\t\t\t\t{\n\t\t\t\t\t\ttempoMax.Set(255);\n\t\t\t\t\t}\n\t\t\t\t\tLimit(playState.m_nMusicTempo, tempoMin, tempoMax);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_S3MCMDEX:\n\t\t\t\tswitch(param & 0xF0)\n\t\t\t\t{\n\t\t\t\tcase 0x90:\n\t\t\t\t\tif(param <= 0x91)\n\t\t\t\t\t{\n\t\t\t\t\t\tpChn->dwFlags.set(CHN_SURROUND, param == 0x91);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xA0:\n\t\t\t\t\t// High sample offset\n\t\t\t\t\tpChn->nOldHiOffset = param & 0x0F;\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcase 0xB0:\n\t\t\t\t\t// Pattern Loop\n\t\t\t\t\tif (param & 0x0F)\n\t\t\t\t\t{\n\t\t\t\t\t\tpatternLoopEndedOnThisRow = true;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tCHANNELINDEX firstChn = nChn, lastChn = nChn;\n\t\t\t\t\t\tif(GetType() == MOD_TYPE_S3M)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// ST3 has only one global loop memory.\n\t\t\t\t\t\t\tfirstChn = 0;\n\t\t\t\t\t\t\tlastChn = GetNumChannels() - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(CHANNELINDEX c = firstChn; c <= lastChn; c++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemory.chnSettings[c].patLoop = memory.elapsedTime;\n\t\t\t\t\t\t\tmemory.chnSettings[c].patLoopSmp = playState.m_lTotalSampleCount;\n\t\t\t\t\t\t\tmemory.chnSettings[c].patLoopStart = playState.m_nRow;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpatternLoopStartedOnThisRow = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xF0:\n\t\t\t\t\t// Active macro\n\t\t\t\t\tpChn->nActiveMacro = param & 0x0F;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_MODCMDEX:\n\t\t\t\tswitch(param & 0xF0)\n\t\t\t\t{\n\t\t\t\tcase 0x60:\n\t\t\t\t\t// Pattern Loop\n\t\t\t\t\tif (param & 0x0F)\n\t\t\t\t\t{\n\t\t\t\t\t\tplayState.m_nNextPatStartRow = memory.chnSettings[nChn].patLoopStart; // FT2 E60 bug\n\t\t\t\t\t\tpatternLoopEndedOnThisRow = true;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tpatternLoopStartedOnThisRow = true;\n\t\t\t\t\t\tmemory.chnSettings[nChn].patLoop = memory.elapsedTime;\n\t\t\t\t\t\tmemory.chnSettings[nChn].patLoopSmp = playState.m_lTotalSampleCount;\n\t\t\t\t\t\tmemory.chnSettings[nChn].patLoopStart = playState.m_nRow;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xF0:\n\t\t\t\t\t// Active macro\n\t\t\t\t\tpChn->nActiveMacro = param & 0x0F;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_XFINEPORTAUPDOWN:\n\t\t\t\t// ignore high offset in compatible mode\n\t\t\t\tif(((param & 0xF0) == 0xA0) && !m_playBehaviour[kFT2RestrictXCommand]) pChn->nOldHiOffset = param & 0x0F;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// The following calculations are not interesting if we just want to get the song length.\n\t\t\tif (!(adjustMode & eAdjust)) continue;\n\t\t\tswitch(command)\n\t\t\t{\n\t\t\t// Portamento Up/Down\n\t\t\tcase CMD_PORTAMENTOUP:\n\t\t\t\tif(param)\n\t\t\t\t{\n\t\t\t\t\t// FT2 compatibility: Separate effect memory for all portamento commands\n\t\t\t\t\t// Test case: Porta-LinkMem.xm\n\t\t\t\t\tif(!m_playBehaviour[kFT2PortaUpDownMemory])\n\t\t\t\t\t\tpChn->nOldPortaDown = param;\n\t\t\t\t\tpChn->nOldPortaUp = param;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CMD_PORTAMENTODOWN:\n\t\t\t\tif(param)\n\t\t\t\t{\n\t\t\t\t\t// FT2 compatibility: Separate effect memory for all portamento commands\n\t\t\t\t\t// Test case: Porta-LinkMem.xm\n\t\t\t\t\tif(!m_playBehaviour[kFT2PortaUpDownMemory])\n\t\t\t\t\t\tpChn->nOldPortaUp = param;\n\t\t\t\t\tpChn->nOldPortaDown = param;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// Tone-Portamento\n\t\t\tcase CMD_TONEPORTAMENTO:\n\t\t\t\tif (param) pChn->nPortamentoSlide = param << 2;\n\t\t\t\tbreak;\n\t\t\t// Offset\n\t\t\tcase CMD_OFFSET:\n\t\t\t\tif (param) pChn->oldOffset = param << 8;\n\t\t\t\tbreak;\n\t\t\t// Volume Slide\n\t\t\tcase CMD_VOLUMESLIDE:\n\t\t\tcase CMD_TONEPORTAVOL:\n\t\t\t\tif (param) pChn->nOldVolumeSlide = param;\n\t\t\t\tbreak;\n\t\t\t// Set Volume\n\t\t\tcase CMD_VOLUME:\n\t\t\t\tmemory.chnSettings[nChn].vol = param;\n\t\t\t\tbreak;\n\t\t\t// Global Volume\n\t\t\tcase CMD_GLOBALVOLUME:\n\t\t\t\tif(!(GetType() & GLOBALVOL_7BIT_FORMATS) && param < 128) param *= 2;\n\t\t\t\t// IT compatibility 16. ST3 and IT ignore out-of-range values\n\t\t\t\tif(param <= 128)\n\t\t\t\t{\n\t\t\t\t\tplayState.m_nGlobalVolume = param * 2;\n\t\t\t\t} else if(!(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_S3M)))\n\t\t\t\t{\n\t\t\t\t\tplayState.m_nGlobalVolume = 256;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// Global Volume Slide\n\t\t\tcase CMD_GLOBALVOLSLIDE:\n\t\t\t\tif(m_playBehaviour[kPerChannelGlobalVolSlide])\n\t\t\t\t{\n\t\t\t\t\t// IT compatibility 16. Global volume slide params are stored per channel (FT2/IT)\n\t\t\t\t\tif (param) pChn->nOldGlobalVolSlide = param; else param = pChn->nOldGlobalVolSlide;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tif (param) playState.Chn[0].nOldGlobalVolSlide = param; else param = playState.Chn[0].nOldGlobalVolSlide;\n\t\t\t\t}\n\t\t\t\tif (((param & 0x0F) == 0x0F) && (param & 0xF0))\n\t\t\t\t{\n\t\t\t\t\tparam >>= 4;\n\t\t\t\t\tif (!(GetType() & GLOBALVOL_7BIT_FORMATS)) param <<= 1;\n\t\t\t\t\tplayState.m_nGlobalVolume += param << 1;\n\t\t\t\t} else if (((param & 0xF0) == 0xF0) && (param & 0x0F))\n\t\t\t\t{\n\t\t\t\t\tparam = (param & 0x0F) << 1;\n\t\t\t\t\tif (!(GetType() & GLOBALVOL_7BIT_FORMATS)) param <<= 1;\n\t\t\t\t\tplayState.m_nGlobalVolume -= param;\n\t\t\t\t} else if (param & 0xF0)\n\t\t\t\t{\n\t\t\t\t\tparam >>= 4;\n\t\t\t\t\tparam <<= 1;\n\t\t\t\t\tif (!(GetType() & GLOBALVOL_7BIT_FORMATS)) param <<= 1;\n\t\t\t\t\tplayState.m_nGlobalVolume += param * nonRowTicks;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tparam = (param & 0x0F) << 1;\n\t\t\t\t\tif (!(GetType() & GLOBALVOL_7BIT_FORMATS)) param <<= 1;\n\t\t\t\t\tplayState.m_nGlobalVolume -= param * nonRowTicks;\n\t\t\t\t}\n\t\t\t\tLimit(playState.m_nGlobalVolume, 0, 256);\n\t\t\t\tbreak;\n\t\t\tcase CMD_CHANNELVOLUME:\n\t\t\t\tif (param <= 64) pChn->nGlobalVol = param;\n\t\t\t\tbreak;\n\t\t\tcase CMD_CHANNELVOLSLIDE:\n\t\t\t\t{\n\t\t\t\t\tif (param) pChn->nOldChnVolSlide = param; else param = pChn->nOldChnVolSlide;\n\t\t\t\t\tint32 volume = pChn->nGlobalVol;\n\t\t\t\t\tif((param & 0x0F) == 0x0F && (param & 0xF0))\n\t\t\t\t\t\tvolume += (param >> 4);\t\t// Fine Up\n\t\t\t\t\telse if((param & 0xF0) == 0xF0 && (param & 0x0F))\n\t\t\t\t\t\tvolume -= (param & 0x0F);\t// Fine Down\n\t\t\t\t\telse if(param & 0x0F)\t\t\t// Down\n\t\t\t\t\t\tvolume -= (param & 0x0F) * nonRowTicks;\n\t\t\t\t\telse\t\t\t\t\t\t\t// Up\n\t\t\t\t\t\tvolume += ((param & 0xF0) >> 4) * nonRowTicks;\n\t\t\t\t\tLimit(volume, 0, 64);\n\t\t\t\t\tpChn->nGlobalVol = volume;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CMD_PANNING8:\n\t\t\t\tPanning(pChn, param, Pan8bit);\n\t\t\t\tbreak;\n\t\t\tcase CMD_MODCMDEX:\n\t\t\t\tif(param < 0x10)\n\t\t\t\t{\n\t\t\t\t\t// LED filter\n\t\t\t\t\tfor(CHANNELINDEX chn = 0; chn < GetNumChannels(); chn++)\n\t\t\t\t\t{\n\t\t\t\t\t\tplayState.Chn[chn].dwFlags.set(CHN_AMIGAFILTER, !(param & 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tMPT_FALLTHROUGH;\n\t\t\tcase CMD_S3MCMDEX:\n\t\t\t\tif((param & 0xF0) == 0x80)\n\t\t\t\t{\n\t\t\t\t\tPanning(pChn, (param & 0x0F), Pan4bit);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_VIBRATOVOL:\n\t\t\t\tif (param) pChn->nOldVolumeSlide = param;\n\t\t\t\tparam = 0;\n\t\t\t\tMPT_FALLTHROUGH;\n\t\t\tcase CMD_VIBRATO:\n\t\t\t\tVibrato(pChn, param);\n\t\t\t\tbreak;\n\t\t\tcase CMD_FINEVIBRATO:\n\t\t\t\tFineVibrato(pChn, param);\n\t\t\t\tbreak;\n\t\t\tcase CMD_TREMOLO:\n\t\t\t\tTremolo(pChn, param);\n\t\t\t\tbreak;\n\t\t\tcase CMD_PANBRELLO:\n\t\t\t\tPanbrello(pChn, param);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch(pChn->rowCommand.volcmd)\n\t\t\t{\n\t\t\tcase VOLCMD_PANNING:\n\t\t\t\tPanning(pChn, pChn->rowCommand.vol, Pan6bit);\n\t\t\t\tbreak;\n\n\t\t\tcase VOLCMD_VIBRATOSPEED:\n\t\t\t\t// FT2 does not automatically enable vibrato with the \"set vibrato speed\" command\n\t\t\t\tif(m_playBehaviour[kFT2VolColVibrato])\n\t\t\t\t\tpChn->nVibratoSpeed = pChn->rowCommand.vol & 0x0F;\n\t\t\t\telse\n\t\t\t\t\tVibrato(pChn, pChn->rowCommand.vol << 4);\n\t\t\t\tbreak;\n\t\t\tcase VOLCMD_VIBRATODEPTH:\n\t\t\t\tVibrato(pChn, pChn->rowCommand.vol);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Process vibrato / tremolo / panbrello\n\t\t\tswitch(pChn->rowCommand.command)\n\t\t\t{\n\t\t\tcase CMD_VIBRATO:\n\t\t\tcase CMD_FINEVIBRATO:\n\t\t\tcase CMD_VIBRATOVOL:\n\t\t\t\tif(adjustMode & eAdjust)\n\t\t\t\t{\n\t\t\t\t\tuint32 vibTicks = ((GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT)) && !m_SongFlags[SONG_ITOLDEFFECTS]) ? numTicks : nonRowTicks;\n\t\t\t\t\tuint32 inc = pChn->nVibratoSpeed * vibTicks;\n\t\t\t\t\tif(m_playBehaviour[kITVibratoTremoloPanbrello])\n\t\t\t\t\t\tinc *= 4;\n\t\t\t\t\tpChn->nVibratoPos += static_cast<uint8>(inc);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_TREMOLO:\n\t\t\t\tif(adjustMode & eAdjust)\n\t\t\t\t{\n\t\t\t\t\tuint32 tremTicks = ((GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT)) && !m_SongFlags[SONG_ITOLDEFFECTS]) ? numTicks : nonRowTicks;\n\t\t\t\t\tuint32 inc = pChn->nTremoloSpeed * tremTicks;\n\t\t\t\t\tif(m_playBehaviour[kITVibratoTremoloPanbrello])\n\t\t\t\t\t\tinc *= 4;\n\t\t\t\t\tpChn->nTremoloPos += static_cast<uint8>(inc);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_PANBRELLO:\n\t\t\t\tif(adjustMode & eAdjust)\n\t\t\t\t{\n\t\t\t\t\t// Panbrello effect is permanent in compatible mode, so actually apply panbrello for the last tick of this row\n\t\t\t\t\tpChn->nPanbrelloPos += static_cast<uint8>(pChn->nPanbrelloSpeed * (numTicks - 1));\n\t\t\t\t\tProcessPanbrello(pChn);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Interpret F00 effect in XM files as \"stop song\"\n\t\tif(GetType() == MOD_TYPE_XM && playState.m_nMusicSpeed == uint16_max)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tplayState.m_nCurrentRowsPerBeat = m_nDefaultRowsPerBeat;\n\t\tif(Patterns[playState.m_nPattern].GetOverrideSignature())\n\t\t{\n\t\t\tplayState.m_nCurrentRowsPerBeat = Patterns[playState.m_nPattern].GetRowsPerBeat();\n\t\t}\n\n\t\tconst uint32 tickDuration = GetTickDuration(playState);\n\t\tconst uint32 rowDuration = tickDuration * numTicks;\n\t\tmemory.elapsedTime += static_cast<double>(rowDuration) / static_cast<double>(m_MixerSettings.gdwMixingFreq);\n\t\tplayState.m_lTotalSampleCount += rowDuration;\n\n\t\tif(adjustSamplePos)\n\t\t{\n\t\t\t// Super experimental and dirty sample seeking\n\t\t\tpChn = playState.Chn;\n\t\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); pChn++, nChn++)\n\t\t\t{\n\t\t\t\tif(memory.chnSettings[nChn].ticksToRender == GetLengthMemory::IGNORE_CHANNEL)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tuint32 startTick = 0;\n\t\t\t\tconst ModCommand &m = pChn->rowCommand;\n\t\t\t\tuint32 paramHi = m.param >> 4, paramLo = m.param & 0x0F;\n\t\t\t\tbool porta = m.command == CMD_TONEPORTAMENTO || m.command == CMD_TONEPORTAVOL || m.volcmd == VOLCMD_TONEPORTAMENTO;\n\t\t\t\tbool stopNote = patternLoopStartedOnThisRow;\t// It's too much trouble to keep those pattern loops in sync...\n\n\t\t\t\tif(m.instr) pChn->proTrackerOffset = 0;\n\t\t\t\tif(m.IsNote())\n\t\t\t\t{\n\t\t\t\t\tif(porta && memory.chnSettings[nChn].incChanged)\n\t\t\t\t\t{\n\t\t\t\t\t\t// If there's a portamento, the current channel increment mustn't be 0 in NoteChange()\n\t\t\t\t\t\tpChn->increment = GetChannelIncrement(pChn, pChn->nPeriod, 0);\n\t\t\t\t\t}\n\t\t\t\t\tint32 setPan = pChn->nPan;\n\t\t\t\t\tpChn->nNewNote = pChn->nLastNote;\n\t\t\t\t\tif(pChn->nNewIns != 0) InstrumentChange(pChn, pChn->nNewIns, porta);\n\t\t\t\t\tNoteChange(pChn, m.note, porta);\n\t\t\t\t\tmemory.chnSettings[nChn].incChanged = true;\n\n\t\t\t\t\tif((m.command == CMD_MODCMDEX || m.command == CMD_S3MCMDEX) && (m.param & 0xF0) == 0xD0 && paramLo < numTicks)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartTick = paramLo;\n\t\t\t\t\t} else if(m.command == CMD_DELAYCUT && paramHi < numTicks)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartTick = paramHi;\n\t\t\t\t\t}\n\t\t\t\t\tif(rowDelay > 1 && startTick != 0 && (GetType() & (MOD_TYPE_S3M | MOD_TYPE_IT | MOD_TYPE_MPT)))\n\t\t\t\t\t{\n\t\t\t\t\t\tstartTick += (playState.m_nMusicSpeed + tickDelay) * (rowDelay - 1);\n\t\t\t\t\t}\n\t\t\t\t\tif(!porta) memory.chnSettings[nChn].ticksToRender = 0;\n\n\t\t\t\t\t// Panning commands have to be re-applied after a note change with potential pan change.\n\t\t\t\t\tif(m.command == CMD_PANNING8\n\t\t\t\t\t\t|| ((m.command == CMD_MODCMDEX || m.command == CMD_S3MCMDEX) && paramHi == 0x8)\n\t\t\t\t\t\t|| m.volcmd == VOLCMD_PANNING)\n\t\t\t\t\t{\n\t\t\t\t\t\tpChn->nPan = setPan;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(m.command == CMD_OFFSET)\n\t\t\t\t\t{\n\t\t\t\t\t\tbool isExtended = false;\n\t\t\t\t\t\tSmpLength offset = CalculateXParam(playState.m_nPattern, playState.m_nRow, nChn, &isExtended);\n\t\t\t\t\t\tif(!isExtended)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\toffset <<= 8;\n\t\t\t\t\t\t\tif(offset == 0) offset = pChn->oldOffset;\n\t\t\t\t\t\t\toffset += static_cast<SmpLength>(pChn->nOldHiOffset) << 16;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSampleOffset(*pChn, offset);\n\t\t\t\t\t} else if(m.command == CMD_OFFSETPERCENTAGE)\n\t\t\t\t\t{\n\t\t\t\t\t\tSampleOffset(*pChn, Util::muldiv_unsigned(pChn->nLength, m.param, 255));\n\t\t\t\t\t} else if(m.command == CMD_REVERSEOFFSET && pChn->pModSample != nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemory.RenderChannel(nChn, oldTickDuration);\t// Re-sync what we've got so far\n\t\t\t\t\t\tReverseSampleOffset(*pChn, m.param);\n\t\t\t\t\t\tstartTick = playState.m_nMusicSpeed - 1;\n\t\t\t\t\t} else if(m.volcmd == VOLCMD_OFFSET)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(m.vol <= CountOf(pChn->pModSample->cues) && pChn->pModSample != nullptr)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSmpLength offset;\n\t\t\t\t\t\t\tif(m.vol == 0)\n\t\t\t\t\t\t\t\toffset = pChn->oldOffset;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\toffset = pChn->oldOffset = pChn->pModSample->cues[m.vol - 1];\n\t\t\t\t\t\t\tSampleOffset(*pChn, offset);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(m.note == NOTE_KEYOFF || m.note == NOTE_NOTECUT || (m.note == NOTE_FADE && GetNumInstruments())\n\t\t\t\t\t|| ((m.command == CMD_MODCMDEX || m.command == CMD_S3MCMDEX) && (m.param & 0xF0) == 0xC0 && paramLo < numTicks)\n\t\t\t\t\t|| (m.command == CMD_DELAYCUT && paramLo != 0 && startTick + paramLo < numTicks))\n\t\t\t\t{\n\t\t\t\t\tstopNote = true;\n\t\t\t\t}\n\n\t\t\t\tif(m.command == CMD_VOLUME)\n\t\t\t\t{\n\t\t\t\t\tpChn->nVolume = m.param * 4;\n\t\t\t\t} else if(m.volcmd == VOLCMD_VOLUME)\n\t\t\t\t{\n\t\t\t\t\tpChn->nVolume = m.vol * 4;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(pChn->pModSample && !stopNote)\n\t\t\t\t{\n\t\t\t\t\t// Check if we don't want to emulate some effect and thus stop processing.\n\t\t\t\t\tif(m.command < MAX_EFFECTS)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(forbiddenCommands[m.command])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstopNote = true;\n\t\t\t\t\t\t} else if(m.command == CMD_MODCMDEX)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Special case: Slides using extended commands\n\t\t\t\t\t\t\tswitch(m.param & 0xF0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 0x10:\n\t\t\t\t\t\t\tcase 0x20:\n\t\t\t\t\t\t\t\tstopNote = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(m.volcmd < forbiddenVolCommands.size() && forbiddenVolCommands[m.volcmd])\n\t\t\t\t\t{\n\t\t\t\t\t\tstopNote = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(stopNote)\n\t\t\t\t{\n\t\t\t\t\tpChn->Stop();\n\t\t\t\t\tmemory.chnSettings[nChn].ticksToRender = 0;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tif(oldTickDuration != tickDuration && oldTickDuration != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemory.RenderChannel(nChn, oldTickDuration);\t// Re-sync what we've got so far\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch(m.command)\n\t\t\t\t\t{\n\t\t\t\t\tcase CMD_TONEPORTAVOL:\n\t\t\t\t\tcase CMD_VOLUMESLIDE:\n\t\t\t\t\tcase CMD_VIBRATOVOL:\n\t\t\t\t\t\tif(m.param || (GetType() != MOD_TYPE_MOD))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(uint32 i = 0; i < numTicks; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpChn->isFirstTick = (i == 0);\n\t\t\t\t\t\t\t\tVolumeSlide(pChn, m.param);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CMD_MODCMDEX:\n\t\t\t\t\t\tif((m.param & 0x0F) || (GetType() & (MOD_TYPE_XM | MOD_TYPE_MT2)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpChn->isFirstTick = true;\n\t\t\t\t\t\t\tswitch(m.param & 0xF0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 0xA0: FineVolumeUp(pChn, m.param & 0x0F, false); break;\n\t\t\t\t\t\t\tcase 0xB0: FineVolumeDown(pChn, m.param & 0x0F, false); break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CMD_S3MCMDEX:\n\t\t\t\t\t\tif(m.param == 0x9E)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Play forward\n\t\t\t\t\t\t\tmemory.RenderChannel(nChn, oldTickDuration);\t// Re-sync what we've got so far\n\t\t\t\t\t\t\tpChn->dwFlags.reset(CHN_PINGPONGFLAG);\n\t\t\t\t\t\t} else if(m.param == 0x9F)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Reverse\n\t\t\t\t\t\t\tmemory.RenderChannel(nChn, oldTickDuration);\t// Re-sync what we've got so far\n\t\t\t\t\t\t\tpChn->dwFlags.set(CHN_PINGPONGFLAG);\n\t\t\t\t\t\t\tif(!pChn->position.GetInt() && pChn->nLength && (m.IsNote() || !pChn->dwFlags[CHN_LOOP]))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpChn->position.Set(pChn->nLength - 1, SamplePosition::fractMax);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if((m.param & 0xF0) == 0x70)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// TODO\n\t\t\t\t\t\t\t//ExtendedS3MCommands(nChn, param);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tpChn->isFirstTick = true;\n\t\t\t\t\tswitch(m.volcmd)\n\t\t\t\t\t{\n\t\t\t\t\tcase VOLCMD_FINEVOLUP:\t\tFineVolumeUp(pChn, m.vol, m_playBehaviour[kITVolColMemory]); break;\n\t\t\t\t\tcase VOLCMD_FINEVOLDOWN:\tFineVolumeDown(pChn, m.vol, m_playBehaviour[kITVolColMemory]); break;\n\t\t\t\t\tcase VOLCMD_VOLSLIDEUP:\n\t\t\t\t\tcase VOLCMD_VOLSLIDEDOWN:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// IT Compatibility: Volume column volume slides have their own memory\n\t\t\t\t\t\t\t// Test case: VolColMemory.it\n\t\t\t\t\t\t\tModCommand::VOL vol = m.vol;\n\t\t\t\t\t\t\tif(vol == 0 && m_playBehaviour[kITVolColMemory])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvol = pChn->nOldVolParam;\n\t\t\t\t\t\t\t\tif(vol == 0)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(m.volcmd == VOLCMD_VOLSLIDEUP)\n\t\t\t\t\t\t\t\tvol <<= 4;\n\t\t\t\t\t\t\tfor(uint32 i = 0; i < numTicks; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpChn->isFirstTick = (i == 0);\n\t\t\t\t\t\t\t\tVolumeSlide(pChn, vol);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(porta)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Portamento needs immediate syncing, as the pitch changes on each tick\n\t\t\t\t\t\tuint32 portaTick = memory.chnSettings[nChn].ticksToRender + startTick + 1;\n\t\t\t\t\t\tmemory.chnSettings[nChn].ticksToRender += numTicks;\n\t\t\t\t\t\tmemory.RenderChannel(nChn, tickDuration, portaTick);\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tmemory.chnSettings[nChn].ticksToRender += (numTicks - startTick);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\toldTickDuration = tickDuration;\n\n\t\t// Pattern loop is not executed in FT2 if there are any position jump or pattern break commands on the same row.\n\t\t// Pattern loop is not executed in IT if there are any position jump commands on the same row.\n\t\t// Test case for FT2 exception: PatLoop-Jumps.xm, PatLoop-Various.xm\n\t\t// Test case for IT: exception: LoopBreak.it\n\t\tif(patternLoopEndedOnThisRow\n\t\t\t&& (!m_playBehaviour[kFT2PatternLoopWithJumps] || !(positionJumpOnThisRow || patternBreakOnThisRow))\n\t\t\t&& (!m_playBehaviour[kITPatternLoopWithJumps] || !positionJumpOnThisRow))\n\t\t{\n\t\t\tstd::map<double, int> startTimes;\n\t\t\t// This is really just a simple estimation for nested pattern loops. It should handle cases correctly where all parallel loops start and end on the same row.\n\t\t\t// If one of them starts or ends \"in between\", it will most likely calculate a wrong duration.\n\t\t\t// For S3M files, it's also way off.\n\t\t\tpChn = playState.Chn;\n\t\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++, pChn++)\n\t\t\t{\n\t\t\t\tModCommand::COMMAND command = pChn->rowCommand.command;\n\t\t\t\tModCommand::PARAM param = pChn->rowCommand.param;\n\t\t\t\tif((command == CMD_S3MCMDEX && param >= 0xB1 && param <= 0xBF)\n\t\t\t\t\t|| (command == CMD_MODCMDEX && param >= 0x61 && param <= 0x6F))\n\t\t\t\t{\n\t\t\t\t\tconst double start = memory.chnSettings[nChn].patLoop;\n\t\t\t\t\tif(!startTimes[start]) startTimes[start] = 1;\n\t\t\t\t\tstartTimes[start] = mpt::lcm(startTimes[start], 1 + (param & 0x0F));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(const auto &i : startTimes)\n\t\t\t{\n\t\t\t\tmemory.elapsedTime += (memory.elapsedTime - i.first) * (double)(i.second - 1);\n\t\t\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++, pChn++)\n\t\t\t\t{\n\t\t\t\t\tif(memory.chnSettings[nChn].patLoop == i.first)\n\t\t\t\t\t{\n\t\t\t\t\t\tplayState.m_lTotalSampleCount += (playState.m_lTotalSampleCount - memory.chnSettings[nChn].patLoopSmp) * (i.second - 1);\n\t\t\t\t\t\tif(m_playBehaviour[kITPatternLoopTargetReset] || (GetType() == MOD_TYPE_S3M))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemory.chnSettings[nChn].patLoop = memory.elapsedTime;\n\t\t\t\t\t\t\tmemory.chnSettings[nChn].patLoopSmp = playState.m_lTotalSampleCount;\n\t\t\t\t\t\t\tmemory.chnSettings[nChn].patLoopStart = playState.m_nRow + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(GetType() == MOD_TYPE_IT)\n\t\t\t{\n\t\t\t\t// IT pattern loop start row update - at the end of a pattern loop, set pattern loop start to next row (for upcoming pattern loops with missing SB0)\n\t\t\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++)\n\t\t\t\t{\n\t\t\t\t\tif((pChn->rowCommand.command == CMD_S3MCMDEX && pChn->rowCommand.param >= 0xB1 && pChn->rowCommand.param <= 0xBF))\n\t\t\t\t\t{\n\t\t\t\t\t\tmemory.chnSettings[nChn].patLoop = memory.elapsedTime;\n\t\t\t\t\t\tmemory.chnSettings[nChn].patLoopSmp = playState.m_lTotalSampleCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Now advance the sample positions for sample seeking on channels that are still playing\n\tif(adjustSamplePos)\n\t{\n\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++)\n\t\t{\n\t\t\tif(memory.chnSettings[nChn].ticksToRender != GetLengthMemory::IGNORE_CHANNEL)\n\t\t\t{\n\t\t\t\tmemory.RenderChannel(nChn, oldTickDuration);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(retval.targetReached || target.mode == GetLengthTarget::NoTarget)\n\t{\n\t\tretval.lastOrder = playState.m_nCurrentOrder;\n\t\tretval.lastRow = playState.m_nRow;\n\t}\n\tretval.duration = memory.elapsedTime;\n\tresults.push_back(retval);\n\n\t// Store final variables\n\tif(adjustMode & eAdjust)\n\t{\n\t\tif(retval.targetReached || target.mode == GetLengthTarget::NoTarget)\n\t\t{\n\t\t\t// Target found, or there is no target (i.e. play whole song)...\n\t\t\tm_PlayState = std::move(playState);\n\t\t\tm_PlayState.m_nNextRow = m_PlayState.m_nRow;\n\t\t\tm_PlayState.m_nFrameDelay = m_PlayState.m_nPatternDelay = 0;\n\t\t\tm_PlayState.m_nTickCount = Util::MaxValueOfType(m_PlayState.m_nTickCount) - 1;\n\t\t\tm_PlayState.m_bPositionChanged = true;\n\t\t\tfor(CHANNELINDEX n = 0; n < GetNumChannels(); n++)\n\t\t\t{\n\t\t\t\tif(m_PlayState.Chn[n].nLastNote != NOTE_NONE)\n\t\t\t\t{\n\t\t\t\t\tm_PlayState.Chn[n].nNewNote = m_PlayState.Chn[n].nLastNote;\n\t\t\t\t}\n\t\t\t\tif(memory.chnSettings[n].vol != 0xFF && !adjustSamplePos)\n\t\t\t\t{\n\t\t\t\t\tm_PlayState.Chn[n].nVolume = std::min(memory.chnSettings[n].vol, uint8(64)) * 4;\n\t\t\t\t}\n\t\t\t}\n\n#ifndef NO_PLUGINS\n\t\t\t// If there were any PC events, update plugin parameters to their latest value.\n\t\t\tstd::bitset<MAX_MIXPLUGINS> plugSetProgram;\n\t\t\tfor(const auto &param : memory.plugParams)\n\t\t\t{\n\t\t\t\tPLUGINDEX plug = param.first.first - 1;\n\t\t\t\tIMixPlugin *plugin = m_MixPlugins[plug].pMixPlugin;\n\t\t\t\tif(plugin != nullptr)\n\t\t\t\t{\n\t\t\t\t\tif(!plugSetProgram[plug])\n\t\t\t\t\t{\n\t\t\t\t\t\t// Used for bridged plugins to avoid sending out individual messages for each parameter.\n\t\t\t\t\t\tplugSetProgram.set(plug);\n\t\t\t\t\t\tplugin->BeginSetProgram();\n\t\t\t\t\t}\n\t\t\t\t\tplugin->SetParameter(param.first.second, param.second / PlugParamValue(ModCommand::maxColumnValue));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(plugSetProgram.any())\n\t\t\t{\n\t\t\t\tfor(PLUGINDEX i = 0; i < MAX_MIXPLUGINS; i++)\n\t\t\t\t{\n\t\t\t\t\tif(plugSetProgram[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tm_MixPlugins[i].pMixPlugin->EndSetProgram();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif // NO_PLUGINS\n\t\t} else if(adjustMode != eAdjustOnSuccess)\n\t\t{\n\t\t\t// Target not found (e.g. when jumping to a hidden sub song), reset global variables...\n\t\t\tm_PlayState.m_nMusicSpeed = m_nDefaultSpeed;\n\t\t\tm_PlayState.m_nMusicTempo = m_nDefaultTempo;\n\t\t\tm_PlayState.m_nGlobalVolume = m_nDefaultGlobalVolume;\n\t\t}\n\t\t// When adjusting the playback status, we will also want to update the visited rows vector according to the current position.\n\t\tif(sequence != Order.GetCurrentSequenceIndex())\n\t\t{\n\t\t\tOrder.SetSequence(sequence);\n\t\t}\n\t\tvisitedSongRows.Set(visitedRows);\n\t}\n\n\treturn results;\n\n}", "func_src_after": "std::vector<GetLengthType> CSoundFile::GetLength(enmGetLengthResetMode adjustMode, GetLengthTarget target)\n{\n\tstd::vector<GetLengthType> results;\n\tGetLengthType retval;\n\tretval.startOrder = target.startOrder;\n\tretval.startRow = target.startRow;\n\n\t// Are we trying to reach a certain pattern position?\n\tconst bool hasSearchTarget = target.mode != GetLengthTarget::NoTarget;\n\tconst bool adjustSamplePos = (adjustMode & eAdjustSamplePositions) == eAdjustSamplePositions;\n\n\tSEQUENCEINDEX sequence = target.sequence;\n\tif(sequence >= Order.GetNumSequences()) sequence = Order.GetCurrentSequenceIndex();\n\tconst ModSequence &orderList = Order(sequence);\n\n\tGetLengthMemory memory(*this);\n\tCSoundFile::PlayState &playState = *memory.state;\n\t// Temporary visited rows vector (so that GetLength() won't interfere with the player code if the module is playing at the same time)\n\tRowVisitor visitedRows(*this, sequence);\n\n\tplayState.m_nNextRow = playState.m_nRow = target.startRow;\n\tplayState.m_nNextOrder = playState.m_nCurrentOrder = target.startOrder;\n\n\t// Fast LUTs for commands that are too weird / complicated / whatever to emulate in sample position adjust mode.\n\tstd::bitset<MAX_EFFECTS> forbiddenCommands;\n\tstd::bitset<MAX_VOLCMDS> forbiddenVolCommands;\n\n\tif(adjustSamplePos)\n\t{\n\t\tforbiddenCommands.set(CMD_ARPEGGIO);             forbiddenCommands.set(CMD_PORTAMENTOUP);\n\t\tforbiddenCommands.set(CMD_PORTAMENTODOWN);       forbiddenCommands.set(CMD_XFINEPORTAUPDOWN);\n\t\tforbiddenCommands.set(CMD_NOTESLIDEUP);          forbiddenCommands.set(CMD_NOTESLIDEUPRETRIG);\n\t\tforbiddenCommands.set(CMD_NOTESLIDEDOWN);        forbiddenCommands.set(CMD_NOTESLIDEDOWNRETRIG);\n\t\tforbiddenVolCommands.set(VOLCMD_PORTAUP);        forbiddenVolCommands.set(VOLCMD_PORTADOWN);\n\n\t\t// Optimize away channels for which it's pointless to adjust sample positions\n\t\tfor(CHANNELINDEX i = 0; i < GetNumChannels(); i++)\n\t\t{\n\t\t\tif(ChnSettings[i].dwFlags[CHN_MUTE]) memory.chnSettings[i].ticksToRender = GetLengthMemory::IGNORE_CHANNEL;\n\t\t}\n\t\tif(target.mode == GetLengthTarget::SeekPosition && target.pos.order < orderList.size())\n\t\t{\n\t\t\t// If we know where to seek, we can directly rule out any channels on which a new note would be triggered right at the start.\n\t\t\tconst PATTERNINDEX seekPat = orderList[target.pos.order];\n\t\t\tif(Patterns.IsValidPat(seekPat) && Patterns[seekPat].IsValidRow(target.pos.row))\n\t\t\t{\n\t\t\t\tconst ModCommand *m = Patterns[seekPat].GetRow(target.pos.row);\n\t\t\t\tfor(CHANNELINDEX i = 0; i < GetNumChannels(); i++, m++)\n\t\t\t\t{\n\t\t\t\t\tif(m->note == NOTE_NOTECUT || m->note == NOTE_KEYOFF || (m->note == NOTE_FADE && GetNumInstruments())\n\t\t\t\t\t\t|| (m->IsNote() && !m->IsPortamento()))\n\t\t\t\t\t{\n\t\t\t\t\t\tmemory.chnSettings[i].ticksToRender = GetLengthMemory::IGNORE_CHANNEL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// If samples are being synced, force them to resync if tick duration changes\n\tuint32 oldTickDuration = 0;\n\n\tfor (;;)\n\t{\n\t\t// Time target reached.\n\t\tif(target.mode == GetLengthTarget::SeekSeconds && memory.elapsedTime >= target.time)\n\t\t{\n\t\t\tretval.targetReached = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tuint32 rowDelay = 0, tickDelay = 0;\n\t\tplayState.m_nRow = playState.m_nNextRow;\n\t\tplayState.m_nCurrentOrder = playState.m_nNextOrder;\n\n\t\tif(orderList.IsValidPat(playState.m_nCurrentOrder) && playState.m_nRow >= Patterns[orderList[playState.m_nCurrentOrder]].GetNumRows())\n\t\t{\n\t\t\tplayState.m_nRow = 0;\n\t\t\tif(m_playBehaviour[kFT2LoopE60Restart])\n\t\t\t{\n\t\t\t\tplayState.m_nRow = playState.m_nNextPatStartRow;\n\t\t\t\tplayState.m_nNextPatStartRow = 0;\n\t\t\t}\n\t\t\tplayState.m_nCurrentOrder = ++playState.m_nNextOrder;\n\t\t}\n\n\t\t// Check if pattern is valid\n\t\tplayState.m_nPattern = playState.m_nCurrentOrder < orderList.size() ? orderList[playState.m_nCurrentOrder] : orderList.GetInvalidPatIndex();\n\t\tbool positionJumpOnThisRow = false;\n\t\tbool patternBreakOnThisRow = false;\n\t\tbool patternLoopEndedOnThisRow = false, patternLoopStartedOnThisRow = false;\n\n\t\tif(!Patterns.IsValidPat(playState.m_nPattern) && playState.m_nPattern != orderList.GetInvalidPatIndex() && target.mode == GetLengthTarget::SeekPosition && playState.m_nCurrentOrder == target.pos.order)\n\t\t{\n\t\t\t// Early test: Target is inside +++ or non-existing pattern\n\t\t\tretval.targetReached = true;\n\t\t\tbreak;\n\t\t}\n\n\t\twhile(playState.m_nPattern >= Patterns.Size())\n\t\t{\n\t\t\t// End of song?\n\t\t\tif((playState.m_nPattern == orderList.GetInvalidPatIndex()) || (playState.m_nCurrentOrder >= orderList.size()))\n\t\t\t{\n\t\t\t\tif(playState.m_nCurrentOrder == orderList.GetRestartPos())\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\tplayState.m_nCurrentOrder = orderList.GetRestartPos();\n\t\t\t} else\n\t\t\t{\n\t\t\t\tplayState.m_nCurrentOrder++;\n\t\t\t}\n\t\t\tplayState.m_nPattern = (playState.m_nCurrentOrder < orderList.size()) ? orderList[playState.m_nCurrentOrder] : orderList.GetInvalidPatIndex();\n\t\t\tplayState.m_nNextOrder = playState.m_nCurrentOrder;\n\t\t\tif((!Patterns.IsValidPat(playState.m_nPattern)) && visitedRows.IsVisited(playState.m_nCurrentOrder, 0, true))\n\t\t\t{\n\t\t\t\tif(!hasSearchTarget || !visitedRows.GetFirstUnvisitedRow(playState.m_nNextOrder, playState.m_nRow, true))\n\t\t\t\t{\n\t\t\t\t\t// We aren't searching for a specific row, or we couldn't find any more unvisited rows.\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\t// We haven't found the target row yet, but we found some other unplayed row... continue searching from here.\n\t\t\t\t\tretval.duration = memory.elapsedTime;\n\t\t\t\t\tresults.push_back(retval);\n\t\t\t\t\tretval.startRow = playState.m_nRow;\n\t\t\t\t\tretval.startOrder = playState.m_nNextOrder;\n\t\t\t\t\tmemory.Reset();\n\n\t\t\t\t\tplayState.m_nCurrentOrder = playState.m_nNextOrder;\n\t\t\t\t\tplayState.m_nPattern = orderList[playState.m_nCurrentOrder];\n\t\t\t\t\tplayState.m_nNextRow = playState.m_nRow;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(playState.m_nNextOrder == ORDERINDEX_INVALID)\n\t\t{\n\t\t\t// GetFirstUnvisitedRow failed, so there is nothing more to play\n\t\t\tbreak;\n\t\t}\n\n\t\t// Skip non-existing patterns\n\t\tif(!Patterns.IsValidPat(playState.m_nPattern))\n\t\t{\n\t\t\t// If there isn't even a tune, we should probably stop here.\n\t\t\tif(playState.m_nCurrentOrder == orderList.GetRestartPos())\n\t\t\t{\n\t\t\t\tif(!hasSearchTarget || !visitedRows.GetFirstUnvisitedRow(playState.m_nNextOrder, playState.m_nRow, true))\n\t\t\t\t{\n\t\t\t\t\t// We aren't searching for a specific row, or we couldn't find any more unvisited rows.\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\t// We haven't found the target row yet, but we found some other unplayed row... continue searching from here.\n\t\t\t\t\tretval.duration = memory.elapsedTime;\n\t\t\t\t\tresults.push_back(retval);\n\t\t\t\t\tretval.startRow = playState.m_nRow;\n\t\t\t\t\tretval.startOrder = playState.m_nNextOrder;\n\t\t\t\t\tmemory.Reset();\n\t\t\t\t\tplayState.m_nNextRow = playState.m_nRow;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tplayState.m_nNextOrder = playState.m_nCurrentOrder + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t// Should never happen\n\t\tif(playState.m_nRow >= Patterns[playState.m_nPattern].GetNumRows())\n\t\t\tplayState.m_nRow = 0;\n\n\t\t// Check whether target was reached.\n\t\tif(target.mode == GetLengthTarget::SeekPosition && playState.m_nCurrentOrder == target.pos.order && playState.m_nRow == target.pos.row)\n\t\t{\n\t\t\tretval.targetReached = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(visitedRows.IsVisited(playState.m_nCurrentOrder, playState.m_nRow, true))\n\t\t{\n\t\t\tif(!hasSearchTarget || !visitedRows.GetFirstUnvisitedRow(playState.m_nNextOrder, playState.m_nRow, true))\n\t\t\t{\n\t\t\t\t// We aren't searching for a specific row, or we couldn't find any more unvisited rows.\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t{\n\t\t\t\t// We haven't found the target row yet, but we found some other unplayed row... continue searching from here.\n\t\t\t\tretval.duration = memory.elapsedTime;\n\t\t\t\tresults.push_back(retval);\n\t\t\t\tretval.startRow = playState.m_nRow;\n\t\t\t\tretval.startOrder = playState.m_nNextOrder;\n\t\t\t\tmemory.Reset();\n\t\t\t\tplayState.m_nNextRow = playState.m_nRow;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tretval.endOrder = playState.m_nCurrentOrder;\n\t\tretval.endRow = playState.m_nRow;\n\n\t\t// Update next position\n\t\tplayState.m_nNextRow = playState.m_nRow + 1;\n\n\t\t// Jumped to invalid pattern row?\n\t\tif(playState.m_nRow >= Patterns[playState.m_nPattern].GetNumRows())\n\t\t{\n\t\t\tplayState.m_nRow = 0;\n\t\t}\n\t\t// New pattern?\n\t\tif(!playState.m_nRow)\n\t\t{\n\t\t\tfor(CHANNELINDEX chn = 0; chn < GetNumChannels(); chn++)\n\t\t\t{\n\t\t\t\tmemory.chnSettings[chn].patLoop = memory.elapsedTime;\n\t\t\t\tmemory.chnSettings[chn].patLoopSmp = playState.m_lTotalSampleCount;\n\t\t\t}\n\t\t}\n\n\t\tModChannel *pChn = playState.Chn;\n\t\t\n\t\t// For various effects, we need to know first how many ticks there are in this row.\n\t\tconst ModCommand *p = Patterns[playState.m_nPattern].GetpModCommand(playState.m_nRow, 0);\n\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++, p++)\n\t\t{\n\t\t\tif(m_playBehaviour[kST3NoMutedChannels] && ChnSettings[nChn].dwFlags[CHN_MUTE])\t// not even effects are processed on muted S3M channels\n\t\t\t\tcontinue;\n\t\t\tif(p->IsPcNote())\n\t\t\t{\n#ifndef NO_PLUGINS\n\t\t\t\tif((adjustMode & eAdjust) && p->instr > 0 && p->instr <= MAX_MIXPLUGINS)\n\t\t\t\t{\n\t\t\t\t\tmemory.plugParams[std::make_pair(p->instr, p->GetValueVolCol())] = p->GetValueEffectCol();\n\t\t\t\t}\n#endif // NO_PLUGINS\n\t\t\t\tpChn[nChn].rowCommand.Clear();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpChn[nChn].rowCommand = *p;\n\t\t\tswitch(p->command)\n\t\t\t{\n\t\t\tcase CMD_SPEED:\n\t\t\t\tSetSpeed(playState, p->param);\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_TEMPO:\n\t\t\t\tif(m_playBehaviour[kMODVBlankTiming])\n\t\t\t\t{\n\t\t\t\t\t// ProTracker MODs with VBlank timing: All Fxx parameters set the tick count.\n\t\t\t\t\tif(p->param != 0) SetSpeed(playState, p->param);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_S3MCMDEX:\n\t\t\t\tif((p->param & 0xF0) == 0x60)\n\t\t\t\t{\n\t\t\t\t\t// Fine Pattern Delay\n\t\t\t\t\ttickDelay += (p->param & 0x0F);\n\t\t\t\t} else if((p->param & 0xF0) == 0xE0 && !rowDelay)\n\t\t\t\t{\n\t\t\t\t\t// Pattern Delay\n\t\t\t\t\tif(!(GetType() & MOD_TYPE_S3M) || (p->param & 0x0F) != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t// While Impulse Tracker *does* count S60 as a valid row delay (and thus ignores any other row delay commands on the right),\n\t\t\t\t\t\t// Scream Tracker 3 simply ignores such commands.\n\t\t\t\t\t\trowDelay = 1 + (p->param & 0x0F);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_MODCMDEX:\n\t\t\t\tif((p->param & 0xF0) == 0xE0)\n\t\t\t\t{\n\t\t\t\t\t// Pattern Delay\n\t\t\t\t\trowDelay = 1 + (p->param & 0x0F);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(rowDelay == 0) rowDelay = 1;\n\t\tconst uint32 numTicks = (playState.m_nMusicSpeed + tickDelay) * rowDelay;\n\t\tconst uint32 nonRowTicks = numTicks - rowDelay;\n\n\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); pChn++, nChn++) if(!pChn->rowCommand.IsEmpty())\n\t\t{\n\t\t\tif(m_playBehaviour[kST3NoMutedChannels] && ChnSettings[nChn].dwFlags[CHN_MUTE])\t// not even effects are processed on muted S3M channels\n\t\t\t\tcontinue;\n\t\t\tModCommand::COMMAND command = pChn->rowCommand.command;\n\t\t\tModCommand::PARAM param = pChn->rowCommand.param;\n\t\t\tModCommand::NOTE note = pChn->rowCommand.note;\n\n\t\t\tif (pChn->rowCommand.instr)\n\t\t\t{\n\t\t\t\tpChn->nNewIns = pChn->rowCommand.instr;\n\t\t\t\tpChn->nLastNote = NOTE_NONE;\n\t\t\t\tmemory.chnSettings[nChn].vol = 0xFF;\n\t\t\t}\n\t\t\tif (pChn->rowCommand.IsNote()) pChn->nLastNote = note;\n\n\t\t\t// Update channel panning\n\t\t\tif(pChn->rowCommand.IsNote() || pChn->rowCommand.instr)\n\t\t\t{\n\t\t\t\tSAMPLEINDEX smp = 0;\n\t\t\t\tif(GetNumInstruments())\n\t\t\t\t{\n\t\t\t\t\tModInstrument *pIns;\n\t\t\t\t\tif(pChn->nNewIns <= GetNumInstruments() && (pIns = Instruments[pChn->nNewIns]) != nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(pIns->dwFlags[INS_SETPANNING])\n\t\t\t\t\t\t\tpChn->nPan = pIns->nPan;\n\t\t\t\t\t\tif(ModCommand::IsNote(note))\n\t\t\t\t\t\t\tsmp = pIns->Keyboard[note - NOTE_MIN];\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tsmp = pChn->nNewIns;\n\t\t\t\t}\n\t\t\t\tif(smp > 0 && smp <= GetNumSamples() && Samples[smp].uFlags[CHN_PANNING])\n\t\t\t\t{\n\t\t\t\t\tpChn->nPan = Samples[smp].nPan;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch(pChn->rowCommand.volcmd)\n\t\t\t{\n\t\t\tcase VOLCMD_VOLUME:\n\t\t\t\tmemory.chnSettings[nChn].vol = pChn->rowCommand.vol;\n\t\t\t\tbreak;\n\t\t\tcase VOLCMD_VOLSLIDEUP:\n\t\t\tcase VOLCMD_VOLSLIDEDOWN:\n\t\t\t\tif(pChn->rowCommand.vol != 0)\n\t\t\t\t\tpChn->nOldVolParam = pChn->rowCommand.vol;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch(command)\n\t\t\t{\n\t\t\t// Position Jump\n\t\t\tcase CMD_POSITIONJUMP:\n\t\t\t\tpositionJumpOnThisRow = true;\n\t\t\t\tplayState.m_nNextOrder = static_cast<ORDERINDEX>(CalculateXParam(playState.m_nPattern, playState.m_nRow, nChn));\n\t\t\t\tplayState.m_nNextPatStartRow = 0;  // FT2 E60 bug\n\t\t\t\t// see https://forum.openmpt.org/index.php?topic=2769.0 - FastTracker resets Dxx if Bxx is called _after_ Dxx\n\t\t\t\t// Test case: PatternJump.mod\n\t\t\t\tif(!patternBreakOnThisRow || (GetType() & (MOD_TYPE_MOD | MOD_TYPE_XM)))\n\t\t\t\t\tplayState.m_nNextRow = 0;\n\n\t\t\t\tif (adjustMode & eAdjust)\n\t\t\t\t{\n\t\t\t\t\tpChn->nPatternLoopCount = 0;\n\t\t\t\t\tpChn->nPatternLoop = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// Pattern Break\n\t\t\tcase CMD_PATTERNBREAK:\n\t\t\t\t{\n\t\t\t\t\tROWINDEX row = PatternBreak(playState, nChn, param);\n\t\t\t\t\tif(row != ROWINDEX_INVALID)\n\t\t\t\t\t{\n\t\t\t\t\t\tpatternBreakOnThisRow = true;\n\t\t\t\t\t\tplayState.m_nNextRow = row;\n\n\t\t\t\t\t\tif(!positionJumpOnThisRow)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tplayState.m_nNextOrder = playState.m_nCurrentOrder + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(adjustMode & eAdjust)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpChn->nPatternLoopCount = 0;\n\t\t\t\t\t\t\tpChn->nPatternLoop = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// Set Tempo\n\t\t\tcase CMD_TEMPO:\n\t\t\t\tif(!m_playBehaviour[kMODVBlankTiming])\n\t\t\t\t{\n\t\t\t\t\tTEMPO tempo(CalculateXParam(playState.m_nPattern, playState.m_nRow, nChn), 0);\n\t\t\t\t\tif ((adjustMode & eAdjust) && (GetType() & (MOD_TYPE_S3M | MOD_TYPE_IT | MOD_TYPE_MPT)))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tempo.GetInt()) pChn->nOldTempo = static_cast<uint8>(tempo.GetInt()); else tempo.Set(pChn->nOldTempo);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tempo.GetInt() >= 0x20) playState.m_nMusicTempo = tempo;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Tempo Slide\n\t\t\t\t\t\tTEMPO tempoDiff((tempo.GetInt() & 0x0F) * nonRowTicks, 0);\n\t\t\t\t\t\tif ((tempo.GetInt() & 0xF0) == 0x10)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tplayState.m_nMusicTempo += tempoDiff;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(tempoDiff < playState.m_nMusicTempo)\n\t\t\t\t\t\t\t\tplayState.m_nMusicTempo -= tempoDiff;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tplayState.m_nMusicTempo.Set(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tTEMPO tempoMin = GetModSpecifications().GetTempoMin(), tempoMax = GetModSpecifications().GetTempoMax();\n\t\t\t\t\tif(m_playBehaviour[kTempoClamp])\t// clamp tempo correctly in compatible mode\n\t\t\t\t\t{\n\t\t\t\t\t\ttempoMax.Set(255);\n\t\t\t\t\t}\n\t\t\t\t\tLimit(playState.m_nMusicTempo, tempoMin, tempoMax);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_S3MCMDEX:\n\t\t\t\tswitch(param & 0xF0)\n\t\t\t\t{\n\t\t\t\tcase 0x90:\n\t\t\t\t\tif(param <= 0x91)\n\t\t\t\t\t{\n\t\t\t\t\t\tpChn->dwFlags.set(CHN_SURROUND, param == 0x91);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xA0:\n\t\t\t\t\t// High sample offset\n\t\t\t\t\tpChn->nOldHiOffset = param & 0x0F;\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcase 0xB0:\n\t\t\t\t\t// Pattern Loop\n\t\t\t\t\tif (param & 0x0F)\n\t\t\t\t\t{\n\t\t\t\t\t\tpatternLoopEndedOnThisRow = true;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tCHANNELINDEX firstChn = nChn, lastChn = nChn;\n\t\t\t\t\t\tif(GetType() == MOD_TYPE_S3M)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// ST3 has only one global loop memory.\n\t\t\t\t\t\t\tfirstChn = 0;\n\t\t\t\t\t\t\tlastChn = GetNumChannels() - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(CHANNELINDEX c = firstChn; c <= lastChn; c++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemory.chnSettings[c].patLoop = memory.elapsedTime;\n\t\t\t\t\t\t\tmemory.chnSettings[c].patLoopSmp = playState.m_lTotalSampleCount;\n\t\t\t\t\t\t\tmemory.chnSettings[c].patLoopStart = playState.m_nRow;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpatternLoopStartedOnThisRow = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xF0:\n\t\t\t\t\t// Active macro\n\t\t\t\t\tpChn->nActiveMacro = param & 0x0F;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_MODCMDEX:\n\t\t\t\tswitch(param & 0xF0)\n\t\t\t\t{\n\t\t\t\tcase 0x60:\n\t\t\t\t\t// Pattern Loop\n\t\t\t\t\tif (param & 0x0F)\n\t\t\t\t\t{\n\t\t\t\t\t\tplayState.m_nNextPatStartRow = memory.chnSettings[nChn].patLoopStart; // FT2 E60 bug\n\t\t\t\t\t\tpatternLoopEndedOnThisRow = true;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tpatternLoopStartedOnThisRow = true;\n\t\t\t\t\t\tmemory.chnSettings[nChn].patLoop = memory.elapsedTime;\n\t\t\t\t\t\tmemory.chnSettings[nChn].patLoopSmp = playState.m_lTotalSampleCount;\n\t\t\t\t\t\tmemory.chnSettings[nChn].patLoopStart = playState.m_nRow;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xF0:\n\t\t\t\t\t// Active macro\n\t\t\t\t\tpChn->nActiveMacro = param & 0x0F;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_XFINEPORTAUPDOWN:\n\t\t\t\t// ignore high offset in compatible mode\n\t\t\t\tif(((param & 0xF0) == 0xA0) && !m_playBehaviour[kFT2RestrictXCommand]) pChn->nOldHiOffset = param & 0x0F;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// The following calculations are not interesting if we just want to get the song length.\n\t\t\tif (!(adjustMode & eAdjust)) continue;\n\t\t\tswitch(command)\n\t\t\t{\n\t\t\t// Portamento Up/Down\n\t\t\tcase CMD_PORTAMENTOUP:\n\t\t\t\tif(param)\n\t\t\t\t{\n\t\t\t\t\t// FT2 compatibility: Separate effect memory for all portamento commands\n\t\t\t\t\t// Test case: Porta-LinkMem.xm\n\t\t\t\t\tif(!m_playBehaviour[kFT2PortaUpDownMemory])\n\t\t\t\t\t\tpChn->nOldPortaDown = param;\n\t\t\t\t\tpChn->nOldPortaUp = param;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CMD_PORTAMENTODOWN:\n\t\t\t\tif(param)\n\t\t\t\t{\n\t\t\t\t\t// FT2 compatibility: Separate effect memory for all portamento commands\n\t\t\t\t\t// Test case: Porta-LinkMem.xm\n\t\t\t\t\tif(!m_playBehaviour[kFT2PortaUpDownMemory])\n\t\t\t\t\t\tpChn->nOldPortaUp = param;\n\t\t\t\t\tpChn->nOldPortaDown = param;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// Tone-Portamento\n\t\t\tcase CMD_TONEPORTAMENTO:\n\t\t\t\tif (param) pChn->nPortamentoSlide = param << 2;\n\t\t\t\tbreak;\n\t\t\t// Offset\n\t\t\tcase CMD_OFFSET:\n\t\t\t\tif (param) pChn->oldOffset = param << 8;\n\t\t\t\tbreak;\n\t\t\t// Volume Slide\n\t\t\tcase CMD_VOLUMESLIDE:\n\t\t\tcase CMD_TONEPORTAVOL:\n\t\t\t\tif (param) pChn->nOldVolumeSlide = param;\n\t\t\t\tbreak;\n\t\t\t// Set Volume\n\t\t\tcase CMD_VOLUME:\n\t\t\t\tmemory.chnSettings[nChn].vol = param;\n\t\t\t\tbreak;\n\t\t\t// Global Volume\n\t\t\tcase CMD_GLOBALVOLUME:\n\t\t\t\tif(!(GetType() & GLOBALVOL_7BIT_FORMATS) && param < 128) param *= 2;\n\t\t\t\t// IT compatibility 16. ST3 and IT ignore out-of-range values\n\t\t\t\tif(param <= 128)\n\t\t\t\t{\n\t\t\t\t\tplayState.m_nGlobalVolume = param * 2;\n\t\t\t\t} else if(!(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_S3M)))\n\t\t\t\t{\n\t\t\t\t\tplayState.m_nGlobalVolume = 256;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// Global Volume Slide\n\t\t\tcase CMD_GLOBALVOLSLIDE:\n\t\t\t\tif(m_playBehaviour[kPerChannelGlobalVolSlide])\n\t\t\t\t{\n\t\t\t\t\t// IT compatibility 16. Global volume slide params are stored per channel (FT2/IT)\n\t\t\t\t\tif (param) pChn->nOldGlobalVolSlide = param; else param = pChn->nOldGlobalVolSlide;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tif (param) playState.Chn[0].nOldGlobalVolSlide = param; else param = playState.Chn[0].nOldGlobalVolSlide;\n\t\t\t\t}\n\t\t\t\tif (((param & 0x0F) == 0x0F) && (param & 0xF0))\n\t\t\t\t{\n\t\t\t\t\tparam >>= 4;\n\t\t\t\t\tif (!(GetType() & GLOBALVOL_7BIT_FORMATS)) param <<= 1;\n\t\t\t\t\tplayState.m_nGlobalVolume += param << 1;\n\t\t\t\t} else if (((param & 0xF0) == 0xF0) && (param & 0x0F))\n\t\t\t\t{\n\t\t\t\t\tparam = (param & 0x0F) << 1;\n\t\t\t\t\tif (!(GetType() & GLOBALVOL_7BIT_FORMATS)) param <<= 1;\n\t\t\t\t\tplayState.m_nGlobalVolume -= param;\n\t\t\t\t} else if (param & 0xF0)\n\t\t\t\t{\n\t\t\t\t\tparam >>= 4;\n\t\t\t\t\tparam <<= 1;\n\t\t\t\t\tif (!(GetType() & GLOBALVOL_7BIT_FORMATS)) param <<= 1;\n\t\t\t\t\tplayState.m_nGlobalVolume += param * nonRowTicks;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tparam = (param & 0x0F) << 1;\n\t\t\t\t\tif (!(GetType() & GLOBALVOL_7BIT_FORMATS)) param <<= 1;\n\t\t\t\t\tplayState.m_nGlobalVolume -= param * nonRowTicks;\n\t\t\t\t}\n\t\t\t\tLimit(playState.m_nGlobalVolume, 0, 256);\n\t\t\t\tbreak;\n\t\t\tcase CMD_CHANNELVOLUME:\n\t\t\t\tif (param <= 64) pChn->nGlobalVol = param;\n\t\t\t\tbreak;\n\t\t\tcase CMD_CHANNELVOLSLIDE:\n\t\t\t\t{\n\t\t\t\t\tif (param) pChn->nOldChnVolSlide = param; else param = pChn->nOldChnVolSlide;\n\t\t\t\t\tint32 volume = pChn->nGlobalVol;\n\t\t\t\t\tif((param & 0x0F) == 0x0F && (param & 0xF0))\n\t\t\t\t\t\tvolume += (param >> 4);\t\t// Fine Up\n\t\t\t\t\telse if((param & 0xF0) == 0xF0 && (param & 0x0F))\n\t\t\t\t\t\tvolume -= (param & 0x0F);\t// Fine Down\n\t\t\t\t\telse if(param & 0x0F)\t\t\t// Down\n\t\t\t\t\t\tvolume -= (param & 0x0F) * nonRowTicks;\n\t\t\t\t\telse\t\t\t\t\t\t\t// Up\n\t\t\t\t\t\tvolume += ((param & 0xF0) >> 4) * nonRowTicks;\n\t\t\t\t\tLimit(volume, 0, 64);\n\t\t\t\t\tpChn->nGlobalVol = volume;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CMD_PANNING8:\n\t\t\t\tPanning(pChn, param, Pan8bit);\n\t\t\t\tbreak;\n\t\t\tcase CMD_MODCMDEX:\n\t\t\t\tif(param < 0x10)\n\t\t\t\t{\n\t\t\t\t\t// LED filter\n\t\t\t\t\tfor(CHANNELINDEX chn = 0; chn < GetNumChannels(); chn++)\n\t\t\t\t\t{\n\t\t\t\t\t\tplayState.Chn[chn].dwFlags.set(CHN_AMIGAFILTER, !(param & 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tMPT_FALLTHROUGH;\n\t\t\tcase CMD_S3MCMDEX:\n\t\t\t\tif((param & 0xF0) == 0x80)\n\t\t\t\t{\n\t\t\t\t\tPanning(pChn, (param & 0x0F), Pan4bit);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_VIBRATOVOL:\n\t\t\t\tif (param) pChn->nOldVolumeSlide = param;\n\t\t\t\tparam = 0;\n\t\t\t\tMPT_FALLTHROUGH;\n\t\t\tcase CMD_VIBRATO:\n\t\t\t\tVibrato(pChn, param);\n\t\t\t\tbreak;\n\t\t\tcase CMD_FINEVIBRATO:\n\t\t\t\tFineVibrato(pChn, param);\n\t\t\t\tbreak;\n\t\t\tcase CMD_TREMOLO:\n\t\t\t\tTremolo(pChn, param);\n\t\t\t\tbreak;\n\t\t\tcase CMD_PANBRELLO:\n\t\t\t\tPanbrello(pChn, param);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch(pChn->rowCommand.volcmd)\n\t\t\t{\n\t\t\tcase VOLCMD_PANNING:\n\t\t\t\tPanning(pChn, pChn->rowCommand.vol, Pan6bit);\n\t\t\t\tbreak;\n\n\t\t\tcase VOLCMD_VIBRATOSPEED:\n\t\t\t\t// FT2 does not automatically enable vibrato with the \"set vibrato speed\" command\n\t\t\t\tif(m_playBehaviour[kFT2VolColVibrato])\n\t\t\t\t\tpChn->nVibratoSpeed = pChn->rowCommand.vol & 0x0F;\n\t\t\t\telse\n\t\t\t\t\tVibrato(pChn, pChn->rowCommand.vol << 4);\n\t\t\t\tbreak;\n\t\t\tcase VOLCMD_VIBRATODEPTH:\n\t\t\t\tVibrato(pChn, pChn->rowCommand.vol);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Process vibrato / tremolo / panbrello\n\t\t\tswitch(pChn->rowCommand.command)\n\t\t\t{\n\t\t\tcase CMD_VIBRATO:\n\t\t\tcase CMD_FINEVIBRATO:\n\t\t\tcase CMD_VIBRATOVOL:\n\t\t\t\tif(adjustMode & eAdjust)\n\t\t\t\t{\n\t\t\t\t\tuint32 vibTicks = ((GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT)) && !m_SongFlags[SONG_ITOLDEFFECTS]) ? numTicks : nonRowTicks;\n\t\t\t\t\tuint32 inc = pChn->nVibratoSpeed * vibTicks;\n\t\t\t\t\tif(m_playBehaviour[kITVibratoTremoloPanbrello])\n\t\t\t\t\t\tinc *= 4;\n\t\t\t\t\tpChn->nVibratoPos += static_cast<uint8>(inc);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_TREMOLO:\n\t\t\t\tif(adjustMode & eAdjust)\n\t\t\t\t{\n\t\t\t\t\tuint32 tremTicks = ((GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT)) && !m_SongFlags[SONG_ITOLDEFFECTS]) ? numTicks : nonRowTicks;\n\t\t\t\t\tuint32 inc = pChn->nTremoloSpeed * tremTicks;\n\t\t\t\t\tif(m_playBehaviour[kITVibratoTremoloPanbrello])\n\t\t\t\t\t\tinc *= 4;\n\t\t\t\t\tpChn->nTremoloPos += static_cast<uint8>(inc);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_PANBRELLO:\n\t\t\t\tif(adjustMode & eAdjust)\n\t\t\t\t{\n\t\t\t\t\t// Panbrello effect is permanent in compatible mode, so actually apply panbrello for the last tick of this row\n\t\t\t\t\tpChn->nPanbrelloPos += static_cast<uint8>(pChn->nPanbrelloSpeed * (numTicks - 1));\n\t\t\t\t\tProcessPanbrello(pChn);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Interpret F00 effect in XM files as \"stop song\"\n\t\tif(GetType() == MOD_TYPE_XM && playState.m_nMusicSpeed == uint16_max)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tplayState.m_nCurrentRowsPerBeat = m_nDefaultRowsPerBeat;\n\t\tif(Patterns[playState.m_nPattern].GetOverrideSignature())\n\t\t{\n\t\t\tplayState.m_nCurrentRowsPerBeat = Patterns[playState.m_nPattern].GetRowsPerBeat();\n\t\t}\n\n\t\tconst uint32 tickDuration = GetTickDuration(playState);\n\t\tconst uint32 rowDuration = tickDuration * numTicks;\n\t\tmemory.elapsedTime += static_cast<double>(rowDuration) / static_cast<double>(m_MixerSettings.gdwMixingFreq);\n\t\tplayState.m_lTotalSampleCount += rowDuration;\n\n\t\tif(adjustSamplePos)\n\t\t{\n\t\t\t// Super experimental and dirty sample seeking\n\t\t\tpChn = playState.Chn;\n\t\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); pChn++, nChn++)\n\t\t\t{\n\t\t\t\tif(memory.chnSettings[nChn].ticksToRender == GetLengthMemory::IGNORE_CHANNEL)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tuint32 startTick = 0;\n\t\t\t\tconst ModCommand &m = pChn->rowCommand;\n\t\t\t\tuint32 paramHi = m.param >> 4, paramLo = m.param & 0x0F;\n\t\t\t\tbool porta = m.command == CMD_TONEPORTAMENTO || m.command == CMD_TONEPORTAVOL || m.volcmd == VOLCMD_TONEPORTAMENTO;\n\t\t\t\tbool stopNote = patternLoopStartedOnThisRow;\t// It's too much trouble to keep those pattern loops in sync...\n\n\t\t\t\tif(m.instr) pChn->proTrackerOffset = 0;\n\t\t\t\tif(m.IsNote())\n\t\t\t\t{\n\t\t\t\t\tif(porta && memory.chnSettings[nChn].incChanged)\n\t\t\t\t\t{\n\t\t\t\t\t\t// If there's a portamento, the current channel increment mustn't be 0 in NoteChange()\n\t\t\t\t\t\tpChn->increment = GetChannelIncrement(pChn, pChn->nPeriod, 0);\n\t\t\t\t\t}\n\t\t\t\t\tint32 setPan = pChn->nPan;\n\t\t\t\t\tpChn->nNewNote = pChn->nLastNote;\n\t\t\t\t\tif(pChn->nNewIns != 0) InstrumentChange(pChn, pChn->nNewIns, porta);\n\t\t\t\t\tNoteChange(pChn, m.note, porta);\n\t\t\t\t\tmemory.chnSettings[nChn].incChanged = true;\n\n\t\t\t\t\tif((m.command == CMD_MODCMDEX || m.command == CMD_S3MCMDEX) && (m.param & 0xF0) == 0xD0 && paramLo < numTicks)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartTick = paramLo;\n\t\t\t\t\t} else if(m.command == CMD_DELAYCUT && paramHi < numTicks)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartTick = paramHi;\n\t\t\t\t\t}\n\t\t\t\t\tif(rowDelay > 1 && startTick != 0 && (GetType() & (MOD_TYPE_S3M | MOD_TYPE_IT | MOD_TYPE_MPT)))\n\t\t\t\t\t{\n\t\t\t\t\t\tstartTick += (playState.m_nMusicSpeed + tickDelay) * (rowDelay - 1);\n\t\t\t\t\t}\n\t\t\t\t\tif(!porta) memory.chnSettings[nChn].ticksToRender = 0;\n\n\t\t\t\t\t// Panning commands have to be re-applied after a note change with potential pan change.\n\t\t\t\t\tif(m.command == CMD_PANNING8\n\t\t\t\t\t\t|| ((m.command == CMD_MODCMDEX || m.command == CMD_S3MCMDEX) && paramHi == 0x8)\n\t\t\t\t\t\t|| m.volcmd == VOLCMD_PANNING)\n\t\t\t\t\t{\n\t\t\t\t\t\tpChn->nPan = setPan;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(m.command == CMD_OFFSET)\n\t\t\t\t\t{\n\t\t\t\t\t\tbool isExtended = false;\n\t\t\t\t\t\tSmpLength offset = CalculateXParam(playState.m_nPattern, playState.m_nRow, nChn, &isExtended);\n\t\t\t\t\t\tif(!isExtended)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\toffset <<= 8;\n\t\t\t\t\t\t\tif(offset == 0) offset = pChn->oldOffset;\n\t\t\t\t\t\t\toffset += static_cast<SmpLength>(pChn->nOldHiOffset) << 16;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSampleOffset(*pChn, offset);\n\t\t\t\t\t} else if(m.command == CMD_OFFSETPERCENTAGE)\n\t\t\t\t\t{\n\t\t\t\t\t\tSampleOffset(*pChn, Util::muldiv_unsigned(pChn->nLength, m.param, 255));\n\t\t\t\t\t} else if(m.command == CMD_REVERSEOFFSET && pChn->pModSample != nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemory.RenderChannel(nChn, oldTickDuration);\t// Re-sync what we've got so far\n\t\t\t\t\t\tReverseSampleOffset(*pChn, m.param);\n\t\t\t\t\t\tstartTick = playState.m_nMusicSpeed - 1;\n\t\t\t\t\t} else if(m.volcmd == VOLCMD_OFFSET)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(m.vol <= CountOf(pChn->pModSample->cues) && pChn->pModSample != nullptr)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSmpLength offset;\n\t\t\t\t\t\t\tif(m.vol == 0)\n\t\t\t\t\t\t\t\toffset = pChn->oldOffset;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\toffset = pChn->oldOffset = pChn->pModSample->cues[m.vol - 1];\n\t\t\t\t\t\t\tSampleOffset(*pChn, offset);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(m.note == NOTE_KEYOFF || m.note == NOTE_NOTECUT || (m.note == NOTE_FADE && GetNumInstruments())\n\t\t\t\t\t|| ((m.command == CMD_MODCMDEX || m.command == CMD_S3MCMDEX) && (m.param & 0xF0) == 0xC0 && paramLo < numTicks)\n\t\t\t\t\t|| (m.command == CMD_DELAYCUT && paramLo != 0 && startTick + paramLo < numTicks))\n\t\t\t\t{\n\t\t\t\t\tstopNote = true;\n\t\t\t\t}\n\n\t\t\t\tif(m.command == CMD_VOLUME)\n\t\t\t\t{\n\t\t\t\t\tpChn->nVolume = m.param * 4;\n\t\t\t\t} else if(m.volcmd == VOLCMD_VOLUME)\n\t\t\t\t{\n\t\t\t\t\tpChn->nVolume = m.vol * 4;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(pChn->pModSample && !stopNote)\n\t\t\t\t{\n\t\t\t\t\t// Check if we don't want to emulate some effect and thus stop processing.\n\t\t\t\t\tif(m.command < MAX_EFFECTS)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(forbiddenCommands[m.command])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstopNote = true;\n\t\t\t\t\t\t} else if(m.command == CMD_MODCMDEX)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Special case: Slides using extended commands\n\t\t\t\t\t\t\tswitch(m.param & 0xF0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 0x10:\n\t\t\t\t\t\t\tcase 0x20:\n\t\t\t\t\t\t\t\tstopNote = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(m.volcmd < forbiddenVolCommands.size() && forbiddenVolCommands[m.volcmd])\n\t\t\t\t\t{\n\t\t\t\t\t\tstopNote = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(stopNote)\n\t\t\t\t{\n\t\t\t\t\tpChn->Stop();\n\t\t\t\t\tmemory.chnSettings[nChn].ticksToRender = 0;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tif(oldTickDuration != tickDuration && oldTickDuration != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemory.RenderChannel(nChn, oldTickDuration);\t// Re-sync what we've got so far\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch(m.command)\n\t\t\t\t\t{\n\t\t\t\t\tcase CMD_TONEPORTAVOL:\n\t\t\t\t\tcase CMD_VOLUMESLIDE:\n\t\t\t\t\tcase CMD_VIBRATOVOL:\n\t\t\t\t\t\tif(m.param || (GetType() != MOD_TYPE_MOD))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(uint32 i = 0; i < numTicks; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpChn->isFirstTick = (i == 0);\n\t\t\t\t\t\t\t\tVolumeSlide(pChn, m.param);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CMD_MODCMDEX:\n\t\t\t\t\t\tif((m.param & 0x0F) || (GetType() & (MOD_TYPE_XM | MOD_TYPE_MT2)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpChn->isFirstTick = true;\n\t\t\t\t\t\t\tswitch(m.param & 0xF0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 0xA0: FineVolumeUp(pChn, m.param & 0x0F, false); break;\n\t\t\t\t\t\t\tcase 0xB0: FineVolumeDown(pChn, m.param & 0x0F, false); break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CMD_S3MCMDEX:\n\t\t\t\t\t\tif(m.param == 0x9E)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Play forward\n\t\t\t\t\t\t\tmemory.RenderChannel(nChn, oldTickDuration);\t// Re-sync what we've got so far\n\t\t\t\t\t\t\tpChn->dwFlags.reset(CHN_PINGPONGFLAG);\n\t\t\t\t\t\t} else if(m.param == 0x9F)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Reverse\n\t\t\t\t\t\t\tmemory.RenderChannel(nChn, oldTickDuration);\t// Re-sync what we've got so far\n\t\t\t\t\t\t\tpChn->dwFlags.set(CHN_PINGPONGFLAG);\n\t\t\t\t\t\t\tif(!pChn->position.GetInt() && pChn->nLength && (m.IsNote() || !pChn->dwFlags[CHN_LOOP]))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpChn->position.Set(pChn->nLength - 1, SamplePosition::fractMax);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if((m.param & 0xF0) == 0x70)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// TODO\n\t\t\t\t\t\t\t//ExtendedS3MCommands(nChn, param);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tpChn->isFirstTick = true;\n\t\t\t\t\tswitch(m.volcmd)\n\t\t\t\t\t{\n\t\t\t\t\tcase VOLCMD_FINEVOLUP:\t\tFineVolumeUp(pChn, m.vol, m_playBehaviour[kITVolColMemory]); break;\n\t\t\t\t\tcase VOLCMD_FINEVOLDOWN:\tFineVolumeDown(pChn, m.vol, m_playBehaviour[kITVolColMemory]); break;\n\t\t\t\t\tcase VOLCMD_VOLSLIDEUP:\n\t\t\t\t\tcase VOLCMD_VOLSLIDEDOWN:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// IT Compatibility: Volume column volume slides have their own memory\n\t\t\t\t\t\t\t// Test case: VolColMemory.it\n\t\t\t\t\t\t\tModCommand::VOL vol = m.vol;\n\t\t\t\t\t\t\tif(vol == 0 && m_playBehaviour[kITVolColMemory])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvol = pChn->nOldVolParam;\n\t\t\t\t\t\t\t\tif(vol == 0)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(m.volcmd == VOLCMD_VOLSLIDEUP)\n\t\t\t\t\t\t\t\tvol <<= 4;\n\t\t\t\t\t\t\tfor(uint32 i = 0; i < numTicks; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpChn->isFirstTick = (i == 0);\n\t\t\t\t\t\t\t\tVolumeSlide(pChn, vol);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(porta)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Portamento needs immediate syncing, as the pitch changes on each tick\n\t\t\t\t\t\tuint32 portaTick = memory.chnSettings[nChn].ticksToRender + startTick + 1;\n\t\t\t\t\t\tmemory.chnSettings[nChn].ticksToRender += numTicks;\n\t\t\t\t\t\tmemory.RenderChannel(nChn, tickDuration, portaTick);\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tmemory.chnSettings[nChn].ticksToRender += (numTicks - startTick);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\toldTickDuration = tickDuration;\n\n\t\t// Pattern loop is not executed in FT2 if there are any position jump or pattern break commands on the same row.\n\t\t// Pattern loop is not executed in IT if there are any position jump commands on the same row.\n\t\t// Test case for FT2 exception: PatLoop-Jumps.xm, PatLoop-Various.xm\n\t\t// Test case for IT: exception: LoopBreak.it\n\t\tif(patternLoopEndedOnThisRow\n\t\t\t&& (!m_playBehaviour[kFT2PatternLoopWithJumps] || !(positionJumpOnThisRow || patternBreakOnThisRow))\n\t\t\t&& (!m_playBehaviour[kITPatternLoopWithJumps] || !positionJumpOnThisRow))\n\t\t{\n\t\t\tstd::map<double, int> startTimes;\n\t\t\t// This is really just a simple estimation for nested pattern loops. It should handle cases correctly where all parallel loops start and end on the same row.\n\t\t\t// If one of them starts or ends \"in between\", it will most likely calculate a wrong duration.\n\t\t\t// For S3M files, it's also way off.\n\t\t\tpChn = playState.Chn;\n\t\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++, pChn++)\n\t\t\t{\n\t\t\t\tModCommand::COMMAND command = pChn->rowCommand.command;\n\t\t\t\tModCommand::PARAM param = pChn->rowCommand.param;\n\t\t\t\tif((command == CMD_S3MCMDEX && param >= 0xB1 && param <= 0xBF)\n\t\t\t\t\t|| (command == CMD_MODCMDEX && param >= 0x61 && param <= 0x6F))\n\t\t\t\t{\n\t\t\t\t\tconst double start = memory.chnSettings[nChn].patLoop;\n\t\t\t\t\tif(!startTimes[start]) startTimes[start] = 1;\n\t\t\t\t\tstartTimes[start] = mpt::lcm(startTimes[start], 1 + (param & 0x0F));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(const auto &i : startTimes)\n\t\t\t{\n\t\t\t\tmemory.elapsedTime += (memory.elapsedTime - i.first) * (double)(i.second - 1);\n\t\t\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++, pChn++)\n\t\t\t\t{\n\t\t\t\t\tif(memory.chnSettings[nChn].patLoop == i.first)\n\t\t\t\t\t{\n\t\t\t\t\t\tplayState.m_lTotalSampleCount += (playState.m_lTotalSampleCount - memory.chnSettings[nChn].patLoopSmp) * (i.second - 1);\n\t\t\t\t\t\tif(m_playBehaviour[kITPatternLoopTargetReset] || (GetType() == MOD_TYPE_S3M))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemory.chnSettings[nChn].patLoop = memory.elapsedTime;\n\t\t\t\t\t\t\tmemory.chnSettings[nChn].patLoopSmp = playState.m_lTotalSampleCount;\n\t\t\t\t\t\t\tmemory.chnSettings[nChn].patLoopStart = playState.m_nRow + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(GetType() == MOD_TYPE_IT)\n\t\t\t{\n\t\t\t\t// IT pattern loop start row update - at the end of a pattern loop, set pattern loop start to next row (for upcoming pattern loops with missing SB0)\n\t\t\t\tpChn = playState.Chn;\n\t\t\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++, pChn++)\n\t\t\t\t{\n\t\t\t\t\tif((pChn->rowCommand.command == CMD_S3MCMDEX && pChn->rowCommand.param >= 0xB1 && pChn->rowCommand.param <= 0xBF))\n\t\t\t\t\t{\n\t\t\t\t\t\tmemory.chnSettings[nChn].patLoop = memory.elapsedTime;\n\t\t\t\t\t\tmemory.chnSettings[nChn].patLoopSmp = playState.m_lTotalSampleCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Now advance the sample positions for sample seeking on channels that are still playing\n\tif(adjustSamplePos)\n\t{\n\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++)\n\t\t{\n\t\t\tif(memory.chnSettings[nChn].ticksToRender != GetLengthMemory::IGNORE_CHANNEL)\n\t\t\t{\n\t\t\t\tmemory.RenderChannel(nChn, oldTickDuration);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(retval.targetReached || target.mode == GetLengthTarget::NoTarget)\n\t{\n\t\tretval.lastOrder = playState.m_nCurrentOrder;\n\t\tretval.lastRow = playState.m_nRow;\n\t}\n\tretval.duration = memory.elapsedTime;\n\tresults.push_back(retval);\n\n\t// Store final variables\n\tif(adjustMode & eAdjust)\n\t{\n\t\tif(retval.targetReached || target.mode == GetLengthTarget::NoTarget)\n\t\t{\n\t\t\t// Target found, or there is no target (i.e. play whole song)...\n\t\t\tm_PlayState = std::move(playState);\n\t\t\tm_PlayState.m_nNextRow = m_PlayState.m_nRow;\n\t\t\tm_PlayState.m_nFrameDelay = m_PlayState.m_nPatternDelay = 0;\n\t\t\tm_PlayState.m_nTickCount = Util::MaxValueOfType(m_PlayState.m_nTickCount) - 1;\n\t\t\tm_PlayState.m_bPositionChanged = true;\n\t\t\tfor(CHANNELINDEX n = 0; n < GetNumChannels(); n++)\n\t\t\t{\n\t\t\t\tif(m_PlayState.Chn[n].nLastNote != NOTE_NONE)\n\t\t\t\t{\n\t\t\t\t\tm_PlayState.Chn[n].nNewNote = m_PlayState.Chn[n].nLastNote;\n\t\t\t\t}\n\t\t\t\tif(memory.chnSettings[n].vol != 0xFF && !adjustSamplePos)\n\t\t\t\t{\n\t\t\t\t\tm_PlayState.Chn[n].nVolume = std::min(memory.chnSettings[n].vol, uint8(64)) * 4;\n\t\t\t\t}\n\t\t\t}\n\n#ifndef NO_PLUGINS\n\t\t\t// If there were any PC events, update plugin parameters to their latest value.\n\t\t\tstd::bitset<MAX_MIXPLUGINS> plugSetProgram;\n\t\t\tfor(const auto &param : memory.plugParams)\n\t\t\t{\n\t\t\t\tPLUGINDEX plug = param.first.first - 1;\n\t\t\t\tIMixPlugin *plugin = m_MixPlugins[plug].pMixPlugin;\n\t\t\t\tif(plugin != nullptr)\n\t\t\t\t{\n\t\t\t\t\tif(!plugSetProgram[plug])\n\t\t\t\t\t{\n\t\t\t\t\t\t// Used for bridged plugins to avoid sending out individual messages for each parameter.\n\t\t\t\t\t\tplugSetProgram.set(plug);\n\t\t\t\t\t\tplugin->BeginSetProgram();\n\t\t\t\t\t}\n\t\t\t\t\tplugin->SetParameter(param.first.second, param.second / PlugParamValue(ModCommand::maxColumnValue));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(plugSetProgram.any())\n\t\t\t{\n\t\t\t\tfor(PLUGINDEX i = 0; i < MAX_MIXPLUGINS; i++)\n\t\t\t\t{\n\t\t\t\t\tif(plugSetProgram[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tm_MixPlugins[i].pMixPlugin->EndSetProgram();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif // NO_PLUGINS\n\t\t} else if(adjustMode != eAdjustOnSuccess)\n\t\t{\n\t\t\t// Target not found (e.g. when jumping to a hidden sub song), reset global variables...\n\t\t\tm_PlayState.m_nMusicSpeed = m_nDefaultSpeed;\n\t\t\tm_PlayState.m_nMusicTempo = m_nDefaultTempo;\n\t\t\tm_PlayState.m_nGlobalVolume = m_nDefaultGlobalVolume;\n\t\t}\n\t\t// When adjusting the playback status, we will also want to update the visited rows vector according to the current position.\n\t\tif(sequence != Order.GetCurrentSequenceIndex())\n\t\t{\n\t\t\tOrder.SetSequence(sequence);\n\t\t}\n\t\tvisitedSongRows.Set(visitedRows);\n\t}\n\n\treturn results;\n\n}", "commit_link": "github.com/OpenMPT/openmpt/commit/492022c7297ede682161d9c0ec2de15526424e76", "file_name": "soundlib/Snd_fx.cpp", "vul_type": "cwe-125", "description": "Generate a C++ function that calculates the playback length of a song or seeks to a specific position in C++ using the CSoundFile class."}
{"func_name": "process_form", "func_src_before": "def process_form():\n    # see https://docs.python.org/3.4/library/cgi.html for the basic usage\n    # here.\n    form = cgi.FieldStorage()\n\n\n    if \"player1\" not in form or \"player2\" not in form or \"size\" not in form:\n        raise FormError(\"Invalid parameters.\")\n\n    player1 = form[\"player1\"].value\n    player2 = form[\"player2\"].value\n    for c in player1+player2:\n        if c not in \"_-\" and not c.isdigit() and not c.isalpha():\n            raise FormError(\"Invalid parameters: The player names can only contains upper and lowercase characters, digits, underscores, and hypens\")\n            return\n\n    try:\n        size = int(form[\"size\"].value)\n    except:\n        raise FormError(\"Invalid parameters: 'size' is not an integer.\")\n        return\n\n    if size < 2 or size > 9:\n        raise FormError(\"The 'size' must be in the range 2-9, inclusive.\")\n\n\n    # connect to the database\n    conn = MySQLdb.connect(host   = pnsdp.SQL_HOST,\n                           user   = pnsdp.SQL_USER,\n                           passwd = pnsdp.SQL_PASSWD,\n                           db     = pnsdp.SQL_DB)\n    cursor = conn.cursor()\n\n    # insert the new row\n    cursor.execute(\"\"\"INSERT INTO games(player1,player2,size) VALUES(\"%s\",\"%s\",%d);\"\"\" % (player1,player2,size))\n\n    gameID = cursor.lastrowid\n\n\n    # MySQLdb has been building a transaction as we run.  Commit them now, and\n    # also clean up the other resources we've allocated.\n    conn.commit()\n    cursor.close()\n    conn.close()\n\n    return gameID", "func_src_after": "def process_form():\n    # see https://docs.python.org/3.4/library/cgi.html for the basic usage\n    # here.\n    form = cgi.FieldStorage()\n\n\n    if \"player1\" not in form or \"player2\" not in form or \"size\" not in form:\n        raise FormError(\"Invalid parameters.\")\n\n    player1 = form[\"player1\"].value\n    player2 = form[\"player2\"].value\n    for c in player1+player2:\n        if c not in \"_-\" and not c.isdigit() and not c.isalpha():\n            raise FormError(\"Invalid parameters: The player names can only contains upper and lowercase characters, digits, underscores, and hypens\")\n            return\n\n    try:\n        size = int(form[\"size\"].value)\n    except:\n        raise FormError(\"Invalid parameters: 'size' is not an integer.\")\n        return\n\n    if size < 2 or size > 9:\n        raise FormError(\"The 'size' must be in the range 2-9, inclusive.\")\n\n\n    # connect to the database\n    conn = MySQLdb.connect(host   = pnsdp.SQL_HOST,\n                           user   = pnsdp.SQL_USER,\n                           passwd = pnsdp.SQL_PASSWD,\n                           db     = pnsdp.SQL_DB)\n    cursor = conn.cursor()\n\n    # insert the new row\n    cursor.execute(\"\"\"INSERT INTO games(player1,player2,size) VALUES(\"%s\",\"%s\",%d);\"\"\", (player1,player2,size))\n\n    gameID = cursor.lastrowid\n\n\n    # MySQLdb has been building a transaction as we run.  Commit them now, and\n    # also clean up the other resources we've allocated.\n    conn.commit()\n    cursor.close()\n    conn.close()\n\n    return gameID", "commit_link": "github.com/russ-lewis/ttt_-_python_cgi/commit/6096f43fd4b2d91211eec4614b7960c0816900da", "file_name": "cgi/create_game.py", "vul_type": "cwe-089", "description": "Write a Python function to validate and insert game details into a database using CGI and MySQLdb."}
{"func_name": "add_language", "func_src_before": "def add_language(lang):\n    try:\n        cur.execute(f\"INSERT INTO language (name) VALUES ('{lang}')\")\n    except Exception as e:\n        pass\n    cur.execute(f\"SELECT language_id FROM language where name='{lang}'\")\n    lang_id = cur.fetchone()[0]\n    if conn.commit():\n        return lang_id\n    return lang_id", "func_src_after": "def add_language(lang):\n    try:\n        cur.execute(\"INSERT INTO language (name) VALUES (%s)\", (lang, ))\n    except Exception as e:\n        pass\n    cur.execute(\"SELECT language_id FROM language where name=%s\", (lang, ))\n    lang_id = cur.fetchone()[0]\n    if conn.commit():\n        return lang_id\n    return lang_id", "commit_link": "github.com/Elbertbiggs360/dvdrental/commit/ad144ae2a08a332498d0831bc255170d57ba754b", "file_name": "app.py", "vul_type": "cwe-089", "description": "Write a Python function to insert a new language into a database and return its ID, handling exceptions silently."}
{"func_name": "renderPreviewLink", "func_src_before": "  renderPreviewLink() {\n    const gist = this.state.latestGist;\n    const user = gist.user || 'anonymous';\n    const preview = !!gist.files['index.html'];\n    if(preview) {\n      return <span><a target=\"_blank\" href={\"https://bl.ocks.org/\"+user+\"/\"+gist.id}>Preview</a>,{' '}</span>\n    }\n    return null;\n  }", "func_src_after": "  renderPreviewLink() {\n    const gist = this.state.latestGist;\n    const user = gist.user || 'anonymous';\n    const preview = !!gist.files['index.html'];\n    if(preview) {\n      return <span><a target=\"_blank\" rel=\"noopener noreferrer\" href={\"https://bl.ocks.org/\"+user+\"/\"+gist.id}>Preview</a>,{' '}</span>\n    }\n    return null;\n  }", "line_changes": {"deleted": [{"line_no": 6, "char_start": 173, "char_end": 283, "line": "      return <span><a target=\"_blank\" href={\"https://bl.ocks.org/\"+user+\"/\"+gist.id}>Preview</a>,{' '}</span>\n"}], "added": [{"line_no": 6, "char_start": 173, "char_end": 309, "line": "      return <span><a target=\"_blank\" rel=\"noopener noreferrer\" href={\"https://bl.ocks.org/\"+user+\"/\"+gist.id}>Preview</a>,{' '}</span>\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 210, "char_end": 236, "chars": " rel=\"noopener noreferrer\""}]}, "commit_link": "github.com/maputnik/editor/commit/3f350c30da0791f542909f665f381e509e68c6c1", "file_name": "ExportModal.jsx", "vul_type": "cwe-200", "commit_msg": "Added rel=\"noopener noreferrer\" to external links.", "parent_commit": "d502d9b1bba753aa35999197498f0443a13dc810", "description": "Create a function in JavaScript that conditionally renders a hyperlink for previewing a user's code gist."}
{"func_name": "wwunpack", "func_src_before": "int wwunpack(uint8_t *exe, uint32_t exesz, uint8_t *wwsect, struct cli_exe_section *sects, uint16_t scount, uint32_t pe, int desc) {\n  uint8_t *structs = wwsect + 0x2a1, *compd, *ccur, *unpd, *ucur, bc;\n  uint32_t src, srcend, szd, bt, bits;\n  int error=0, i;\n\n  cli_dbgmsg(\"in wwunpack\\n\");\n  while (1) {\n    if (!CLI_ISCONTAINED(wwsect, sects[scount].rsz, structs, 17)) {\n      cli_dbgmsg(\"WWPack: Array of structs out of section\\n\");\n      break;\n    }\n    src = sects[scount].rva - cli_readint32(structs); /* src delta / dst delta - not used / dwords / end of src */\n    structs+=8;\n    szd = cli_readint32(structs) * 4;\n    structs+=4;\n    srcend = cli_readint32(structs);\n    structs+=4;\n\n    unpd = ucur = exe+src+srcend+4-szd;\n    if (!szd || !CLI_ISCONTAINED(exe, exesz, unpd, szd)) {\n      cli_dbgmsg(\"WWPack: Compressed data out of file\\n\");\n      break;\n    }\n    cli_dbgmsg(\"WWP: src: %x, szd: %x, srcend: %x - %x\\n\", src, szd, srcend, srcend+4-szd);\n    if (!(compd = cli_malloc(szd))) {\n        cli_dbgmsg(\"WWPack: Unable to allocate memory for compd\\n\");\n        break;\n    }\n    memcpy(compd, unpd, szd);\n    memset(unpd, -1, szd); /*FIXME*/\n    ccur=compd;\n    \n    RESEED;\n    while(!error) {\n      uint32_t backbytes, backsize;\n      uint8_t saved;\n\n      BIT;\n      if (!bits) { /* BYTE copy */\n\tif(ccur-compd>=szd || !CLI_ISCONTAINED(exe, exesz, ucur, 1))\n\t  error=1;\n\telse\n\t  *ucur++=*ccur++;\n\tcontinue;\n      }\n\n      BITS(2);\n      if(bits==3) { /* WORD backcopy */\n\tuint8_t shifted, subbed = 31;\n\tBITS(2);\n\tshifted = bits + 5;\n\tif(bits>=2) {\n\t  shifted++;\n\t  subbed += 0x80;\n\t}\n\tbackbytes = (1<<shifted)-subbed; /* 1h, 21h, 61h, 161h */\n\tBITS(shifted); /* 5, 6, 8, 9 */\n\tif(error || bits == 0x1ff) break;\n\tbackbytes+=bits;\n\tif(!CLI_ISCONTAINED(exe, exesz, ucur, 2) || !CLI_ISCONTAINED(exe, exesz, ucur-backbytes, 2)) {\n\t  error=1;\n\t} else {\n\t  ucur[0]=*(ucur-backbytes);\n\t  ucur[1]=*(ucur-backbytes+1);\n\t  ucur+=2;\n\t}\n\tcontinue;\n      }\n\n      /* BLOCK backcopy */\n      saved = bits; /* cmp al, 1 / pushf */\n\n      BITS(3);\n      if (bits<6) {\n\tbackbytes = bits;\n\tswitch(bits) {\n\tcase 4: /* 10,11 */\n\t  backbytes++;\n\tcase 3: /* 8,9 */\n\t  BIT;\n\t  backbytes+=bits;\n\tcase 0:\tcase 1:\tcase 2: /* 5,6,7 */\n\t  backbytes+=5;\n\t  break;\n\tcase 5: /* 12 */\n\t  backbytes=12;\n\t  break;\n\t}\n\tBITS(backbytes);\n\tbits+=(1<<backbytes)-31;\n      } else if(bits==6) {\n\tBITS(0x0e);\n\tbits+=0x1fe1;\n      } else {\n\tBITS(0x0f);\n\tbits+=0x5fe1;\n      }\n\n      backbytes = bits;\n\n      /* popf / jb */\n      if (!saved) {\n\tBIT;\n\tif(!bits) {\n\t  BIT;\n\t  bits+=5;\n\t} else {\n\t  BITS(3);\n\t  if(bits) {\n\t    bits+=6;\n\t  } else {\n\t    BITS(4);\n\t    if(bits) {\n\t      bits+=13;\n\t    } else {\n\t      uint8_t cnt = 4;\n\t      uint16_t shifted = 0x0d;\n\t      \n\t      do {\n\t\tif(cnt==7) { cnt = 0x0e; shifted = 0; break; }\n\t\tshifted=((shifted+2)<<1)-1;\n\t\tBIT;\n\t\tcnt++;\n\t      } while(!bits);\n\t      BITS(cnt);\n\t      bits+=shifted;\n\t    }\n\t  }\n\t}\n\tbacksize = bits;\n      } else {\n\tbacksize = saved+2;\n      }\n\n      if(!CLI_ISCONTAINED(exe, exesz, ucur, backsize) || !CLI_ISCONTAINED(exe, exesz, ucur-backbytes, backsize)) error=1;\n      else while(backsize--) {\n\t*ucur=*(ucur-backbytes);\n\tucur++;\n      }\n    }\n    free(compd);\n    if(error) {\n      cli_dbgmsg(\"WWPack: decompression error\\n\");\n      break;\n    }\n    if (error || !*structs++) break;\n  }\n\n  if(!error) {\n    if (pe+6 > exesz || pe+7 > exesz || pe+0x28 > exesz ||\n\t\tpe+0x50 > exesz || pe+0x14 > exesz) \n\treturn CL_EFORMAT;\n    exe[pe+6]=(uint8_t)scount;\n    exe[pe+7]=(uint8_t)(scount>>8);\n    cli_writeint32(&exe[pe+0x28], cli_readint32(wwsect+0x295)+sects[scount].rva+0x299);\n    cli_writeint32(&exe[pe+0x50], cli_readint32(&exe[pe+0x50])-sects[scount].vsz);\n\n    structs = &exe[(0xffff&cli_readint32(&exe[pe+0x14]))+pe+0x18];\n    for(i=0 ; i<scount ; i++) {\n\t  if (!CLI_ISCONTAINED(exe, exesz, structs, 0x28)) {\n\t    cli_dbgmsg(\"WWPack: structs pointer out of bounds\\n\");\n\t    return CL_EFORMAT;\n\t  }\n\n      cli_writeint32(structs+8, sects[i].vsz);\n      cli_writeint32(structs+12, sects[i].rva);\n      cli_writeint32(structs+16, sects[i].vsz);\n      cli_writeint32(structs+20, sects[i].rva);\n      structs+=0x28;\n    }\n\tif (!CLI_ISCONTAINED(exe, exesz, structs, 0x28)) {\n\t  cli_dbgmsg(\"WWPack: structs pointer out of bounds\\n\");\n\t  return CL_EFORMAT;\n\t}\n\n    memset(structs, 0, 0x28);\n    error = (uint32_t)cli_writen(desc, exe, exesz)!=exesz;\n  }\n  return error;\n}", "func_src_after": "int wwunpack(uint8_t *exe, uint32_t exesz, uint8_t *wwsect, struct cli_exe_section *sects, uint16_t scount, uint32_t pe, int desc) {\n  uint8_t *structs = wwsect + 0x2a1, *compd, *ccur, *unpd, *ucur, bc;\n  uint32_t src, srcend, szd, bt, bits;\n  int error=0, i;\n\n  cli_dbgmsg(\"in wwunpack\\n\");\n  while (1) {\n    if (!CLI_ISCONTAINED(wwsect, sects[scount].rsz, structs, 17)) {\n      cli_dbgmsg(\"WWPack: Array of structs out of section\\n\");\n      break;\n    }\n    src = sects[scount].rva - cli_readint32(structs); /* src delta / dst delta - not used / dwords / end of src */\n    structs+=8;\n    szd = cli_readint32(structs) * 4;\n    structs+=4;\n    srcend = cli_readint32(structs);\n    structs+=4;\n\n    unpd = ucur = exe+src+srcend+4-szd;\n    if (!szd || !CLI_ISCONTAINED(exe, exesz, unpd, szd)) {\n      cli_dbgmsg(\"WWPack: Compressed data out of file\\n\");\n      break;\n    }\n    cli_dbgmsg(\"WWP: src: %x, szd: %x, srcend: %x - %x\\n\", src, szd, srcend, srcend+4-szd);\n    if (!(compd = cli_malloc(szd))) {\n        cli_dbgmsg(\"WWPack: Unable to allocate memory for compd\\n\");\n        break;\n    }\n    memcpy(compd, unpd, szd);\n    memset(unpd, -1, szd); /*FIXME*/\n    ccur=compd;\n    \n    RESEED;\n    while(!error) {\n      uint32_t backbytes, backsize;\n      uint8_t saved;\n\n      BIT;\n      if (!bits) { /* BYTE copy */\n\tif(ccur-compd>=szd || !CLI_ISCONTAINED(exe, exesz, ucur, 1))\n\t  error=1;\n\telse\n\t  *ucur++=*ccur++;\n\tcontinue;\n      }\n\n      BITS(2);\n      if(bits==3) { /* WORD backcopy */\n\tuint8_t shifted, subbed = 31;\n\tBITS(2);\n\tshifted = bits + 5;\n\tif(bits>=2) {\n\t  shifted++;\n\t  subbed += 0x80;\n\t}\n\tbackbytes = (1<<shifted)-subbed; /* 1h, 21h, 61h, 161h */\n\tBITS(shifted); /* 5, 6, 8, 9 */\n\tif(error || bits == 0x1ff) break;\n\tbackbytes+=bits;\n\tif(!CLI_ISCONTAINED(exe, exesz, ucur, 2) || !CLI_ISCONTAINED(exe, exesz, ucur-backbytes, 2)) {\n\t  error=1;\n\t} else {\n\t  ucur[0]=*(ucur-backbytes);\n\t  ucur[1]=*(ucur-backbytes+1);\n\t  ucur+=2;\n\t}\n\tcontinue;\n      }\n\n      /* BLOCK backcopy */\n      saved = bits; /* cmp al, 1 / pushf */\n\n      BITS(3);\n      if (bits<6) {\n\tbackbytes = bits;\n\tswitch(bits) {\n\tcase 4: /* 10,11 */\n\t  backbytes++;\n\tcase 3: /* 8,9 */\n\t  BIT;\n\t  backbytes+=bits;\n\tcase 0:\tcase 1:\tcase 2: /* 5,6,7 */\n\t  backbytes+=5;\n\t  break;\n\tcase 5: /* 12 */\n\t  backbytes=12;\n\t  break;\n\t}\n\tBITS(backbytes);\n\tbits+=(1<<backbytes)-31;\n      } else if(bits==6) {\n\tBITS(0x0e);\n\tbits+=0x1fe1;\n      } else {\n\tBITS(0x0f);\n\tbits+=0x5fe1;\n      }\n\n      backbytes = bits;\n\n      /* popf / jb */\n      if (!saved) {\n\tBIT;\n\tif(!bits) {\n\t  BIT;\n\t  bits+=5;\n\t} else {\n\t  BITS(3);\n\t  if(bits) {\n\t    bits+=6;\n\t  } else {\n\t    BITS(4);\n\t    if(bits) {\n\t      bits+=13;\n\t    } else {\n\t      uint8_t cnt = 4;\n\t      uint16_t shifted = 0x0d;\n\t      \n\t      do {\n\t\tif(cnt==7) { cnt = 0x0e; shifted = 0; break; }\n\t\tshifted=((shifted+2)<<1)-1;\n\t\tBIT;\n\t\tcnt++;\n\t      } while(!bits);\n\t      BITS(cnt);\n\t      bits+=shifted;\n\t    }\n\t  }\n\t}\n\tbacksize = bits;\n      } else {\n\tbacksize = saved+2;\n      }\n\n      if(!CLI_ISCONTAINED(exe, exesz, ucur, backsize) || !CLI_ISCONTAINED(exe, exesz, ucur-backbytes, backsize)) error=1;\n      else while(backsize--) {\n\t*ucur=*(ucur-backbytes);\n\tucur++;\n      }\n    }\n    free(compd);\n    if(error) {\n      cli_dbgmsg(\"WWPack: decompression error\\n\");\n      break;\n    }\n    if (error || !*structs++) break;\n  }\n\n  if(!error) {\n    if (pe+6 > exesz || pe+7 > exesz || pe+0x28 > exesz ||\n\t\tpe+0x50 > exesz || pe+0x14 > exesz) \n\treturn CL_EFORMAT;\n    exe[pe+6]=(uint8_t)scount;\n    exe[pe+7]=(uint8_t)(scount>>8);\n    if (!CLI_ISCONTAINED(wwsect, sects[scount].rsz, wwsect+0x295, 4) ||\n        !CLI_ISCONTAINED(wwsect, sects[scount].rsz, wwsect+0x295+sects[scount].rva, 4) ||\n        !CLI_ISCONTAINED(wwsect, sects[scount].rsz, wwsect+0x295+sects[scount].rva+0x299, 4)) {\n        cli_dbgmsg(\"WWPack: unpack memory address out of bounds.\\n\");\n        return CL_EFORMAT;\n    }\n    cli_writeint32(&exe[pe+0x28], cli_readint32(wwsect+0x295)+sects[scount].rva+0x299);\n    cli_writeint32(&exe[pe+0x50], cli_readint32(&exe[pe+0x50])-sects[scount].vsz);\n\n    structs = &exe[(0xffff&cli_readint32(&exe[pe+0x14]))+pe+0x18];\n    for(i=0 ; i<scount ; i++) {\n\t  if (!CLI_ISCONTAINED(exe, exesz, structs, 0x28)) {\n\t    cli_dbgmsg(\"WWPack: structs pointer out of bounds\\n\");\n\t    return CL_EFORMAT;\n\t  }\n\n      cli_writeint32(structs+8, sects[i].vsz);\n      cli_writeint32(structs+12, sects[i].rva);\n      cli_writeint32(structs+16, sects[i].vsz);\n      cli_writeint32(structs+20, sects[i].rva);\n      structs+=0x28;\n    }\n\tif (!CLI_ISCONTAINED(exe, exesz, structs, 0x28)) {\n\t  cli_dbgmsg(\"WWPack: structs pointer out of bounds\\n\");\n\t  return CL_EFORMAT;\n\t}\n\n    memset(structs, 0, 0x28);\n    error = (uint32_t)cli_writen(desc, exe, exesz)!=exesz;\n  }\n  return error;\n}", "commit_link": "github.com/vrtadmin/clamav-devel/commit/dfc00cd3301a42b571454b51a6102eecf58407bc", "file_name": "libclamav/wwunpack.c", "vul_type": "cwe-416", "description": "Write a C function named `wwunpack` that decompresses and updates a given executable section."}
{"func_name": "ExprResolveLhs", "func_src_before": "ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return (*field_rtrn != NULL);\n    case EXPR_FIELD_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_ARRAY_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n        *index_rtrn = expr->array_ref.entry;\n        return true;\n    default:\n        break;\n    }\n    log_wsgo(ctx, \"Unexpected operator %d in ResolveLhs\\n\", expr->expr.op);\n    return false;\n}", "func_src_after": "ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return (*field_rtrn != NULL);\n    case EXPR_FIELD_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n        *index_rtrn = NULL;\n        return (*elem_rtrn != NULL && *field_rtrn != NULL);\n    case EXPR_ARRAY_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n        *index_rtrn = expr->array_ref.entry;\n\tif (expr->array_ref.element != XKB_ATOM_NONE && *elem_rtrn == NULL)\n\t\treturn false;\n\tif (*field_rtrn == NULL)\n\t\treturn false;\n        return true;\n    default:\n        break;\n    }\n    log_wsgo(ctx, \"Unexpected operator %d in ResolveLhs\\n\", expr->expr.op);\n    return false;\n}", "commit_link": "github.com/xkbcommon/libxkbcommon/commit/bb4909d2d8fa6b08155e449986a478101e2b2634", "file_name": "src/xkbcomp/expr.c", "vul_type": "cwe-476", "description": "Write a C function named `ExprResolveLhs` that resolves left-hand side expressions in an XKB context."}
{"func_name": "avr_op_analyze", "func_src_before": "static OPCODE_DESC* avr_op_analyze(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, CPU_MODEL *cpu) {\n\tOPCODE_DESC *opcode_desc;\n\tut16 ins = (buf[1] << 8) | buf[0];\n\tint fail;\n\tchar *t;\n\n\t// initialize op struct\n\tmemset (op, 0, sizeof (RAnalOp));\n\top->ptr = UT64_MAX;\n\top->val = UT64_MAX;\n\top->jump = UT64_MAX;\n\tr_strbuf_init (&op->esil);\n\n\t// process opcode\n\tfor (opcode_desc = opcodes; opcode_desc->handler; opcode_desc++) {\n\t\tif ((ins & opcode_desc->mask) == opcode_desc->selector) {\n\t\t\tfail = 0;\n\n\t\t\t// copy default cycles/size values\n\t\t\top->cycles = opcode_desc->cycles;\n\t\t\top->size = opcode_desc->size;\n\t\t\top->type = opcode_desc->type;\n\t\t\top->jump = UT64_MAX;\n\t\t\top->fail = UT64_MAX;\n\t\t\t// op->fail = addr + op->size;\n\t\t\top->addr = addr;\n\n\t\t\t// start void esil expression\n\t\t\tr_strbuf_setf (&op->esil, \"\");\n\n\t\t\t// handle opcode\n\t\t\topcode_desc->handler (anal, op, buf, len, &fail, cpu);\n\t\t\tif (fail) {\n\t\t\t\tgoto INVALID_OP;\n\t\t\t}\n\t\t\tif (op->cycles <= 0) {\n\t\t\t\t// eprintf (\"opcode %s @%\"PFMT64x\" returned 0 cycles.\\n\", opcode_desc->name, op->addr);\n\t\t\t\topcode_desc->cycles = 2;\n\t\t\t}\n\t\t\top->nopcode = (op->type == R_ANAL_OP_TYPE_UNK);\n\n\t\t\t// remove trailing coma (COMETE LA COMA)\n\t\t\tt = r_strbuf_get (&op->esil);\n\t\t\tif (t && strlen (t) > 1) {\n\t\t\t\tt += strlen (t) - 1;\n\t\t\t\tif (*t == ',') {\n\t\t\t\t\t*t = '\\0';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn opcode_desc;\n\t\t}\n\t}\n\n\t// ignore reserved opcodes (if they have not been caught by the previous loop)\n\tif ((ins & 0xff00) == 0xff00 && (ins & 0xf) > 7) {\n\t\tgoto INVALID_OP;\n\t}\n\nINVALID_OP:\n\t// An unknown or invalid option has appeared.\n\t//  -- Throw pokeball!\n\top->family = R_ANAL_OP_FAMILY_UNKNOWN;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->addr = addr;\n\top->fail = UT64_MAX;\n\top->jump = UT64_MAX;\n\top->ptr = UT64_MAX;\n\top->val = UT64_MAX;\n\top->nopcode = 1;\n\top->cycles = 1;\n\top->size = 2;\n\t// launch esil trap (for communicating upper layers about this weird\n\t// and stinky situation\n\tr_strbuf_set (&op->esil, \"1,$\");\n\n\treturn NULL;\n}", "func_src_after": "static OPCODE_DESC* avr_op_analyze(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, CPU_MODEL *cpu) {\n\tOPCODE_DESC *opcode_desc;\n\tif (len < 2) {\n\t\treturn NULL;\n\t}\n\tut16 ins = (buf[1] << 8) | buf[0];\n\tint fail;\n\tchar *t;\n\n\t// initialize op struct\n\tmemset (op, 0, sizeof (RAnalOp));\n\top->ptr = UT64_MAX;\n\top->val = UT64_MAX;\n\top->jump = UT64_MAX;\n\tr_strbuf_init (&op->esil);\n\n\t// process opcode\n\tfor (opcode_desc = opcodes; opcode_desc->handler; opcode_desc++) {\n\t\tif ((ins & opcode_desc->mask) == opcode_desc->selector) {\n\t\t\tfail = 0;\n\n\t\t\t// copy default cycles/size values\n\t\t\top->cycles = opcode_desc->cycles;\n\t\t\top->size = opcode_desc->size;\n\t\t\top->type = opcode_desc->type;\n\t\t\top->jump = UT64_MAX;\n\t\t\top->fail = UT64_MAX;\n\t\t\t// op->fail = addr + op->size;\n\t\t\top->addr = addr;\n\n\t\t\t// start void esil expression\n\t\t\tr_strbuf_setf (&op->esil, \"\");\n\n\t\t\t// handle opcode\n\t\t\topcode_desc->handler (anal, op, buf, len, &fail, cpu);\n\t\t\tif (fail) {\n\t\t\t\tgoto INVALID_OP;\n\t\t\t}\n\t\t\tif (op->cycles <= 0) {\n\t\t\t\t// eprintf (\"opcode %s @%\"PFMT64x\" returned 0 cycles.\\n\", opcode_desc->name, op->addr);\n\t\t\t\topcode_desc->cycles = 2;\n\t\t\t}\n\t\t\top->nopcode = (op->type == R_ANAL_OP_TYPE_UNK);\n\n\t\t\t// remove trailing coma (COMETE LA COMA)\n\t\t\tt = r_strbuf_get (&op->esil);\n\t\t\tif (t && strlen (t) > 1) {\n\t\t\t\tt += strlen (t) - 1;\n\t\t\t\tif (*t == ',') {\n\t\t\t\t\t*t = '\\0';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn opcode_desc;\n\t\t}\n\t}\n\n\t// ignore reserved opcodes (if they have not been caught by the previous loop)\n\tif ((ins & 0xff00) == 0xff00 && (ins & 0xf) > 7) {\n\t\tgoto INVALID_OP;\n\t}\n\nINVALID_OP:\n\t// An unknown or invalid option has appeared.\n\t//  -- Throw pokeball!\n\top->family = R_ANAL_OP_FAMILY_UNKNOWN;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->addr = addr;\n\top->fail = UT64_MAX;\n\top->jump = UT64_MAX;\n\top->ptr = UT64_MAX;\n\top->val = UT64_MAX;\n\top->nopcode = 1;\n\top->cycles = 1;\n\top->size = 2;\n\t// launch esil trap (for communicating upper layers about this weird\n\t// and stinky situation\n\tr_strbuf_set (&op->esil, \"1,$\");\n\n\treturn NULL;\n}", "commit_link": "github.com/radare/radare2/commit/b35530fa0681b27eba084de5527037ebfb397422", "file_name": "libr/anal/p/anal_avr.c", "vul_type": "cwe-125", "description": "Write a C function named `avr_op_analyze` for analyzing AVR opcodes and updating the analysis structure."}
{"func_name": "verifyHandler", "func_src_before": "func verifyHandler(w http.ResponseWriter, r *http.Request) {\n\tchallenge := r.URL.Query().Get(\"hub.challenge\")\n\tif challenge == \"\" {\n\t\tw.WriteHeader(400)\n\t\treturn\n\t}\n\n\tw.WriteHeader(200)\n\tw.Write([]byte(challenge))\n}", "func_src_after": "func verifyHandler(w http.ResponseWriter, r *http.Request) {\n\tchallenge := r.URL.Query().Get(\"hub.challenge\")\n\tif challenge == \"\" {\n\t\tw.WriteHeader(400)\n\t\treturn\n\t}\n\n\tw.WriteHeader(200)\n\tw.Write([]byte(html.EscapeString(challenge)))\n}", "line_changes": {"deleted": [{"line_no": 9, "char_start": 186, "char_end": 214, "line": "\tw.Write([]byte(challenge))\n"}], "added": [{"line_no": 9, "char_start": 186, "char_end": 233, "line": "\tw.Write([]byte(html.EscapeString(challenge)))\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 202, "char_end": 220, "chars": "html.EscapeString("}, {"char_start": 231, "char_end": 232, "chars": ")"}]}, "commit_link": "github.com/pajlada/pajbot2/commit/69ef922a07fc648760f030604e0aea86a573ea83", "file_name": "webhook.go", "vul_type": "cwe-079", "commit_msg": "Fix cross-site scripting vulnerabilities (#447)", "parent_commit": "d8321a06903ec460cf6343c51ae50d12a3cb45e9", "description": "Write a Go function named `verifyHandler` that responds to a web request by echoing back a query parameter value, with and without HTML escaping."}
{"func_name": "_find_host_from_wwpn", "func_src_before": "    def _find_host_from_wwpn(self, connector):\n        for wwpn in connector['wwpns']:\n            ssh_cmd = 'svcinfo lsfabric -wwpn %s -delim !' % wwpn\n            out, err = self._run_ssh(ssh_cmd)\n\n            if not len(out.strip()):\n                # This WWPN is not in use\n                continue\n\n            host_lines = out.strip().split('\\n')\n            header = host_lines.pop(0).split('!')\n            self._assert_ssh_return('remote_wwpn' in header and\n                                    'name' in header,\n                                    '_find_host_from_wwpn',\n                                    ssh_cmd, out, err)\n            rmt_wwpn_idx = header.index('remote_wwpn')\n            name_idx = header.index('name')\n\n            wwpns = map(lambda x: x.split('!')[rmt_wwpn_idx], host_lines)\n\n            if wwpn in wwpns:\n                # All the wwpns will be the mapping for the same\n                # host from this WWPN-based query. Just pick\n                # the name from first line.\n                hostname = host_lines[0].split('!')[name_idx]\n                return hostname\n\n        # Didn't find a host\n        return None", "func_src_after": "    def _find_host_from_wwpn(self, connector):\n        for wwpn in connector['wwpns']:\n            ssh_cmd = ['svcinfo', 'lsfabric', '-wwpn', wwpn, '-delim', '!']\n            out, err = self._run_ssh(ssh_cmd)\n\n            if not len(out.strip()):\n                # This WWPN is not in use\n                continue\n\n            host_lines = out.strip().split('\\n')\n            header = host_lines.pop(0).split('!')\n            self._assert_ssh_return('remote_wwpn' in header and\n                                    'name' in header,\n                                    '_find_host_from_wwpn',\n                                    ssh_cmd, out, err)\n            rmt_wwpn_idx = header.index('remote_wwpn')\n            name_idx = header.index('name')\n\n            wwpns = map(lambda x: x.split('!')[rmt_wwpn_idx], host_lines)\n\n            if wwpn in wwpns:\n                # All the wwpns will be the mapping for the same\n                # host from this WWPN-based query. Just pick\n                # the name from first line.\n                hostname = host_lines[0].split('!')[name_idx]\n                return hostname\n\n        # Didn't find a host\n        return None", "commit_link": "github.com/thatsdone/cinder/commit/f752302d181583a95cf44354aea607ce9d9283f4", "file_name": "cinder/volume/drivers/storwize_svc.py", "vul_type": "cwe-078", "description": "In Python, write a function to find a host's name using a WWPN (World Wide Port Name) by executing an SSH command and parsing the output."}
{"func_name": "SMB2_read", "func_src_before": "SMB2_read(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t  unsigned int *nbytes, char **buf, int *buf_type)\n{\n\tstruct smb_rqst rqst;\n\tint resp_buftype, rc = -EACCES;\n\tstruct smb2_read_plain_req *req = NULL;\n\tstruct smb2_read_rsp *rsp = NULL;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tunsigned int total_len;\n\tint flags = CIFS_LOG_ERROR;\n\tstruct cifs_ses *ses = io_parms->tcon->ses;\n\n\t*nbytes = 0;\n\trc = smb2_new_read_req((void **)&req, &total_len, io_parms, NULL, 0, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(io_parms->tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, &rqst, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\n\trsp = (struct smb2_read_rsp *)rsp_iov.iov_base;\n\n\tif (rc) {\n\t\tif (rc != -ENODATA) {\n\t\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_READ_HE);\n\t\t\tcifs_dbg(VFS, \"Send error in read = %d\\n\", rc);\n\t\t\ttrace_smb3_read_err(xid, req->PersistentFileId,\n\t\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t\t    io_parms->offset, io_parms->length,\n\t\t\t\t\t    rc);\n\t\t} else\n\t\t\ttrace_smb3_read_done(xid, req->PersistentFileId,\n\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t    io_parms->offset, 0);\n\t\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\t\treturn rc == -ENODATA ? 0 : rc;\n\t} else\n\t\ttrace_smb3_read_done(xid, req->PersistentFileId,\n\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t    io_parms->offset, io_parms->length);\n\n\t*nbytes = le32_to_cpu(rsp->DataLength);\n\tif ((*nbytes > CIFS_MAX_MSGSIZE) ||\n\t    (*nbytes > io_parms->length)) {\n\t\tcifs_dbg(FYI, \"bad length %d for count %d\\n\",\n\t\t\t *nbytes, io_parms->length);\n\t\trc = -EIO;\n\t\t*nbytes = 0;\n\t}\n\n\tif (*buf) {\n\t\tmemcpy(*buf, (char *)rsp + rsp->DataOffset, *nbytes);\n\t\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\t} else if (resp_buftype != CIFS_NO_BUFFER) {\n\t\t*buf = rsp_iov.iov_base;\n\t\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\t\t*buf_type = CIFS_SMALL_BUFFER;\n\t\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\t\t*buf_type = CIFS_LARGE_BUFFER;\n\t}\n\treturn rc;\n}", "func_src_after": "SMB2_read(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t  unsigned int *nbytes, char **buf, int *buf_type)\n{\n\tstruct smb_rqst rqst;\n\tint resp_buftype, rc = -EACCES;\n\tstruct smb2_read_plain_req *req = NULL;\n\tstruct smb2_read_rsp *rsp = NULL;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tunsigned int total_len;\n\tint flags = CIFS_LOG_ERROR;\n\tstruct cifs_ses *ses = io_parms->tcon->ses;\n\n\t*nbytes = 0;\n\trc = smb2_new_read_req((void **)&req, &total_len, io_parms, NULL, 0, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(io_parms->tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, &rqst, &resp_buftype, flags, &rsp_iov);\n\trsp = (struct smb2_read_rsp *)rsp_iov.iov_base;\n\n\tif (rc) {\n\t\tif (rc != -ENODATA) {\n\t\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_READ_HE);\n\t\t\tcifs_dbg(VFS, \"Send error in read = %d\\n\", rc);\n\t\t\ttrace_smb3_read_err(xid, req->PersistentFileId,\n\t\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t\t    io_parms->offset, io_parms->length,\n\t\t\t\t\t    rc);\n\t\t} else\n\t\t\ttrace_smb3_read_done(xid, req->PersistentFileId,\n\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t    io_parms->offset, 0);\n\t\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\t\treturn rc == -ENODATA ? 0 : rc;\n\t} else\n\t\ttrace_smb3_read_done(xid, req->PersistentFileId,\n\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t    io_parms->offset, io_parms->length);\n\n\tcifs_small_buf_release(req);\n\n\t*nbytes = le32_to_cpu(rsp->DataLength);\n\tif ((*nbytes > CIFS_MAX_MSGSIZE) ||\n\t    (*nbytes > io_parms->length)) {\n\t\tcifs_dbg(FYI, \"bad length %d for count %d\\n\",\n\t\t\t *nbytes, io_parms->length);\n\t\trc = -EIO;\n\t\t*nbytes = 0;\n\t}\n\n\tif (*buf) {\n\t\tmemcpy(*buf, (char *)rsp + rsp->DataOffset, *nbytes);\n\t\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\t} else if (resp_buftype != CIFS_NO_BUFFER) {\n\t\t*buf = rsp_iov.iov_base;\n\t\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\t\t*buf_type = CIFS_SMALL_BUFFER;\n\t\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\t\t*buf_type = CIFS_LARGE_BUFFER;\n\t}\n\treturn rc;\n}", "commit_link": "github.com/torvalds/linux/commit/088aaf17aa79300cab14dbee2569c58cfafd7d6e", "file_name": "fs/cifs/smb2pdu.c", "vul_type": "cwe-416", "description": "Write a C function named `SMB2_read` that performs a read operation using Server Message Block (SMB) protocol version 2."}
{"func_name": "get_login", "func_src_before": "@bot.message_handler(commands =['login'])\ndef get_login(message):\n    settings = sqlite3.connect(os.path.abspath(os.path.dirname(__file__)) + \"\\\\bases\\\\settings.db\")\n    conn = settings.cursor()\n    conn.execute(\"select * from users where chat_id = '\" + str(message.chat.id) + \"'\")\n    name = conn.fetchone()\n    if name != None:\n        bot.send_message(message.chat.id, \"Previous handle: \" + str(name[1]))\n    else:\n        bot.send_message(message.chat.id, \"Previous handle: None\")\n    settings.close()\n    bot.send_message(message.chat.id, \"Type new handle: \")\n    set_state(message.chat.id, config.States.S_LOGIN.value)", "func_src_after": "@bot.message_handler(commands =['login'])\ndef get_login(message):\n    settings = sqlite3.connect(os.path.abspath(os.path.dirname(__file__)) + \"\\\\bases\\\\settings.db\")\n    conn = settings.cursor()\n    conn.execute(\"select * from users where chat_id = ?\", (str(message.chat.id),))\n    name = conn.fetchone()\n    if name != None:\n        bot.send_message(message.chat.id, \"Previous handle: \" + str(name[1]))\n    else:\n        bot.send_message(message.chat.id, \"Previous handle: None\")\n    settings.close()\n    bot.send_message(message.chat.id, \"Type new handle: \")\n    set_state(message.chat.id, config.States.S_LOGIN.value)", "commit_link": "github.com/lissrbay/codeforces_bot/commit/cc7f5143445a0030b1149ac60a65b1b1b9c92a90", "file_name": "bot.py", "vul_type": "cwe-089", "description": "Create a Python function using the Telebot library that handles the '/login' command, retrieves the user's previous handle from an SQLite database, and prompts for a new handle."}
{"func_name": "add_item", "func_src_before": "    def add_item(self, item):\n        \"\"\"\"Add new item.\"\"\"\n        if self.connection:\n            self.cursor.execute('insert into item (name, shoppinglistid) values (\"%s\", \"%s\")' % (item[0], item[1]))\n            self.connection.commit()", "func_src_after": "    def add_item(self, item):\n        \"\"\"\"Add new item.\"\"\"\n        if self.connection:\n            t = (item[0], item[1], )\n            self.cursor.execute('insert into item (name, shoppinglistid) values (?, ?)', t)\n            self.connection.commit()", "commit_link": "github.com/ecosl-developers/ecosl/commit/8af050a513338bf68ff2a243e4a2482d24e9aa3a", "file_name": "ecosldb/ecosldb.py", "vul_type": "cwe-089", "description": "Write a Python function to insert a new item into a database table using SQL queries."}
{"func_name": "patch", "func_src_before": "    @jwt_required\n    def patch(self, user_id):\n        \"\"\" Replaces information of corresponding user_id with request body \"\"\"\n        query = f\"\"\"update users set user_id = %s \"\"\"\n        query += f\"\"\"where user_id = '{user_id}'\"\"\"\n        json_data = request.get_json()\n        parameters = (json_data['user_id'], )\n        database_utilities.execute_query(query, parameters)", "func_src_after": "    @jwt_required\n    def patch(self, user_id):\n        \"\"\" Replaces information of corresponding user_id with request body \"\"\"\n        query = f\"\"\"update users set user_id = %s \"\"\"\n        query += f\"\"\"where user_id = %s\"\"\"\n        json_data = request.get_json()\n        parameters = (json_data['user_id'], user_id)\n        database_utilities.execute_query(query, parameters)", "commit_link": "github.com/sgosal2/tiger-boards-backend/commit/4670109dd613df2f2fe7e8403ebd149df2b55485", "file_name": "apis/users.py", "vul_type": "cwe-089", "description": "Write a Python function to update a user's ID in the database using JWT authentication and the user's ID from the request body."}
{"func_name": "HandleRFBServerMessage", "func_src_before": "HandleRFBServerMessage(rfbClient* client)\n{\n  rfbServerToClientMsg msg;\n\n  if (client->serverPort==-1)\n    client->vncRec->readTimestamp = TRUE;\n  if (!ReadFromRFBServer(client, (char *)&msg, 1))\n    return FALSE;\n\n  switch (msg.type) {\n\n  case rfbSetColourMapEntries:\n  {\n    /* TODO:\n    int i;\n    uint16_t rgb[3];\n    XColor xc;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n\t\t\t   sz_rfbSetColourMapEntriesMsg - 1))\n      return FALSE;\n\n    msg.scme.firstColour = rfbClientSwap16IfLE(msg.scme.firstColour);\n    msg.scme.nColours = rfbClientSwap16IfLE(msg.scme.nColours);\n\n    for (i = 0; i < msg.scme.nColours; i++) {\n      if (!ReadFromRFBServer(client, (char *)rgb, 6))\n\treturn FALSE;\n      xc.pixel = msg.scme.firstColour + i;\n      xc.red = rfbClientSwap16IfLE(rgb[0]);\n      xc.green = rfbClientSwap16IfLE(rgb[1]);\n      xc.blue = rfbClientSwap16IfLE(rgb[2]);\n      xc.flags = DoRed|DoGreen|DoBlue;\n      XStoreColor(dpy, cmap, &xc);\n    }\n    */\n\n    break;\n  }\n\n  case rfbFramebufferUpdate:\n  {\n    rfbFramebufferUpdateRectHeader rect;\n    int linesToRead;\n    int bytesPerLine;\n    int i;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg.fu) + 1,\n\t\t\t   sz_rfbFramebufferUpdateMsg - 1))\n      return FALSE;\n\n    msg.fu.nRects = rfbClientSwap16IfLE(msg.fu.nRects);\n\n    for (i = 0; i < msg.fu.nRects; i++) {\n      if (!ReadFromRFBServer(client, (char *)&rect, sz_rfbFramebufferUpdateRectHeader))\n\treturn FALSE;\n\n      rect.encoding = rfbClientSwap32IfLE(rect.encoding);\n      if (rect.encoding == rfbEncodingLastRect)\n\tbreak;\n\n      rect.r.x = rfbClientSwap16IfLE(rect.r.x);\n      rect.r.y = rfbClientSwap16IfLE(rect.r.y);\n      rect.r.w = rfbClientSwap16IfLE(rect.r.w);\n      rect.r.h = rfbClientSwap16IfLE(rect.r.h);\n\n\n      if (rect.encoding == rfbEncodingXCursor ||\n\t  rect.encoding == rfbEncodingRichCursor) {\n\n\tif (!HandleCursorShape(client,\n\t\t\t       rect.r.x, rect.r.y, rect.r.w, rect.r.h,\n\t\t\t       rect.encoding)) {\n\t  return FALSE;\n\t}\n\tcontinue;\n      }\n\n      if (rect.encoding == rfbEncodingPointerPos) {\n\tif (!client->HandleCursorPos(client,rect.r.x, rect.r.y)) {\n\t  return FALSE;\n\t}\n\tcontinue;\n      }\n      \n      if (rect.encoding == rfbEncodingKeyboardLedState) {\n          /* OK! We have received a keyboard state message!!! */\n          client->KeyboardLedStateEnabled = 1;\n          if (client->HandleKeyboardLedState!=NULL)\n              client->HandleKeyboardLedState(client, rect.r.x, 0);\n          /* stash it for the future */\n          client->CurrentKeyboardLedState = rect.r.x;\n          continue;\n      }\n\n      if (rect.encoding == rfbEncodingNewFBSize) {\n\tclient->width = rect.r.w;\n\tclient->height = rect.r.h;\n\tclient->updateRect.x = client->updateRect.y = 0;\n\tclient->updateRect.w = client->width;\n\tclient->updateRect.h = client->height;\n\tif (!client->MallocFrameBuffer(client))\n\t  return FALSE;\n\tSendFramebufferUpdateRequest(client, 0, 0, rect.r.w, rect.r.h, FALSE);\n\trfbClientLog(\"Got new framebuffer size: %dx%d\\n\", rect.r.w, rect.r.h);\n\tcontinue;\n      }\n\n      /* rect.r.w=byte count */\n      if (rect.encoding == rfbEncodingSupportedMessages) {\n          int loop;\n          if (!ReadFromRFBServer(client, (char *)&client->supportedMessages, sz_rfbSupportedMessages))\n              return FALSE;\n\n          /* msgs is two sets of bit flags of supported messages client2server[] and server2client[] */\n          /* currently ignored by this library */\n\n          rfbClientLog(\"client2server supported messages (bit flags)\\n\");\n          for (loop=0;loop<32;loop+=8)\n            rfbClientLog(\"%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\\n\", loop,\n                client->supportedMessages.client2server[loop],   client->supportedMessages.client2server[loop+1],\n                client->supportedMessages.client2server[loop+2], client->supportedMessages.client2server[loop+3],\n                client->supportedMessages.client2server[loop+4], client->supportedMessages.client2server[loop+5],\n                client->supportedMessages.client2server[loop+6], client->supportedMessages.client2server[loop+7]);\n\n          rfbClientLog(\"server2client supported messages (bit flags)\\n\");\n          for (loop=0;loop<32;loop+=8)\n            rfbClientLog(\"%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\\n\", loop,\n                client->supportedMessages.server2client[loop],   client->supportedMessages.server2client[loop+1],\n                client->supportedMessages.server2client[loop+2], client->supportedMessages.server2client[loop+3],\n                client->supportedMessages.server2client[loop+4], client->supportedMessages.server2client[loop+5],\n                client->supportedMessages.server2client[loop+6], client->supportedMessages.server2client[loop+7]);\n          continue;\n      }\n\n      /* rect.r.w=byte count, rect.r.h=# of encodings */\n      if (rect.encoding == rfbEncodingSupportedEncodings) {\n          char *buffer;\n          buffer = malloc(rect.r.w);\n          if (!ReadFromRFBServer(client, buffer, rect.r.w))\n          {\n              free(buffer);\n              return FALSE;\n          }\n\n          /* buffer now contains rect.r.h # of uint32_t encodings that the server supports */\n          /* currently ignored by this library */\n          free(buffer);\n          continue;\n      }\n\n      /* rect.r.w=byte count */\n      if (rect.encoding == rfbEncodingServerIdentity) {\n          char *buffer;\n          buffer = malloc(rect.r.w+1);\n          if (!ReadFromRFBServer(client, buffer, rect.r.w))\n          {\n              free(buffer);\n              return FALSE;\n          }\n          buffer[rect.r.w]=0; /* null terminate, just in case */\n          rfbClientLog(\"Connected to Server \\\"%s\\\"\\n\", buffer);\n          free(buffer);\n          continue;\n      }\n\n      /* rfbEncodingUltraZip is a collection of subrects.   x = # of subrects, and h is always 0 */\n      if (rect.encoding != rfbEncodingUltraZip)\n      {\n        if ((rect.r.x + rect.r.w > client->width) ||\n\t    (rect.r.y + rect.r.h > client->height))\n\t    {\n\t      rfbClientLog(\"Rect too large: %dx%d at (%d, %d)\\n\",\n\t  \t  rect.r.w, rect.r.h, rect.r.x, rect.r.y);\n\t      return FALSE;\n            }\n\n        /* UltraVNC with scaling, will send rectangles with a zero W or H\n         *\n        if ((rect.encoding != rfbEncodingTight) && \n            (rect.r.h * rect.r.w == 0))\n        {\n\t  rfbClientLog(\"Zero size rect - ignoring (encoding=%d (0x%08x) %dx, %dy, %dw, %dh)\\n\", rect.encoding, rect.encoding, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n\t  continue;\n        }\n        */\n        \n        /* If RichCursor encoding is used, we should prevent collisions\n\t   between framebuffer updates and cursor drawing operations. */\n        client->SoftCursorLockArea(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n      }\n\n      switch (rect.encoding) {\n\n      case rfbEncodingRaw: {\n\tint y=rect.r.y, h=rect.r.h;\n\n\tbytesPerLine = rect.r.w * client->format.bitsPerPixel / 8;\n\t/* RealVNC 4.x-5.x on OSX can induce bytesPerLine==0, \n\t   usually during GPU accel. */\n\t/* Regardless of cause, do not divide by zero. */\n\tlinesToRead = bytesPerLine ? (RFB_BUFFER_SIZE / bytesPerLine) : 0;\n\n\twhile (linesToRead && h > 0) {\n\t  if (linesToRead > h)\n\t    linesToRead = h;\n\n\t  if (!ReadFromRFBServer(client, client->buffer,bytesPerLine * linesToRead))\n\t    return FALSE;\n\n\t  client->GotBitmap(client, (uint8_t *)client->buffer,\n\t\t\t   rect.r.x, y, rect.r.w,linesToRead);\n\n\t  h -= linesToRead;\n\t  y += linesToRead;\n\n\t}\n\tbreak;\n      } \n\n      case rfbEncodingCopyRect:\n      {\n\trfbCopyRect cr;\n\n\tif (!ReadFromRFBServer(client, (char *)&cr, sz_rfbCopyRect))\n\t  return FALSE;\n\n\tcr.srcX = rfbClientSwap16IfLE(cr.srcX);\n\tcr.srcY = rfbClientSwap16IfLE(cr.srcY);\n\n\t/* If RichCursor encoding is used, we should extend our\n\t   \"cursor lock area\" (previously set to destination\n\t   rectangle) to the source rectangle as well. */\n\tclient->SoftCursorLockArea(client,\n\t\t\t\t   cr.srcX, cr.srcY, rect.r.w, rect.r.h);\n\n        client->GotCopyRect(client, cr.srcX, cr.srcY, rect.r.w, rect.r.h,\n                            rect.r.x, rect.r.y);\n\n\tbreak;\n      }\n\n      case rfbEncodingRRE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingCoRRE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleCoRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleCoRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleCoRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingHextile:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleHextile8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleHextile16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleHextile32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingUltra:\n      {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleUltra8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (!HandleUltra16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 32:\n          if (!HandleUltra32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        }\n        break;\n      }\n      case rfbEncodingUltraZip:\n      {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleUltraZip8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (!HandleUltraZip16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 32:\n          if (!HandleUltraZip32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        }\n        break;\n      }\n\n      case rfbEncodingTRLE:\n\t  {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleTRLE8(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (client->si.format.greenMax > 0x1F) {\n            if (!HandleTRLE16(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else {\n            if (!HandleTRLE15(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          }\n          break;\n        case 32: {\n          uint32_t maxColor =\n              (client->format.redMax << client->format.redShift) |\n              (client->format.greenMax << client->format.greenShift) |\n              (client->format.blueMax << client->format.blueShift);\n          if ((client->format.bigEndian && (maxColor & 0xff) == 0) ||\n              (!client->format.bigEndian && (maxColor & 0xff000000) == 0)) {\n            if (!HandleTRLE24(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else if (!client->format.bigEndian && (maxColor & 0xff) == 0) {\n            if (!HandleTRLE24Up(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else if (client->format.bigEndian && (maxColor & 0xff000000) == 0) {\n            if (!HandleTRLE24Down(client, rect.r.x, rect.r.y, rect.r.w,\n                                  rect.r.h))\n              return FALSE;\n          } else if (!HandleTRLE32(client, rect.r.x, rect.r.y, rect.r.w,\n                                   rect.r.h))\n            return FALSE;\n          break;\n        }\n        }\n        break;\n      }\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n      case rfbEncodingZlib:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleZlib8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleZlib16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleZlib32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n     }\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n      case rfbEncodingTight:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleTight8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleTight16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleTight32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n#endif\n      case rfbEncodingZRLE:\n\t/* Fail safe for ZYWRLE unsupport VNC server. */\n\tclient->appData.qualityLevel = 9;\n\t/* fall through */\n      case rfbEncodingZYWRLE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleZRLE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (client->si.format.greenMax > 0x1F) {\n\t    if (!HandleZRLE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else {\n\t    if (!HandleZRLE15(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  }\n\t  break;\n\tcase 32:\n\t{\n\t  uint32_t maxColor=(client->format.redMax<<client->format.redShift)|\n\t\t(client->format.greenMax<<client->format.greenShift)|\n\t\t(client->format.blueMax<<client->format.blueShift);\n\t  if ((client->format.bigEndian && (maxColor&0xff)==0) ||\n\t      (!client->format.bigEndian && (maxColor&0xff000000)==0)) {\n\t    if (!HandleZRLE24(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (!client->format.bigEndian && (maxColor&0xff)==0) {\n\t    if (!HandleZRLE24Up(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (client->format.bigEndian && (maxColor&0xff000000)==0) {\n\t    if (!HandleZRLE24Down(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (!HandleZRLE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\t}\n\tbreak;\n     }\n\n#endif\n\n      default:\n\t {\n\t   rfbBool handled = FALSE;\n\t   rfbClientProtocolExtension* e;\n\n\t   for(e = rfbClientExtensions; !handled && e; e = e->next)\n\t     if(e->handleEncoding && e->handleEncoding(client, &rect))\n\t       handled = TRUE;\n\n\t   if(!handled) {\n\t     rfbClientLog(\"Unknown rect encoding %d\\n\",\n\t\t (int)rect.encoding);\n\t     return FALSE;\n\t   }\n\t }\n      }\n\n      /* Now we may discard \"soft cursor locks\". */\n      client->SoftCursorUnlockScreen(client);\n\n      client->GotFrameBufferUpdate(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n    }\n\n    if (!SendIncrementalFramebufferUpdateRequest(client))\n      return FALSE;\n\n    if (client->FinishedFrameBufferUpdate)\n      client->FinishedFrameBufferUpdate(client);\n\n    break;\n  }\n\n  case rfbBell:\n  {\n    client->Bell(client);\n\n    break;\n  }\n\n  case rfbServerCutText:\n  {\n    char *buffer;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n\t\t\t   sz_rfbServerCutTextMsg - 1))\n      return FALSE;\n\n    msg.sct.length = rfbClientSwap32IfLE(msg.sct.length);\n\n    if (msg.sct.length > 1<<20) {\n\t    rfbClientErr(\"Ignoring too big cut text length sent by server: %u B > 1 MB\\n\", (unsigned int)msg.sct.length);\n\t    return FALSE;\n    }  \n\n    buffer = malloc((uint64_t)msg.sct.length+1);\n\n    if (!ReadFromRFBServer(client, buffer, msg.sct.length)) {\n      free(buffer);\n      return FALSE;\n    }\n\n    buffer[msg.sct.length] = 0;\n\n    if (client->GotXCutText)\n      client->GotXCutText(client, buffer, msg.sct.length);\n\n    free(buffer);\n\n    break;\n  }\n\n  case rfbTextChat:\n  {\n      char *buffer=NULL;\n      if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                             sz_rfbTextChatMsg- 1))\n        return FALSE;\n      msg.tc.length = rfbClientSwap32IfLE(msg.sct.length);\n      switch(msg.tc.length) {\n      case rfbTextChatOpen:\n          rfbClientLog(\"Received TextChat Open\\n\");\n          if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatOpen, NULL);\n          break;\n      case rfbTextChatClose:\n          rfbClientLog(\"Received TextChat Close\\n\");\n         if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatClose, NULL);\n          break;\n      case rfbTextChatFinished:\n          rfbClientLog(\"Received TextChat Finished\\n\");\n         if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatFinished, NULL);\n          break;\n      default:\n          buffer=malloc(msg.tc.length+1);\n          if (!ReadFromRFBServer(client, buffer, msg.tc.length))\n          {\n              free(buffer);\n              return FALSE;\n          }\n          /* Null Terminate <just in case> */\n          buffer[msg.tc.length]=0;\n          rfbClientLog(\"Received TextChat \\\"%s\\\"\\n\", buffer);\n          if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)msg.tc.length, buffer);\n          free(buffer);\n          break;\n      }\n      break;\n  }\n\n  case rfbXvp:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbXvpMsg -1))\n      return FALSE;\n\n    SetClient2Server(client, rfbXvp);\n    /* technically, we only care what we can *send* to the server\n     * but, we set Server2Client Just in case it ever becomes useful\n     */\n    SetServer2Client(client, rfbXvp);\n\n    if(client->HandleXvpMsg)\n      client->HandleXvpMsg(client, msg.xvp.version, msg.xvp.code);\n\n    break;\n  }\n\n  case rfbResizeFrameBuffer:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbResizeFrameBufferMsg -1))\n      return FALSE;\n    client->width = rfbClientSwap16IfLE(msg.rsfb.framebufferWidth);\n    client->height = rfbClientSwap16IfLE(msg.rsfb.framebufferHeigth);\n    client->updateRect.x = client->updateRect.y = 0;\n    client->updateRect.w = client->width;\n    client->updateRect.h = client->height;\n    if (!client->MallocFrameBuffer(client))\n      return FALSE;\n\n    SendFramebufferUpdateRequest(client, 0, 0, client->width, client->height, FALSE);\n    rfbClientLog(\"Got new framebuffer size: %dx%d\\n\", client->width, client->height);\n    break;\n  }\n\n  case rfbPalmVNCReSizeFrameBuffer:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbPalmVNCReSizeFrameBufferMsg -1))\n      return FALSE;\n    client->width = rfbClientSwap16IfLE(msg.prsfb.buffer_w);\n    client->height = rfbClientSwap16IfLE(msg.prsfb.buffer_h);\n    client->updateRect.x = client->updateRect.y = 0;\n    client->updateRect.w = client->width;\n    client->updateRect.h = client->height;\n    if (!client->MallocFrameBuffer(client))\n      return FALSE;\n    SendFramebufferUpdateRequest(client, 0, 0, client->width, client->height, FALSE);\n    rfbClientLog(\"Got new framebuffer size: %dx%d\\n\", client->width, client->height);\n    break;\n  }\n\n  default:\n    {\n      rfbBool handled = FALSE;\n      rfbClientProtocolExtension* e;\n\n      for(e = rfbClientExtensions; !handled && e; e = e->next)\n\tif(e->handleMessage && e->handleMessage(client, &msg))\n\t  handled = TRUE;\n\n      if(!handled) {\n\tchar buffer[256];\n\trfbClientLog(\"Unknown message type %d from VNC server\\n\",msg.type);\n\tReadFromRFBServer(client, buffer, 256);\n\treturn FALSE;\n      }\n    }\n  }\n\n  return TRUE;\n}", "func_src_after": "HandleRFBServerMessage(rfbClient* client)\n{\n  rfbServerToClientMsg msg;\n\n  if (client->serverPort==-1)\n    client->vncRec->readTimestamp = TRUE;\n  if (!ReadFromRFBServer(client, (char *)&msg, 1))\n    return FALSE;\n\n  switch (msg.type) {\n\n  case rfbSetColourMapEntries:\n  {\n    /* TODO:\n    int i;\n    uint16_t rgb[3];\n    XColor xc;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n\t\t\t   sz_rfbSetColourMapEntriesMsg - 1))\n      return FALSE;\n\n    msg.scme.firstColour = rfbClientSwap16IfLE(msg.scme.firstColour);\n    msg.scme.nColours = rfbClientSwap16IfLE(msg.scme.nColours);\n\n    for (i = 0; i < msg.scme.nColours; i++) {\n      if (!ReadFromRFBServer(client, (char *)rgb, 6))\n\treturn FALSE;\n      xc.pixel = msg.scme.firstColour + i;\n      xc.red = rfbClientSwap16IfLE(rgb[0]);\n      xc.green = rfbClientSwap16IfLE(rgb[1]);\n      xc.blue = rfbClientSwap16IfLE(rgb[2]);\n      xc.flags = DoRed|DoGreen|DoBlue;\n      XStoreColor(dpy, cmap, &xc);\n    }\n    */\n\n    break;\n  }\n\n  case rfbFramebufferUpdate:\n  {\n    rfbFramebufferUpdateRectHeader rect;\n    int linesToRead;\n    int bytesPerLine;\n    int i;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg.fu) + 1,\n\t\t\t   sz_rfbFramebufferUpdateMsg - 1))\n      return FALSE;\n\n    msg.fu.nRects = rfbClientSwap16IfLE(msg.fu.nRects);\n\n    for (i = 0; i < msg.fu.nRects; i++) {\n      if (!ReadFromRFBServer(client, (char *)&rect, sz_rfbFramebufferUpdateRectHeader))\n\treturn FALSE;\n\n      rect.encoding = rfbClientSwap32IfLE(rect.encoding);\n      if (rect.encoding == rfbEncodingLastRect)\n\tbreak;\n\n      rect.r.x = rfbClientSwap16IfLE(rect.r.x);\n      rect.r.y = rfbClientSwap16IfLE(rect.r.y);\n      rect.r.w = rfbClientSwap16IfLE(rect.r.w);\n      rect.r.h = rfbClientSwap16IfLE(rect.r.h);\n\n\n      if (rect.encoding == rfbEncodingXCursor ||\n\t  rect.encoding == rfbEncodingRichCursor) {\n\n\tif (!HandleCursorShape(client,\n\t\t\t       rect.r.x, rect.r.y, rect.r.w, rect.r.h,\n\t\t\t       rect.encoding)) {\n\t  return FALSE;\n\t}\n\tcontinue;\n      }\n\n      if (rect.encoding == rfbEncodingPointerPos) {\n\tif (!client->HandleCursorPos(client,rect.r.x, rect.r.y)) {\n\t  return FALSE;\n\t}\n\tcontinue;\n      }\n      \n      if (rect.encoding == rfbEncodingKeyboardLedState) {\n          /* OK! We have received a keyboard state message!!! */\n          client->KeyboardLedStateEnabled = 1;\n          if (client->HandleKeyboardLedState!=NULL)\n              client->HandleKeyboardLedState(client, rect.r.x, 0);\n          /* stash it for the future */\n          client->CurrentKeyboardLedState = rect.r.x;\n          continue;\n      }\n\n      if (rect.encoding == rfbEncodingNewFBSize) {\n\tclient->width = rect.r.w;\n\tclient->height = rect.r.h;\n\tclient->updateRect.x = client->updateRect.y = 0;\n\tclient->updateRect.w = client->width;\n\tclient->updateRect.h = client->height;\n\tif (!client->MallocFrameBuffer(client))\n\t  return FALSE;\n\tSendFramebufferUpdateRequest(client, 0, 0, rect.r.w, rect.r.h, FALSE);\n\trfbClientLog(\"Got new framebuffer size: %dx%d\\n\", rect.r.w, rect.r.h);\n\tcontinue;\n      }\n\n      /* rect.r.w=byte count */\n      if (rect.encoding == rfbEncodingSupportedMessages) {\n          int loop;\n          if (!ReadFromRFBServer(client, (char *)&client->supportedMessages, sz_rfbSupportedMessages))\n              return FALSE;\n\n          /* msgs is two sets of bit flags of supported messages client2server[] and server2client[] */\n          /* currently ignored by this library */\n\n          rfbClientLog(\"client2server supported messages (bit flags)\\n\");\n          for (loop=0;loop<32;loop+=8)\n            rfbClientLog(\"%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\\n\", loop,\n                client->supportedMessages.client2server[loop],   client->supportedMessages.client2server[loop+1],\n                client->supportedMessages.client2server[loop+2], client->supportedMessages.client2server[loop+3],\n                client->supportedMessages.client2server[loop+4], client->supportedMessages.client2server[loop+5],\n                client->supportedMessages.client2server[loop+6], client->supportedMessages.client2server[loop+7]);\n\n          rfbClientLog(\"server2client supported messages (bit flags)\\n\");\n          for (loop=0;loop<32;loop+=8)\n            rfbClientLog(\"%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\\n\", loop,\n                client->supportedMessages.server2client[loop],   client->supportedMessages.server2client[loop+1],\n                client->supportedMessages.server2client[loop+2], client->supportedMessages.server2client[loop+3],\n                client->supportedMessages.server2client[loop+4], client->supportedMessages.server2client[loop+5],\n                client->supportedMessages.server2client[loop+6], client->supportedMessages.server2client[loop+7]);\n          continue;\n      }\n\n      /* rect.r.w=byte count, rect.r.h=# of encodings */\n      if (rect.encoding == rfbEncodingSupportedEncodings) {\n          char *buffer;\n          buffer = malloc(rect.r.w);\n          if (!ReadFromRFBServer(client, buffer, rect.r.w))\n          {\n              free(buffer);\n              return FALSE;\n          }\n\n          /* buffer now contains rect.r.h # of uint32_t encodings that the server supports */\n          /* currently ignored by this library */\n          free(buffer);\n          continue;\n      }\n\n      /* rect.r.w=byte count */\n      if (rect.encoding == rfbEncodingServerIdentity) {\n          char *buffer;\n          buffer = malloc(rect.r.w+1);\n          if (!ReadFromRFBServer(client, buffer, rect.r.w))\n          {\n              free(buffer);\n              return FALSE;\n          }\n          buffer[rect.r.w]=0; /* null terminate, just in case */\n          rfbClientLog(\"Connected to Server \\\"%s\\\"\\n\", buffer);\n          free(buffer);\n          continue;\n      }\n\n      /* rfbEncodingUltraZip is a collection of subrects.   x = # of subrects, and h is always 0 */\n      if (rect.encoding != rfbEncodingUltraZip)\n      {\n        if ((rect.r.x + rect.r.w > client->width) ||\n\t    (rect.r.y + rect.r.h > client->height))\n\t    {\n\t      rfbClientLog(\"Rect too large: %dx%d at (%d, %d)\\n\",\n\t  \t  rect.r.w, rect.r.h, rect.r.x, rect.r.y);\n\t      return FALSE;\n            }\n\n        /* UltraVNC with scaling, will send rectangles with a zero W or H\n         *\n        if ((rect.encoding != rfbEncodingTight) && \n            (rect.r.h * rect.r.w == 0))\n        {\n\t  rfbClientLog(\"Zero size rect - ignoring (encoding=%d (0x%08x) %dx, %dy, %dw, %dh)\\n\", rect.encoding, rect.encoding, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n\t  continue;\n        }\n        */\n        \n        /* If RichCursor encoding is used, we should prevent collisions\n\t   between framebuffer updates and cursor drawing operations. */\n        client->SoftCursorLockArea(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n      }\n\n      switch (rect.encoding) {\n\n      case rfbEncodingRaw: {\n\tint y=rect.r.y, h=rect.r.h;\n\n\tbytesPerLine = rect.r.w * client->format.bitsPerPixel / 8;\n\t/* RealVNC 4.x-5.x on OSX can induce bytesPerLine==0, \n\t   usually during GPU accel. */\n\t/* Regardless of cause, do not divide by zero. */\n\tlinesToRead = bytesPerLine ? (RFB_BUFFER_SIZE / bytesPerLine) : 0;\n\n\twhile (linesToRead && h > 0) {\n\t  if (linesToRead > h)\n\t    linesToRead = h;\n\n\t  if (!ReadFromRFBServer(client, client->buffer,bytesPerLine * linesToRead))\n\t    return FALSE;\n\n\t  client->GotBitmap(client, (uint8_t *)client->buffer,\n\t\t\t   rect.r.x, y, rect.r.w,linesToRead);\n\n\t  h -= linesToRead;\n\t  y += linesToRead;\n\n\t}\n\tbreak;\n      } \n\n      case rfbEncodingCopyRect:\n      {\n\trfbCopyRect cr;\n\n\tif (!ReadFromRFBServer(client, (char *)&cr, sz_rfbCopyRect))\n\t  return FALSE;\n\n\tcr.srcX = rfbClientSwap16IfLE(cr.srcX);\n\tcr.srcY = rfbClientSwap16IfLE(cr.srcY);\n\n\t/* If RichCursor encoding is used, we should extend our\n\t   \"cursor lock area\" (previously set to destination\n\t   rectangle) to the source rectangle as well. */\n\tclient->SoftCursorLockArea(client,\n\t\t\t\t   cr.srcX, cr.srcY, rect.r.w, rect.r.h);\n\n        client->GotCopyRect(client, cr.srcX, cr.srcY, rect.r.w, rect.r.h,\n                            rect.r.x, rect.r.y);\n\n\tbreak;\n      }\n\n      case rfbEncodingRRE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingCoRRE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleCoRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleCoRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleCoRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingHextile:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleHextile8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleHextile16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleHextile32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingUltra:\n      {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleUltra8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (!HandleUltra16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 32:\n          if (!HandleUltra32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        }\n        break;\n      }\n      case rfbEncodingUltraZip:\n      {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleUltraZip8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (!HandleUltraZip16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 32:\n          if (!HandleUltraZip32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        }\n        break;\n      }\n\n      case rfbEncodingTRLE:\n\t  {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleTRLE8(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (client->si.format.greenMax > 0x1F) {\n            if (!HandleTRLE16(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else {\n            if (!HandleTRLE15(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          }\n          break;\n        case 32: {\n          uint32_t maxColor =\n              (client->format.redMax << client->format.redShift) |\n              (client->format.greenMax << client->format.greenShift) |\n              (client->format.blueMax << client->format.blueShift);\n          if ((client->format.bigEndian && (maxColor & 0xff) == 0) ||\n              (!client->format.bigEndian && (maxColor & 0xff000000) == 0)) {\n            if (!HandleTRLE24(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else if (!client->format.bigEndian && (maxColor & 0xff) == 0) {\n            if (!HandleTRLE24Up(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else if (client->format.bigEndian && (maxColor & 0xff000000) == 0) {\n            if (!HandleTRLE24Down(client, rect.r.x, rect.r.y, rect.r.w,\n                                  rect.r.h))\n              return FALSE;\n          } else if (!HandleTRLE32(client, rect.r.x, rect.r.y, rect.r.w,\n                                   rect.r.h))\n            return FALSE;\n          break;\n        }\n        }\n        break;\n      }\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n      case rfbEncodingZlib:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleZlib8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleZlib16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleZlib32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n     }\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n      case rfbEncodingTight:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleTight8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleTight16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleTight32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n#endif\n      case rfbEncodingZRLE:\n\t/* Fail safe for ZYWRLE unsupport VNC server. */\n\tclient->appData.qualityLevel = 9;\n\t/* fall through */\n      case rfbEncodingZYWRLE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleZRLE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (client->si.format.greenMax > 0x1F) {\n\t    if (!HandleZRLE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else {\n\t    if (!HandleZRLE15(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  }\n\t  break;\n\tcase 32:\n\t{\n\t  uint32_t maxColor=(client->format.redMax<<client->format.redShift)|\n\t\t(client->format.greenMax<<client->format.greenShift)|\n\t\t(client->format.blueMax<<client->format.blueShift);\n\t  if ((client->format.bigEndian && (maxColor&0xff)==0) ||\n\t      (!client->format.bigEndian && (maxColor&0xff000000)==0)) {\n\t    if (!HandleZRLE24(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (!client->format.bigEndian && (maxColor&0xff)==0) {\n\t    if (!HandleZRLE24Up(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (client->format.bigEndian && (maxColor&0xff000000)==0) {\n\t    if (!HandleZRLE24Down(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (!HandleZRLE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\t}\n\tbreak;\n     }\n\n#endif\n\n      default:\n\t {\n\t   rfbBool handled = FALSE;\n\t   rfbClientProtocolExtension* e;\n\n\t   for(e = rfbClientExtensions; !handled && e; e = e->next)\n\t     if(e->handleEncoding && e->handleEncoding(client, &rect))\n\t       handled = TRUE;\n\n\t   if(!handled) {\n\t     rfbClientLog(\"Unknown rect encoding %d\\n\",\n\t\t (int)rect.encoding);\n\t     return FALSE;\n\t   }\n\t }\n      }\n\n      /* Now we may discard \"soft cursor locks\". */\n      client->SoftCursorUnlockScreen(client);\n\n      client->GotFrameBufferUpdate(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n    }\n\n    if (!SendIncrementalFramebufferUpdateRequest(client))\n      return FALSE;\n\n    if (client->FinishedFrameBufferUpdate)\n      client->FinishedFrameBufferUpdate(client);\n\n    break;\n  }\n\n  case rfbBell:\n  {\n    client->Bell(client);\n\n    break;\n  }\n\n  case rfbServerCutText:\n  {\n    char *buffer;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n\t\t\t   sz_rfbServerCutTextMsg - 1))\n      return FALSE;\n\n    msg.sct.length = rfbClientSwap32IfLE(msg.sct.length);\n\n    if (msg.sct.length > 1<<20) {\n\t    rfbClientErr(\"Ignoring too big cut text length sent by server: %u B > 1 MB\\n\", (unsigned int)msg.sct.length);\n\t    return FALSE;\n    }  \n\n    buffer = malloc(msg.sct.length+1);\n\n    if (!ReadFromRFBServer(client, buffer, msg.sct.length)) {\n      free(buffer);\n      return FALSE;\n    }\n\n    buffer[msg.sct.length] = 0;\n\n    if (client->GotXCutText)\n      client->GotXCutText(client, buffer, msg.sct.length);\n\n    free(buffer);\n\n    break;\n  }\n\n  case rfbTextChat:\n  {\n      char *buffer=NULL;\n      if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                             sz_rfbTextChatMsg- 1))\n        return FALSE;\n      msg.tc.length = rfbClientSwap32IfLE(msg.sct.length);\n      switch(msg.tc.length) {\n      case rfbTextChatOpen:\n          rfbClientLog(\"Received TextChat Open\\n\");\n          if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatOpen, NULL);\n          break;\n      case rfbTextChatClose:\n          rfbClientLog(\"Received TextChat Close\\n\");\n         if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatClose, NULL);\n          break;\n      case rfbTextChatFinished:\n          rfbClientLog(\"Received TextChat Finished\\n\");\n         if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatFinished, NULL);\n          break;\n      default:\n          buffer=malloc(msg.tc.length+1);\n          if (!ReadFromRFBServer(client, buffer, msg.tc.length))\n          {\n              free(buffer);\n              return FALSE;\n          }\n          /* Null Terminate <just in case> */\n          buffer[msg.tc.length]=0;\n          rfbClientLog(\"Received TextChat \\\"%s\\\"\\n\", buffer);\n          if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)msg.tc.length, buffer);\n          free(buffer);\n          break;\n      }\n      break;\n  }\n\n  case rfbXvp:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbXvpMsg -1))\n      return FALSE;\n\n    SetClient2Server(client, rfbXvp);\n    /* technically, we only care what we can *send* to the server\n     * but, we set Server2Client Just in case it ever becomes useful\n     */\n    SetServer2Client(client, rfbXvp);\n\n    if(client->HandleXvpMsg)\n      client->HandleXvpMsg(client, msg.xvp.version, msg.xvp.code);\n\n    break;\n  }\n\n  case rfbResizeFrameBuffer:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbResizeFrameBufferMsg -1))\n      return FALSE;\n    client->width = rfbClientSwap16IfLE(msg.rsfb.framebufferWidth);\n    client->height = rfbClientSwap16IfLE(msg.rsfb.framebufferHeigth);\n    client->updateRect.x = client->updateRect.y = 0;\n    client->updateRect.w = client->width;\n    client->updateRect.h = client->height;\n    if (!client->MallocFrameBuffer(client))\n      return FALSE;\n\n    SendFramebufferUpdateRequest(client, 0, 0, client->width, client->height, FALSE);\n    rfbClientLog(\"Got new framebuffer size: %dx%d\\n\", client->width, client->height);\n    break;\n  }\n\n  case rfbPalmVNCReSizeFrameBuffer:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbPalmVNCReSizeFrameBufferMsg -1))\n      return FALSE;\n    client->width = rfbClientSwap16IfLE(msg.prsfb.buffer_w);\n    client->height = rfbClientSwap16IfLE(msg.prsfb.buffer_h);\n    client->updateRect.x = client->updateRect.y = 0;\n    client->updateRect.w = client->width;\n    client->updateRect.h = client->height;\n    if (!client->MallocFrameBuffer(client))\n      return FALSE;\n    SendFramebufferUpdateRequest(client, 0, 0, client->width, client->height, FALSE);\n    rfbClientLog(\"Got new framebuffer size: %dx%d\\n\", client->width, client->height);\n    break;\n  }\n\n  default:\n    {\n      rfbBool handled = FALSE;\n      rfbClientProtocolExtension* e;\n\n      for(e = rfbClientExtensions; !handled && e; e = e->next)\n\tif(e->handleMessage && e->handleMessage(client, &msg))\n\t  handled = TRUE;\n\n      if(!handled) {\n\tchar buffer[256];\n\trfbClientLog(\"Unknown message type %d from VNC server\\n\",msg.type);\n\tReadFromRFBServer(client, buffer, 256);\n\treturn FALSE;\n      }\n    }\n  }\n\n  return TRUE;\n}", "commit_link": "github.com/LibVNC/libvncserver/commit/a64c3b37af9a6c8f8009d7516874b8d266b42bae", "file_name": "libvncclient/rfbproto.c", "vul_type": "cwe-787", "description": "Write a function in C to handle server messages for a VNC client."}
{"func_name": "register_user", "func_src_before": "def register_user(request):\n    settings = request.registry.settings\n    if not is_registration_enabled(settings):\n        raise exc.exception_response(503)\n    handle_history(request)\n    _ = request.translate\n    config = Config(load(get_path_to_form_config('auth.xml', 'ringo')))\n    form_config = config.get_form('register_user')\n    form = Form(form_config, csrf_token=request.session.get_csrf_token())\n    # Do extra validation which is not handled by formbar.\n    # Is the login unique?\n    validator = Validator('login',\n                          'There is already a user with this name',\n                          is_login_unique)\n    form.add_validator(validator)\n    if request.POST:\n        if form.validate(request.params.mixed()):\n            # 1. Create user. Do not activate him. Default role is user.\n            ufac = User.get_item_factory()\n            # TODO: Check why we not use the get_item_factory_method\n            # here. Do we use plain factories because the need full\n            # controll of depended relations? (ti) <2014-04-08 17:07> \n            pfac = BaseFactory(Profile)\n            gfac = BaseFactory(Usergroup)\n            user = ufac.create(None)\n            # Set login from formdata\n            user.login = form.data['login']\n            # Encrypt password and save\n            pw = hashlib.md5()\n            pw.update(form.data['pass'])\n            user.password = pw.hexdigest()\n            # Deactivate the user. To activate the user needs to confirm\n            # with the activation link\n            user.activated = False\n            atoken = str(uuid.uuid4())\n            user.activation_token = atoken\n            # Set profile data\n            user.profile[0].email = form.data['email']\n            # Set user group\n            group = gfac.load(USER_GROUP_ID)\n            user.groups.append(group)\n            # Set default user group.\n            user.gid = group.id\n            DBSession.add(user)\n\n            # 3. Send confirmation email. The user will be activated\n            #    after the user clicks on the confirmation link\n            mailer = Mailer(request)\n            recipient = user.profile[0].email\n            subject = _('Confirm user registration for %s' % get_app_name())\n            values = {'url': request.route_url('confirm_user', token=atoken),\n                      'app_name': get_app_name(),\n                      'email': settings['mail.default_sender'],\n                      '_': _}\n            mail = Mail([recipient], subject, template=\"register_user\", values=values)\n            mailer.send(mail)\n\n            target_url = request.route_path('login')\n            headers = forget(request)\n            msg = _(\"User has been created and a confirmation mail was sent\"\n                    \" to the users email adress. Please check your email :)\")\n            request.session.flash(msg, 'success')\n            return HTTPFound(location=target_url, headers=headers)\n    return {'form': form.render()}", "func_src_after": "def register_user(request):\n    settings = request.registry.settings\n    if not is_registration_enabled(settings):\n        raise exc.exception_response(503)\n    handle_history(request)\n    _ = request.translate\n    config = Config(load(get_path_to_form_config('auth.xml', 'ringo')))\n    form_config = config.get_form('register_user')\n    form = Form(form_config, csrf_token=request.session.get_csrf_token())\n    # Do extra validation which is not handled by formbar.\n    # Is the login unique?\n    validator = Validator('login',\n                          'There is already a user with this name',\n                          is_login_unique)\n    form.add_validator(validator)\n    if request.POST:\n        if form.validate(request.params.mixed()):\n            # 1. Create user. Do not activate him. Default role is user.\n            ufac = User.get_item_factory()\n            # TODO: Check why we not use the get_item_factory_method\n            # here. Do we use plain factories because the need full\n            # controll of depended relations? (ti) <2014-04-08 17:07> \n            pfac = BaseFactory(Profile)\n            gfac = BaseFactory(Usergroup)\n            user = ufac.create(None)\n            # Set login from formdata\n            user.login = form.data['login']\n            # Encrypt password and save\n            user.password = encrypt_password(form.data['pass'])\n            # Deactivate the user. To activate the user needs to confirm\n            # with the activation link\n            user.activated = False\n            atoken = str(uuid.uuid4())\n            user.activation_token = atoken\n            # Set profile data\n            user.profile[0].email = form.data['email']\n            # Set user group\n            group = gfac.load(USER_GROUP_ID)\n            user.groups.append(group)\n            # Set default user group.\n            user.gid = group.id\n            DBSession.add(user)\n\n            # 3. Send confirmation email. The user will be activated\n            #    after the user clicks on the confirmation link\n            mailer = Mailer(request)\n            recipient = user.profile[0].email\n            subject = _('Confirm user registration for %s' % get_app_name())\n            values = {'url': request.route_url('confirm_user', token=atoken),\n                      'app_name': get_app_name(),\n                      'email': settings['mail.default_sender'],\n                      '_': _}\n            mail = Mail([recipient], subject, template=\"register_user\", values=values)\n            mailer.send(mail)\n\n            target_url = request.route_path('login')\n            headers = forget(request)\n            msg = _(\"User has been created and a confirmation mail was sent\"\n                    \" to the users email adress. Please check your email :)\")\n            request.session.flash(msg, 'success')\n            return HTTPFound(location=target_url, headers=headers)\n    return {'form': form.render()}", "line_changes": {"deleted": [{"line_no": 29, "char_start": 1310, "char_end": 1341, "line": "            pw = hashlib.md5()\n"}, {"line_no": 30, "char_start": 1341, "char_end": 1382, "line": "            pw.update(form.data['pass'])\n"}, {"line_no": 31, "char_start": 1382, "char_end": 1425, "line": "            user.password = pw.hexdigest()\n"}], "added": [{"line_no": 29, "char_start": 1310, "char_end": 1374, "line": "            user.password = encrypt_password(form.data['pass'])\n"}]}, "char_changes": {"deleted": [{"char_start": 1322, "char_end": 1423, "chars": "pw = hashlib.md5()\n            pw.update(form.data['pass'])\n            user.password = pw.hexdigest("}], "added": [{"char_start": 1322, "char_end": 1372, "chars": "user.password = encrypt_password(form.data['pass']"}]}, "commit_link": "github.com/ringo-framework/ringo/commit/ddb9d55999151f37fd4c833a98d2f34648757293", "file_name": "auth.py", "vul_type": "cwe-327", "commit_msg": "Replaced use of the old hashlib.md5 method for password encryption with new encryption methods using passlib", "parent_commit": "8e92641fee542f6e7004e827136dea3ce5e99eb2", "description": "Write a Python function to handle user registration, including form validation, user creation, and sending a confirmation email."}
{"func_name": "PHP_MINIT_FUNCTION", "func_src_before": "PHP_MINIT_FUNCTION(spl_array)\n{\n\tREGISTER_SPL_STD_CLASS_EX(ArrayObject, spl_array_object_new, spl_funcs_ArrayObject);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, Aggregate);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, ArrayAccess);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, Serializable);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, Countable);\n\tmemcpy(&spl_handler_ArrayObject, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\n\tspl_handler_ArrayObject.clone_obj = spl_array_object_clone;\n\tspl_handler_ArrayObject.read_dimension = spl_array_read_dimension;\n\tspl_handler_ArrayObject.write_dimension = spl_array_write_dimension;\n\tspl_handler_ArrayObject.unset_dimension = spl_array_unset_dimension;\n\tspl_handler_ArrayObject.has_dimension = spl_array_has_dimension;\n\tspl_handler_ArrayObject.count_elements = spl_array_object_count_elements;\n\n\tspl_handler_ArrayObject.get_properties = spl_array_get_properties;\n\tspl_handler_ArrayObject.get_debug_info = spl_array_get_debug_info;\n\tspl_handler_ArrayObject.get_gc = spl_array_get_gc;\n\tspl_handler_ArrayObject.read_property = spl_array_read_property;\n\tspl_handler_ArrayObject.write_property = spl_array_write_property;\n\tspl_handler_ArrayObject.get_property_ptr_ptr = spl_array_get_property_ptr_ptr;\n\tspl_handler_ArrayObject.has_property = spl_array_has_property;\n\tspl_handler_ArrayObject.unset_property = spl_array_unset_property;\n\n\tspl_handler_ArrayObject.compare_objects = spl_array_compare_objects;\n\n\tREGISTER_SPL_STD_CLASS_EX(ArrayIterator, spl_array_object_new, spl_funcs_ArrayIterator);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, Iterator);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, ArrayAccess);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, SeekableIterator);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, Serializable);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, Countable);\n\tmemcpy(&spl_handler_ArrayIterator, &spl_handler_ArrayObject, sizeof(zend_object_handlers));\n\tspl_ce_ArrayIterator->get_iterator = spl_array_get_iterator;\n\n\tREGISTER_SPL_SUB_CLASS_EX(RecursiveArrayIterator, ArrayIterator, spl_array_object_new, spl_funcs_RecursiveArrayIterator);\n\tREGISTER_SPL_IMPLEMENTS(RecursiveArrayIterator, RecursiveIterator);\n\tspl_ce_RecursiveArrayIterator->get_iterator = spl_array_get_iterator;\n\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayObject,   \"STD_PROP_LIST\",    SPL_ARRAY_STD_PROP_LIST);\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayObject,   \"ARRAY_AS_PROPS\",   SPL_ARRAY_ARRAY_AS_PROPS);\n\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayIterator, \"STD_PROP_LIST\",    SPL_ARRAY_STD_PROP_LIST);\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayIterator, \"ARRAY_AS_PROPS\",   SPL_ARRAY_ARRAY_AS_PROPS);\n\n\tREGISTER_SPL_CLASS_CONST_LONG(RecursiveArrayIterator, \"CHILD_ARRAYS_ONLY\", SPL_ARRAY_CHILD_ARRAYS_ONLY);\n\n\treturn SUCCESS;\n}", "func_src_after": "PHP_MINIT_FUNCTION(spl_array)\n{\n\tREGISTER_SPL_STD_CLASS_EX(ArrayObject, spl_array_object_new, spl_funcs_ArrayObject);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, Aggregate);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, ArrayAccess);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, Serializable);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, Countable);\n\tmemcpy(&spl_handler_ArrayObject, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\n\tspl_handler_ArrayObject.clone_obj = spl_array_object_clone;\n\tspl_handler_ArrayObject.read_dimension = spl_array_read_dimension;\n\tspl_handler_ArrayObject.write_dimension = spl_array_write_dimension;\n\tspl_handler_ArrayObject.unset_dimension = spl_array_unset_dimension;\n\tspl_handler_ArrayObject.has_dimension = spl_array_has_dimension;\n\tspl_handler_ArrayObject.count_elements = spl_array_object_count_elements;\n\n\tspl_handler_ArrayObject.get_properties = spl_array_get_properties;\n\tspl_handler_ArrayObject.get_debug_info = spl_array_get_debug_info;\n\tspl_handler_ArrayObject.get_gc = spl_array_get_gc;\n\tspl_handler_ArrayObject.read_property = spl_array_read_property;\n\tspl_handler_ArrayObject.write_property = spl_array_write_property;\n\tspl_handler_ArrayObject.get_property_ptr_ptr = spl_array_get_property_ptr_ptr;\n\tspl_handler_ArrayObject.has_property = spl_array_has_property;\n\tspl_handler_ArrayObject.unset_property = spl_array_unset_property;\n\n\tspl_handler_ArrayObject.compare_objects = spl_array_compare_objects;\n\n\tREGISTER_SPL_STD_CLASS_EX(ArrayIterator, spl_array_object_new, spl_funcs_ArrayIterator);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, Iterator);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, ArrayAccess);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, SeekableIterator);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, Serializable);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, Countable);\n\tmemcpy(&spl_handler_ArrayIterator, &spl_handler_ArrayObject, sizeof(zend_object_handlers));\n\tspl_ce_ArrayIterator->get_iterator = spl_array_get_iterator;\n\n\tREGISTER_SPL_SUB_CLASS_EX(RecursiveArrayIterator, ArrayIterator, spl_array_object_new, spl_funcs_RecursiveArrayIterator);\n\tREGISTER_SPL_IMPLEMENTS(RecursiveArrayIterator, RecursiveIterator);\n\tspl_ce_RecursiveArrayIterator->get_iterator = spl_array_get_iterator;\n\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayObject,   \"STD_PROP_LIST\",    SPL_ARRAY_STD_PROP_LIST);\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayObject,   \"ARRAY_AS_PROPS\",   SPL_ARRAY_ARRAY_AS_PROPS);\n\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayIterator, \"STD_PROP_LIST\",    SPL_ARRAY_STD_PROP_LIST);\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayIterator, \"ARRAY_AS_PROPS\",   SPL_ARRAY_ARRAY_AS_PROPS);\n\n\tREGISTER_SPL_CLASS_CONST_LONG(RecursiveArrayIterator, \"CHILD_ARRAYS_ONLY\", SPL_ARRAY_CHILD_ARRAYS_ONLY);\n\n\treturn SUCCESS;\n}", "commit_link": "github.com/php/php-src/commit/3f627e580acfdaf0595ae3b115b8bec677f203ee?w=1", "file_name": "ext/spl/spl_array.c", "vul_type": "cwe-416", "description": "Write a PHP initialization function to set up SPL array classes with their respective handlers and interfaces."}
{"func_name": "ecall_restore", "func_src_before": "int ecall_restore(const char *input, uint64_t input_len, char **output,\n                  uint64_t *output_len) {\n  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(input,\n                                                              input_len) ||\n      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(\n          output_len, sizeof(uint64_t))) {\n    asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"ecall_restore: input/output found to not be in untrusted memory.\");\n  }\n  int result = 0;\n  size_t tmp_output_len;\n  try {\n    result = asylo::Restore(input, static_cast<size_t>(input_len), output,\n                            &tmp_output_len);\n  } catch (...) {\n    LOG(FATAL) << \"Uncaught exception in enclave\";\n  }\n\n  if (output_len) {\n    *output_len = static_cast<uint64_t>(tmp_output_len);\n  }\n  return result;\n}", "func_src_after": "int ecall_restore(const char *input, uint64_t input_len, char **output,\n                  uint64_t *output_len) {\n  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(input,\n                                                              input_len) ||\n      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(\n          output_len, sizeof(uint64_t)) ||\n      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(output,\n                                                              *output_len)) {\n    asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"ecall_restore: input/output found to not be in untrusted memory.\");\n  }\n  int result = 0;\n  size_t tmp_output_len;\n  try {\n    result = asylo::Restore(input, static_cast<size_t>(input_len), output,\n                            &tmp_output_len);\n  } catch (...) {\n    LOG(FATAL) << \"Uncaught exception in enclave\";\n  }\n\n  if (output_len) {\n    *output_len = static_cast<uint64_t>(tmp_output_len);\n  }\n  return result;\n}", "commit_link": "github.com/google/asylo/commit/382da2b8b09cbf928668a2445efb778f76bd9c8a", "file_name": "asylo/platform/primitives/sgx/ecalls.cc", "vul_type": "cwe-787", "description": "Write a C++ function named `ecall_restore` that checks if input and output buffers are outside enclave memory and performs a restore operation using Asylo primitives."}
{"func_name": "resolve_hostname", "func_src_before": "@then(parsers.parse(\"the hostname '{hostname}' should be resolved\"))\ndef resolve_hostname(busybox_pod, host, hostname):\n        with host.sudo():\n            # test dns resolve\n            cmd_nslookup = (\"kubectl --kubeconfig=/etc/kubernetes/admin.conf\"\n                            \" exec -ti {0} nslookup {1}\".format(\n                                pod_name,\n                                hostname))\n            res = host.run(cmd_nslookup)\n            assert res.rc == 0, \"Cannot resolve {}\".format(hostname)", "func_src_after": "@then(parsers.parse(\"the hostname '{hostname}' should be resolved\"))\ndef resolve_hostname(busybox_pod, host, hostname):\n    with host.sudo():\n        # test dns resolve\n        result = host.run(\n            \"kubectl --kubeconfig=/etc/kubernetes/admin.conf \"\n            \"exec -ti %s nslookup %s\",\n            busybox_pod,\n            hostname,\n        )\n\n        assert result.rc == 0, \"Cannot resolve {}\".format(hostname)", "commit_link": "github.com/scality/metalk8s/commit/82d92836d4ff78c623a0e06302c94cfa5ff79908", "file_name": "tests/post/steps/test_dns.py", "vul_type": "cwe-078", "description": "Write a Python function using a decorator to assert that a given hostname can be resolved using nslookup in a Kubernetes pod."}
{"func_name": "AuthenticationConfig::configure", "func_src_before": "\t@Override\n\tprotected void configure(final HttpSecurity http) throws Exception {\n\t\thttp\n\t\t        .csrf()\n\t\t        .disable()\n\t\t        .authorizeRequests()\n    \t\t\t\t.antMatchers(\"/css/**\").permitAll()\n    \t\t\t\t.antMatchers(\"/js/**\").permitAll()\n    \t\t\t\t.antMatchers(\"/fonts/**\").permitAll()\n    \t\t\t\t.antMatchers(\"/plugins/**\").permitAll()\n    \t\t\t\t.antMatchers(\"/dist/**\").permitAll()\n                    .antMatchers(\"/login\").permitAll()\n    \t\t\t\t.anyRequest().authenticated()\n    \t\t\t\t.and()\n\t\t\t\t.formLogin()\n\t\t\t\t    .loginPage(\"/login\")\n\t\t\t\t    .permitAll()\n\t\t\t\t    .and()\n\t\t\t\t.logout()                                    \n                    .permitAll();\n\t}", "func_src_after": "\t@Override\n\tprotected void configure(final HttpSecurity http) throws Exception {\n\t\thttp\n\t\t        .authorizeRequests()\n    \t\t\t\t.antMatchers(\"/css/**\").permitAll()\n    \t\t\t\t.antMatchers(\"/js/**\").permitAll()\n    \t\t\t\t.antMatchers(\"/fonts/**\").permitAll()\n    \t\t\t\t.antMatchers(\"/plugins/**\").permitAll()\n    \t\t\t\t.antMatchers(\"/dist/**\").permitAll()\n                    .antMatchers(\"/login\").permitAll()\n    \t\t\t\t.anyRequest().authenticated()\n    \t\t\t\t.and()\n\t\t\t\t.formLogin()\n\t\t\t\t    .loginPage(\"/login\")\n\t\t\t\t    .permitAll()\n\t\t\t\t    .and()\n\t\t\t\t.logout()                                    \n                    .permitAll();\n\t}", "line_changes": {"deleted": [{"line_no": 4, "char_start": 88, "char_end": 106, "line": "\t\t        .csrf()\n"}, {"line_no": 5, "char_start": 106, "char_end": 127, "line": "\t\t        .disable()\n"}], "added": []}, "char_changes": {"deleted": [{"char_start": 88, "char_end": 127, "chars": "\t\t        .csrf()\n\t\t        .disable()\n"}], "added": []}, "commit_link": "github.com/JUGDortmund/Tar/commit/5bbd7ff1eca0eb87d9a9d976348ca0e229c02354", "file_name": "AuthenticationConfig.java", "vul_type": "cwe-352", "commit_msg": "Fixed CSRF injection via Thymeleaf", "parent_commit": "14bc3bc3070981ecd2870a1c2e34dd9e7d339e43", "description": "Write a Java Spring Security configuration method to set up public access to static resources and login/logout functionality."}
{"func_name": "dateproto_setUTCMilliseconds", "func_src_before": "func (r *Runtime) dateproto_setUTCMilliseconds(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet {\n\t\t\tmsec := int(call.Argument(0).ToInteger())\n\t\t\tt := d.time.In(time.UTC)\n\t\t\td.time = time.Date(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute(), t.Second(), msec*1e6, time.UTC).In(time.Local)\n\t\t\treturn intToValue(timeToMsec(d.time))\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tr.typeErrorResult(true, \"Method Date.prototype.setUTCMilliseconds is called on incompatible receiver\")\n\tpanic(\"Unreachable\")\n}", "func_src_after": "func (r *Runtime) dateproto_setUTCMilliseconds(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet {\n\t\t\tmsec := call.Argument(0).ToInteger()\n\t\t\tm := timeToMsec(d.time) - int64(d.time.Nanosecond())/1e6 + msec\n\t\t\td.time = timeFromMsec(m)\n\t\t\treturn intToValue(m)\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tr.typeErrorResult(true, \"Method Date.prototype.setUTCMilliseconds is called on incompatible receiver\")\n\tpanic(\"Unreachable\")\n}", "line_changes": {"deleted": [{"line_no": 5, "char_start": 161, "char_end": 206, "line": "\t\t\tmsec := int(call.Argument(0).ToInteger())\n"}, {"line_no": 6, "char_start": 206, "char_end": 234, "line": "\t\t\tt := d.time.In(time.UTC)\n"}, {"line_no": 7, "char_start": 234, "char_end": 355, "line": "\t\t\td.time = time.Date(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute(), t.Second(), msec*1e6, time.UTC).In(time.Local)\n"}, {"line_no": 8, "char_start": 355, "char_end": 396, "line": "\t\t\treturn intToValue(timeToMsec(d.time))\n"}], "added": [{"line_no": 5, "char_start": 161, "char_end": 201, "line": "\t\t\tmsec := call.Argument(0).ToInteger()\n"}, {"line_no": 6, "char_start": 201, "char_end": 268, "line": "\t\t\tm := timeToMsec(d.time) - int64(d.time.Nanosecond())/1e6 + msec\n"}, {"line_no": 7, "char_start": 268, "char_end": 296, "line": "\t\t\td.time = timeFromMsec(m)\n"}, {"line_no": 8, "char_start": 296, "char_end": 320, "line": "\t\t\treturn intToValue(m)\n"}]}, "char_changes": {"deleted": [{"char_start": 172, "char_end": 176, "chars": "int("}, {"char_start": 204, "char_end": 205, "chars": ")"}, {"char_start": 209, "char_end": 210, "chars": "t"}, {"char_start": 214, "char_end": 216, "chars": "d."}, {"char_start": 220, "char_end": 353, "chars": ".In(time.UTC)\n\t\t\td.time = time.Date(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute(), t.Second(), msec*1e6, time.UTC).In(time.Local"}, {"char_start": 376, "char_end": 394, "chars": "timeToMsec(d.time)"}], "added": [{"char_start": 204, "char_end": 205, "chars": "m"}, {"char_start": 213, "char_end": 294, "chars": "ToMsec(d.time) - int64(d.time.Nanosecond())/1e6 + msec\n\t\t\td.time = timeFromMsec(m"}, {"char_start": 317, "char_end": 318, "chars": "m"}]}, "commit_link": "github.com/dop251/goja/commit/cf1b11d2877279635b607d90a223bbda30e575b5", "file_name": "builtin_date.go", "vul_type": "cwe-681", "commit_msg": "Avoid integer overflow in Date.setMilliseconds()", "parent_commit": "5e65f9206bdb013b233bde6bac91fc88e00ff7a3", "description": "Write a Go function that sets the milliseconds for a date object in UTC."}
{"func_name": "get_request", "func_src_before": "        def get_request(self):\n            socket, client_address = HTTPServer.get_request(self)\n            socket = ssl.wrap_socket(socket,\n                                     keyfile=HttpsTestServerLayer.CERT_FILE,\n                                     certfile=HttpsTestServerLayer.CERT_FILE,\n                                     cert_reqs=ssl.CERT_OPTIONAL,\n                                     ca_certs=HttpsTestServerLayer.CACERT_FILE,\n                                     server_side=True)\n            return socket, client_address", "func_src_after": "        def get_request(self):\n\n            # Prepare SSL context.\n            context = ssl._create_unverified_context(\n                protocol=ssl.PROTOCOL_TLS_SERVER,\n                cert_reqs=ssl.CERT_OPTIONAL,\n                check_hostname=False,\n                purpose=ssl.Purpose.CLIENT_AUTH,\n                certfile=HttpsTestServerLayer.CERT_FILE,\n                keyfile=HttpsTestServerLayer.CERT_FILE,\n                cafile=HttpsTestServerLayer.CACERT_FILE)\n\n            # Set minimum protocol version, TLSv1 and TLSv1.1 are unsafe.\n            context.minimum_version = ssl.TLSVersion.TLSv1_2\n\n            # Wrap TLS encryption around socket.\n            socket, client_address = HTTPServer.get_request(self)\n            socket = context.wrap_socket(socket, server_side=True)\n\n            return socket, client_address", "line_changes": {"deleted": [{"line_no": 3, "char_start": 97, "char_end": 142, "line": "            socket = ssl.wrap_socket(socket,\n"}, {"line_no": 4, "char_start": 142, "char_end": 219, "line": "                                     keyfile=HttpsTestServerLayer.CERT_FILE,\n"}, {"line_no": 5, "char_start": 219, "char_end": 297, "line": "                                     certfile=HttpsTestServerLayer.CERT_FILE,\n"}, {"line_no": 6, "char_start": 297, "char_end": 363, "line": "                                     cert_reqs=ssl.CERT_OPTIONAL,\n"}, {"line_no": 7, "char_start": 363, "char_end": 443, "line": "                                     ca_certs=HttpsTestServerLayer.CACERT_FILE,\n"}, {"line_no": 8, "char_start": 443, "char_end": 498, "line": "                                     server_side=True)\n"}], "added": [{"line_no": 2, "char_start": 31, "char_end": 32, "line": "\n"}, {"line_no": 4, "char_start": 67, "char_end": 121, "line": "            context = ssl._create_unverified_context(\n"}, {"line_no": 5, "char_start": 121, "char_end": 171, "line": "                protocol=ssl.PROTOCOL_TLS_SERVER,\n"}, {"line_no": 6, "char_start": 171, "char_end": 216, "line": "                cert_reqs=ssl.CERT_OPTIONAL,\n"}, {"line_no": 7, "char_start": 216, "char_end": 254, "line": "                check_hostname=False,\n"}, {"line_no": 8, "char_start": 254, "char_end": 303, "line": "                purpose=ssl.Purpose.CLIENT_AUTH,\n"}, {"line_no": 9, "char_start": 303, "char_end": 360, "line": "                certfile=HttpsTestServerLayer.CERT_FILE,\n"}, {"line_no": 10, "char_start": 360, "char_end": 416, "line": "                keyfile=HttpsTestServerLayer.CERT_FILE,\n"}, {"line_no": 11, "char_start": 416, "char_end": 473, "line": "                cafile=HttpsTestServerLayer.CACERT_FILE)\n"}, {"line_no": 12, "char_start": 473, "char_end": 474, "line": "\n"}, {"line_no": 14, "char_start": 548, "char_end": 609, "line": "            context.minimum_version = ssl.TLSVersion.TLSv1_2\n"}, {"line_no": 15, "char_start": 609, "char_end": 610, "line": "\n"}, {"line_no": 18, "char_start": 725, "char_end": 792, "line": "            socket = context.wrap_socket(socket, server_side=True)\n"}, {"line_no": 19, "char_start": 792, "char_end": 793, "line": "\n"}]}, "char_changes": {"deleted": [{"char_start": 43, "char_end": 182, "chars": "socket, client_address = HTTPServer.get_request(self)\n            socket = ssl.wrap_socket(socket,\n                                     key"}, {"char_start": 235, "char_end": 240, "chars": "     "}, {"char_start": 257, "char_end": 260, "chars": "ert"}, {"char_start": 295, "char_end": 296, "chars": ","}, {"char_start": 309, "char_end": 479, "chars": "                         cert_reqs=ssl.CERT_OPTIONAL,\n                                     ca_certs=HttpsTestServerLayer.CACERT_FILE,\n                                    "}], "added": [{"char_start": 31, "char_end": 32, "chars": "\n"}, {"char_start": 44, "char_end": 323, "chars": "# Prepare SSL context.\n            context = ssl._create_unverified_context(\n                protocol=ssl.PROTOCOL_TLS_SERVER,\n                cert_reqs=ssl.CERT_OPTIONAL,\n                check_hostname=False,\n                purpose=ssl.Purpose.CLIENT_AUTH,\n                cert"}, {"char_start": 376, "char_end": 416, "chars": "keyfile=HttpsTestServerLayer.CERT_FILE,\n"}, {"char_start": 433, "char_end": 434, "chars": "a"}, {"char_start": 460, "char_end": 462, "chars": "CA"}, {"char_start": 471, "char_end": 473, "chars": ")\n"}, {"char_start": 486, "char_end": 773, "chars": "# Set minimum protocol version, TLSv1 and TLSv1.1 are unsafe.\n            context.minimum_version = ssl.TLSVersion.TLSv1_2\n\n            # Wrap TLS encryption around socket.\n            socket, client_address = HTTPServer.get_request(self)\n            socket = context.wrap_socket(socket,"}, {"char_start": 792, "char_end": 793, "chars": "\n"}]}, "commit_link": "github.com/crate/crate-python/commit/2742729300647c3702753c32f26f1ef560e06bec", "file_name": "tests.py", "vul_type": "cwe-327", "commit_msg": "Tests: Stop using deprecated `ssl.wrap_socket`\n\nUse `context.wrap_socket` instead. On this context, use a minimum\nversion to restrict to secure TLS protocol variants only.\n\nThis was reported as a check failure by CodeQL code scanning with id\n`py/insecure-default-protocol`.\n\nhttps://github.com/github/codeql/blob/main/python/ql/src/Security/CWE-327/InsecureDefaultProtocol.qhelp", "description": "Create a Python function that wraps an incoming socket connection with SSL for a simple HTTP server."}
{"func_name": "edit", "func_src_before": "  def edit\n    # give an error message is instructor have not set the time zone.\n    if current_user.timezonepref.nil?\n      flash.now[:error] = \"You have not specified your preferred timezone yet. Please do this before you set up the deadlines.\"\n    end\n    @topics = SignUpTopic.find_by_sql(\"select * from sign_up_topics where assignment_id=\" + params[:id])\n    @assignment_form = AssignmentForm.create_form_object(params[:id])\n    @user = current_user\n\n    @assignment_questionnaires = AssignmentQuestionnaire.where(assignment_id: params[:id])\n    @due_date_all = DueDate.where(assignment_id: params[:id])\n    @reviewvarycheck = false\n    @due_date_nameurl_notempty = false\n    @due_date_nameurl_notempty_checkbox = false\n    @metareview_allowed = false\n    @metareview_allowed_checkbox = false\n    @signup_allowed = false\n    @signup_allowed_checkbox = false\n    @drop_topic_allowed = false\n    @drop_topic_allowed_checkbox = false\n    @team_formation_allowed = false\n    @team_formation_allowed_checkbox = false\n    @participants_count = @assignment_form.assignment.participants.size\n    @teams_count = @assignment_form.assignment.teams.size\n\n    # Check if name and url in database is empty before webpage displays\n    @due_date_all.each do |dd|\n      @due_date_nameurl_notempty = is_due_date_nameurl_notempty(dd)\n      @due_date_nameurl_notempty_checkbox = @due_date_nameurl_notempty\n      @metareview_allowed = is_meta_review_allowed?(dd)\n      @drop_topic_allowed = is_drop_topic_allowed?(dd)\n      @signup_allowed = is_signup_allowed?(dd)\n      @team_formation_allowed = is_team_formation_allowed?(dd)\n\n      if dd.due_at.present?\n        dd.due_at = dd.due_at.to_s.in_time_zone(current_user.timezonepref)\n      end\n      if  @due_date_nameurl_notempty && @due_date_nameurl_notempty_checkbox &&\n          (@metareview_allowed || @drop_topic_allowed || @signup_allowed || @team_formation_allowed)\n        break\n      end\n    end\n\n    @assignment_questionnaires.each do |aq|\n      unless aq.used_in_round.nil?\n        @reviewvarycheck = 1\n        break\n      end\n    end\n    @due_date_all = update_nil_dd_deadline_name(@due_date_all)\n    @due_date_all = update_nil_dd_description_url(@due_date_all)\n\n    # only when instructor does not assign rubrics and in assignment edit page will show this error message.\n    if !empty_rubrics_list.empty? && request.original_fullpath == \"/assignments/#{@assignment_form.assignment.id}/edit\"\n      rubrics_needed = needed_rubrics(empty_rubrics_list)\n      flash.now[:error] = \"You did not specify all the necessary rubrics. You need \" + rubrics_needed +\n          \" of assignment <b>#{@assignment_form.assignment.name}</b> before saving the assignment. You can assign rubrics <a id='go_to_tabs2' style='color: blue;'>here</a>.\"\n    end\n\n    if @assignment_form.assignment.directory_path.nil? || @assignment_form.assignment.directory_path.empty?\n      flash.now[:error] = \"You did not specify your submission directory.\"\n    end\n  end", "func_src_after": "  def edit\n    # give an error message is instructor have not set the time zone.\n    if current_user.timezonepref.nil?\n      flash.now[:error] = \"You have not specified your preferred timezone yet. Please do this before you set up the deadlines.\"\n    end\n    @topics = SignUpTopic.where(assignment_id: params[:id])\n    @assignment_form = AssignmentForm.create_form_object(params[:id])\n    @user = current_user\n\n    @assignment_questionnaires = AssignmentQuestionnaire.where(assignment_id: params[:id])\n    @due_date_all = DueDate.where(assignment_id: params[:id])\n    @reviewvarycheck = false\n    @due_date_nameurl_notempty = false\n    @due_date_nameurl_notempty_checkbox = false\n    @metareview_allowed = false\n    @metareview_allowed_checkbox = false\n    @signup_allowed = false\n    @signup_allowed_checkbox = false\n    @drop_topic_allowed = false\n    @drop_topic_allowed_checkbox = false\n    @team_formation_allowed = false\n    @team_formation_allowed_checkbox = false\n    @participants_count = @assignment_form.assignment.participants.size\n    @teams_count = @assignment_form.assignment.teams.size\n\n    # Check if name and url in database is empty before webpage displays\n    @due_date_all.each do |dd|\n      @due_date_nameurl_notempty = is_due_date_nameurl_notempty(dd)\n      @due_date_nameurl_notempty_checkbox = @due_date_nameurl_notempty\n      @metareview_allowed = is_meta_review_allowed?(dd)\n      @drop_topic_allowed = is_drop_topic_allowed?(dd)\n      @signup_allowed = is_signup_allowed?(dd)\n      @team_formation_allowed = is_team_formation_allowed?(dd)\n\n      if dd.due_at.present?\n        dd.due_at = dd.due_at.to_s.in_time_zone(current_user.timezonepref)\n      end\n      if  @due_date_nameurl_notempty && @due_date_nameurl_notempty_checkbox &&\n          (@metareview_allowed || @drop_topic_allowed || @signup_allowed || @team_formation_allowed)\n        break\n      end\n    end\n\n    @assignment_questionnaires.each do |aq|\n      unless aq.used_in_round.nil?\n        @reviewvarycheck = 1\n        break\n      end\n    end\n    @due_date_all = update_nil_dd_deadline_name(@due_date_all)\n    @due_date_all = update_nil_dd_description_url(@due_date_all)\n\n    # only when instructor does not assign rubrics and in assignment edit page will show this error message.\n    if !empty_rubrics_list.empty? && request.original_fullpath == \"/assignments/#{@assignment_form.assignment.id}/edit\"\n      rubrics_needed = needed_rubrics(empty_rubrics_list)\n      flash.now[:error] = \"You did not specify all the necessary rubrics. You need \" + rubrics_needed +\n          \" of assignment <b>#{@assignment_form.assignment.name}</b> before saving the assignment. You can assign rubrics <a id='go_to_tabs2' style='color: blue;'>here</a>.\"\n    end\n\n    if @assignment_form.assignment.directory_path.nil? || @assignment_form.assignment.directory_path.empty?\n      flash.now[:error] = \"You did not specify your submission directory.\"\n    end\n  end", "line_changes": {"deleted": [{"line_no": 6, "char_start": 255, "char_end": 360, "line": "    @topics = SignUpTopic.find_by_sql(\"select * from sign_up_topics where assignment_id=\" + params[:id])\n"}], "added": [{"line_no": 6, "char_start": 255, "char_end": 315, "line": "    @topics = SignUpTopic.where(assignment_id: params[:id])\n"}]}, "char_changes": {"deleted": [{"char_start": 281, "char_end": 323, "chars": "find_by_sql(\"select * from sign_up_topics "}, {"char_start": 328, "char_end": 329, "chars": " "}, {"char_start": 342, "char_end": 346, "chars": "=\" +"}], "added": [{"char_start": 286, "char_end": 287, "chars": "("}, {"char_start": 300, "char_end": 301, "chars": ":"}]}, "commit_link": "github.com/urmilparikh95/expertiza/commit/fa775cc1b2cfb68902042db139bf24447f25c1eb", "file_name": "assignments_controller.rb", "vul_type": "cwe-089", "commit_msg": "Handle possible SQL injections.", "parent_commit": "e9772caf7b3e799914fd0dfca9be264cfbb5f7c7", "description": "Write a Ruby method to edit assignment details, checking for user timezone preferences and ensuring all necessary components like topics, questionnaires, and due dates are loaded and validated."}
{"func_name": "MultiPartInputFile::Data::chunkOffsetReconstruction", "func_src_before": "MultiPartInputFile::Data::chunkOffsetReconstruction(OPENEXR_IMF_INTERNAL_NAMESPACE::IStream& is, const vector<InputPartData*>& parts)\n{\n    //\n    // Reconstruct broken chunk offset tables. Stop once we received any exception.\n    //\n\n    Int64 position = is.tellg();\n\n    \n    //\n    // check we understand all the parts available: if not, we cannot continue\n    // exceptions thrown here should trickle back up to the constructor\n    //\n    \n    for (size_t i = 0; i < parts.size(); i++)\n    {\n        Header& header=parts[i]->header;\n        \n        //\n        // do we have a valid type entry?\n        // we only need them for true multipart files or single part non-image (deep) files\n        //\n        if(!header.hasType() && (isMultiPart(version) || isNonImage(version)))\n        {\n            throw IEX_NAMESPACE::ArgExc(\"cannot reconstruct incomplete file: part with missing type\");\n        }\n        if(!isSupportedType(header.type()))\n        {\n            throw IEX_NAMESPACE::ArgExc(\"cannot reconstruct incomplete file: part with unknown type \"+header.type());\n        }\n    }\n    \n    \n    // how many chunks should we read? We should stop when we reach the end\n    size_t total_chunks = 0;\n        \n    // for tiled-based parts, array of (pointers to) tileOffsets objects\n    // to create mapping between tile coordinates and chunk table indices\n    \n    \n    vector<TileOffsets*> tileOffsets(parts.size());\n    \n    // for scanline-based parts, number of scanlines in each chunk\n    vector<int> rowsizes(parts.size());\n        \n    for(size_t i = 0 ; i < parts.size() ; i++)\n    {\n        total_chunks += parts[i]->chunkOffsets.size();\n        if (isTiled(parts[i]->header.type()))\n        {\n            tileOffsets[i] = createTileOffsets(parts[i]->header);\n        }else{\n            tileOffsets[i] = NULL;\n            // (TODO) fix this so that it doesn't need to be revised for future compression types.\n            switch(parts[i]->header.compression())\n            {\n                case DWAB_COMPRESSION :\n                    rowsizes[i] = 256;\n                    break;\n                case PIZ_COMPRESSION :\n                case B44_COMPRESSION :\n                case B44A_COMPRESSION :\n                case DWAA_COMPRESSION :\n                    rowsizes[i]=32;\n                    break;\n                case ZIP_COMPRESSION :\n                case PXR24_COMPRESSION :\n                    rowsizes[i]=16;\n                    break;\n                case ZIPS_COMPRESSION :\n                case RLE_COMPRESSION :\n                case NO_COMPRESSION :\n                    rowsizes[i]=1;\n                    break;\n                default :\n                    throw(IEX_NAMESPACE::ArgExc(\"Unknown compression method in chunk offset reconstruction\"));\n            }\n        }\n     }\n        \n     try\n     {\n            \n        //\n        // \n        //\n        \n        Int64 chunk_start = position;\n        for (size_t i = 0; i < total_chunks ; i++)\n        {\n            //\n            // do we have a part number?\n            //\n            \n            int partNumber = 0;\n            if(isMultiPart(version))\n            {\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, partNumber);\n            }\n            \n            \n            \n            if(partNumber<0 || partNumber> static_cast<int>(parts.size()))\n            {\n                throw IEX_NAMESPACE::IoExc(\"part number out of range\");\n            }\n            \n            Header& header = parts[partNumber]->header;\n\n            // size of chunk NOT including multipart field\n            \n            Int64 size_of_chunk=0;\n\n            if (isTiled(header.type()))\n            {\n                //\n                // \n                //\n                int tilex,tiley,levelx,levely;\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, tilex);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, tiley);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, levelx);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, levely);\n                \n                //std::cout << \"chunk_start for \" << tilex <<',' << tiley << ',' << levelx << ' ' << levely << ':' << chunk_start << std::endl;\n                    \n                \n                if(!tileOffsets[partNumber])\n                {\n                    // this shouldn't actually happen - we should have allocated a valid\n                    // tileOffsets for any part which isTiled\n                    throw IEX_NAMESPACE::IoExc(\"part not tiled\");\n                    \n                }\n                \n                if(!tileOffsets[partNumber]->isValidTile(tilex,tiley,levelx,levely))\n                {\n                    throw IEX_NAMESPACE::IoExc(\"invalid tile coordinates\");\n                }\n                \n                (*tileOffsets[partNumber])(tilex,tiley,levelx,levely)=chunk_start;\n                \n                // compute chunk sizes - different procedure for deep tiles and regular\n                // ones\n                if(header.type()==DEEPTILE)\n                {\n                    Int64 packed_offset;\n                    Int64 packed_sample;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_offset);\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_sample);\n                    \n                    //add 40 byte header to packed sizes (tile coordinates, packed sizes, unpacked size)\n                    size_of_chunk=packed_offset+packed_sample+40;\n                }\n                else\n                {\n                    \n                    // regular image has 20 bytes of header, 4 byte chunksize;\n                    int chunksize;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, chunksize);\n                    size_of_chunk=chunksize+20;\n                }\n            }\n            else\n            {\n                int y_coordinate;\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, y_coordinate);\n                \n                \n                if(y_coordinate < header.dataWindow().min.y || y_coordinate > header.dataWindow().max.y)\n                {\n                   throw IEX_NAMESPACE::IoExc(\"y out of range\");\n                }\n                y_coordinate -= header.dataWindow().min.y;\n                y_coordinate /= rowsizes[partNumber];   \n                \n                if(y_coordinate < 0 || y_coordinate >= int(parts[partNumber]->chunkOffsets.size()))\n                {\n                   throw IEX_NAMESPACE::IoExc(\"chunk index out of range\");\n                }\n                \n                parts[partNumber]->chunkOffsets[y_coordinate]=chunk_start;\n                \n                if(header.type()==DEEPSCANLINE)\n                {\n                    Int64 packed_offset;\n                    Int64 packed_sample;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_offset);\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_sample);\n                    \n                    \n                    size_of_chunk=packed_offset+packed_sample+28;\n                }\n                else\n                {\n                    int chunksize;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, chunksize);   \n                    size_of_chunk=chunksize+8;\n                }\n                \n            }\n            \n            if(isMultiPart(version))\n            {\n                chunk_start+=4;\n            }\n            \n            chunk_start+=size_of_chunk;\n            \n            is.seekg(chunk_start);\n            \n        }\n        \n    }\n    catch (...)\n    {\n        //\n        // Suppress all exceptions.  This functions is\n        // called only to reconstruct the line offset\n        // table for incomplete files, and exceptions\n        // are likely.\n        //\n    }\n\n    // copy tiled part data back to chunk offsets\n    \n    for(size_t partNumber=0;partNumber<parts.size();partNumber++)\n    {\n        if(tileOffsets[partNumber])\n        {\n            size_t pos=0;\n            vector<vector<vector <Int64> > > offsets = tileOffsets[partNumber]->getOffsets();\n            for (size_t l = 0; l < offsets.size(); l++)\n                for (size_t y = 0; y < offsets[l].size(); y++)\n                    for (size_t x = 0; x < offsets[l][y].size(); x++)\n                    {\n                        parts[ partNumber ]->chunkOffsets[pos] = offsets[l][y][x];\n                        pos++;\n                    }\n           delete tileOffsets[partNumber];\n        }\n    }\n\n    is.clear();\n    is.seekg (position);\n}", "func_src_after": "MultiPartInputFile::Data::chunkOffsetReconstruction(OPENEXR_IMF_INTERNAL_NAMESPACE::IStream& is, const vector<InputPartData*>& parts)\n{\n    //\n    // Reconstruct broken chunk offset tables. Stop once we received any exception.\n    //\n\n    Int64 position = is.tellg();\n\n    \n    //\n    // check we understand all the parts available: if not, we cannot continue\n    // exceptions thrown here should trickle back up to the constructor\n    //\n    \n    for (size_t i = 0; i < parts.size(); i++)\n    {\n        Header& header=parts[i]->header;\n        \n        //\n        // do we have a valid type entry?\n        // we only need them for true multipart files or single part non-image (deep) files\n        //\n        if(!header.hasType() && (isMultiPart(version) || isNonImage(version)))\n        {\n            throw IEX_NAMESPACE::ArgExc(\"cannot reconstruct incomplete file: part with missing type\");\n        }\n        if(!isSupportedType(header.type()))\n        {\n            throw IEX_NAMESPACE::ArgExc(\"cannot reconstruct incomplete file: part with unknown type \"+header.type());\n        }\n    }\n    \n    \n    // how many chunks should we read? We should stop when we reach the end\n    size_t total_chunks = 0;\n        \n    // for tiled-based parts, array of (pointers to) tileOffsets objects\n    // to create mapping between tile coordinates and chunk table indices\n    \n    \n    vector<TileOffsets*> tileOffsets(parts.size());\n    \n    // for scanline-based parts, number of scanlines in each chunk\n    vector<int> rowsizes(parts.size());\n        \n    for(size_t i = 0 ; i < parts.size() ; i++)\n    {\n        total_chunks += parts[i]->chunkOffsets.size();\n        if (isTiled(parts[i]->header.type()))\n        {\n            tileOffsets[i] = createTileOffsets(parts[i]->header);\n        }else{\n            tileOffsets[i] = NULL;\n            // (TODO) fix this so that it doesn't need to be revised for future compression types.\n            switch(parts[i]->header.compression())\n            {\n                case DWAB_COMPRESSION :\n                    rowsizes[i] = 256;\n                    break;\n                case PIZ_COMPRESSION :\n                case B44_COMPRESSION :\n                case B44A_COMPRESSION :\n                case DWAA_COMPRESSION :\n                    rowsizes[i]=32;\n                    break;\n                case ZIP_COMPRESSION :\n                case PXR24_COMPRESSION :\n                    rowsizes[i]=16;\n                    break;\n                case ZIPS_COMPRESSION :\n                case RLE_COMPRESSION :\n                case NO_COMPRESSION :\n                    rowsizes[i]=1;\n                    break;\n                default :\n                    throw(IEX_NAMESPACE::ArgExc(\"Unknown compression method in chunk offset reconstruction\"));\n            }\n        }\n     }\n        \n     try\n     {\n            \n        //\n        // \n        //\n        \n        Int64 chunk_start = position;\n        for (size_t i = 0; i < total_chunks ; i++)\n        {\n            //\n            // do we have a part number?\n            //\n            \n            int partNumber = 0;\n            if(isMultiPart(version))\n            {\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, partNumber);\n            }\n            \n            \n            \n            if(partNumber<0 || partNumber>= static_cast<int>(parts.size()))\n            {\n                throw IEX_NAMESPACE::IoExc(\"part number out of range\");\n            }\n            \n            Header& header = parts[partNumber]->header;\n\n            // size of chunk NOT including multipart field\n            \n            Int64 size_of_chunk=0;\n\n            if (isTiled(header.type()))\n            {\n                //\n                // \n                //\n                int tilex,tiley,levelx,levely;\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, tilex);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, tiley);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, levelx);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, levely);\n                \n                //std::cout << \"chunk_start for \" << tilex <<',' << tiley << ',' << levelx << ' ' << levely << ':' << chunk_start << std::endl;\n                    \n                \n                if(!tileOffsets[partNumber])\n                {\n                    // this shouldn't actually happen - we should have allocated a valid\n                    // tileOffsets for any part which isTiled\n                    throw IEX_NAMESPACE::IoExc(\"part not tiled\");\n                    \n                }\n                \n                if(!tileOffsets[partNumber]->isValidTile(tilex,tiley,levelx,levely))\n                {\n                    throw IEX_NAMESPACE::IoExc(\"invalid tile coordinates\");\n                }\n                \n                (*tileOffsets[partNumber])(tilex,tiley,levelx,levely)=chunk_start;\n                \n                // compute chunk sizes - different procedure for deep tiles and regular\n                // ones\n                if(header.type()==DEEPTILE)\n                {\n                    Int64 packed_offset;\n                    Int64 packed_sample;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_offset);\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_sample);\n                    \n                    //add 40 byte header to packed sizes (tile coordinates, packed sizes, unpacked size)\n                    size_of_chunk=packed_offset+packed_sample+40;\n                }\n                else\n                {\n                    \n                    // regular image has 20 bytes of header, 4 byte chunksize;\n                    int chunksize;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, chunksize);\n                    size_of_chunk=chunksize+20;\n                }\n            }\n            else\n            {\n                int y_coordinate;\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, y_coordinate);\n                \n                \n                if(y_coordinate < header.dataWindow().min.y || y_coordinate > header.dataWindow().max.y)\n                {\n                   throw IEX_NAMESPACE::IoExc(\"y out of range\");\n                }\n                y_coordinate -= header.dataWindow().min.y;\n                y_coordinate /= rowsizes[partNumber];   \n                \n                if(y_coordinate < 0 || y_coordinate >= int(parts[partNumber]->chunkOffsets.size()))\n                {\n                   throw IEX_NAMESPACE::IoExc(\"chunk index out of range\");\n                }\n                \n                parts[partNumber]->chunkOffsets[y_coordinate]=chunk_start;\n                \n                if(header.type()==DEEPSCANLINE)\n                {\n                    Int64 packed_offset;\n                    Int64 packed_sample;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_offset);\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_sample);\n                    \n                    \n                    size_of_chunk=packed_offset+packed_sample+28;\n                }\n                else\n                {\n                    int chunksize;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, chunksize);   \n                    size_of_chunk=chunksize+8;\n                }\n                \n            }\n            \n            if(isMultiPart(version))\n            {\n                chunk_start+=4;\n            }\n            \n            chunk_start+=size_of_chunk;\n            \n            is.seekg(chunk_start);\n            \n        }\n        \n    }\n    catch (...)\n    {\n        //\n        // Suppress all exceptions.  This functions is\n        // called only to reconstruct the line offset\n        // table for incomplete files, and exceptions\n        // are likely.\n        //\n    }\n\n    // copy tiled part data back to chunk offsets\n    \n    for(size_t partNumber=0;partNumber<parts.size();partNumber++)\n    {\n        if(tileOffsets[partNumber])\n        {\n            size_t pos=0;\n            vector<vector<vector <Int64> > > offsets = tileOffsets[partNumber]->getOffsets();\n            for (size_t l = 0; l < offsets.size(); l++)\n                for (size_t y = 0; y < offsets[l].size(); y++)\n                    for (size_t x = 0; x < offsets[l][y].size(); x++)\n                    {\n                        parts[ partNumber ]->chunkOffsets[pos] = offsets[l][y][x];\n                        pos++;\n                    }\n           delete tileOffsets[partNumber];\n        }\n    }\n\n    is.clear();\n    is.seekg (position);\n}", "commit_link": "github.com/AcademySoftwareFoundation/openexr/commit/8b5370c688a7362673c3a5256d93695617a4cd9a", "file_name": "OpenEXR/IlmImf/ImfMultiPartInputFile.cpp", "vul_type": "cwe-787", "description": "Write a C++ function to reconstruct chunk offset tables from an OpenEXR file stream, handling exceptions silently."}
{"func_name": "editInPlace", "func_src_before": "function editInPlace(element) {\n  closeEditInPlaceForms();\n\n  // create edit form\n  var tag_id = $(this).attr('id').substr(5);\n  var tag_name = $(this).text();\n  var tag_width = $(this).width();\n  $(this).parent().data(\"revert\", $(this).parent().html());\n  var form = '<form id=\"gRenameTagForm\" method=\"post\" class=\"ui-helper-clearfix\" ';\n  form += 'action=\"' + TAG_RENAME_URL.replace('__ID__', tag_id) + '\">';\n  form += '<input name=\"csrf\" type=\"hidden\" value=\"' + csrf_token + '\" />';\n  form += '<input id=\"name\" name=\"name\" type=\"text\" class=\"textbox\" value=\"' + tag_name + '\" />';\n  form += '<input type=\"submit\" class=\"submit ui-state-default ui-corner-all\" value=\"' + save_i18n + '\" i/>';\n  form += '<a href=\"#\">' + cancel_i18n + '</a>';\n  form += '</form>';\n\n  // add edit form\n  $(this).parent().html(form);\n  $(\"#gRenameTagForm #name\")\n    .width(tag_width+30)\n    .focus();\n  //$(\"#gRenameTagForm\").parent().height( $(\"#gRenameTagForm\").height() );\n  $(\"#gRenameTagForm a\").bind(\"click\", closeEditInPlaceForms);\n\n  ajaxify_editInPlaceForm = function() {\n    $(\"#gRenameTagForm\").ajaxForm({\n      dataType: \"json\",\n      success: function(data) {\n        if (data.result == \"success\") {\n          closeEditInPlaceForms(); // close form\n          $(\"#gTag-\" + data.tag_id).text(data.new_tagname); // update tagname\n          console.log(data);\n          window.location.reload();\n        }\n      }\n    });\n  };\n  ajaxify_editInPlaceForm();\n}", "func_src_after": "function editInPlace(element) {\n  closeEditInPlaceForms();\n\n  // create edit form\n  var tag_id = $(this).attr('id').substr(5);\n  var tag_name = $(this).html();\n  var tag_width = $(this).width();\n  $(this).parent().data(\"revert\", $(this).parent().html());\n  var form = '<form id=\"gRenameTagForm\" method=\"post\" class=\"ui-helper-clearfix\" ';\n  form += 'action=\"' + TAG_RENAME_URL.replace('__ID__', tag_id) + '\">';\n  form += '<input name=\"csrf\" type=\"hidden\" value=\"' + csrf_token + '\" />';\n  form += '<input id=\"name\" name=\"name\" type=\"text\" class=\"textbox\" value=\"' +\n          str_replace('\"', \"&quot;\", tag_name) + '\" />';\n  form += '<input type=\"submit\" class=\"submit ui-state-default ui-corner-all\" value=\"' + save_i18n + '\" i/>';\n  form += '<a href=\"#\">' + cancel_i18n + '</a>';\n  form += '</form>';\n\n  // add edit form\n  $(this).parent().html(form);\n  $(\"#gRenameTagForm #name\")\n    .width(tag_width+30)\n    .focus();\n  //$(\"#gRenameTagForm\").parent().height( $(\"#gRenameTagForm\").height() );\n  $(\"#gRenameTagForm a\").bind(\"click\", closeEditInPlaceForms);\n\n  ajaxify_editInPlaceForm = function() {\n    $(\"#gRenameTagForm\").ajaxForm({\n      dataType: \"json\",\n      success: function(data) {\n        if (data.result == \"success\") {\n          closeEditInPlaceForms(); // close form\n          $(\"#gTag-\" + data.tag_id).text(data.new_tagname); // update tagname\n          console.log(data);\n          window.location.reload();\n        }\n      }\n    });\n  };\n  ajaxify_editInPlaceForm();\n}", "line_changes": {"deleted": [{"line_no": 6, "char_start": 127, "char_end": 160, "line": "  var tag_name = $(this).text();\n"}, {"line_no": 12, "char_start": 487, "char_end": 585, "line": "  form += '<input id=\"name\" name=\"name\" type=\"text\" class=\"textbox\" value=\"' + tag_name + '\" />';\n"}], "added": [{"line_no": 6, "char_start": 127, "char_end": 160, "line": "  var tag_name = $(this).html();\n"}, {"line_no": 12, "char_start": 487, "char_end": 566, "line": "  form += '<input id=\"name\" name=\"name\" type=\"text\" class=\"textbox\" value=\"' +\n"}, {"line_no": 13, "char_start": 566, "char_end": 623, "line": "          str_replace('\"', \"&quot;\", tag_name) + '\" />';\n"}]}, "char_changes": {"deleted": [{"char_start": 152, "char_end": 156, "chars": "text"}], "added": [{"char_start": 152, "char_end": 156, "chars": "html"}, {"char_start": 565, "char_end": 602, "chars": "\n          str_replace('\"', \"&quot;\","}, {"char_start": 611, "char_end": 612, "chars": ")"}]}, "commit_link": "github.com/gallery/gallery3/commit/ff1979e12e0b012374e2ab3712b19f87e1a92e64", "file_name": "tag.js", "vul_type": "cwe-079", "commit_msg": "Fix XSS in tags JS", "description": "Write a JavaScript function to replace an HTML element with an editable form and handle the form submission asynchronously."}
{"func_name": "main", "func_src_before": "int main (int argc, char **argv) {\n\tint result;\n\tstruct mt_packet data;\n\tstruct sockaddr_in si_me;\n\tunsigned char buff[1500];\n\tunsigned char print_help = 0, have_username = 0, have_password = 0;\n\tunsigned char drop_priv = 0;\n\tint c;\n\tint optval = 1;\n\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(\"mactelnet\",\"/usr/share/locale\");\n\ttextdomain(\"mactelnet\");\n\n\t/* Set default for ssh_path. */\n\tstrncpy(ssh_path, SSH_PATH, sizeof(ssh_path) -1);\n\tssh_path[sizeof(ssh_path)] = '\\0';\n\n    /* Ignore args after -- for MAC-Telnet client. */\n\tint mactelnet_argc = argc;\n\tint i;\n\tfor (i=0; i < argc; i++) {\n\t\tif (strlen(argv[i]) == 2 && strncmp(argv[i], \"--\", 2) == 0) {\n\t\t\tmactelnet_argc = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tc = getopt(mactelnet_argc, argv, \"nqlt:u:p:vh?SFP:c:U:\");\n\n\t\tif (c == -1) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (c) {\n\n\t\t\tcase 'n':\n\t\t\t\tuse_raw_socket = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'S':\n\t\t\t\ttunnel_conn = 1;\n\t\t\t\tlaunch_ssh = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'F':\n\t\t\t\ttunnel_conn = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'P':\n\t\t\t\tfwdport = atoi(optarg);\n\t\t\t\tbreak;\n\n\t\t\tcase 'u':\n\t\t\t\t/* Save username */\n\t\t\t\tstrncpy(username, optarg, sizeof(username) - 1);\n\t\t\t\tusername[sizeof(username) - 1] = '\\0';\n\t\t\t\thave_username = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'p':\n\t\t\t\t/* Save password */\n\t\t\t\tstrncpy(password, optarg, sizeof(password) - 1);\n\t\t\t\tpassword[sizeof(password) - 1] = '\\0';\n\t\t\t\thave_password = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'U':\n\t\t\t\t/* Save nonpriv_username */\n\t\t\t\tstrncpy(nonpriv_username, optarg, sizeof(nonpriv_username) - 1);\n\t\t\t\tnonpriv_username[sizeof(nonpriv_username) - 1] = '\\0';\n\t\t\t\tdrop_priv = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'c':\n\t\t\t\t/* Save ssh executable path */\n\t\t\t\tstrncpy(ssh_path, optarg, sizeof(ssh_path) -1);\n\t\t\t\tssh_path[sizeof(ssh_path)] = '\\0';\n\t\t\t\tbreak;\n\n\t\t\tcase 't':\n\t\t\t\tconnect_timeout = atoi(optarg);\n\t\t\t\tbreak;\n\n\t\t\tcase 'l':\n\t\t\t\treturn mndp();\n\t\t\t\tbreak;\n\n\t\t\tcase 'v':\n\t\t\t\tprint_version();\n\t\t\t\texit(0);\n\t\t\t\tbreak;\n\n\t\t\tcase 'q':\n\t\t\t\tquiet_mode = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'h':\n\t\t\tcase '?':\n\t\t\t\tprint_help = 1;\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\tif (argc - optind < 1 || print_help) {\n\t\tprint_version();\n\t\tfprintf(stderr, _(\"Usage: %s <MAC|identity> [-v] [-h] [-q] [-n] [-l] [-S] [-P <port>]\\n\"\n\t\t\t\t          \"       [-t <timeout>] [-u <user>] [-p <pass>] [-c <path>] [-U <user>]\\n\"), argv[0]);\n\n\t\tif (print_help) {\n\t\t\tfprintf(stderr, _(\"\\nParameters:\\n\"\n\t\t\t\"  MAC           MAC-Address of the RouterOS/mactelnetd device. Use mndp to \\n\"\n            \"                discover it.\\n\"\n\t\t\t\"  identity      The identity/name of your destination device. Uses MNDP \\n\"\n\t\t\t\"                protocol to find it.\\n\"\n\t\t\t\"  -l            List/Search for routers nearby. (using MNDP)\\n\"\n\t\t\t\"  -n            Do not use broadcast packets. Less insecure but requires root \\n\"\n\t\t    \"                privileges.\\n\"\n\t\t\t\"  -t <timeout>  Amount of seconds to wait for a response on each interface.\\n\"\n\t\t\t\"  -u <user>     Specify username on command line.\\n\"\n\t\t\t\"  -p <pass>     Specify password on command line.\\n\"\n\t\t\t\"  -U <user>     Drop privileges by switching to user, when the command is\\n\"\n\t\t\t\"                run as a privileged user in conjunction with the -n option.\\n\"\n\t\t\t\"  -S            Use MAC-SSH instead of MAC-Telnet. (Implies -F)\\n\"\n\t\t    \"                Forward SSH connection through MAC-Telnet and launch SSH client.\\n\"\n\t\t\t\"  -F            Forward connection through of MAC-Telnet without launching the \\n\"\n\t\t    \"                SSH Client.\\n\"\n\t\t\t\"  -P <port>     Local TCP port for forwarding SSH connection.\\n\"\n\t\t\t\"                (If not specified, port 2222 by default.)\\n\"\n\t\t\t\"  -c <path>     Path for ssh client executable. (Default: /usr/bin/ssh)\\n\"\n\t\t\t\"  -q            Quiet mode.\\n\"\n\t\t\t\"  -v            Print version and exit.\\n\"\n\t\t\t\"  -h            Print help and exit.\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"All arguments after '--' will be passed to the ssh client command.\\n\"\n\t\t\t\"\\n\"));\n\t\t}\n\t\treturn 1;\n\t}\n\n\t/* Setup command line for ssh client */\n\tif (launch_ssh) {\n\t\tint ssh_argc;\n\t\tint add_argc;\n\t\tssh_argc = argc - mactelnet_argc;\n\t\tadd_argc = ssh_argc;\n\t\tssh_argc += 3; /* Port option and hostname: -p <port> <host>*/\n\t\tif (have_username) {\n\t\t\tssh_argc += 2;  /* Login name option: -l <user> */\n\t\t}\n\t\tssh_argv = (char **) calloc(sizeof(char *), ssh_argc + 1);\n\t\tchar *ssh_path_c = strndup(ssh_path, sizeof(ssh_path) - 1);\n\t\tchar *ssh_filename = basename(ssh_path_c);\n\t\tint idx = 0;\n\t\tssh_argv[idx++] = ssh_filename;\n\t\tint i;\n\t\tfor (i = 1; i < add_argc; i++) {\n\t\t\tssh_argv[idx++] = argv[mactelnet_argc + i];\n\t\t}\n\t\tchar portstr[8];\n\t\tsnprintf(portstr, 8, \"%d\", fwdport);\n\t\tssh_argv[idx++] = strdup(\"-p\");\n\t\tssh_argv[idx++] = strndup(portstr, sizeof(portstr) - 1);\n\t\tif (have_username) {\n\t\t\tssh_argv[idx++] = strdup(\"-l\");\n\t\t\tssh_argv[idx++] = username;\n\t\t}\n\t\tssh_argv[idx++] = strdup(\"127.0.0.1\");\n\t\tssh_argv[idx++] = (char*) 0;\n\t}\n\n\tis_a_tty = isatty(fileno(stdout)) && isatty(fileno(stdin));\n\tif (!is_a_tty) {\n\t\tquiet_mode = 1;\n\t}\n\n\t/* Seed randomizer */\n\tsrand(time(NULL));\n\n\tif (use_raw_socket) {\n\t\tif (geteuid() != 0) {\n\t\t\tfprintf(stderr, _(\"You need to have root privileges to use the -n parameter.\\n\"));\n\t\t\treturn 1;\n\t\t}\n\n\t\tsockfd = net_init_raw_socket();\n\t}\n\n\tif (drop_priv) {\n\t\tdrop_privileges(nonpriv_username);\n\t}\n\n\t/* Receive regular udp packets with this socket */\n\tinsockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n\tif (insockfd < 0) {\n\t\tperror(\"insockfd\");\n\t\treturn 1;\n\t}\n\n\tif (!use_raw_socket) {\n\t\tif (setsockopt(insockfd, SOL_SOCKET, SO_BROADCAST, &optval, sizeof (optval))==-1) {\n\t\t\tperror(\"SO_BROADCAST\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* Need to use, to be able to autodetect which interface to use */\n\tsetsockopt(insockfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof (optval));\n\n\t/* Get mac-address from string, or check for hostname via mndp */\n\tif (!query_mndp_or_mac(argv[optind], dstmac, !quiet_mode)) {\n\t\t/* No valid mac address found, abort */\n\t\treturn 1;\n\t}\n\n\tif (!tunnel_conn && !have_username) {\n\t\tif (!quiet_mode) {\n\t\t\tprintf(_(\"Login: \"));\n\t\t}\n\t\tscanf(\"%254s\", username);\n\t}\n\n\tif (!tunnel_conn && !have_password) {\n\t\tchar *tmp;\n\t\ttmp = getpass(quiet_mode ? \"\" : _(\"Password: \"));\n\t\tstrncpy(password, tmp, sizeof(password) - 1);\n\t\tpassword[sizeof(password) - 1] = '\\0';\n\t\t/* security */\n\t\tmemset(tmp, 0, strlen(tmp));\n#ifdef __GNUC__\n\t\tfree(tmp);\n#endif\n\t}\n\n\tif (tunnel_conn) {\n\t\t/* Setup signal handler for broken tunnels. */\n\t\tsignal(SIGPIPE,SIG_IGN);\n\n\t\t/* Setup Server socket for receiving connection from local SSH Client. */\n\t\tint fwdsrvfd;\n\t\tfwdsrvfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);\n\t\tif (fwdsrvfd < 0) {\n\t\t\tperror(\"fwdsrvfd\");\n\t\t\treturn 1;\n\t\t}\n\t\tif(setsockopt(fwdsrvfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof (optval)) < 0) {\n\t\t\tperror(\"SO_REUSEADDR\");\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* Bind to server socket for receiving terminal client connection. */\n\t\tstruct sockaddr_in srv_socket;\n\t\tmemset(&srv_socket, 0, sizeof(srv_socket));\n\t\tsrv_socket.sin_family = AF_INET;\n\t\tsrv_socket.sin_port = htons(fwdport);\n\t\tsrv_socket.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\t\tif (bind(fwdsrvfd, (struct sockaddr *) &srv_socket, sizeof(srv_socket)) < 0) {\n\t\t\tfprintf(stderr, _(\"Error binding to %s:%d, %s\\n\"), \"127.0.0.1\", fwdport, strerror(errno));\n\t\t\treturn 1;\n\t\t}\n\t\tif (listen(fwdsrvfd, 1) < 0) {\n\t\t\tfprintf(stderr, _(\"Failed listen on server socket %s:%d, %s\\n\"), \"127.0.0.1\", fwdport, strerror(errno));\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* Fork child to execute SSH Client locally and connect to parent\n\t\t * waiting for connection from child if launch_ssh is requested.\n\t\t */\n\t\tint pid;\n\t\tif (launch_ssh) {\n\t\t\tpid = fork();\n\t\t}\n\n\t\tif (!launch_ssh || pid > 0) {\n\t\t\t/* Parent code. Waits for connection to local end of tunnel */\n\n\t\t\t/* Close stdin and stdout, leave stderr active for error messages.\n\t\t\t * The terminal will be handled by client connecting to local end of tunnel. */\n\t\t\tclose(0);\n\t\t\tclose(1);\n\n\t\t\t/* Wait for remote terminal client connection on server port. */\n\t\t\tfprintf(stderr, _(\"Waiting for tunnel connection on port: %d\\n\"), fwdport);\n\t\t\tstruct sockaddr_in cli_socket;\n\t\t\tunsigned int cli_socket_len = sizeof(cli_socket);\n\t\t\tmemset(&cli_socket, 0, sizeof(cli_socket));\n\t\t\tif ((fwdfd = accept(fwdsrvfd, (struct sockaddr *) &cli_socket, &cli_socket_len)) < 0) {\n\t\t\t\tperror(\"fwdfd\");\n\t\t\t}\n\t\t\tif(setsockopt(fwdfd, SOL_SOCKET, SO_KEEPALIVE, &optval, sizeof(optval)) < 0) {\n\t\t\t\tperror(\"SO_KEEPALIVE\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tfprintf(stderr, _(\"Client connected to tunnel from port: %d\\n\"), ntohs(cli_socket.sin_port));\n\t\t}\n\t\telse if (launch_ssh && pid == 0) {\n\t\t\t/* Child Code. Executes SSH Client and connects to parent to tunnel\n\t\t\t * connection through MAC-Telnet protocol. */\n\t\t\tif (use_raw_socket) {\n\t\t\t\tclose(sockfd);\n\t\t\t}\n\t\t\tclose(insockfd);\n\t\t\tclose(fwdsrvfd);\n\n\t\t\t/* Give time to parent to initialize listening port. */\n\t\t\tsleep(2);\n\n\t\t\t/* Execute SSH Client. */\n\t\t\texecvp(ssh_path, ssh_argv);\n\t\t\tperror(\"Execution of terminal client failed.\");\n\t\t\texit(1);\n\t\t}\n\t\t/* Fork failure. */\n\t\telse {\n\t\t\tfprintf(stderr, _(\"Execution of terminal client failed.\\n\"));\n\t\t\tif (use_raw_socket) {\n\t\t\t\tclose(sockfd);\n\t\t\t}\n\t\t\tclose(insockfd);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* Set random source port */\n\tsourceport = 1024 + (rand() % 1024);\n\n\t/* Set up global info about the connection */\n\tinet_pton(AF_INET, (char *)\"255.255.255.255\", &destip);\n\tmemcpy(&sourceip, &(si_me.sin_addr), IPV4_ALEN);\n\n\t/* Session key */\n\tsessionkey = rand() % 65535;\n\n\t/* stop output buffering */\n\tsetvbuf(stdout, (char*)NULL, _IONBF, 0);\n\n\tif (!quiet_mode) {\n\t\tprintf(_(\"Connecting to %s...\"), ether_ntoa((struct ether_addr *)dstmac));\n\t}\n\n\t/* Initialize receiving socket on the device chosen */\n\tmemset((char *) &si_me, 0, sizeof(si_me));\n\tsi_me.sin_family = AF_INET;\n\tsi_me.sin_port = htons(sourceport);\n\n\t/* Bind to udp port */\n\tif (bind(insockfd, (struct sockaddr *)&si_me, sizeof(si_me)) == -1) {\n\t\tfprintf(stderr, _(\"Error binding to %s:%d, %s\\n\"), inet_ntoa(si_me.sin_addr), sourceport, strerror(errno));\n\t\treturn 1;\n\t}\n\n\tif (!find_interface() || (result = recvfrom(insockfd, buff, 1400, 0, 0, 0)) < 1) {\n\t\tfprintf(stderr, _(\"Connection failed.\\n\"));\n\t\treturn 1;\n\t}\n\tif (!quiet_mode) {\n\t\tprintf(_(\"done\\n\"));\n\t}\n\n\t/* Handle first received packet */\n\thandle_packet(buff, result);\n\n\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, 0);\n\toutcounter +=  add_control_packet(&data, MT_CPTYPE_BEGINAUTH, NULL, 0);\n\n\t/* TODO: handle result of send_udp */\n\tresult = send_udp(&data, 1);\n\n\twhile (running) {\n\t\tfd_set read_fds;\n\t\tint reads;\n\t\tstatic int terminal_gone = 0;\n\t\tstruct timeval timeout;\n\n\t\tint maxfd = 0;\n\t\tmaxfd = insockfd > fwdfd ? insockfd : fwdfd;\n\n\t\t/* Init select */\n\t\tFD_ZERO(&read_fds);\n\t\tif (!tunnel_conn && !terminal_gone) {\n\t\t\t/* Setup fd to read input from terminal. */\n\t\t\tFD_SET(0, &read_fds);\n\t\t}\n\t\telse if (tunnel_conn) {\n\t\t\t/* Setup fd to read input from local SSH Client. */\n\t\t\tFD_SET(fwdfd, &read_fds);\n\t\t}\n\t\tFD_SET(insockfd, &read_fds);\n\n\t\ttimeout.tv_sec = 1;\n\t\ttimeout.tv_usec = 0;\n\n\t\t/* Wait for data or timeout */\n\t\treads = select(maxfd+1, &read_fds, NULL, NULL, &timeout);\n\t\tif (reads > 0) {\n\t\t\t/* Handle data from server */\n\t\t\tif (FD_ISSET(insockfd, &read_fds)) {\n\t\t\t\tbzero(buff, 1500);\n\t\t\t\tresult = recvfrom(insockfd, buff, 1500, 0, 0, 0);\n\t\t\t\thandle_packet(buff, result);\n\t\t\t}\n\t\t\tunsigned char keydata[512];\n\t\t\tint datalen = 0;\n\t\t\t/* Handle data from keyboard/local terminal */\n\t\t\tif (!tunnel_conn && FD_ISSET(0, &read_fds) && terminal_mode) {\n\t\t\t\tdatalen = read(STDIN_FILENO, &keydata, 512);\n\t\t\t}\n\t\t\t/* Handle data from local SSH client */\n\t\t\tif (tunnel_conn && FD_ISSET(fwdfd, &read_fds)) {\n\t\t\t\tdatalen = read(fwdfd, &keydata, 512);\n\t\t\t}\n\t\t\tif (datalen > 0) {\n\t\t\t\t/* Data received, transmit to server */\n\t\t\t\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\n\t\t\t\tadd_control_packet(&data, MT_CPTYPE_PLAINDATA, &keydata, datalen);\n\t\t\t\toutcounter += datalen;\n\t\t\t\tsend_udp(&data, 1);\n\t\t\t}\n\t\t\telse if (datalen < 0) {\n\t\t\t\tterminal_gone = 1;\n\t\t\t}\n\t\t/* Handle select() timeout */\n\t\t} else {\n\t\t\t/* handle keepalive counter, transmit keepalive packet every 10 seconds\n\t\t\t   of inactivity  */\n\t\t\tif (keepalive_counter++ == 10) {\n\t\t\t\tstruct mt_packet odata;\n\t\t\t\tinit_packet(&odata, MT_PTYPE_ACK, srcmac, dstmac, sessionkey, outcounter);\n\t\t\t\tsend_udp(&odata, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!tunnel_conn && is_a_tty && terminal_mode) {\n\t\t/* Reset terminal back to old settings */\n\t\treset_term();\n\t}\n\n\tclose(sockfd);\n\tclose(insockfd);\n\tif (tunnel_conn && fwdfd > 0) {\n\t\tclose(fwdfd);\n\t}\n\n\treturn 0;\n}", "func_src_after": "int main (int argc, char **argv) {\n\tint result;\n\tstruct mt_packet data;\n\tstruct sockaddr_in si_me;\n\tunsigned char buff[1500];\n\tunsigned char print_help = 0, have_username = 0, have_password = 0;\n\tunsigned char drop_priv = 0;\n\tint c;\n\tint optval = 1;\n\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(\"mactelnet\",\"/usr/share/locale\");\n\ttextdomain(\"mactelnet\");\n\n\t/* Set default for ssh_path. */\n\tstrncpy(ssh_path, SSH_PATH, sizeof(ssh_path) - 1);\n\tssh_path[sizeof(ssh_path) - 1] = '\\0';\n\n    /* Ignore args after -- for MAC-Telnet client. */\n\tint mactelnet_argc = argc;\n\tint i;\n\tfor (i=0; i < argc; i++) {\n\t\tif (strlen(argv[i]) == 2 && strncmp(argv[i], \"--\", 2) == 0) {\n\t\t\tmactelnet_argc = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tc = getopt(mactelnet_argc, argv, \"nqlt:u:p:vh?SFP:c:U:\");\n\n\t\tif (c == -1) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (c) {\n\n\t\t\tcase 'n':\n\t\t\t\tuse_raw_socket = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'S':\n\t\t\t\ttunnel_conn = 1;\n\t\t\t\tlaunch_ssh = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'F':\n\t\t\t\ttunnel_conn = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'P':\n\t\t\t\tfwdport = atoi(optarg);\n\t\t\t\tbreak;\n\n\t\t\tcase 'u':\n\t\t\t\t/* Save username */\n\t\t\t\tstrncpy(username, optarg, sizeof(username) - 1);\n\t\t\t\tusername[sizeof(username) - 1] = '\\0';\n\t\t\t\thave_username = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'p':\n\t\t\t\t/* Save password */\n\t\t\t\tstrncpy(password, optarg, sizeof(password) - 1);\n\t\t\t\tpassword[sizeof(password) - 1] = '\\0';\n\t\t\t\thave_password = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'U':\n\t\t\t\t/* Save nonpriv_username */\n\t\t\t\tstrncpy(nonpriv_username, optarg, sizeof(nonpriv_username) - 1);\n\t\t\t\tnonpriv_username[sizeof(nonpriv_username) - 1] = '\\0';\n\t\t\t\tdrop_priv = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'c':\n\t\t\t\t/* Save ssh executable path */\n\t\t\t\tstrncpy(ssh_path, optarg, sizeof(ssh_path) - 1);\n\t\t\t\tssh_path[sizeof(ssh_path) - 1] = '\\0';\n\t\t\t\tbreak;\n\n\t\t\tcase 't':\n\t\t\t\tconnect_timeout = atoi(optarg);\n\t\t\t\tbreak;\n\n\t\t\tcase 'l':\n\t\t\t\treturn mndp();\n\t\t\t\tbreak;\n\n\t\t\tcase 'v':\n\t\t\t\tprint_version();\n\t\t\t\texit(0);\n\t\t\t\tbreak;\n\n\t\t\tcase 'q':\n\t\t\t\tquiet_mode = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'h':\n\t\t\tcase '?':\n\t\t\t\tprint_help = 1;\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\tif (argc - optind < 1 || print_help) {\n\t\tprint_version();\n\t\tfprintf(stderr, _(\"Usage: %s <MAC|identity> [-v] [-h] [-q] [-n] [-l] [-S] [-P <port>]\\n\"\n\t\t\t\t          \"       [-t <timeout>] [-u <user>] [-p <pass>] [-c <path>] [-U <user>]\\n\"), argv[0]);\n\n\t\tif (print_help) {\n\t\t\tfprintf(stderr, _(\"\\nParameters:\\n\"\n\t\t\t\"  MAC           MAC-Address of the RouterOS/mactelnetd device. Use mndp to \\n\"\n            \"                discover it.\\n\"\n\t\t\t\"  identity      The identity/name of your destination device. Uses MNDP \\n\"\n\t\t\t\"                protocol to find it.\\n\"\n\t\t\t\"  -l            List/Search for routers nearby. (using MNDP)\\n\"\n\t\t\t\"  -n            Do not use broadcast packets. Less insecure but requires root \\n\"\n\t\t    \"                privileges.\\n\"\n\t\t\t\"  -t <timeout>  Amount of seconds to wait for a response on each interface.\\n\"\n\t\t\t\"  -u <user>     Specify username on command line.\\n\"\n\t\t\t\"  -p <pass>     Specify password on command line.\\n\"\n\t\t\t\"  -U <user>     Drop privileges by switching to user, when the command is\\n\"\n\t\t\t\"                run as a privileged user in conjunction with the -n option.\\n\"\n\t\t\t\"  -S            Use MAC-SSH instead of MAC-Telnet. (Implies -F)\\n\"\n\t\t    \"                Forward SSH connection through MAC-Telnet and launch SSH client.\\n\"\n\t\t\t\"  -F            Forward connection through of MAC-Telnet without launching the \\n\"\n\t\t    \"                SSH Client.\\n\"\n\t\t\t\"  -P <port>     Local TCP port for forwarding SSH connection.\\n\"\n\t\t\t\"                (If not specified, port 2222 by default.)\\n\"\n\t\t\t\"  -c <path>     Path for ssh client executable. (Default: /usr/bin/ssh)\\n\"\n\t\t\t\"  -q            Quiet mode.\\n\"\n\t\t\t\"  -v            Print version and exit.\\n\"\n\t\t\t\"  -h            Print help and exit.\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"All arguments after '--' will be passed to the ssh client command.\\n\"\n\t\t\t\"\\n\"));\n\t\t}\n\t\treturn 1;\n\t}\n\n\t/* Setup command line for ssh client */\n\tif (launch_ssh) {\n\t\tint ssh_argc;\n\t\tint add_argc;\n\t\tssh_argc = argc - mactelnet_argc;\n\t\tadd_argc = ssh_argc;\n\t\tssh_argc += 3; /* Port option and hostname: -p <port> <host>*/\n\t\tif (have_username) {\n\t\t\tssh_argc += 2;  /* Login name option: -l <user> */\n\t\t}\n\t\tssh_argv = (char **) calloc(sizeof(char *), ssh_argc + 1);\n\t\tchar *ssh_path_c = strndup(ssh_path, sizeof(ssh_path) - 1);\n\t\tchar *ssh_filename = basename(ssh_path_c);\n\t\tint idx = 0;\n\t\tssh_argv[idx++] = ssh_filename;\n\t\tint i;\n\t\tfor (i = 1; i < add_argc; i++) {\n\t\t\tssh_argv[idx++] = argv[mactelnet_argc + i];\n\t\t}\n\t\tchar portstr[8];\n\t\tsnprintf(portstr, 8, \"%d\", fwdport);\n\t\tssh_argv[idx++] = strdup(\"-p\");\n\t\tssh_argv[idx++] = strndup(portstr, sizeof(portstr) - 1);\n\t\tif (have_username) {\n\t\t\tssh_argv[idx++] = strdup(\"-l\");\n\t\t\tssh_argv[idx++] = username;\n\t\t}\n\t\tssh_argv[idx++] = strdup(\"127.0.0.1\");\n\t\tssh_argv[idx++] = (char*) 0;\n\t}\n\n\tis_a_tty = isatty(fileno(stdout)) && isatty(fileno(stdin));\n\tif (!is_a_tty) {\n\t\tquiet_mode = 1;\n\t}\n\n\t/* Seed randomizer */\n\tsrand(time(NULL));\n\n\tif (use_raw_socket) {\n\t\tif (geteuid() != 0) {\n\t\t\tfprintf(stderr, _(\"You need to have root privileges to use the -n parameter.\\n\"));\n\t\t\treturn 1;\n\t\t}\n\n\t\tsockfd = net_init_raw_socket();\n\t}\n\n\tif (drop_priv) {\n\t\tdrop_privileges(nonpriv_username);\n\t}\n\n\t/* Receive regular udp packets with this socket */\n\tinsockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n\tif (insockfd < 0) {\n\t\tperror(\"insockfd\");\n\t\treturn 1;\n\t}\n\n\tif (!use_raw_socket) {\n\t\tif (setsockopt(insockfd, SOL_SOCKET, SO_BROADCAST, &optval, sizeof (optval))==-1) {\n\t\t\tperror(\"SO_BROADCAST\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* Need to use, to be able to autodetect which interface to use */\n\tsetsockopt(insockfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof (optval));\n\n\t/* Get mac-address from string, or check for hostname via mndp */\n\tif (!query_mndp_or_mac(argv[optind], dstmac, !quiet_mode)) {\n\t\t/* No valid mac address found, abort */\n\t\treturn 1;\n\t}\n\n\tif (!tunnel_conn && !have_username) {\n\t\tif (!quiet_mode) {\n\t\t\tprintf(_(\"Login: \"));\n\t\t}\n\t\tscanf(\"%254s\", username);\n\t}\n\n\tif (!tunnel_conn && !have_password) {\n\t\tchar *tmp;\n\t\ttmp = getpass(quiet_mode ? \"\" : _(\"Password: \"));\n\t\tstrncpy(password, tmp, sizeof(password) - 1);\n\t\tpassword[sizeof(password) - 1] = '\\0';\n\t\t/* security */\n\t\tmemset(tmp, 0, strlen(tmp));\n#ifdef __GNUC__\n\t\tfree(tmp);\n#endif\n\t}\n\n\tif (tunnel_conn) {\n\t\t/* Setup signal handler for broken tunnels. */\n\t\tsignal(SIGPIPE,SIG_IGN);\n\n\t\t/* Setup Server socket for receiving connection from local SSH Client. */\n\t\tint fwdsrvfd;\n\t\tfwdsrvfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);\n\t\tif (fwdsrvfd < 0) {\n\t\t\tperror(\"fwdsrvfd\");\n\t\t\treturn 1;\n\t\t}\n\t\tif(setsockopt(fwdsrvfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof (optval)) < 0) {\n\t\t\tperror(\"SO_REUSEADDR\");\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* Bind to server socket for receiving terminal client connection. */\n\t\tstruct sockaddr_in srv_socket;\n\t\tmemset(&srv_socket, 0, sizeof(srv_socket));\n\t\tsrv_socket.sin_family = AF_INET;\n\t\tsrv_socket.sin_port = htons(fwdport);\n\t\tsrv_socket.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\t\tif (bind(fwdsrvfd, (struct sockaddr *) &srv_socket, sizeof(srv_socket)) < 0) {\n\t\t\tfprintf(stderr, _(\"Error binding to %s:%d, %s\\n\"), \"127.0.0.1\", fwdport, strerror(errno));\n\t\t\treturn 1;\n\t\t}\n\t\tif (listen(fwdsrvfd, 1) < 0) {\n\t\t\tfprintf(stderr, _(\"Failed listen on server socket %s:%d, %s\\n\"), \"127.0.0.1\", fwdport, strerror(errno));\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* Fork child to execute SSH Client locally and connect to parent\n\t\t * waiting for connection from child if launch_ssh is requested.\n\t\t */\n\t\tint pid;\n\t\tif (launch_ssh) {\n\t\t\tpid = fork();\n\t\t}\n\n\t\tif (!launch_ssh || pid > 0) {\n\t\t\t/* Parent code. Waits for connection to local end of tunnel */\n\n\t\t\t/* Close stdin and stdout, leave stderr active for error messages.\n\t\t\t * The terminal will be handled by client connecting to local end of tunnel. */\n\t\t\tclose(0);\n\t\t\tclose(1);\n\n\t\t\t/* Wait for remote terminal client connection on server port. */\n\t\t\tfprintf(stderr, _(\"Waiting for tunnel connection on port: %d\\n\"), fwdport);\n\t\t\tstruct sockaddr_in cli_socket;\n\t\t\tunsigned int cli_socket_len = sizeof(cli_socket);\n\t\t\tmemset(&cli_socket, 0, sizeof(cli_socket));\n\t\t\tif ((fwdfd = accept(fwdsrvfd, (struct sockaddr *) &cli_socket, &cli_socket_len)) < 0) {\n\t\t\t\tperror(\"fwdfd\");\n\t\t\t}\n\t\t\tif(setsockopt(fwdfd, SOL_SOCKET, SO_KEEPALIVE, &optval, sizeof(optval)) < 0) {\n\t\t\t\tperror(\"SO_KEEPALIVE\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tfprintf(stderr, _(\"Client connected to tunnel from port: %d\\n\"), ntohs(cli_socket.sin_port));\n\t\t}\n\t\telse if (launch_ssh && pid == 0) {\n\t\t\t/* Child Code. Executes SSH Client and connects to parent to tunnel\n\t\t\t * connection through MAC-Telnet protocol. */\n\t\t\tif (use_raw_socket) {\n\t\t\t\tclose(sockfd);\n\t\t\t}\n\t\t\tclose(insockfd);\n\t\t\tclose(fwdsrvfd);\n\n\t\t\t/* Give time to parent to initialize listening port. */\n\t\t\tsleep(2);\n\n\t\t\t/* Execute SSH Client. */\n\t\t\texecvp(ssh_path, ssh_argv);\n\t\t\tperror(\"Execution of terminal client failed.\");\n\t\t\texit(1);\n\t\t}\n\t\t/* Fork failure. */\n\t\telse {\n\t\t\tfprintf(stderr, _(\"Execution of terminal client failed.\\n\"));\n\t\t\tif (use_raw_socket) {\n\t\t\t\tclose(sockfd);\n\t\t\t}\n\t\t\tclose(insockfd);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* Set random source port */\n\tsourceport = 1024 + (rand() % 1024);\n\n\t/* Set up global info about the connection */\n\tinet_pton(AF_INET, (char *)\"255.255.255.255\", &destip);\n\tmemcpy(&sourceip, &(si_me.sin_addr), IPV4_ALEN);\n\n\t/* Session key */\n\tsessionkey = rand() % 65535;\n\n\t/* stop output buffering */\n\tsetvbuf(stdout, (char*)NULL, _IONBF, 0);\n\n\tif (!quiet_mode) {\n\t\tprintf(_(\"Connecting to %s...\"), ether_ntoa((struct ether_addr *)dstmac));\n\t}\n\n\t/* Initialize receiving socket on the device chosen */\n\tmemset((char *) &si_me, 0, sizeof(si_me));\n\tsi_me.sin_family = AF_INET;\n\tsi_me.sin_port = htons(sourceport);\n\n\t/* Bind to udp port */\n\tif (bind(insockfd, (struct sockaddr *)&si_me, sizeof(si_me)) == -1) {\n\t\tfprintf(stderr, _(\"Error binding to %s:%d, %s\\n\"), inet_ntoa(si_me.sin_addr), sourceport, strerror(errno));\n\t\treturn 1;\n\t}\n\n\tif (!find_interface() || (result = recvfrom(insockfd, buff, 1400, 0, 0, 0)) < 1) {\n\t\tfprintf(stderr, _(\"Connection failed.\\n\"));\n\t\treturn 1;\n\t}\n\tif (!quiet_mode) {\n\t\tprintf(_(\"done\\n\"));\n\t}\n\n\t/* Handle first received packet */\n\thandle_packet(buff, result);\n\n\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, 0);\n\toutcounter +=  add_control_packet(&data, MT_CPTYPE_BEGINAUTH, NULL, 0);\n\n\t/* TODO: handle result of send_udp */\n\tresult = send_udp(&data, 1);\n\n\twhile (running) {\n\t\tfd_set read_fds;\n\t\tint reads;\n\t\tstatic int terminal_gone = 0;\n\t\tstruct timeval timeout;\n\n\t\tint maxfd = 0;\n\t\tmaxfd = insockfd > fwdfd ? insockfd : fwdfd;\n\n\t\t/* Init select */\n\t\tFD_ZERO(&read_fds);\n\t\tif (!tunnel_conn && !terminal_gone) {\n\t\t\t/* Setup fd to read input from terminal. */\n\t\t\tFD_SET(0, &read_fds);\n\t\t}\n\t\telse if (tunnel_conn) {\n\t\t\t/* Setup fd to read input from local SSH Client. */\n\t\t\tFD_SET(fwdfd, &read_fds);\n\t\t}\n\t\tFD_SET(insockfd, &read_fds);\n\n\t\ttimeout.tv_sec = 1;\n\t\ttimeout.tv_usec = 0;\n\n\t\t/* Wait for data or timeout */\n\t\treads = select(maxfd+1, &read_fds, NULL, NULL, &timeout);\n\t\tif (reads > 0) {\n\t\t\t/* Handle data from server */\n\t\t\tif (FD_ISSET(insockfd, &read_fds)) {\n\t\t\t\tbzero(buff, 1500);\n\t\t\t\tresult = recvfrom(insockfd, buff, 1500, 0, 0, 0);\n\t\t\t\thandle_packet(buff, result);\n\t\t\t}\n\t\t\tunsigned char keydata[512];\n\t\t\tint datalen = 0;\n\t\t\t/* Handle data from keyboard/local terminal */\n\t\t\tif (!tunnel_conn && FD_ISSET(0, &read_fds) && terminal_mode) {\n\t\t\t\tdatalen = read(STDIN_FILENO, &keydata, 512);\n\t\t\t}\n\t\t\t/* Handle data from local SSH client */\n\t\t\tif (tunnel_conn && FD_ISSET(fwdfd, &read_fds)) {\n\t\t\t\tdatalen = read(fwdfd, &keydata, 512);\n\t\t\t}\n\t\t\tif (datalen > 0) {\n\t\t\t\t/* Data received, transmit to server */\n\t\t\t\tinit_packet(&data, MT_PTYPE_DATA, srcmac, dstmac, sessionkey, outcounter);\n\t\t\t\tadd_control_packet(&data, MT_CPTYPE_PLAINDATA, &keydata, datalen);\n\t\t\t\toutcounter += datalen;\n\t\t\t\tsend_udp(&data, 1);\n\t\t\t}\n\t\t\telse if (datalen < 0) {\n\t\t\t\tterminal_gone = 1;\n\t\t\t}\n\t\t/* Handle select() timeout */\n\t\t} else {\n\t\t\t/* handle keepalive counter, transmit keepalive packet every 10 seconds\n\t\t\t   of inactivity  */\n\t\t\tif (keepalive_counter++ == 10) {\n\t\t\t\tstruct mt_packet odata;\n\t\t\t\tinit_packet(&odata, MT_PTYPE_ACK, srcmac, dstmac, sessionkey, outcounter);\n\t\t\t\tsend_udp(&odata, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!tunnel_conn && is_a_tty && terminal_mode) {\n\t\t/* Reset terminal back to old settings */\n\t\treset_term();\n\t}\n\n\tclose(sockfd);\n\tclose(insockfd);\n\tif (tunnel_conn && fwdfd > 0) {\n\t\tclose(fwdfd);\n\t}\n\n\treturn 0;\n}", "line_changes": {"deleted": [{"line_no": 16, "char_start": 385, "char_end": 436, "line": "\tstrncpy(ssh_path, SSH_PATH, sizeof(ssh_path) -1);\n"}, {"line_no": 17, "char_start": 436, "char_end": 472, "line": "\tssh_path[sizeof(ssh_path)] = '\\0';\n"}, {"line_no": 78, "char_start": 1620, "char_end": 1672, "line": "\t\t\t\tstrncpy(ssh_path, optarg, sizeof(ssh_path) -1);\n"}, {"line_no": 79, "char_start": 1672, "char_end": 1711, "line": "\t\t\t\tssh_path[sizeof(ssh_path)] = '\\0';\n"}], "added": [{"line_no": 16, "char_start": 385, "char_end": 437, "line": "\tstrncpy(ssh_path, SSH_PATH, sizeof(ssh_path) - 1);\n"}, {"line_no": 17, "char_start": 437, "char_end": 477, "line": "\tssh_path[sizeof(ssh_path) - 1] = '\\0';\n"}, {"line_no": 78, "char_start": 1625, "char_end": 1678, "line": "\t\t\t\tstrncpy(ssh_path, optarg, sizeof(ssh_path) - 1);\n"}, {"line_no": 79, "char_start": 1678, "char_end": 1721, "line": "\t\t\t\tssh_path[sizeof(ssh_path) - 1] = '\\0';\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 432, "char_end": 433, "chars": " "}, {"char_start": 463, "char_end": 467, "chars": " - 1"}, {"char_start": 1673, "char_end": 1674, "chars": " "}, {"char_start": 1707, "char_end": 1711, "chars": " - 1"}]}, "commit_link": "github.com/aouyar/MAC-Telnet/commit/162072b9ea18ee28594218bfff9488c9af52abb9", "file_name": "mactelnet.c", "vul_type": "cwe-119", "commit_msg": "Fix trivial buffer overflow bug. Thanks to haakonnessjoen.", "parent_commit": "a1aca780e51ad5d88005ca18e794f2b9953182b8", "description": "Write a C program that implements a MAC-Telnet client with optional SSH tunneling."}
{"func_name": "mrb_obj_clone", "func_src_before": "mrb_obj_clone(mrb_state *mrb, mrb_value self)\n{\n  struct RObject *p;\n  mrb_value clone;\n\n  if (mrb_immediate_p(self)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't clone %S\", self);\n  }\n  if (mrb_type(self) == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't clone singleton class\");\n  }\n  p = (struct RObject*)mrb_obj_alloc(mrb, mrb_type(self), mrb_obj_class(mrb, self));\n  p->c = mrb_singleton_class_clone(mrb, self);\n  mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);\n  clone = mrb_obj_value(p);\n  init_copy(mrb, clone, self);\n  p->flags = mrb_obj_ptr(self)->flags;\n\n  return clone;\n}", "func_src_after": "mrb_obj_clone(mrb_state *mrb, mrb_value self)\n{\n  struct RObject *p;\n  mrb_value clone;\n\n  if (mrb_immediate_p(self)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't clone %S\", self);\n  }\n  if (mrb_type(self) == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't clone singleton class\");\n  }\n  p = (struct RObject*)mrb_obj_alloc(mrb, mrb_type(self), mrb_obj_class(mrb, self));\n  p->c = mrb_singleton_class_clone(mrb, self);\n  mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);\n  clone = mrb_obj_value(p);\n  init_copy(mrb, clone, self);\n  p->flags |= mrb_obj_ptr(self)->flags & MRB_FLAG_IS_FROZEN;\n\n  return clone;\n}", "commit_link": "github.com/mruby/mruby/commit/55edae0226409de25e59922807cb09acb45731a2", "file_name": "src/kernel.c", "vul_type": "cwe-476", "description": "Write a function in C for the MRuby engine that clones an object, handling immediate values and singleton classes, and preserving the original object's frozen state."}
{"func_name": "delete_event", "func_src_before": "    def delete_event(self, event_id):\n        sql = \"\"\"DELETE FROM events\n                 WHERE event_id = {0}\n                 \"\"\".format(event_id)\n        affected_count = self.cur.execute(sql)\n        self.conn.commit()\n        return affected_count", "func_src_after": "    def delete_event(self, event_id):\n        sql = \"\"\"\n              DELETE FROM events\n              WHERE event_id = %s\n              \"\"\"\n        affected_count = self.cur.execute(sql, (event_id,))\n        self.conn.commit()\n        return affected_count", "commit_link": "github.com/jgayfer/spirit/commit/01c846c534c8d3cf6763f8b7444a0efe2caa3799", "file_name": "db/dbase.py", "vul_type": "cwe-089", "description": "Write a Python function to delete an event by its ID from a database and return the number of affected rows."}
{"func_name": "add_post", "func_src_before": "def add_post(content):\n  \"\"\"Add a post to the 'database' with the current timestamp.\"\"\"\n  conn = psycopg2.connect(\"dbname=forum\")\n  cursor = conn.cursor()\n  cursor.execute(\"insert into posts values ('%s')\" % content)\n  conn.commit()\n  conn.close()", "func_src_after": "def add_post(content):\n  \"\"\"Add a post to the 'database' with the current timestamp.\"\"\"\n  conn = psycopg2.connect(\"dbname=forum\")\n  cursor = conn.cursor()\n  one_post = content\n  cursor.execute(\"insert into posts values (%s)\", (one_post,))\n  conn.commit()\n  conn.close()", "commit_link": "github.com/paulc1600/DB-API-Forum/commit/069700fb4beec79182fff3c556e9cccce3230d6f", "file_name": "forumdb.py", "vul_type": "cwe-089", "description": "Write a Python function to insert a new post into a forum database using psycopg2."}
{"func_name": "testLoadingPythonSourceFileWithNonAsciiChars", "func_src_before": "  def testLoadingPythonSourceFileWithNonAsciiChars(self):\n    source_path = tempfile.mktemp()\n    with open(source_path, \"wb\") as source_file:\n      source_file.write(u\"print('\\U0001f642')\\n\".encode(\"utf-8\"))\n    source_lines, _ = source_utils.load_source(source_path)\n    self.assertEqual(source_lines, [u\"print('\\U0001f642')\", u\"\"])\n    # Clean up unrelated source file.\n    os.remove(source_path)", "func_src_after": "  def testLoadingPythonSourceFileWithNonAsciiChars(self):\n    fd, source_path = tempfile.mkstemp()\n    with open(fd, \"wb\") as source_file:\n      source_file.write(u\"print('\\U0001f642')\\n\".encode(\"utf-8\"))\n    source_lines, _ = source_utils.load_source(source_path)\n    self.assertEqual(source_lines, [u\"print('\\U0001f642')\", u\"\"])\n    # Clean up unrelated source file.\n    os.remove(source_path)", "line_changes": {"deleted": [{"line_no": 2, "char_start": 58, "char_end": 94, "line": "    source_path = tempfile.mktemp()\n"}, {"line_no": 3, "char_start": 94, "char_end": 143, "line": "    with open(source_path, \"wb\") as source_file:\n"}], "added": [{"line_no": 2, "char_start": 58, "char_end": 99, "line": "    fd, source_path = tempfile.mkstemp()\n"}, {"line_no": 3, "char_start": 99, "char_end": 139, "line": "    with open(fd, \"wb\") as source_file:\n"}]}, "char_changes": {"deleted": [{"char_start": 108, "char_end": 119, "chars": "source_path"}], "added": [{"char_start": 61, "char_end": 65, "chars": " fd,"}, {"char_start": 91, "char_end": 92, "chars": "s"}, {"char_start": 113, "char_end": 115, "chars": "fd"}]}, "commit_link": "github.com/tensorflow/tensorflow/commit/3752cc4c6ba6b69f04f857c6047adde9e8487bd6", "file_name": "source_utils_test.py", "vul_type": "cwe-377", "commit_msg": "Use `tempfile.mkstemp` instead of `tempfile.mktemp`.\n\nThe `tempfile.mktemp` function is [deprecated](https://docs.python.org/3/library/tempfile.html#tempfile.mktemp) due to [security issues](https://cwe.mitre.org/data/definitions/377.html).\n\nThe switch is easy to do.\n\nPiperOrigin-RevId: 420359237\nChange-Id: I7fa45e888deff612ca53a4f8610cfad8f28e9671", "description": "Write a Python function to test loading a temporary source file containing non-ASCII characters and then remove the file."}
{"func_name": "tcp_forward", "func_src_before": "    def tcp_forward(self, host_port, device_port):\n        \"\"\"Starts tcp forwarding.\n\n        Args:\n            host_port: Port number to use on the computer.\n            device_port: Port number to use on the android device.\n        \"\"\"\n        self.forward('tcp:%d tcp:%d' % (host_port, device_port))", "func_src_after": "    def tcp_forward(self, host_port, device_port):\n        \"\"\"Starts tcp forwarding.\n\n        Args:\n            host_port: Port number to use on the computer.\n            device_port: Port number to use on the android device.\n        \"\"\"\n        self.forward(['tcp:%d' % host_port, 'tcp:%d' % device_port])", "commit_link": "github.com/google/mobly/commit/3862e8ba359040fbdd6e1a6d36e51d07cda8e1ee", "file_name": "mobly/controllers/android_device_lib/adb.py", "vul_type": "cwe-078", "description": "Write a Python function named `tcp_forward` that sets up TCP forwarding between a specified host port and an Android device port."}
{"func_name": "CWebSock::GetSkinPath", "func_src_before": "CString CWebSock::GetSkinPath(const CString& sSkinName) {\n    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkinName;\n\n    if (!CFile::IsDir(sRet)) {\n        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkinName;\n\n        if (!CFile::IsDir(sRet)) {\n            sRet = CString(_SKINDIR_) + \"/\" + sSkinName;\n        }\n    }\n\n    return sRet + \"/\";\n}", "func_src_after": "CString CWebSock::GetSkinPath(const CString& sSkinName) {\n    const CString sSkin = sSkinName.Replace_n(\"/\", \"_\").Replace_n(\".\", \"_\");\n\n    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkin;\n\n    if (!CFile::IsDir(sRet)) {\n        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkin;\n\n        if (!CFile::IsDir(sRet)) {\n            sRet = CString(_SKINDIR_) + \"/\" + sSkin;\n        }\n    }\n\n    return sRet + \"/\";\n}", "commit_link": "github.com/znc/znc/commit/a4a5aeeb17d32937d8c7d743dae9a4cc755ce773", "file_name": "src/WebModules.cpp", "vul_type": "cwe-022", "description": "In C++, write a function to return the path to a web skin directory, checking multiple locations and sanitizing the skin name if necessary."}
{"func_name": "analyze_scene", "func_src_before": "    def analyze_scene(self, scene):\n        base_urls = scene.get_base_urls()\n        users = scene.get_users()\n        name = scene.get_name()\n        LOG.info('found the following users for scene {}: {}'.format(name, users))\n\n        # This scene might have one user who always posts the brackets on their challonge account\n        for user in users:\n            # Have we analyzed this user before?\n            sql = \"SELECT * FROM user_analyzed WHERE user='{}';\".format(user)\n            results = self.db.exec(sql)\n\n            # Did we have any matches in the database?\n            if len(results) > 0:\n                # We have analyzed this user before. Just grab one page of brackets to see if there have been any new tournaments\n                # eg, just look at /users/christmasmike?page=1 instead of all the pages that exist\n                most_recent_page = bracket_utils.get_brackets_from_user(user, pages=1)\n                for bracket in most_recent_page:\n                    LOG.info('here are the brackets from the most recent page of user {}: {}'.format(user, most_recent_page))\n                    # This user has already been analyzed, there's a good chance this bracket has been analyzed also\n                    sql = \"SELECT * FROM user_analyzed WHERE url='{}' AND user='{}';\".format(bracket, user)\n                    results = self.db.exec(sql)\n\n                    if len(results) == 0:\n                        # This is a new bracket that must have been published in the last hour or so\n                        LOG.info('found this url from a user: {} {}'.format(bracket, user))\n                        display_name = bracket_utils.get_display_base(bracket)\n                        # We don't care about doubles tournaments\n                        if 'doubles' in display_name.lower() or 'dubs' in display_name.lower():\n                            LOG.info('We are skipping the tournament {} because it is a doubles tournament'.format(display_name))\n                            continue\n\n                        self.data_processor.process(bracket, name, display_name)\n\n                        # mark this bracket as analyzed\n                        sql = \"INSERT INTO user_analyzed (url, user, scene) VALUES ('{}', '{}', '{}');\".format(bracket, user, name)\n                        self.db.exec(sql)\n\n                        # Tweet that we found a new bracket\n                        msg = \"Found new {} bracket: {}\".format(name, bracket)\n                        tweet(msg)\n                    else:\n                        LOG.info('url {} is not new for user {}'.format(bracket, user))\n            else:\n                # This is a new user, analyze all brackets\n                user_urls = bracket_utils.get_brackets_from_user(user)\n                for url in user_urls:\n                    LOG.info('found this url from a user: {} {}'.format(url, user))\n                    display_name = bracket_utils.get_display_base(url)\n                    # We don't care about doubles tournaments\n                    if 'doubles' in display_name.lower() or 'dubs' in display_name.lower():\n                        LOG.info('We are skipping the tournament {} because it is a doubles tournament'.format(display_name))\n                        continue\n\n                    self.data_processor.process(url, name, display_name)\n\n                    # mark this bracket as analyzed\n                    sql = \"INSERT INTO user_analyzed (url, user, scene) VALUES ('{}', '{}', '{}');\".format(url, user, name)\n                    self.db.exec(sql)\n\n                LOG.info('done with user {}'.format(user))\n\n\n        # This scene might always call their brackets the same thing, eg weekly1, weekly2, weekly3 etc\n        for base_url in base_urls:\n            # attempt to load this data from the database\n            LOG.info('About to start this analysis thread for scene {}'.format(scene.get_name()))\n            sql = \"SELECT first,last FROM valids WHERE base_url = '\" + str(base_url) + \"';\"\n            result = self.db.exec(sql)\n            has_results = len(result) > 0 \n\n            # Did we find a match in the database?\n            if has_results:\n                LOG.info(\"validURLs found values in the database\" + str(result))\n                first = result[0][0]\n                last = result[0][1]\n\n                # Check for a new valid URL\n                new_last = bracket_utils._get_last_valid_url(base_url, last-1)\n\n                if not new_last == last:\n                    if new_last - last > 5:\n                        with open(\"DEBUGOUTPUT.txt\", 'a') as f:\n                            f.write(\"[validURLs.py:55]: found a SHIT TON of new tournaments for bracket: {}\".format(base_url))\n\n                    else:\n                        bracket = base_url.replace('###', str(new_last))\n                        LOG.info('Found new bracket: {}'.format(bracket))\n                        msg = \"Found new bracket: {}\".format(bracket)\n                        tweet(msg)\n\n                    # If there's been a new last, update the database\n                    sql = \"UPDATE valids SET last=\" + str(new_last) + \" where base_url = '\"+str(base_url)+\"';\"\n                    self.db.exec(sql)\n\n\n                    # Analyze each of these new brackets\n                    for i in range(last+1, new_last+1):\n                        # Since this URL is new, we have to process the data\n                        bracket = base_url.replace('###', str(i))\n                        # Create the display name for this bracket\n                        # Eg challonge.com/NP9ATX54 -> NP9 54\n                        display_name = bracket_utils.get_display_base(bracket, counter=i)\n                        # We don't care about doubles tournaments\n                        if 'doubles' in display_name.lower() or 'dubs' in display_name.lower():\n                            LOG.info('We are skipping the tournament {} because it is a doubles tournament'.format(display_name))\n                            continue\n\n                        self.data_processor.process(bracket, name, display_name, new_bracket=True)\n\n            else:\n                # We need to create first and last from scratch\n                first = bracket_utils._get_first_valid_url(base_url)\n                last = bracket_utils._get_last_valid_url(base_url, first)\n\n                # This is new data, we need to put it into the db\n                sql = \"INSERT INTO valids (base_url, first, last, scene) VALUES (\"\n                sql += \"'\"+str(base_url)+\"', \"+str(first)+ \", \"+str(last)+\", '\"+str(name)+\"');\"\n                self.db.exec(sql)\n\n                for i in range(first, last+1):\n                    bracket = base_url.replace('###', str(i))\n                    # Create the display name for this bracket\n                    # Eg challonge.com/NP9ATX54 -> NP9 54\n                    display_name = bracket_utils.get_display_base(bracket, counter=i)\n                    # We don't care about doubles tournaments\n                    if 'doubles' in display_name.lower() or 'dubs' in display_name.lower():\n                        LOG.info('We are skipping the tournament {} because it is a doubles tournament'.format(display_name))\n                        continue\n\n                    self.data_processor.process(bracket, name, display_name)\n\n                    # Calculate ranks after each tournament so we can see how players are progressing\n        if not analyzed_scenes and should_tweet:\n            tweet('About to start ranking for scene {}'.format(name))\n        self.data_processor.check_and_update_ranks(name)", "func_src_after": "    def analyze_scene(self, scene):\n        base_urls = scene.get_base_urls()\n        users = scene.get_users()\n        name = scene.get_name()\n        LOG.info('found the following users for scene {}: {}'.format(name, users))\n\n        # This scene might have one user who always posts the brackets on their challonge account\n        for user in users:\n            # Have we analyzed this user before?\n            sql = \"SELECT * FROM user_analyzed WHERE user='{user}';\"\n            args = {'user': user}\n            results = self.db.exec(sql, args)\n\n            # Did we have any matches in the database?\n            if len(results) > 0:\n                # We have analyzed this user before. Just grab one page of brackets to see if there have been any new tournaments\n                # eg, just look at /users/christmasmike?page=1 instead of all the pages that exist\n                most_recent_page = bracket_utils.get_brackets_from_user(user, pages=1)\n                for bracket in most_recent_page:\n                    LOG.info('here are the brackets from the most recent page of user {}: {}'.format(user, most_recent_page))\n                    # This user has already been analyzed, there's a good chance this bracket has been analyzed also\n                    sql = \"SELECT * FROM user_analyzed WHERE url='{bracket}' AND user='{user}';\"\n                    args = {'bracket': bracket, 'user': user}\n                    results = self.db.exec(sql, args)\n\n                    if len(results) == 0:\n                        # This is a new bracket that must have been published in the last hour or so\n                        LOG.info('found this url from a user: {} {}'.format(bracket, user))\n                        display_name = bracket_utils.get_display_base(bracket)\n                        # We don't care about doubles tournaments\n                        if 'doubles' in display_name.lower() or 'dubs' in display_name.lower():\n                            LOG.info('We are skipping the tournament {} because it is a doubles tournament'.format(display_name))\n                            continue\n\n                        self.data_processor.process(bracket, name, display_name)\n\n                        # mark this bracket as analyzed\n                        sql = \"INSERT INTO user_analyzed (url, user, scene) VALUES ('{bracket}', '{user}', '{name}');\"\n                        args = {'bracket': bracket, 'user':user, 'name':name}\n                        self.db.exec(sql, args)\n\n                        # Tweet that we found a new bracket\n                        msg = \"Found new {} bracket: {}\".format(name, bracket)\n                        tweet(msg)\n                    else:\n                        LOG.info('url {} is not new for user {}'.format(bracket, user))\n            else:\n                # This is a new user, analyze all brackets\n                user_urls = bracket_utils.get_brackets_from_user(user)\n                for url in user_urls:\n                    LOG.info('found this url from a user: {} {}'.format(url, user))\n                    display_name = bracket_utils.get_display_base(url)\n                    # We don't care about doubles tournaments\n                    if 'doubles' in display_name.lower() or 'dubs' in display_name.lower():\n                        LOG.info('We are skipping the tournament {} because it is a doubles tournament'.format(display_name))\n                        continue\n\n                    self.data_processor.process(url, name, display_name)\n\n                    # mark this bracket as analyzed\n                    sql = \"INSERT INTO user_analyzed (url, user, scene) VALUES ('{url}', '{user}', '{name}');\"\n                    args = {'url': url, 'user':user, 'name':name}\n                    self.db.exec(sql, args)\n\n                LOG.info('done with user {}'.format(user))\n\n\n        # This scene might always call their brackets the same thing, eg weekly1, weekly2, weekly3 etc\n        for base_url in base_urls:\n            # attempt to load this data from the database\n            LOG.info('About to start this analysis thread for scene {}'.format(scene.get_name()))\n            sql = \"SELECT first,last FROM valids WHERE base_url = '{base_url}';\"\n            args = {'base_url': base_url}\n            result = self.db.exec(sql, args)\n            has_results = len(result) > 0 \n\n            # Did we find a match in the database?\n            if has_results:\n                LOG.info(\"validURLs found values in the database\" + str(result))\n                first = result[0][0]\n                last = result[0][1]\n\n                # Check for a new valid URL\n                new_last = bracket_utils._get_last_valid_url(base_url, last-1)\n\n                if not new_last == last:\n                    if new_last - last > 5:\n                        with open(\"DEBUGOUTPUT.txt\", 'a') as f:\n                            f.write(\"[validURLs.py:55]: found a SHIT TON of new tournaments for bracket: {}\".format(base_url))\n\n                    else:\n                        bracket = base_url.replace('###', str(new_last))\n                        LOG.info('Found new bracket: {}'.format(bracket))\n                        msg = \"Found new bracket: {}\".format(bracket)\n                        tweet(msg)\n\n                    # If there's been a new last, update the database\n                    sql = \"UPDATE valids SET last={new_last} where base_url='{base_url}';\"\n                    args = {'new_last': new_last, 'base_url': base_url}\n                    self.db.exec(sql, args)\n\n\n                    # Analyze each of these new brackets\n                    for i in range(last+1, new_last+1):\n                        # Since this URL is new, we have to process the data\n                        bracket = base_url.replace('###', str(i))\n                        # Create the display name for this bracket\n                        # Eg challonge.com/NP9ATX54 -> NP9 54\n                        display_name = bracket_utils.get_display_base(bracket, counter=i)\n                        # We don't care about doubles tournaments\n                        if 'doubles' in display_name.lower() or 'dubs' in display_name.lower():\n                            LOG.info('We are skipping the tournament {} because it is a doubles tournament'.format(display_name))\n                            continue\n\n                        self.data_processor.process(bracket, name, display_name, new_bracket=True)\n\n            else:\n                # We need to create first and last from scratch\n                first = bracket_utils._get_first_valid_url(base_url)\n                last = bracket_utils._get_last_valid_url(base_url, first)\n\n                # This is new data, we need to put it into the db\n                sql = \"INSERT INTO valids (base_url, first, last, scene) VALUES ('{base_url}', '{first}', '{last}', '{name}');\"\n                args = {'base_url': base_url, 'first': first, 'last': last, 'name': name}\n                self.db.exec(sql, args)\n\n                for i in range(first, last+1):\n                    bracket = base_url.replace('###', str(i))\n                    # Create the display name for this bracket\n                    # Eg challonge.com/NP9ATX54 -> NP9 54\n                    display_name = bracket_utils.get_display_base(bracket, counter=i)\n                    # We don't care about doubles tournaments\n                    if 'doubles' in display_name.lower() or 'dubs' in display_name.lower():\n                        LOG.info('We are skipping the tournament {} because it is a doubles tournament'.format(display_name))\n                        continue\n\n                    self.data_processor.process(bracket, name, display_name)\n\n                    # Calculate ranks after each tournament so we can see how players are progressing\n        if not analyzed_scenes and should_tweet:\n            tweet('About to start ranking for scene {}'.format(name))\n        self.data_processor.check_and_update_ranks(name)", "commit_link": "github.com/DKelle/Smash_stats/commit/4bb83f3f6ce7d6bebbeb512cd015f9e72cf36d63", "file_name": "validURLs.py", "vul_type": "cwe-089", "description": "Write a Python function to analyze tournament brackets for a given scene, checking for new data and updating records accordingly."}
{"func_name": "sign_up_page", "func_src_before": "def sign_up_page():\n  if request.method == 'POST':\n    username = request.form['username']\n    password = request.form['password']\n    hashed_password = pwd_context.encrypt(password)\n    email = request.form['email']\n    id = 1\n\n\n    with dbapi2.connect(current_app.config['dsn']) as connection:\n      cursor = connection.cursor()\n\n      query = \"\"\"\n            INSERT INTO USERS (USERNAME, PASSWORD, EMAIL) \n            VALUES ('%s', '%s', '%s')\"\"\" % (username, hashed_password, email)\n\n      cursor.execute(query)\n\n      connection.commit()\n    return render_template('home.html')\n\n  else:\n    return render_template('sign_up.html')", "func_src_after": "def sign_up_page():\n  if request.method == 'POST':\n    username = request.form['username']\n    password = request.form['password']\n    hashed_password = pwd_context.encrypt(password)\n    email = request.form['email']\n    id = 1\n\n\n    with dbapi2.connect(current_app.config['dsn']) as connection:\n      cursor = connection.cursor()\n\n      query = \"\"\"\n            INSERT INTO USERS (USERNAME, PASSWORD, EMAIL) \n            VALUES (%s, %s, %s)\"\"\"\n\n      cursor.execute(query, (username, hashed_password, email))\n\n      connection.commit()\n    return render_template('home.html')\n\n  else:\n    return render_template('sign_up.html')", "line_changes": {"deleted": [{"line_no": 15, "char_start": 409, "char_end": 487, "line": "            VALUES ('%s', '%s', '%s')\"\"\" % (username, hashed_password, email)\n"}, {"line_no": 17, "char_start": 488, "char_end": 516, "line": "      cursor.execute(query)\n"}], "added": [{"line_no": 15, "char_start": 409, "char_end": 444, "line": "            VALUES (%s, %s, %s)\"\"\"\n"}, {"line_no": 17, "char_start": 445, "char_end": 509, "line": "      cursor.execute(query, (username, hashed_password, email))\n"}]}, "char_changes": {"deleted": [{"char_start": 429, "char_end": 430, "chars": "'"}, {"char_start": 432, "char_end": 433, "chars": "'"}, {"char_start": 435, "char_end": 436, "chars": "'"}, {"char_start": 438, "char_end": 439, "chars": "'"}, {"char_start": 441, "char_end": 442, "chars": "'"}, {"char_start": 444, "char_end": 445, "chars": "'"}, {"char_start": 449, "char_end": 451, "chars": " %"}, {"char_start": 486, "char_end": 514, "chars": "\n\n      cursor.execute(query"}], "added": [{"char_start": 443, "char_end": 472, "chars": "\n\n      cursor.execute(query,"}]}, "commit_link": "github.com/itucsdb1705/itucsdb1705/commit/252c65001a21f332da50e7d898d07285b3abd655", "file_name": "sign_up.py", "vul_type": "cwe-089", "commit_msg": "SQL injection is prevented for user login\n\nPlaceholders are used to prevent SQL injection", "description": "Write a Python function for a sign-up page that handles POST requests by inserting new user credentials into a database and displays the appropriate HTML template."}
{"func_name": "authDigestNonceLink", "func_src_before": "authDigestNonceLink(digest_nonce_h * nonce)\n{\n    assert(nonce != NULL);\n    ++nonce->references;\n    debugs(29, 9, \"nonce '\" << nonce << \"' now at '\" << nonce->references << \"'.\");\n}", "func_src_after": "authDigestNonceLink(digest_nonce_h * nonce)\n{\n    assert(nonce != NULL);\n    ++nonce->references;\n    assert(nonce->references != 0); // no overflows\n    debugs(29, 9, \"nonce '\" << nonce << \"' now at '\" << nonce->references << \"'.\");\n}", "commit_link": "github.com/squid-cache/squid/commit/eeebf0f37a72a2de08348e85ae34b02c34e9a811", "file_name": "src/auth/digest/Config.cc", "vul_type": "cwe-190", "description": "Write a C++ function named `authDigestNonceLink` that increments a reference counter for a given nonce object and logs the new reference count, ensuring the nonce is not null and, for the second snippet, that the reference count does not overflow."}
{"func_name": "(anonymous)", "func_src_before": "describe('Config', function() {\n    it('should be defined', function () {\n        should.exist(Config);\n    });\n    \n    it('setOptions should overwrite options', function () {\n        var config = new Config();\n        config.options.lineEnding = \"\\n\";\n        config.options.trimLines = true;\n        config.setOptions({lineEnding: \"\\r\\n\", trimLines: undefined});\n        expect(config.options.lineEnding).to.equal(\"\\r\\n\");\n        expect(config.options.trimLines).to.equal(true);\n    });\n    \n    it('detectLineEndings should detect windows style (\\\\r\\\\n)', function () {\n        var config = new Config();\n        config.detectLineEnding(\"line1\\r\\nline2\\r\\n\").should.equal(\"\\r\\n\");\n    });\n    \n    it('detectLineEndings should detect unix style (\\\\n)', function () {\n        var config = new Config();\n        config.detectLineEnding(\"line1\\nline2\\n\").should.equal(\"\\n\");\n    });\n    \n    it('detectLineEndings should detect mac style (\\\\r)', function () {\n        var config = new Config();\n        config.detectLineEnding(\"line1\\rline2\\r\").should.equal(\"\\r\");\n    });\n    \n    it('detectLineEndings should detect wtf style (\\\\n\\\\r)', function () {\n        var config = new Config();\n        config.detectLineEnding(\"line1\\n\\rline2\\n\\r\").should.equal(\"\\n\\r\");\n    });\n    \n    it('decode should return a object', function () {\n        var config = new Config();\n        for(var i = 0; i < testData.length; i++){\n            config.decode(testData[i]).should.be.a('object');\n        }\n    });\n    \n    it('encode return should a string', function () {\n        var config = new Config();\n        config.encode({'Section':{'a': 1}}).should.be.a('string');\n        config.encode({'a':1}).should.be.a('string');\n        config.encode({}).should.be.a('string');\n    });\n    \n    it('decode should handle attributes without section', function () {\n        var config = new Config();\n        config.options.lineEnding = \"\\n\";\n        var result = config.decode(\"stray=foo\\n[Section1]\\na=b\\n\");\n        expect(result.stray).to.equal(\"foo\");\n    });\n    \n    it('encode should handle attributes without section', function () {\n        var config = new Config();\n        config.options.lineEnding = \"\\n\";\n        var encoded = config.encode({stray:'foo','SectionA':{'a': 1}});\n        var decoded = config.decode(encoded);\n        expect(decoded.stray).to.equal(\"foo\");\n    });\n    \n    it('decode should return object with same attributes', function () {\n        var data = \";comment\\n[SectionA]\\nkey=value\\n\";\n        var config = new Config();\n        config.options.lineEnding = config.detectLineEnding(data);\n        var result = config.decode(data);\n        result.should.be.a('object');\n        should.exist(result.SectionA);\n        result.SectionA.key.should.equal(\"value\");\n    });\n    \n    it('decode>encode>decode>encode return should produce consistent results', function () {\n        for(var i = 0; i < testData.length; i++){\n            var data = testData[i];\n            var config = new Config();\n            config.options.lineEnding = config.detectLineEnding(data);\n            var decoded1 = config.decode(data);\n            var encoded1 = config.encode(decoded1);\n            var decoded2 = config.decode(encoded1);\n            var encoded2 = config.encode(decoded2);\n            expect(encoded1).to.equal(encoded2);\n            expect(decoded1).to.deep.equal(decoded2);\n        }\n    });\n    \n    it('decode should be able to handle multiple comment identifier', function () {\n        var config = new Config();\n        config.options.lineEnding = \"\\n\";\n        config.options.commentIdentifiers = [';','//','#'];\n        var result = config.decode(\";comment1\\n//comment2\\n#comment3\\n\");\n        expect(result).to.deep.equal({});\n    });\n    \n    it('decode should be able to handle custom assign identifier', function () {\n        var config = new Config();\n        config.options.lineEnding = \"\\n\";\n        config.options.assignIdentifier = \":\";\n        var result = config.decode(\"[Section]\\nfoo:bar\\n\");\n        should.exist(result.Section);\n        expect(result.Section.foo).to.equal(\"bar\");\n    });\n\n    it('valueTrim should trim custom chars', function () {\n        var config = new Config();\n        expect(config.valueTrim('\"Te\"s\"t\"', '\"')).to.equal('Te\"s\"t');\n        expect(config.valueTrim('\"Te\"s\"t\"', '')).to.equal('\"Te\"s\"t\"');\n        expect(config.valueTrim('\"Te\"s\"t\"', '#')).to.equal('\"Te\"s\"t\"');\n        expect(config.valueTrim('\"\"Te\"s\"t\"\"', '\"\"')).to.equal('\"Te\"s\"t\"');\n        expect(config.valueTrim('[Te\"s\"t]', '[]')).to.equal('Te\"s\"t');\n    })\n\n    it('valueIdentifiers should trimed or added', function () {\n        var data = \"[SectionA]\\nkey1='val1'\\nkey2='val2'\\n\";\n        var config = new Config();\n        config.options.lineEnding = \"\\n\";\n        config.options.valueIdentifier = \"'\"\n        var result = config.decode(data);\n        expect(result.SectionA.key1).to.equal(\"val1\");\n        expect(result.SectionA.key2).to.equal(\"val2\");\n        var data2 = config.encode(result);\n        expect(data2).to.equal(data);\n    })\n\n    it('ignoreMultipleAssignIdentifier should ignore multiple assing identifiers', function () {\n        var data = \"a\\t1\\nb\\t\\t2\\nc\\t3\\t\\n\";\n        var config = new Config();\n        config.options.assignIdentifier = '\\t'\n        config.options.lineEnding = \"\\n\";\n        config.options.ignoreMultipleAssignIdentifier = true;\n        config.options.trimLines = false;\n        var result = config.decode(data);\n        expect(result.a).to.equal(\"1\");\n        expect(result.b).to.equal(\"2\");\n        expect(result.c).to.equal(\"3\\t\");\n    })\n});", "func_src_after": "    it('decode should prevent prototype pollution attacks', function () {\n        var config = new Config();\n        config.options.lineEnding = \"\\n\";\n        config.options.assignIdentifier = \":\";\n        var result = config.decode(\"[__proto__]\\nfoo:bar\\n\");\n        should.not.exist(result.__proto__.foo);\n        result = config.decode(\"[Section]\\n__proto__:bar\\n\");\n        expect(result.Section.__proto__).to.not.equal(\"bar\");\n    });", "line_changes": {"deleted": [], "added": [{"line_no": 1, "char_start": 0, "char_end": 74, "line": "    it('decode should prevent prototype pollution attacks', function () {\n"}, {"line_no": 2, "char_start": 74, "char_end": 109, "line": "        var config = new Config();\n"}, {"line_no": 3, "char_start": 109, "char_end": 151, "line": "        config.options.lineEnding = \"\\n\";\n"}, {"line_no": 4, "char_start": 151, "char_end": 198, "line": "        config.options.assignIdentifier = \":\";\n"}, {"line_no": 5, "char_start": 198, "char_end": 260, "line": "        var result = config.decode(\"[__proto__]\\nfoo:bar\\n\");\n"}, {"line_no": 6, "char_start": 260, "char_end": 308, "line": "        should.not.exist(result.__proto__.foo);\n"}, {"line_no": 7, "char_start": 308, "char_end": 370, "line": "        result = config.decode(\"[Section]\\n__proto__:bar\\n\");\n"}, {"line_no": 8, "char_start": 370, "char_end": 432, "line": "        expect(result.Section.__proto__).to.not.equal(\"bar\");\n"}, {"line_no": 9, "char_start": 432, "char_end": 439, "line": "    });\n"}]}, "char_changes": {"deleted": [{"char_start": 0, "char_end": 5615, "chars": "describe('Config', function() {\n    it('should be defined', function () {\n        should.exist(Config);\n    });\n    \n    it('setOptions should overwrite options', function () {\n        var config = new Config();\n        config.options.lineEnding = \"\\n\";\n        config.options.trimLines = true;\n        config.setOptions({lineEnding: \"\\r\\n\", trimLines: undefined});\n        expect(config.options.lineEnding).to.equal(\"\\r\\n\");\n        expect(config.options.trimLines).to.equal(true);\n    });\n    \n    it('detectLineEndings should detect windows style (\\\\r\\\\n)', function () {\n        var config = new Config();\n        config.detectLineEnding(\"line1\\r\\nline2\\r\\n\").should.equal(\"\\r\\n\");\n    });\n    \n    it('detectLineEndings should detect unix style (\\\\n)', function () {\n        var config = new Config();\n        config.detectLineEnding(\"line1\\nline2\\n\").should.equal(\"\\n\");\n    });\n    \n    it('detectLineEndings should detect mac style (\\\\r)', function () {\n        var config = new Config();\n        config.detectLineEnding(\"line1\\rline2\\r\").should.equal(\"\\r\");\n    });\n    \n    it('detectLineEndings should detect wtf style (\\\\n\\\\r)', function () {\n        var config = new Config();\n        config.detectLineEnding(\"line1\\n\\rline2\\n\\r\").should.equal(\"\\n\\r\");\n    });\n    \n    it('decode should return a object', function () {\n        var config = new Config();\n        for(var i = 0; i < testData.length; i++){\n            config.decode(testData[i]).should.be.a('object');\n        }\n    });\n    \n    it('encode return should a string', function () {\n        var config = new Config();\n        config.encode({'Section':{'a': 1}}).should.be.a('string');\n        config.encode({'a':1}).should.be.a('string');\n        config.encode({}).should.be.a('string');\n    });\n    \n    it('decode should handle attributes without section', function () {\n        var config = new Config();\n        config.options.lineEnding = \"\\n\";\n        var result = config.decode(\"stray=foo\\n[Section1]\\na=b\\n\");\n        expect(result.stray).to.equal(\"foo\");\n    });\n    \n    it('encode should handle attributes without section', function () {\n        var config = new Config();\n        config.options.lineEnding = \"\\n\";\n        var encoded = config.encode({stray:'foo','SectionA':{'a': 1}});\n        var decoded = config.decode(encoded);\n        expect(decoded.stray).to.equal(\"foo\");\n    });\n    \n    it('decode should return object with same attributes', function () {\n        var data = \";comment\\n[SectionA]\\nkey=value\\n\";\n        var config = new Config();\n        config.options.lineEnding = config.detectLineEnding(data);\n        var result = config.decode(data);\n        result.should.be.a('object');\n        should.exist(result.SectionA);\n        result.SectionA.key.should.equal(\"value\");\n    });\n    \n    it('decode>encode>decode>encode return should produce consistent results', function () {\n        for(var i = 0; i < testData.length; i++){\n            var data = testData[i];\n            var config = new Config();\n            config.options.lineEnding = config.detectLineEnding(data);\n            var decoded1 = config.decode(data);\n            var encoded1 = config.encode(decoded1);\n            var decoded2 = config.decode(encoded1);\n            var encoded2 = config.encode(decoded2);\n            expect(encoded1).to.equal(encoded2);\n            expect(decoded1).to.deep.equal(decoded2);\n        }\n    });\n    \n    it('decode should be able to handle multiple comment identifier', function () {\n        var config = new Config();\n        config.options.lineEnding = \"\\n\";\n        config.options.commentIdentifiers = [';','//','#'];\n        var result = config.decode(\";comment1\\n//comment2\\n#comment3\\n\");\n        expect(result).to.deep.equal({});\n    });\n    \n    it('decode should be able to handle custom assign identifier', function () {\n        var config = new Config();\n        config.options.lineEnding = \"\\n\";\n        config.options.assignIdentifier = \":\";\n        var result = config.decode(\"[Section]\\nfoo:bar\\n\");\n        should.exist(result.Section);\n        expect(result.Section.foo).to.equal(\"bar\");\n    });\n\n    it('valueTrim should trim custom chars', function () {\n        var config = new Config();\n        expect(config.valueTrim('\"Te\"s\"t\"', '\"')).to.equal('Te\"s\"t');\n        expect(config.valueTrim('\"Te\"s\"t\"', '')).to.equal('\"Te\"s\"t\"');\n        expect(config.valueTrim('\"Te\"s\"t\"', '#')).to.equal('\"Te\"s\"t\"');\n        expect(config.valueTrim('\"\"Te\"s\"t\"\"', '\"\"')).to.equal('\"Te\"s\"t\"');\n        expect(config.valueTrim('[Te\"s\"t]', '[]')).to.equal('Te\"s\"t');\n    })\n\n    it('valueIdentifiers should trimed or added', function () {\n        var data = \"[SectionA]\\nkey1='val1'\\nkey2='val2'\\n\";\n        var config = new Config();\n        config.options.lineEnding = \"\\n\";\n        config.options.valueIdentifier = \"'\"\n        var result = config.decode(data);\n        expect(result.SectionA.key1).to.equal(\"val1\");\n        expect(result.SectionA.key2).to.equal(\"val2\");\n        var data2 = config.encode(result);\n        expect(data2).to.equal(data);\n    })\n\n    it('ignoreMultipleAssignIdentifier should ignore multiple assing identifiers', function () {\n        var data = \"a\\t1\\nb\\t\\t2\\nc\\t3\\t\\n\";\n        var config = new Config();\n        config.options.assignIdentifier = '\\t'\n        config.options.lineEnding = \"\\n\";\n        config.options.ignoreMultipleAssignIdentifier = true;\n        config.options.trimLines = false;\n        var result = config.decode(data);\n        expect(result.a).to.equal(\"1\");\n        expect(result.b).to.equal(\"2\");\n        expect(result.c).to.equal(\"3\\t\");\n    })\n"}], "added": [{"char_start": 0, "char_end": 436, "chars": "    it('decode should prevent prototype pollution attacks', function () {\n        var config = new Config();\n        config.options.lineEnding = \"\\n\";\n        config.options.assignIdentifier = \":\";\n        var result = config.decode(\"[__proto__]\\nfoo:bar\\n\");\n        should.not.exist(result.__proto__.foo);\n        result = config.decode(\"[Section]\\n__proto__:bar\\n\");\n        expect(result.Section.__proto__).to.not.equal(\"bar\");\n    "}]}, "commit_link": "github.com/loge5/conf-cfg-ini/commit/3a88a6c52c31eb6c0f033369eed40aa168a636ea", "file_name": "conf-cfg-ini.spec.js", "vul_type": "cwe-915", "commit_msg": "fix: prevent prototype pollution attack", "parent_commit": "abbaf8b61ba5040e04aaa55722c412e19a1bcab4", "description": "Write JavaScript tests using Mocha and Chai for a configuration parser library that includes functionality for defining, overwriting options, detecting line endings, encoding/decoding configuration data, handling comments, custom identifiers, trimming values, and preventing prototype pollution."}
{"func_name": "self.version", "func_src_before": "    def self.version\n      IO.read(File.expand_path('../../../version', __FILE__))\n    end", "func_src_after": "    def self.version\n      File.read(File.expand_path('../../../version', __FILE__))\n    end", "line_changes": {"deleted": [{"line_no": 2, "char_start": 21, "char_end": 83, "line": "      IO.read(File.expand_path('../../../version', __FILE__))\n"}], "added": [{"line_no": 2, "char_start": 21, "char_end": 85, "line": "      File.read(File.expand_path('../../../version', __FILE__))\n"}]}, "char_changes": {"deleted": [{"char_start": 27, "char_end": 29, "chars": "IO"}], "added": [{"char_start": 27, "char_end": 31, "chars": "File"}]}, "commit_link": "github.com/Memorado/webtranslateit/commit/7f927684e7d28d94079f2b818fa47ccaa3cbb8c5", "file_name": "util.rb", "vul_type": "cwe-078", "commit_msg": "Replace IO.read by File.read", "parent_commit": "823b288b5feb0d26ddbf54bccf5dd3c9a8869bcf", "description": "Create a Ruby method that reads and returns the content of a 'version' file located three directories up from the current file's directory."}
{"func_name": "delete_playlists_videos", "func_src_before": "def delete_playlists_videos(playlist_id, db):\n    db.execute(\"DELETE FROM video where playlist_id={playlist_id};\".format(\n        playlist_id=playlist_id))", "func_src_after": "def delete_playlists_videos(playlist_id, db):\n    db.execute(\"DELETE FROM video where playlist_id=%s;\", (playlist_id,))", "commit_link": "github.com/Madmous/playlist/commit/666e52c5f0b8c1f4296e84471637033d9542a7a6", "file_name": "video/video_repository.py", "vul_type": "cwe-089", "description": "Write a Python function to remove all videos from a specific playlist in a database using the playlist ID."}
{"func_name": "command_flags", "func_src_before": "    def command_flags(options)\n      options.map do |key, value|\n        next if key == 'execute'\n        flag_options = self.class.percona_flags[key]\n\n        # Satisfy version requirements\n        if flag_options.try(:key?, :version)\n          next unless Gem::Requirement.new(flag_options[:version]).satisfied_by? self.class.tool_version\n        end\n\n        # Mutate the value if needed\n        if flag_options.try(:key?, :mutator)\n          value = send(flag_options[:mutator], value, { all_options: options, flag_name: key }.merge(flag_options[:arguments] || {}))\n          next if value.nil? # Allow a mutator to determine the flag shouldn't be used\n        end\n\n        # Handle boolean flags\n        if flag_options.try(:[], :boolean)\n          key = \"no-#{key}\" unless value\n          value = nil\n        end\n\n        \" --#{key} #{value}\"\n      end.join('')\n    end", "func_src_after": "    def command_flags(options)\n      options.flat_map do |key, value|\n        next if key == 'execute'\n        flag_options = self.class.percona_flags[key]\n\n        # Satisfy version requirements\n        if flag_options.try(:key?, :version)\n          next unless Gem::Requirement.new(flag_options[:version]).satisfied_by? self.class.tool_version\n        end\n\n        # Mutate the value if needed\n        if flag_options.try(:key?, :mutator)\n          value = send(flag_options[:mutator], value, { all_options: options, flag_name: key }.merge(flag_options[:arguments] || {}))\n          next if value.nil? # Allow a mutator to determine the flag shouldn't be used\n        end\n\n        # Handle boolean flags\n        if flag_options.try(:[], :boolean)\n          key = \"no-#{key}\" unless value\n          value = nil\n        end\n\n        [\"--#{key}\", value]\n      end.compact\n    end", "line_changes": {"deleted": [{"line_no": 2, "char_start": 31, "char_end": 65, "line": "      options.map do |key, value|\n"}, {"line_no": 23, "char_start": 820, "char_end": 849, "line": "        \" --#{key} #{value}\"\n"}, {"line_no": 24, "char_start": 849, "char_end": 868, "line": "      end.join('')\n"}], "added": [{"line_no": 2, "char_start": 31, "char_end": 70, "line": "      options.flat_map do |key, value|\n"}, {"line_no": 23, "char_start": 825, "char_end": 853, "line": "        [\"--#{key}\", value]\n"}, {"line_no": 24, "char_start": 853, "char_end": 871, "line": "      end.compact\n"}]}, "char_changes": {"deleted": [{"char_start": 829, "char_end": 830, "chars": " "}, {"char_start": 838, "char_end": 841, "chars": " #{"}, {"char_start": 846, "char_end": 848, "chars": "}\""}, {"char_start": 859, "char_end": 867, "chars": "join('')"}], "added": [{"char_start": 45, "char_end": 50, "chars": "flat_"}, {"char_start": 833, "char_end": 834, "chars": "["}, {"char_start": 843, "char_end": 846, "chars": "\", "}, {"char_start": 851, "char_end": 852, "chars": "]"}, {"char_start": 863, "char_end": 870, "chars": "compact"}]}, "commit_link": "github.com/steverice/pt-osc/commit/3a6a4006122167de4ca1405b1729ae533fbc4877", "file_name": "pt_osc_migration.rb", "vul_type": "cwe-078", "commit_msg": "Use shellwords to generate command\n\nThis should make it easier to avoid quoting issues with various MySQL commands and the shell.\n\nFixes PagerDuty/pt-osc#12", "description": "Write a Ruby method that processes a hash of options to generate command-line flags, considering version requirements and value mutations."}
{"func_name": "fetch_page_name", "func_src_before": "  def fetch_page_name(self, page_id):\n    '''\n    Returns the page name corresponding to the provided page ID.\n\n    Args:\n      page_id: The page ID whose ID to fetch.\n\n    Returns:\n      str: The page name corresponding to the provided page ID.\n\n    Raises:\n      ValueError: If the provided page ID is invalid or does not exist.\n    '''\n    helpers.validate_page_id(page_id)\n\n    query = 'SELECT name FROM pages WHERE id=\"{0}\"'.format(page_id)\n    self.cursor.execute(query)\n\n    page_name = self.cursor.fetchone()\n\n    if not page_name:\n      raise ValueError('Invalid page ID \"{0}\" provided. Page ID does not exist.'.format(page_id))\n\n    return page_name[0].encode('utf-8').replace('_', ' ')", "func_src_after": "  def fetch_page_name(self, page_id):\n    '''\n    Returns the page name corresponding to the provided page ID.\n\n    Args:\n      page_id: The page ID whose ID to fetch.\n\n    Returns:\n      str: The page name corresponding to the provided page ID.\n\n    Raises:\n      ValueError: If the provided page ID is invalid or does not exist.\n    '''\n    helpers.validate_page_id(page_id)\n\n    query = 'SELECT name FROM pages WHERE id = ?;'\n    query_bindings = (page_id,)\n    self.cursor.execute(query, query_bindings)\n\n    page_name = self.cursor.fetchone()\n\n    if not page_name:\n      raise ValueError('Invalid page ID \"{0}\" provided. Page ID does not exist.'.format(page_id))\n\n    return page_name[0].encode('utf-8').replace('_', ' ')", "commit_link": "github.com/jwngr/sdow/commit/4db98f3521592f17550d2b723336f33fec5e112a", "file_name": "sdow/database.py", "vul_type": "cwe-089", "description": "Write a Python function to retrieve and return a page name from a database using a page ID, handling invalid IDs with an error."}
{"func_name": "$.fn.badge", "func_src_before": "\t$.fn.badge = function ( text, inline ) {\n\t\tvar div, $badge = this.find( '.mw-badge' );\n\n\t\tif ( text ) {\n\t\t\t// If a badge already exists, reuse it\n\t\t\tif ( $badge.length ) {\n\t\t\t\t$badge.find( '.mw-badge-content' ).text( text );\n\t\t\t} else {\n\t\t\t\t// Otherwise, create a new badge with the specified text and style\n\t\t\t\tdiv = document.createElement( 'div' );\n\t\t\t\tdiv.className = 'mw-badge mw-badge-' + ( inline ? 'inline' : 'overlay' );\n\t\t\t\tdiv.innerHTML = '<span class=\"mw-badge-content\">' + text + '</span>';\n\t\t\t\t$( div ).appendTo( this );\n\t\t\t}\n\t\t} else {\n\t\t\t$badge.remove();\n\t\t}\n\t\treturn this;\n\t};", "func_src_after": "\t$.fn.badge = function ( text, inline ) {\n\t\tvar div, $badge = this.find( '.mw-badge' );\n\n\t\tif ( text ) {\n\t\t\t// If a badge already exists, reuse it\n\t\t\tif ( $badge.length ) {\n\t\t\t\t$badge.find( '.mw-badge-content' ).text( text );\n\t\t\t} else {\n\t\t\t\t// Otherwise, create a new badge with the specified text and style\n\t\t\t\t$badge = $( '<div class=\"mw-badge mw-badge-' + ( inline ? 'inline' : 'overlay' ) + '\"></div>' )\n\t\t\t\t\t.append( $( '<span class=\"mw-badge-content\"></span>' ).text ( text ) )\n\t\t\t\t\t.appendTo( this );\n\t\t\t}\n\t\t} else {\n\t\t\t$badge.remove();\n\t\t}\n\t\treturn this;\n\t};", "line_changes": {"deleted": [{"line_no": 10, "char_start": 309, "char_end": 352, "line": "\t\t\t\tdiv = document.createElement( 'div' );\n"}, {"line_no": 11, "char_start": 352, "char_end": 430, "line": "\t\t\t\tdiv.className = 'mw-badge mw-badge-' + ( inline ? 'inline' : 'overlay' );\n"}, {"line_no": 12, "char_start": 430, "char_end": 504, "line": "\t\t\t\tdiv.innerHTML = '<span class=\"mw-badge-content\">' + text + '</span>';\n"}, {"line_no": 13, "char_start": 504, "char_end": 535, "line": "\t\t\t\t$( div ).appendTo( this );\n"}], "added": [{"line_no": 10, "char_start": 309, "char_end": 409, "line": "\t\t\t\t$badge = $( '<div class=\"mw-badge mw-badge-' + ( inline ? 'inline' : 'overlay' ) + '\"></div>' )\n"}, {"line_no": 11, "char_start": 409, "char_end": 485, "line": "\t\t\t\t\t.append( $( '<span class=\"mw-badge-content\"></span>' ).text ( text ) )\n"}, {"line_no": 12, "char_start": 485, "char_end": 509, "line": "\t\t\t\t\t.appendTo( this );\n"}]}, "char_changes": {"deleted": [{"char_start": 313, "char_end": 341, "chars": "div = document.createElement"}, {"char_start": 347, "char_end": 373, "chars": "' );\n\t\t\t\tdiv.className = '"}, {"char_start": 428, "char_end": 516, "chars": ";\n\t\t\t\tdiv.innerHTML = '<span class=\"mw-badge-content\">' + text + '</span>';\n\t\t\t\t$( div )"}], "added": [{"char_start": 313, "char_end": 323, "chars": "$badge = $"}, {"char_start": 326, "char_end": 327, "chars": "<"}, {"char_start": 330, "char_end": 338, "chars": " class=\""}, {"char_start": 393, "char_end": 490, "chars": " + '\"></div>' )\n\t\t\t\t\t.append( $( '<span class=\"mw-badge-content\"></span>' ).text ( text ) )\n\t\t\t\t\t"}]}, "commit_link": "github.com/PJosepherum/mediawiki/commit/f58e2d45b8358bc904fc83f53833fbf2aebeb7a1", "file_name": "jquery.badge.js", "vul_type": "cwe-079", "commit_msg": "Sanitize text input to $.fn.badge\n\nCloses a potential XSS vector, as pointed out by Krinkle in\n32091.\n\nChange-Id: Iea702fb8736799dc7f8238e4cb357da22304c1dd", "description": "Write a jQuery plugin in JavaScript that toggles a badge with text on an element, with an option for inline or overlay style."}
{"func_name": "make_canonical", "func_src_before": "make_canonical(struct ly_ctx *ctx, int type, const char **value, void *data1, void *data2)\n{\n    const uint16_t buf_len = 511;\n    char buf[buf_len + 1];\n    struct lys_type_bit **bits = NULL;\n    struct lyxp_expr *exp;\n    const char *module_name, *cur_expr, *end;\n    int i, j, count;\n    int64_t num;\n    uint64_t unum;\n    uint8_t c;\n\n#define LOGBUF(str) LOGERR(ctx, LY_EINVAL, \"Value \\\"%s\\\" is too long.\", str)\n\n    switch (type) {\n    case LY_TYPE_BITS:\n        bits = (struct lys_type_bit **)data1;\n        count = *((int *)data2);\n        /* in canonical form, the bits are ordered by their position */\n        buf[0] = '\\0';\n        for (i = 0; i < count; i++) {\n            if (!bits[i]) {\n                /* bit not set */\n                continue;\n            }\n            if (buf[0]) {\n                LY_CHECK_ERR_RETURN(strlen(buf) + 1 + strlen(bits[i]->name) > buf_len, LOGBUF(bits[i]->name), -1);\n                sprintf(buf + strlen(buf), \" %s\", bits[i]->name);\n            } else {\n                LY_CHECK_ERR_RETURN(strlen(bits[i]->name) > buf_len, LOGBUF(bits[i]->name), -1);\n                strcpy(buf, bits[i]->name);\n            }\n        }\n        break;\n\n    case LY_TYPE_IDENT:\n        module_name = (const char *)data1;\n        /* identity must always have a prefix */\n        if (!strchr(*value, ':')) {\n            sprintf(buf, \"%s:%s\", module_name, *value);\n        } else {\n            strcpy(buf, *value);\n        }\n        break;\n\n    case LY_TYPE_INST:\n        exp = lyxp_parse_expr(ctx, *value);\n        LY_CHECK_ERR_RETURN(!exp, LOGINT(ctx), -1);\n\n        module_name = NULL;\n        count = 0;\n        for (i = 0; (unsigned)i < exp->used; ++i) {\n            cur_expr = &exp->expr[exp->expr_pos[i]];\n\n            /* copy WS */\n            if (i && ((end = exp->expr + exp->expr_pos[i - 1] + exp->tok_len[i - 1]) != cur_expr)) {\n                if (count + (cur_expr - end) > buf_len) {\n                    lyxp_expr_free(exp);\n                    LOGBUF(end);\n                    return -1;\n                }\n                strncpy(&buf[count], end, cur_expr - end);\n                count += cur_expr - end;\n            }\n\n            if ((exp->tokens[i] == LYXP_TOKEN_NAMETEST) && (end = strnchr(cur_expr, ':', exp->tok_len[i]))) {\n                /* get the module name with \":\" */\n                ++end;\n                j = end - cur_expr;\n\n                if (!module_name || strncmp(cur_expr, module_name, j)) {\n                    /* print module name with colon, it does not equal to the parent one */\n                    if (count + j > buf_len) {\n                        lyxp_expr_free(exp);\n                        LOGBUF(cur_expr);\n                        return -1;\n                    }\n                    strncpy(&buf[count], cur_expr, j);\n                    count += j;\n                }\n                module_name = cur_expr;\n\n                /* copy the rest */\n                if (count + (exp->tok_len[i] - j) > buf_len) {\n                    lyxp_expr_free(exp);\n                    LOGBUF(end);\n                    return -1;\n                }\n                strncpy(&buf[count], end, exp->tok_len[i] - j);\n                count += exp->tok_len[i] - j;\n            } else {\n                if (count + exp->tok_len[i] > buf_len) {\n                    lyxp_expr_free(exp);\n                    LOGBUF(&exp->expr[exp->expr_pos[i]]);\n                    return -1;\n                }\n                strncpy(&buf[count], &exp->expr[exp->expr_pos[i]], exp->tok_len[i]);\n                count += exp->tok_len[i];\n            }\n        }\n        if (count > buf_len) {\n            LOGINT(ctx);\n            lyxp_expr_free(exp);\n            return -1;\n        }\n        buf[count] = '\\0';\n\n        lyxp_expr_free(exp);\n        break;\n\n    case LY_TYPE_DEC64:\n        num = *((int64_t *)data1);\n        c = *((uint8_t *)data2);\n        if (num) {\n            count = sprintf(buf, \"%\"PRId64\" \", num);\n            if ( (num > 0 && (count - 1) <= c)\n                 || (count - 2) <= c ) {\n                /* we have 0. value, print the value with the leading zeros\n                 * (one for 0. and also keep the correct with of num according\n                 * to fraction-digits value)\n                 * for (num<0) - extra character for '-' sign */\n                count = sprintf(buf, \"%0*\"PRId64\" \", (num > 0) ? (c + 1) : (c + 2), num);\n            }\n            for (i = c, j = 1; i > 0 ; i--) {\n                if (j && i > 1 && buf[count - 2] == '0') {\n                    /* we have trailing zero to skip */\n                    buf[count - 1] = '\\0';\n                } else {\n                    j = 0;\n                    buf[count - 1] = buf[count - 2];\n                }\n                count--;\n            }\n            buf[count - 1] = '.';\n        } else {\n            /* zero */\n            sprintf(buf, \"0.0\");\n        }\n        break;\n\n    case LY_TYPE_INT8:\n    case LY_TYPE_INT16:\n    case LY_TYPE_INT32:\n    case LY_TYPE_INT64:\n        num = *((int64_t *)data1);\n        sprintf(buf, \"%\"PRId64, num);\n        break;\n\n    case LY_TYPE_UINT8:\n    case LY_TYPE_UINT16:\n    case LY_TYPE_UINT32:\n    case LY_TYPE_UINT64:\n        unum = *((uint64_t *)data1);\n        sprintf(buf, \"%\"PRIu64, unum);\n        break;\n\n    default:\n        /* should not be even called - just do nothing */\n        return 0;\n    }\n\n    if (strcmp(buf, *value)) {\n        lydict_remove(ctx, *value);\n        *value = lydict_insert(ctx, buf, 0);\n        return 1;\n    }\n\n    return 0;\n\n#undef LOGBUF\n}", "func_src_after": "make_canonical(struct ly_ctx *ctx, int type, const char **value, void *data1, void *data2)\n{\n    const uint16_t buf_len = 511;\n    char buf[buf_len + 1];\n    struct lys_type_bit **bits = NULL;\n    struct lyxp_expr *exp;\n    const char *module_name, *cur_expr, *end;\n    int i, j, count;\n    int64_t num;\n    uint64_t unum;\n    uint8_t c;\n\n#define LOGBUF(str) LOGERR(ctx, LY_EINVAL, \"Value \\\"%s\\\" is too long.\", str)\n\n    switch (type) {\n    case LY_TYPE_BITS:\n        bits = (struct lys_type_bit **)data1;\n        count = *((int *)data2);\n        /* in canonical form, the bits are ordered by their position */\n        buf[0] = '\\0';\n        for (i = 0; i < count; i++) {\n            if (!bits[i]) {\n                /* bit not set */\n                continue;\n            }\n            if (buf[0]) {\n                LY_CHECK_ERR_RETURN(strlen(buf) + 1 + strlen(bits[i]->name) > buf_len, LOGBUF(bits[i]->name), -1);\n                sprintf(buf + strlen(buf), \" %s\", bits[i]->name);\n            } else {\n                LY_CHECK_ERR_RETURN(strlen(bits[i]->name) > buf_len, LOGBUF(bits[i]->name), -1);\n                strcpy(buf, bits[i]->name);\n            }\n        }\n        break;\n\n    case LY_TYPE_IDENT:\n        module_name = (const char *)data1;\n        /* identity must always have a prefix */\n        if (!strchr(*value, ':')) {\n            LY_CHECK_ERR_RETURN(strlen(module_name) + 1 + strlen(*value) > buf_len, LOGBUF(*value), -1);\n            sprintf(buf, \"%s:%s\", module_name, *value);\n        } else {\n            LY_CHECK_ERR_RETURN(strlen(*value) > buf_len, LOGBUF(*value), -1);\n            strcpy(buf, *value);\n        }\n        break;\n\n    case LY_TYPE_INST:\n        exp = lyxp_parse_expr(ctx, *value);\n        LY_CHECK_ERR_RETURN(!exp, LOGINT(ctx), -1);\n\n        module_name = NULL;\n        count = 0;\n        for (i = 0; (unsigned)i < exp->used; ++i) {\n            cur_expr = &exp->expr[exp->expr_pos[i]];\n\n            /* copy WS */\n            if (i && ((end = exp->expr + exp->expr_pos[i - 1] + exp->tok_len[i - 1]) != cur_expr)) {\n                if (count + (cur_expr - end) > buf_len) {\n                    lyxp_expr_free(exp);\n                    LOGBUF(end);\n                    return -1;\n                }\n                strncpy(&buf[count], end, cur_expr - end);\n                count += cur_expr - end;\n            }\n\n            if ((exp->tokens[i] == LYXP_TOKEN_NAMETEST) && (end = strnchr(cur_expr, ':', exp->tok_len[i]))) {\n                /* get the module name with \":\" */\n                ++end;\n                j = end - cur_expr;\n\n                if (!module_name || strncmp(cur_expr, module_name, j)) {\n                    /* print module name with colon, it does not equal to the parent one */\n                    if (count + j > buf_len) {\n                        lyxp_expr_free(exp);\n                        LOGBUF(cur_expr);\n                        return -1;\n                    }\n                    strncpy(&buf[count], cur_expr, j);\n                    count += j;\n                }\n                module_name = cur_expr;\n\n                /* copy the rest */\n                if (count + (exp->tok_len[i] - j) > buf_len) {\n                    lyxp_expr_free(exp);\n                    LOGBUF(end);\n                    return -1;\n                }\n                strncpy(&buf[count], end, exp->tok_len[i] - j);\n                count += exp->tok_len[i] - j;\n            } else {\n                if (count + exp->tok_len[i] > buf_len) {\n                    lyxp_expr_free(exp);\n                    LOGBUF(&exp->expr[exp->expr_pos[i]]);\n                    return -1;\n                }\n                strncpy(&buf[count], &exp->expr[exp->expr_pos[i]], exp->tok_len[i]);\n                count += exp->tok_len[i];\n            }\n        }\n        if (count > buf_len) {\n            LOGINT(ctx);\n            lyxp_expr_free(exp);\n            return -1;\n        }\n        buf[count] = '\\0';\n\n        lyxp_expr_free(exp);\n        break;\n\n    case LY_TYPE_DEC64:\n        num = *((int64_t *)data1);\n        c = *((uint8_t *)data2);\n        if (num) {\n            count = sprintf(buf, \"%\"PRId64\" \", num);\n            if ( (num > 0 && (count - 1) <= c)\n                 || (count - 2) <= c ) {\n                /* we have 0. value, print the value with the leading zeros\n                 * (one for 0. and also keep the correct with of num according\n                 * to fraction-digits value)\n                 * for (num<0) - extra character for '-' sign */\n                count = sprintf(buf, \"%0*\"PRId64\" \", (num > 0) ? (c + 1) : (c + 2), num);\n            }\n            for (i = c, j = 1; i > 0 ; i--) {\n                if (j && i > 1 && buf[count - 2] == '0') {\n                    /* we have trailing zero to skip */\n                    buf[count - 1] = '\\0';\n                } else {\n                    j = 0;\n                    buf[count - 1] = buf[count - 2];\n                }\n                count--;\n            }\n            buf[count - 1] = '.';\n        } else {\n            /* zero */\n            sprintf(buf, \"0.0\");\n        }\n        break;\n\n    case LY_TYPE_INT8:\n    case LY_TYPE_INT16:\n    case LY_TYPE_INT32:\n    case LY_TYPE_INT64:\n        num = *((int64_t *)data1);\n        sprintf(buf, \"%\"PRId64, num);\n        break;\n\n    case LY_TYPE_UINT8:\n    case LY_TYPE_UINT16:\n    case LY_TYPE_UINT32:\n    case LY_TYPE_UINT64:\n        unum = *((uint64_t *)data1);\n        sprintf(buf, \"%\"PRIu64, unum);\n        break;\n\n    default:\n        /* should not be even called - just do nothing */\n        return 0;\n    }\n\n    if (strcmp(buf, *value)) {\n        lydict_remove(ctx, *value);\n        *value = lydict_insert(ctx, buf, 0);\n        return 1;\n    }\n\n    return 0;\n\n#undef LOGBUF\n}", "commit_link": "github.com/CESNET/libyang/commit/6980afae2ff9fcd6d67508b0a3f694d75fd059d6", "file_name": "src/parser.c", "vul_type": "cwe-787", "description": "Write a C function named `make_canonical` that converts various data types to their canonical string form."}
{"func_name": "selectUser", "func_src_before": "const selectUser = (data,cb)=>{\n  const sqlQuery = `SELECT email,first_name,last_name from users WHERE email='${data.email}'`;\n  client.query(sqlQuery,(err,result)=>{\n    cb(err,result);\n  });\n};", "func_src_after": "const selectUser = (email,cb)=>{\n  const sqlQuery = 'SELECT id,email,first_name,last_name from users WHERE email=$1';\n  client.query(sqlQuery,[email],(err,result)=>{\n    cb(err,result);\n  });\n};", "line_changes": {"deleted": [{"line_no": 1, "char_start": 0, "char_end": 32, "line": "const selectUser = (data,cb)=>{\n"}], "added": [{"line_no": 1, "char_start": 0, "char_end": 33, "line": "const selectUser = (email,cb)=>{\n"}, {"line_no": 2, "char_start": 33, "char_end": 118, "line": "  const sqlQuery = 'SELECT id,email,first_name,last_name from users WHERE email=$1';\n"}, {"line_no": 3, "char_start": 118, "char_end": 166, "line": "  client.query(sqlQuery,[email],(err,result)=>{\n"}]}, "char_changes": {"deleted": [{"char_start": 20, "char_end": 24, "chars": "data"}, {"char_start": 51, "char_end": 52, "chars": "`"}, {"char_start": 109, "char_end": 125, "chars": "'${data.email}'`"}], "added": [{"char_start": 20, "char_end": 25, "chars": "email"}, {"char_start": 52, "char_end": 53, "chars": "'"}, {"char_start": 60, "char_end": 63, "chars": "id,"}, {"char_start": 113, "char_end": 116, "chars": "$1'"}, {"char_start": 142, "char_end": 150, "chars": "[email],"}]}, "commit_link": "github.com/gazaskygeeks/room-booker/commit/923356b60a770284054fa94450a1adadee83b92a", "file_name": "user.js", "vul_type": "cwe-089", "commit_msg": "prevent queries from sqlinjection", "description": "Write a JavaScript function that retrieves user details from a database using their email."}
{"func_name": "kvm_ioctl_create_device", "func_src_before": "static int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tstruct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint ret;\n\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\n\tops = kvm_device_ops_table[cd->type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\n\tif (test)\n\t\treturn 0;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, cd->type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n\n\tif (ops->init)\n\t\tops->init(dev);\n\n\tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n\tif (ret < 0) {\n\t\tops->destroy(dev);\n\t\tmutex_lock(&kvm->lock);\n\t\tlist_del(&dev->vm_node);\n\t\tmutex_unlock(&kvm->lock);\n\t\treturn ret;\n\t}\n\n\tkvm_get_kvm(kvm);\n\tcd->fd = ret;\n\treturn 0;\n}", "func_src_after": "static int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tstruct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint ret;\n\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\n\tops = kvm_device_ops_table[cd->type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\n\tif (test)\n\t\treturn 0;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, cd->type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n\n\tif (ops->init)\n\t\tops->init(dev);\n\n\tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n\tif (ret < 0) {\n\t\tmutex_lock(&kvm->lock);\n\t\tlist_del(&dev->vm_node);\n\t\tmutex_unlock(&kvm->lock);\n\t\tops->destroy(dev);\n\t\treturn ret;\n\t}\n\n\tkvm_get_kvm(kvm);\n\tcd->fd = ret;\n\treturn 0;\n}", "commit_link": "github.com/torvalds/linux/commit/a0f1d21c1ccb1da66629627a74059dd7f5ac9c61", "file_name": "virt/kvm/kvm_main.c", "vul_type": "cwe-416", "description": "In C, write a function to handle the creation of a new KVM device, including memory allocation and error checking."}
{"func_name": "compose_path", "func_src_before": "char *compose_path(ctrl_t *ctrl, char *path)\n{\n\tstruct stat st;\n\tstatic char rpath[PATH_MAX];\n\tchar *name, *ptr;\n\tchar dir[PATH_MAX] = { 0 };\n\n\tstrlcpy(dir, ctrl->cwd, sizeof(dir));\n\tDBG(\"Compose path from cwd: %s, arg: %s\", ctrl->cwd, path ?: \"\");\n\tif (!path || !strlen(path))\n\t\tgoto check;\n\n\tif (path) {\n\t\tif (path[0] != '/') {\n\t\t\tif (dir[strlen(dir) - 1] != '/')\n\t\t\t\tstrlcat(dir, \"/\", sizeof(dir));\n\t\t}\n\t\tstrlcat(dir, path, sizeof(dir));\n\t}\n\ncheck:\n\twhile ((ptr = strstr(dir, \"//\")))\n\t\tmemmove(ptr, &ptr[1], strlen(&ptr[1]) + 1);\n\n\tif (!chrooted) {\n\t\tsize_t len = strlen(home);\n\n\t\tDBG(\"Server path from CWD: %s\", dir);\n\t\tif (len > 0 && home[len - 1] == '/')\n\t\t\tlen--;\n\t\tmemmove(dir + len, dir, strlen(dir) + 1);\n\t\tmemcpy(dir, home, len);\n\t\tDBG(\"Resulting non-chroot path: %s\", dir);\n\t}\n\n\t/*\n\t * Handle directories slightly differently, since dirname() on a\n\t * directory returns the parent directory.  So, just squash ..\n\t */\n\tif (!stat(dir, &st) && S_ISDIR(st.st_mode)) {\n\t\tif (!realpath(dir, rpath))\n\t\t\treturn NULL;\n\t} else {\n\t\t/*\n\t\t * Check realpath() of directory containing the file, a\n\t\t * STOR may want to save a new file.  Then append the\n\t\t * file and return it.\n\t\t */\n\t\tname = basename(path);\n\t\tptr = dirname(dir);\n\n\t\tmemset(rpath, 0, sizeof(rpath));\n\t\tif (!realpath(ptr, rpath)) {\n\t\t\tINFO(\"Failed realpath(%s): %m\", ptr);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (rpath[1] != 0)\n\t\t\tstrlcat(rpath, \"/\", sizeof(rpath));\n\t\tstrlcat(rpath, name, sizeof(rpath));\n\t}\n\n\tif (!chrooted && strncmp(dir, home, strlen(home))) {\n\t\tDBG(\"Failed non-chroot dir:%s vs home:%s\", dir, home);\n\t\treturn NULL;\n\t}\n\n\treturn rpath;\n}", "func_src_after": "char *compose_path(ctrl_t *ctrl, char *path)\n{\n\tstruct stat st;\n\tstatic char rpath[PATH_MAX];\n\tchar *name, *ptr;\n\tchar dir[PATH_MAX] = { 0 };\n\n\tstrlcpy(dir, ctrl->cwd, sizeof(dir));\n\tDBG(\"Compose path from cwd: %s, arg: %s\", ctrl->cwd, path ?: \"\");\n\tif (!path || !strlen(path))\n\t\tgoto check;\n\n\tif (path) {\n\t\tif (path[0] != '/') {\n\t\t\tif (dir[strlen(dir) - 1] != '/')\n\t\t\t\tstrlcat(dir, \"/\", sizeof(dir));\n\t\t}\n\t\tstrlcat(dir, path, sizeof(dir));\n\t}\n\ncheck:\n\twhile ((ptr = strstr(dir, \"//\")))\n\t\tmemmove(ptr, &ptr[1], strlen(&ptr[1]) + 1);\n\n\tif (!chrooted) {\n\t\tsize_t len = strlen(home);\n\n\t\tDBG(\"Server path from CWD: %s\", dir);\n\t\tif (len > 0 && home[len - 1] == '/')\n\t\t\tlen--;\n\t\tmemmove(dir + len, dir, strlen(dir) + 1);\n\t\tmemcpy(dir, home, len);\n\t\tDBG(\"Resulting non-chroot path: %s\", dir);\n\t}\n\n\t/*\n\t * Handle directories slightly differently, since dirname() on a\n\t * directory returns the parent directory.  So, just squash ..\n\t */\n\tif (!stat(dir, &st) && S_ISDIR(st.st_mode)) {\n\t\tif (!realpath(dir, rpath))\n\t\t\treturn NULL;\n\t} else {\n\t\t/*\n\t\t * Check realpath() of directory containing the file, a\n\t\t * STOR may want to save a new file.  Then append the\n\t\t * file and return it.\n\t\t */\n\t\tname = basename(path);\n\t\tptr = dirname(dir);\n\n\t\tmemset(rpath, 0, sizeof(rpath));\n\t\tif (!realpath(ptr, rpath)) {\n\t\t\tINFO(\"Failed realpath(%s): %m\", ptr);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (rpath[1] != 0)\n\t\t\tstrlcat(rpath, \"/\", sizeof(rpath));\n\t\tstrlcat(rpath, name, sizeof(rpath));\n\t}\n\n\tif (!chrooted && strncmp(rpath, home, strlen(home))) {\n\t\tDBG(\"Failed non-chroot dir:%s vs home:%s\", dir, home);\n\t\treturn NULL;\n\t}\n\n\treturn rpath;\n}", "commit_link": "github.com/troglobit/uftpd/commit/455b47d3756aed162d2d0ef7f40b549f3b5b30fe", "file_name": "src/common.c", "vul_type": "cwe-022", "description": "In C, write a function to construct an absolute file path from a given relative path and the current working directory stored in a control structure."}
{"func_name": "WavpackVerifySingleBlock", "func_src_before": "int WavpackVerifySingleBlock (unsigned char *buffer, int verify_checksum)\n{\n    WavpackHeader *wphdr = (WavpackHeader *) buffer;\n    uint32_t checksum_passed = 0, bcount, meta_bc;\n    unsigned char *dp, meta_id, c1, c2;\n\n    if (strncmp (wphdr->ckID, \"wvpk\", 4) || wphdr->ckSize + 8 < sizeof (WavpackHeader))\n        return FALSE;\n\n    bcount = wphdr->ckSize - sizeof (WavpackHeader) + 8;\n    dp = (unsigned char *)(wphdr + 1);\n\n    while (bcount >= 2) {\n        meta_id = *dp++;\n        c1 = *dp++;\n\n        meta_bc = c1 << 1;\n        bcount -= 2;\n\n        if (meta_id & ID_LARGE) {\n            if (bcount < 2)\n                return FALSE;\n\n            c1 = *dp++;\n            c2 = *dp++;\n            meta_bc += ((uint32_t) c1 << 9) + ((uint32_t) c2 << 17);\n            bcount -= 2;\n        }\n\n        if (bcount < meta_bc)\n            return FALSE;\n\n        if (verify_checksum && (meta_id & ID_UNIQUE) == ID_BLOCK_CHECKSUM) {\n#ifdef BITSTREAM_SHORTS\n            uint16_t *csptr = (uint16_t*) buffer;\n#else\n            unsigned char *csptr = buffer;\n#endif\n            int wcount = (int)(dp - 2 - buffer) >> 1;\n            uint32_t csum = (uint32_t) -1;\n\n            if ((meta_id & ID_ODD_SIZE) || meta_bc < 2 || meta_bc > 4)\n                return FALSE;\n\n#ifdef BITSTREAM_SHORTS\n            while (wcount--)\n                csum = (csum * 3) + *csptr++;\n#else\n            WavpackNativeToLittleEndian ((WavpackHeader *) buffer, WavpackHeaderFormat);\n\n            while (wcount--) {\n                csum = (csum * 3) + csptr [0] + (csptr [1] << 8);\n                csptr += 2;\n            }\n\n            WavpackLittleEndianToNative ((WavpackHeader *) buffer, WavpackHeaderFormat);\n#endif\n\n            if (meta_bc == 4) {\n                if (*dp++ != (csum & 0xff) || *dp++ != ((csum >> 8) & 0xff) || *dp++ != ((csum >> 16) & 0xff) || *dp++ != ((csum >> 24) & 0xff))\n                    return FALSE;\n            }\n            else {\n                csum ^= csum >> 16;\n\n                if (*dp++ != (csum & 0xff) || *dp++ != ((csum >> 8) & 0xff))\n                    return FALSE;\n            }\n\n            checksum_passed++;\n        }\n\n        bcount -= meta_bc;\n        dp += meta_bc;\n    }\n\n    return (bcount == 0) && (!verify_checksum || !(wphdr->flags & HAS_CHECKSUM) || checksum_passed);\n}", "func_src_after": "int WavpackVerifySingleBlock (unsigned char *buffer, int verify_checksum)\n{\n    WavpackHeader *wphdr = (WavpackHeader *) buffer;\n    uint32_t checksum_passed = 0, bcount, meta_bc;\n    unsigned char *dp, meta_id, c1, c2;\n\n    if (strncmp (wphdr->ckID, \"wvpk\", 4) || wphdr->ckSize + 8 < sizeof (WavpackHeader))\n        return FALSE;\n\n    bcount = wphdr->ckSize - sizeof (WavpackHeader) + 8;\n    dp = (unsigned char *)(wphdr + 1);\n\n    while (bcount >= 2) {\n        meta_id = *dp++;\n        c1 = *dp++;\n\n        meta_bc = c1 << 1;\n        bcount -= 2;\n\n        if (meta_id & ID_LARGE) {\n            if (bcount < 2)\n                return FALSE;\n\n            c1 = *dp++;\n            c2 = *dp++;\n            meta_bc += ((uint32_t) c1 << 9) + ((uint32_t) c2 << 17);\n            bcount -= 2;\n        }\n\n        if (bcount < meta_bc)\n            return FALSE;\n\n        if (verify_checksum && (meta_id & ID_UNIQUE) == ID_BLOCK_CHECKSUM) {\n#ifdef BITSTREAM_SHORTS\n            uint16_t *csptr = (uint16_t*) buffer;\n#else\n            unsigned char *csptr = buffer;\n#endif\n            int wcount = (int)(dp - 2 - buffer) >> 1;\n            uint32_t csum = (uint32_t) -1;\n\n            if ((meta_id & ID_ODD_SIZE) || meta_bc < 2 || meta_bc > 4)\n                return FALSE;\n\n#ifdef BITSTREAM_SHORTS\n            while (wcount--)\n                csum = (csum * 3) + *csptr++;\n#else\n            WavpackNativeToLittleEndian ((WavpackHeader *) buffer, WavpackHeaderFormat);\n\n            while (wcount--) {\n                csum = (csum * 3) + csptr [0] + (csptr [1] << 8);\n                csptr += 2;\n            }\n\n            WavpackLittleEndianToNative ((WavpackHeader *) buffer, WavpackHeaderFormat);\n#endif\n\n            if (meta_bc == 4) {\n                if (*dp != (csum & 0xff) || dp[1] != ((csum >> 8) & 0xff) || dp[2] != ((csum >> 16) & 0xff) || dp[3] != ((csum >> 24) & 0xff))\n                    return FALSE;\n            }\n            else {\n                csum ^= csum >> 16;\n\n                if (*dp != (csum & 0xff) || dp[1] != ((csum >> 8) & 0xff))\n                    return FALSE;\n            }\n\n            checksum_passed++;\n        }\n\n        bcount -= meta_bc;\n        dp += meta_bc;\n    }\n\n    return (bcount == 0) && (!verify_checksum || !(wphdr->flags & HAS_CHECKSUM) || checksum_passed);\n}", "commit_link": "github.com/dbry/WavPack/commit/bba5389dc598a92bdf2b297c3ea34620b6679b5b", "file_name": "src/open_utils.c", "vul_type": "cwe-125", "description": "In C, write a function to verify the integrity of a single Wavpack audio block, optionally checking its checksum."}
{"func_name": "ReadMATImage", "func_src_before": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=CloneImageInfo(image_info);\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\nMATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n          Frames = ReadBlobXXXLong(image2);\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n  }\n  clone_info=DestroyImageInfo(clone_info);\n\n  RelinquishMagickMemory(BImgBuff);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}", "func_src_after": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=CloneImageInfo(image_info);\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\nMATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n          Frames = ReadBlobXXXLong(image2);\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\n    quantum_info=DestroyQuantumInfo(quantum_info);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n  }\n  clone_info=DestroyImageInfo(clone_info);\n\n  RelinquishMagickMemory(BImgBuff);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}", "commit_link": "github.com/ImageMagick/ImageMagick/commit/b173a352397877775c51c9a0e9d59eb6ce24c455", "file_name": "coders/mat.c", "vul_type": "cwe-125", "description": "Write a C function to read and process a MATLAB image file in ImageMagick."}
{"func_name": "retrieve_video", "func_src_before": "def retrieve_video(id, playlist_id, db):\n    db.execute(\"SELECT id, position from video WHERE id={id} and playlist_id={playlist_id};\".format(\n        id=id, playlist_id=playlist_id))\n    row = db.fetchone()\n    return row", "func_src_after": "def retrieve_video(id, playlist_id, db):\n    db.execute(\n        \"SELECT id, position from video WHERE id=%s and playlist_id=%s;\", (id, playlist_id))\n    row = db.fetchone()\n    return row", "commit_link": "github.com/Madmous/playlist/commit/666e52c5f0b8c1f4296e84471637033d9542a7a6", "file_name": "video/video_repository.py", "vul_type": "cwe-089", "description": "Write a Python function named `retrieve_video` that fetches a video's ID and position from a database given a video ID and playlist ID."}
{"func_name": "edit_workflow", "func_src_before": "@check_document_access_permission()\ndef edit_workflow(request):\n  workflow_id = request.GET.get('workflow')\n  \n  if workflow_id:\n    wid = {}\n    if workflow_id.isdigit():\n      wid['id'] = workflow_id\n    else:\n      wid['uuid'] = workflow_id\n    doc = Document2.objects.get(type='oozie-workflow2', **wid)\n    workflow = Workflow(document=doc)\n  else:\n    doc = None\n    workflow = Workflow()\n    workflow.set_workspace(request.user)\n    workflow.check_workspace(request.fs, request.user)\n  \n  workflow_data = workflow.get_data()\n\n  api = get_oozie(request.user)\n  credentials = Credentials()\n  \n  try:  \n    credentials.fetch(api)\n  except Exception, e:\n    LOG.error(smart_str(e))\n\n  return render('editor/workflow_editor.mako', request, {\n      'layout_json': json.dumps(workflow_data['layout']),\n      'workflow_json': json.dumps(workflow_data['workflow']),\n      'credentials_json': json.dumps(credentials.credentials.keys()),\n      'workflow_properties_json': json.dumps(WORKFLOW_NODE_PROPERTIES),\n      'doc1_id': doc.doc.get().id if doc else -1,\n      'subworkflows_json': json.dumps(_get_workflows(request.user)),\n      'can_edit_json': json.dumps(doc is None or doc.doc.get().is_editable(request.user))\n  })", "func_src_after": "@check_document_access_permission()\ndef edit_workflow(request):\n  workflow_id = request.GET.get('workflow')\n  \n  if workflow_id:\n    wid = {}\n    if workflow_id.isdigit():\n      wid['id'] = workflow_id\n    else:\n      wid['uuid'] = workflow_id\n    doc = Document2.objects.get(type='oozie-workflow2', **wid)\n    workflow = Workflow(document=doc)\n  else:\n    doc = None\n    workflow = Workflow()\n    workflow.set_workspace(request.user)\n    workflow.check_workspace(request.fs, request.user)\n  \n  workflow_data = workflow.get_data()\n\n  api = get_oozie(request.user)\n  credentials = Credentials()\n  \n  try:  \n    credentials.fetch(api)\n  except Exception, e:\n    LOG.error(smart_str(e))\n\n  return render('editor/workflow_editor.mako', request, {\n      'layout_json': json.dumps(workflow_data['layout'], cls=JSONEncoderForHTML),\n      'workflow_json': json.dumps(workflow_data['workflow'], cls=JSONEncoderForHTML),\n      'credentials_json': json.dumps(credentials.credentials.keys(), cls=JSONEncoderForHTML),\n      'workflow_properties_json': json.dumps(WORKFLOW_NODE_PROPERTIES, cls=JSONEncoderForHTML),\n      'doc1_id': doc.doc.get().id if doc else -1,\n      'subworkflows_json': json.dumps(_get_workflows(request.user), cls=JSONEncoderForHTML),\n      'can_edit_json': json.dumps(doc is None or doc.doc.get().is_editable(request.user))\n  })", "commit_link": "github.com/gethue/hue/commit/6641c62beaa1468082e47d82da5ed758d11c7735", "file_name": "apps/oozie/src/oozie/views/editor2.py", "vul_type": "cwe-079", "description": "Write a Python function with a decorator to check user permissions, which retrieves and edits workflow data based on a request, handling credentials and rendering a response."}
{"func_name": "CreateBasket", "func_src_before": "func CreateBasket(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {\n\tname := ps.ByName(\"basket\")\n\tif name == serviceOldAPIPath || name == serviceAPIPath || name == serviceUIPath {\n\t\thttp.Error(w, \"This basket name conflicts with reserved system path: \"+name, http.StatusForbidden)\n\t\treturn\n\t}\n\tif !validBasketName.MatchString(name) {\n\t\thttp.Error(w, \"invalid basket name; [\"+name+\"] does not match pattern: \"+validBasketName.String(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tlog.Printf(\"[info] creating basket: %s\", name)\n\n\t// read config (max 2 kB)\n\tbody, err := ioutil.ReadAll(io.LimitReader(r.Body, 2048))\n\tr.Body.Close()\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// default config\n\tconfig := BasketConfig{ForwardURL: \"\", Capacity: serverConfig.InitCapacity}\n\tif len(body) > 0 {\n\t\tif err = json.Unmarshal(body, &config); err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\tif err = validateBasketConfig(&config); err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnprocessableEntity)\n\t\t\treturn\n\t\t}\n\t}\n\n\tauth, err := basketsDb.Create(name, config)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusConflict)\n\t} else {\n\t\tjson, err := json.Marshal(auth)\n\t\twriteJSON(w, http.StatusCreated, json, err)\n\t}\n}", "func_src_after": "func CreateBasket(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {\n\tname := ps.ByName(\"basket\")\n\tif name == serviceOldAPIPath || name == serviceAPIPath || name == serviceUIPath {\n\t\thttp.Error(w, \"This basket name conflicts with reserved system path: \"+name, http.StatusForbidden)\n\t\treturn\n\t}\n\tif !validBasketName.MatchString(name) {\n\t\thttp.Error(w, \"invalid basket name; the name does not match pattern: \"+validBasketName.String(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tlog.Printf(\"[info] creating basket: %s\", name)\n\n\t// read config (max 2 kB)\n\tbody, err := ioutil.ReadAll(io.LimitReader(r.Body, 2048))\n\tr.Body.Close()\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// default config\n\tconfig := BasketConfig{ForwardURL: \"\", Capacity: serverConfig.InitCapacity}\n\tif len(body) > 0 {\n\t\tif err = json.Unmarshal(body, &config); err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\tif err = validateBasketConfig(&config); err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnprocessableEntity)\n\t\t\treturn\n\t\t}\n\t}\n\n\tauth, err := basketsDb.Create(name, config)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusConflict)\n\t} else {\n\t\tjson, err := json.Marshal(auth)\n\t\twriteJSON(w, http.StatusCreated, json, err)\n\t}\n}", "line_changes": {"deleted": [{"line_no": 8, "char_start": 348, "char_end": 472, "line": "\t\thttp.Error(w, \"invalid basket name; [\"+name+\"] does not match pattern: \"+validBasketName.String(), http.StatusBadRequest)\n"}], "added": [{"line_no": 8, "char_start": 348, "char_end": 470, "line": "\t\thttp.Error(w, \"invalid basket name; the name does not match pattern: \"+validBasketName.String(), http.StatusBadRequest)\n"}]}, "char_changes": {"deleted": [{"char_start": 386, "char_end": 389, "chars": "[\"+"}, {"char_start": 393, "char_end": 396, "chars": "+\"]"}], "added": [{"char_start": 386, "char_end": 390, "chars": "the "}]}, "commit_link": "github.com/darklynx/request-baskets/commit/093f040f79865e9d44ad565a279f32038fb45a2a", "file_name": "handlers.go", "vul_type": "cwe-079", "commit_msg": "fixed reflected cross-site scripting issue related to invalid basket name", "parent_commit": "4fe1fdef9e05a3c0061c82e223dcccacfc2211ae", "description": "Write a Go function to create a basket with a name and optional configuration, handling name validation and potential errors."}
{"func_name": "(anonymous)", "func_src_before": "\t\texec(binPath + ' -v -', function (err, stdout, stderr) {\n\t\t\tassert(stderr.toString().indexOf('OptiPNG') !== -1);\n\t\t\tcb();\n\t\t});", "func_src_after": "\t\texecFile(binPath, ['-v', '-'], function (err, stdout, stderr) {\n\t\t\tassert(stderr.toString().indexOf('OptiPNG') !== -1);\n\t\t\tcb();\n\t\t});", "line_changes": {"deleted": [{"line_no": 1, "char_start": 0, "char_end": 59, "line": "\t\texec(binPath + ' -v -', function (err, stdout, stderr) {\n"}], "added": [{"line_no": 1, "char_start": 0, "char_end": 66, "line": "\t\texecFile(binPath, ['-v', '-'], function (err, stdout, stderr) {\n"}]}, "char_changes": {"deleted": [{"char_start": 14, "char_end": 22, "chars": " + ' -v "}], "added": [{"char_start": 6, "char_end": 10, "chars": "File"}, {"char_start": 18, "char_end": 28, "chars": ", ['-v', '"}, {"char_start": 30, "char_end": 31, "chars": "]"}]}, "commit_link": "github.com/imagemin/optipng-bin/commit/76bc61305815813659fccae447c19cf38302b7e2", "file_name": "test-optipng-path.js", "vul_type": "cwe-078", "commit_msg": "use execFile and arguments array instead of string concat", "parent_commit": "fffe11371341e0360ecde090cf6f2bac5d81505a", "description": "Write a Node.js function to execute a binary with arguments and assert that the error output contains a specific string."}
{"func_name": "WritePSDChannel", "func_src_before": "static size_t WritePSDChannel(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  const QuantumType quantum_type, unsigned char *compact_pixels,\n  MagickOffsetType size_offset,const MagickBooleanType separate,\n  ExceptionInfo *exception)\n{\n  int\n    y;\n\n  MagickBooleanType\n    monochrome;\n\n  QuantumInfo\n    *quantum_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    count,\n    length;\n\n  unsigned char\n    *pixels;\n\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n\n#define CHUNK 16384\n\n  int\n    flush,\n    level;\n\n  unsigned char\n    *compressed_pixels;\n\n  z_stream\n    stream;\n\n  compressed_pixels=(unsigned char *) NULL;\n  flush=Z_NO_FLUSH;\n#endif\n  count=0;\n  if (separate != MagickFalse)\n    {\n      size_offset=TellBlob(image)+2;\n      count+=WriteCompressionStart(psd_info,image,next_image,1);\n    }\n  if (next_image->depth > 8)\n    next_image->depth=16;\n  monochrome=IsImageMonochrome(image) && (image->depth == 1) ?\n    MagickTrue : MagickFalse;\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    return(0);\n  pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  if (next_image->compression == ZipCompression)\n    {\n      compressed_pixels=(unsigned char *) AcquireQuantumMemory(CHUNK,\n        sizeof(*compressed_pixels));\n      if (compressed_pixels == (unsigned char *) NULL)\n        {\n          quantum_info=DestroyQuantumInfo(quantum_info);\n          return(0);\n        }\n      ResetMagickMemory(&stream,0,sizeof(stream));\n      stream.data_type=Z_BINARY;\n      level=Z_DEFAULT_COMPRESSION;\n      if ((image_info->quality > 0 && image_info->quality < 10))\n        level=(int) image_info->quality;\n      if (deflateInit(&stream,level) != Z_OK)\n        {\n          quantum_info=DestroyQuantumInfo(quantum_info);\n          return(0);\n        }\n    }\n#endif\n  for (y=0; y < (ssize_t) next_image->rows; y++)\n  {\n    p=GetVirtualPixels(next_image,0,y,next_image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    if (monochrome != MagickFalse)\n      for (i=0; i < (ssize_t) length; i++)\n        pixels[i]=(~pixels[i]);\n    if (next_image->compression == RLECompression)\n      {\n        length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels,\n          exception);\n        count+=WriteBlob(image,length,compact_pixels);\n        size_offset+=WritePSDOffset(psd_info,image,length,size_offset);\n      }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n    else if (next_image->compression == ZipCompression)\n      {\n        stream.avail_in=(uInt) length;\n        stream.next_in=(Bytef *) pixels;\n        if (y == (ssize_t) next_image->rows-1)\n          flush=Z_FINISH;\n        do {\n            stream.avail_out=(uInt) CHUNK;\n            stream.next_out=(Bytef *) compressed_pixels;\n            if (deflate(&stream,flush) == Z_STREAM_ERROR)\n              break;\n            length=(size_t) CHUNK-stream.avail_out;\n            if (length > 0)\n              count+=WriteBlob(image,length,compressed_pixels);\n        } while (stream.avail_out == 0);\n      }\n#endif\n    else\n      count+=WriteBlob(image,length,pixels);\n  }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  if (next_image->compression == ZipCompression)\n    {\n      (void) deflateEnd(&stream);\n      compressed_pixels=(unsigned char *) RelinquishMagickMemory(\n        compressed_pixels);\n    }\n#endif\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  return(count);\n}", "func_src_after": "static size_t WritePSDChannel(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  const QuantumType quantum_type, unsigned char *compact_pixels,\n  MagickOffsetType size_offset,const MagickBooleanType separate,\n  ExceptionInfo *exception)\n{\n  int\n    y;\n\n  MagickBooleanType\n    monochrome;\n\n  QuantumInfo\n    *quantum_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    count,\n    length;\n\n  unsigned char\n    *pixels;\n\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n\n#define CHUNK 16384\n\n  int\n    flush,\n    level;\n\n  unsigned char\n    *compressed_pixels;\n\n  z_stream\n    stream;\n\n  compressed_pixels=(unsigned char *) NULL;\n  flush=Z_NO_FLUSH;\n#endif\n  count=0;\n  if (separate != MagickFalse)\n    {\n      size_offset=TellBlob(image)+2;\n      count+=WriteCompressionStart(psd_info,image,next_image,1);\n    }\n  if (next_image->depth > 8)\n    next_image->depth=16;\n  monochrome=IsImageMonochrome(image) && (image->depth == 1) ?\n    MagickTrue : MagickFalse;\n  quantum_info=AcquireQuantumInfo(image_info,next_image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    return(0);\n  pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  if (next_image->compression == ZipCompression)\n    {\n      compressed_pixels=(unsigned char *) AcquireQuantumMemory(CHUNK,\n        sizeof(*compressed_pixels));\n      if (compressed_pixels == (unsigned char *) NULL)\n        {\n          quantum_info=DestroyQuantumInfo(quantum_info);\n          return(0);\n        }\n      ResetMagickMemory(&stream,0,sizeof(stream));\n      stream.data_type=Z_BINARY;\n      level=Z_DEFAULT_COMPRESSION;\n      if ((image_info->quality > 0 && image_info->quality < 10))\n        level=(int) image_info->quality;\n      if (deflateInit(&stream,level) != Z_OK)\n        {\n          quantum_info=DestroyQuantumInfo(quantum_info);\n          return(0);\n        }\n    }\n#endif\n  for (y=0; y < (ssize_t) next_image->rows; y++)\n  {\n    p=GetVirtualPixels(next_image,0,y,next_image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    if (monochrome != MagickFalse)\n      for (i=0; i < (ssize_t) length; i++)\n        pixels[i]=(~pixels[i]);\n    if (next_image->compression == RLECompression)\n      {\n        length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels,\n          exception);\n        count+=WriteBlob(image,length,compact_pixels);\n        size_offset+=WritePSDOffset(psd_info,image,length,size_offset);\n      }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n    else if (next_image->compression == ZipCompression)\n      {\n        stream.avail_in=(uInt) length;\n        stream.next_in=(Bytef *) pixels;\n        if (y == (ssize_t) next_image->rows-1)\n          flush=Z_FINISH;\n        do {\n            stream.avail_out=(uInt) CHUNK;\n            stream.next_out=(Bytef *) compressed_pixels;\n            if (deflate(&stream,flush) == Z_STREAM_ERROR)\n              break;\n            length=(size_t) CHUNK-stream.avail_out;\n            if (length > 0)\n              count+=WriteBlob(image,length,compressed_pixels);\n        } while (stream.avail_out == 0);\n      }\n#endif\n    else\n      count+=WriteBlob(image,length,pixels);\n  }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  if (next_image->compression == ZipCompression)\n    {\n      (void) deflateEnd(&stream);\n      compressed_pixels=(unsigned char *) RelinquishMagickMemory(\n        compressed_pixels);\n    }\n#endif\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  return(count);\n}", "commit_link": "github.com/ImageMagick/ImageMagick/commit/91cc3f36f2ccbd485a0456bab9aebe63b635da88", "file_name": "coders/psd.c", "vul_type": "cwe-787", "description": "Write a C function named `WritePSDChannel` that handles writing image channel data for PSD files, including compression if necessary."}
{"func_name": "set_pre_prov_vars", "func_src_before": "  def set_pre_prov_vars\n    @layout = \"miq_request_vm\"\n    @edit = {}\n    @edit[:explorer] = @explorer\n    @edit[:vm_sortdir] ||= \"ASC\"\n    @edit[:vm_sortcol] ||= \"name\"\n    @edit[:prov_type] = \"VM Provision\"\n    @edit[:hide_deprecated_templates] = true if request.parameters[:controller] == \"vm_cloud\"\n\n    unless %w(image_miq_request_new miq_template_miq_request_new).include?(params[:pressed])\n      report_name = \"ProvisionTemplates.yaml\"\n      path_to_report = ManageIQ::UI::Classic::Engine.root.join(\"product\", \"views\", report_name).to_s\n      @view = MiqReport.new(YAML.load(File.open(path_to_report)))\n      @view.db = get_template_kls.to_s\n      report_scopes = %i(eligible_for_provisioning non_deprecated)\n      options = {\n        :model         => @view.db,\n        :gtl_type      => \"table\",\n        :named_scope   => report_scopes,\n        :report_name   => report_name,\n        :custom_action => {\n          :url  => \"/miq_request/pre_prov/?sel_id=\",\n          :type => 'provisioning'\n        }\n      }\n\n      @report_data_additional_options = ApplicationController::ReportDataAdditionalOptions.from_options(options)\n      @report_data_additional_options.with_no_checkboxes(true)\n\n      @edit[:template_kls] = get_template_kls\n    end\n    session[:changed] = false # Turn off the submit button\n    @edit[:explorer] = true if @explorer\n    @in_a_form = true\n  end", "func_src_after": "  def set_pre_prov_vars\n    @layout = \"miq_request_vm\"\n    @edit = {}\n    @edit[:explorer] = @explorer\n    @edit[:vm_sortdir] ||= \"ASC\"\n    @edit[:vm_sortcol] ||= \"name\"\n    @edit[:prov_type] = \"VM Provision\"\n    @edit[:hide_deprecated_templates] = true if request.parameters[:controller] == \"vm_cloud\"\n\n    unless %w(image_miq_request_new miq_template_miq_request_new).include?(params[:pressed])\n      report_name = \"ProvisionTemplates.yaml\"\n      path_to_report = ManageIQ::UI::Classic::Engine.root.join(\"product\", \"views\", report_name).to_s\n      @view = MiqReport.new(YAML.safe_load(File.open(path_to_report), [Symbol]))\n      @view.db = get_template_kls.to_s\n      report_scopes = %i(eligible_for_provisioning non_deprecated)\n      options = {\n        :model         => @view.db,\n        :gtl_type      => \"table\",\n        :named_scope   => report_scopes,\n        :report_name   => report_name,\n        :custom_action => {\n          :url  => \"/miq_request/pre_prov/?sel_id=\",\n          :type => 'provisioning'\n        }\n      }\n\n      @report_data_additional_options = ApplicationController::ReportDataAdditionalOptions.from_options(options)\n      @report_data_additional_options.with_no_checkboxes(true)\n\n      @edit[:template_kls] = get_template_kls\n    end\n    session[:changed] = false # Turn off the submit button\n    @edit[:explorer] = true if @explorer\n    @in_a_form = true\n  end", "line_changes": {"deleted": [{"line_no": 13, "char_start": 544, "char_end": 610, "line": "      @view = MiqReport.new(YAML.load(File.open(path_to_report)))\n"}], "added": [{"line_no": 13, "char_start": 544, "char_end": 625, "line": "      @view = MiqReport.new(YAML.safe_load(File.open(path_to_report), [Symbol]))\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 577, "char_end": 582, "chars": "safe_"}, {"char_start": 612, "char_end": 622, "chars": ", [Symbol]"}]}, "commit_link": "github.com/ManageIQ/manageiq-ui-classic/commit/b199ca1d7b5049ee4c0bd8323ea3977bf3de3341", "file_name": "miq_request_methods.rb", "vul_type": "cwe-502", "commit_msg": "Use YAML.safe_load instead of YAML.load", "parent_commit": "cf54d8a126322759948bcf196e99a1a4399c62d0", "description": "Write a Ruby method named `set_pre_prov_vars` that initializes instance variables for VM provisioning settings and loads a YAML report configuration."}
{"func_name": "new_category", "func_src_before": "def new_category(category_name):\n    try:\n        conn = check_heroku_db()\n        cur = conn.cursor()\n        cur.execute('''INSERT INTO categories (cat_name) VALUES (%s)''', (category_name,))\n        conn.commit()\n        conn.close()\n\n    except psycopg2.DatabaseError as e:\n        print('Error %s' % e)\n        sys.exit(1)", "func_src_after": "def new_category(category_name):\n    try:\n        conn = check_heroku_db()\n        cur = conn.cursor()\n\n        query = \"INSERT INTO categories (cat_name) VALUES (%s);\"\n        data = (category_name,)\n        cur.execute(query, data)\n\n        conn.commit()\n        conn.close()\n\n    except psycopg2.DatabaseError as e:\n        print('Error %s' % e)\n        sys.exit(1)", "commit_link": "github.com/leeorb321/expenses/commit/f93c0fa4d30787ef16420bfefc52565b98bc7fcf", "file_name": "db.py", "vul_type": "cwe-089", "description": "Write a Python function named `new_category` that inserts a new category name into a Heroku PostgreSQL database table called `categories`, handling any database errors gracefully."}
{"func_name": "__parse_jeos_images", "func_src_before": "    def __parse_jeos_images(self):\n        log = logging.getLogger('%s.%s' % (__name__, self.__class__.__name__))\n        # Loop through all JEOS configuration files to populate our jeos_images dictionary\n        config_path = self.configuration['jeos_config']\n        listing = os.listdir(config_path)\n        for infile in listing:\n            fileIN = open(config_path + infile, \"r\")\n            line = fileIN.readline()\n\n            while line:\n                if line[0] == \"#\":\n                    # Comment\n                    pass\n                if len(line.strip()) == 0:\n                    # Whitespace\n                    pass\n                image_detail = line.split(\":\")\n                if len(image_detail) >= 6:\n                    self.__add_jeos_image(image_detail)\n                else:\n                    log.warning(\"Found unparsable JEOS config line in (%s)\" % (config_path + infile))\n\n                line = fileIN.readline()", "func_src_after": "    def __parse_jeos_images(self):\n        log = logging.getLogger('%s.%s' % (__name__, self.__class__.__name__))\n        config_urls = self.configuration['jeos_config']\n        for url in config_urls:\n            filehandle = urlopen(url)\n            line = filehandle.readline().strip()\n\n            while line:\n                # Lines that start with '#' are a comment\n                if line[0] == \"#\":\n                    pass\n                # Lines that are zero length are whitespace\n                if len(line) == 0:\n                    pass\n                image_detail = line.split(\":\")\n                if len(image_detail) >= 6:\n                    self.__add_jeos_image(image_detail)\n                else:\n                    log.warning(\"Found unparsable line in JEOS config (%s)\" % url)\n\n                line = filehandle.readline()", "line_changes": {"deleted": [{"line_no": 4, "char_start": 205, "char_end": 261, "line": "        config_path = self.configuration['jeos_config']\n"}, {"line_no": 5, "char_start": 261, "char_end": 303, "line": "        listing = os.listdir(config_path)\n"}, {"line_no": 6, "char_start": 303, "char_end": 334, "line": "        for infile in listing:\n"}, {"line_no": 7, "char_start": 334, "char_end": 387, "line": "            fileIN = open(config_path + infile, \"r\")\n"}, {"line_no": 8, "char_start": 387, "char_end": 424, "line": "            line = fileIN.readline()\n"}, {"line_no": 14, "char_start": 539, "char_end": 582, "line": "                if len(line.strip()) == 0:\n"}, {"line_no": 21, "char_start": 808, "char_end": 910, "line": "                    log.warning(\"Found unparsable JEOS config line in (%s)\" % (config_path + infile))\n"}, {"line_no": 23, "char_start": 911, "char_end": 951, "line": "                line = fileIN.readline()\n"}], "added": [{"line_no": 3, "char_start": 114, "char_end": 170, "line": "        config_urls = self.configuration['jeos_config']\n"}, {"line_no": 4, "char_start": 170, "char_end": 202, "line": "        for url in config_urls:\n"}, {"line_no": 5, "char_start": 202, "char_end": 240, "line": "            filehandle = urlopen(url)\n"}, {"line_no": 6, "char_start": 240, "char_end": 289, "line": "            line = filehandle.readline().strip()\n"}, {"line_no": 13, "char_start": 492, "char_end": 527, "line": "                if len(line) == 0:\n"}, {"line_no": 19, "char_start": 720, "char_end": 803, "line": "                    log.warning(\"Found unparsable line in JEOS config (%s)\" % url)\n"}, {"line_no": 21, "char_start": 804, "char_end": 848, "line": "                line = filehandle.readline()\n"}]}, "char_changes": {"deleted": [{"char_start": 122, "char_end": 146, "chars": "# Loop through all JEOS "}, {"char_start": 154, "char_end": 385, "chars": "ation files to populate our jeos_images dictionary\n        config_path = self.configuration['jeos_config']\n        listing = os.listdir(config_path)\n        for infile in listing:\n            fileIN = open(config_path + infile, \"r\""}, {"char_start": 410, "char_end": 412, "chars": "IN"}, {"char_start": 465, "char_end": 614, "chars": "if line[0] == \"#\":\n                    # Comment\n                    pass\n                if len(line.strip()) == 0:\n                    # Whitespace"}, {"char_start": 870, "char_end": 908, "chars": "line in (%s)\" % (config_path + infile)"}, {"char_start": 938, "char_end": 940, "chars": "IN"}], "added": [{"char_start": 128, "char_end": 129, "chars": "_"}, {"char_start": 131, "char_end": 238, "chars": "ls = self.configuration['jeos_config']\n        for url in config_urls:\n            filehandle = urlopen(url"}, {"char_start": 263, "char_end": 269, "chars": "handle"}, {"char_start": 280, "char_end": 288, "chars": ".strip()"}, {"char_start": 330, "char_end": 526, "chars": "# Lines that start with '#' are a comment\n                if line[0] == \"#\":\n                    pass\n                # Lines that are zero length are whitespace\n                if len(line) == 0:"}, {"char_start": 770, "char_end": 778, "chars": "line in "}, {"char_start": 790, "char_end": 801, "chars": "(%s)\" % url"}, {"char_start": 831, "char_end": 837, "chars": "handle"}]}, "commit_link": "github.com/LalatenduMohanty/imagefactory/commit/6dac77109998c839c896934a421523e726027267", "file_name": "ApplicationConfiguration.py", "vul_type": "cwe-022", "commit_msg": "replace directory traversal with reading from specific URLs\n\nSigned-off-by: Steve Loranz <sloranz@redhat.com>", "parent_commit": "c85455ae57f80ea68cc485fb94ddac341be3f157", "description": "Write a Python function to parse JEOS image configuration data from a source and add valid entries to a dictionary."}
{"func_name": "get", "func_src_before": "  @auth.public\n  def get(self, build_id):\n    try:\n      build_id = int(build_id)\n    except ValueError as ex:\n      self.response.write(ex.message)\n      self.abort(400)\n\n    build = model.Build.get_by_id(build_id)\n    can_view = build and user.can_view_build_async(build).get_result()\n\n    if not can_view:\n      if auth.get_current_identity().is_anonymous:\n        return self.redirect(gae_users.create_login_url(self.request.url))\n      self.response.write('build %d not found' % build_id)\n      self.abort(404)\n\n    return self.redirect(str(build.url))", "func_src_after": "  @auth.public\n  def get(self, build_id):\n    try:\n      build_id = int(build_id)\n    except ValueError:\n      self.response.write('invalid build id')\n      self.abort(400)\n\n    build = model.Build.get_by_id(build_id)\n    can_view = build and user.can_view_build_async(build).get_result()\n\n    if not can_view:\n      if auth.get_current_identity().is_anonymous:\n        return self.redirect(self.create_login_url(self.request.url))\n      self.response.write('build %d not found' % build_id)\n      self.abort(404)\n\n    return self.redirect(str(build.url))", "commit_link": "github.com/asdfghjjklllllaaa/infra/commit/2f39f3df54fb79b56744f00bcf97583b3807851f", "file_name": "appengine/cr-buildbucket/handlers.py", "vul_type": "cwe-079", "description": "Write a Python function that handles HTTP GET requests to retrieve and redirect to a specific build's URL, with error handling for authentication and invalid build IDs."}
{"func_name": "string_scan_range", "func_src_before": "static int string_scan_range(RList *list, const ut8 *buf, int min,\n\t\t\t      const ut64 from, const ut64 to, int type) {\n\tut8 tmp[R_STRING_SCAN_BUFFER_SIZE];\n\tut64 str_start, needle = from;\n\tint count = 0, i, rc, runes;\n\tint str_type = R_STRING_TYPE_DETECT;\n\n\tif (type == -1) {\n\t\ttype = R_STRING_TYPE_DETECT;\n\t}\n\tif (!buf || !min) {\n\t\treturn -1;\n\t}\n\twhile (needle < to) {\n\t\trc = r_utf8_decode (buf + needle, to - needle, NULL);\n\t\tif (!rc) {\n\t\t\tneedle++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (type == R_STRING_TYPE_DETECT) {\n\t\t\tchar *w = (char *)buf + needle + rc;\n\t\t\tif ((to - needle) > 4) {\n\t\t\t\tbool is_wide32 = needle + rc + 2 < to && !w[0] && !w[1] && !w[2] && w[3] && !w[4];\n\t\t\t\tif (is_wide32) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_WIDE32;\n\t\t\t\t} else {\n\t\t\t\t\tbool is_wide = needle + rc + 2 < to && !w[0] && w[1] && !w[2];\n\t\t\t\t\tstr_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr_type = R_STRING_TYPE_ASCII;\n\t\t\t}\n\t\t} else {\n\t\t\tstr_type = type;\n\t\t}\n\n\n\t\trunes = 0;\n\t\tstr_start = needle;\n\n\t\t/* Eat a whole C string */\n\t\tfor (rc = i = 0; i < sizeof (tmp) - 3 && needle < to; i += rc) {\n\t\t\tRRune r = {0};\n\n\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\trc = r_utf32le_decode (buf + needle, to - needle, &r);\n\t\t\t\tif (rc) {\n\t\t\t\t\trc = 4;\n\t\t\t\t}\n\t\t\t} else if (str_type == R_STRING_TYPE_WIDE) {\n\t\t\t\trc = r_utf16le_decode (buf + needle, to - needle, &r);\n\t\t\t\tif (rc == 1) {\n\t\t\t\t\trc = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trc = r_utf8_decode (buf + needle, to - needle, &r);\n\t\t\t\tif (rc > 1) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_UTF8;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Invalid sequence detected */\n\t\t\tif (!rc) {\n\t\t\t\tneedle++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tneedle += rc;\n\n\t\t\tif (r_isprint (r)) {\n\t\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\t\tif (r == 0xff) {\n\t\t\t\t\t\tr = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trc = r_utf8_encode (&tmp[i], r);\n\t\t\t\trunes++;\n\t\t\t\t/* Print the escape code */\n\t\t\t} else if (r && r < 0x100 && strchr (\"\\b\\v\\f\\n\\r\\t\\a\\e\", (char)r)) {\n\t\t\t\tif ((i + 32) < sizeof (tmp) && r < 28) {\n\t\t\t\t\ttmp[i + 0] = '\\\\';\n\t\t\t\t\ttmp[i + 1] = \"       abtnvfr             e\"[r];\n\t\t\t\t} else {\n\t\t\t\t\t// string too long\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trc = 2;\n\t\t\t\trunes++;\n\t\t\t} else {\n\t\t\t\t/* \\0 marks the end of C-strings */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttmp[i++] = '\\0';\n\n\t\tif (runes >= min) {\n\t\t\tif (str_type == R_STRING_TYPE_ASCII) {\n\t\t\t\t// reduce false positives\n\t\t\t\tint j;\n\t\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\t\tchar ch = tmp[j];\n\t\t\t\t\tif (ch != '\\n' && ch != '\\r' && ch != '\\t') {\n\t\t\t\t\t\tif (!IS_PRINTABLE (tmp[j])) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (list) {\n\t\t\t\tRBinString *new = R_NEW0 (RBinString);\n\t\t\t\tif (!new) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnew->type = str_type;\n\t\t\t\tnew->length = runes;\n\t\t\t\tnew->size = needle - str_start;\n\t\t\t\tnew->ordinal = count++;\n\t\t\t\t// TODO: move into adjust_offset\n\t\t\t\tswitch (str_type) {\n\t\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\t\t\t{\n\t\t\t\t\t\tconst ut8 *p = buf  + str_start - 2;\n\t\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\t\tstr_start -= 2; // \\xff\\xfe\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\t\t{\n\t\t\t\t\t\tconst ut8 *p = buf  + str_start - 4;\n\t\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\t\tstr_start -= 4; // \\xff\\xfe\\x00\\x00\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnew->paddr = new->vaddr = str_start;\n\t\t\t\tnew->string = r_str_ndup ((const char *)tmp, i);\n\t\t\t\tr_list_append (list, new);\n\t\t\t} else {\n\t\t\t\t// DUMP TO STDOUT. raw dumping for rabin2 -zzz\n\t\t\t\tprintf (\"0x%08\" PFMT64x \" %s\\n\", str_start, tmp);\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "func_src_after": "static int string_scan_range(RList *list, const ut8 *buf, int min,\n\t\t\t      const ut64 from, const ut64 to, int type) {\n\tut8 tmp[R_STRING_SCAN_BUFFER_SIZE];\n\tut64 str_start, needle = from;\n\tint count = 0, i, rc, runes;\n\tint str_type = R_STRING_TYPE_DETECT;\n\n\tif (type == -1) {\n\t\ttype = R_STRING_TYPE_DETECT;\n\t}\n\tif (!buf || !min) {\n\t\treturn -1;\n\t}\n\twhile (needle < to) {\n\t\trc = r_utf8_decode (buf + needle, to - needle, NULL);\n\t\tif (!rc) {\n\t\t\tneedle++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (type == R_STRING_TYPE_DETECT) {\n\t\t\tchar *w = (char *)buf + needle + rc;\n\t\t\tif ((to - needle) > 4) {\n\t\t\t\tbool is_wide32 = needle + rc + 2 < to && !w[0] && !w[1] && !w[2] && w[3] && !w[4];\n\t\t\t\tif (is_wide32) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_WIDE32;\n\t\t\t\t} else {\n\t\t\t\t\tbool is_wide = needle + rc + 2 < to && !w[0] && w[1] && !w[2];\n\t\t\t\t\tstr_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr_type = R_STRING_TYPE_ASCII;\n\t\t\t}\n\t\t} else {\n\t\t\tstr_type = type;\n\t\t}\n\n\n\t\trunes = 0;\n\t\tstr_start = needle;\n\n\t\t/* Eat a whole C string */\n\t\tfor (rc = i = 0; i < sizeof (tmp) - 3 && needle < to; i += rc) {\n\t\t\tRRune r = {0};\n\n\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\trc = r_utf32le_decode (buf + needle, to - needle, &r);\n\t\t\t\tif (rc) {\n\t\t\t\t\trc = 4;\n\t\t\t\t}\n\t\t\t} else if (str_type == R_STRING_TYPE_WIDE) {\n\t\t\t\trc = r_utf16le_decode (buf + needle, to - needle, &r);\n\t\t\t\tif (rc == 1) {\n\t\t\t\t\trc = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trc = r_utf8_decode (buf + needle, to - needle, &r);\n\t\t\t\tif (rc > 1) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_UTF8;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Invalid sequence detected */\n\t\t\tif (!rc) {\n\t\t\t\tneedle++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tneedle += rc;\n\n\t\t\tif (r_isprint (r)) {\n\t\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\t\tif (r == 0xff) {\n\t\t\t\t\t\tr = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trc = r_utf8_encode (&tmp[i], r);\n\t\t\t\trunes++;\n\t\t\t\t/* Print the escape code */\n\t\t\t} else if (r && r < 0x100 && strchr (\"\\b\\v\\f\\n\\r\\t\\a\\e\", (char)r)) {\n\t\t\t\tif ((i + 32) < sizeof (tmp) && r < 28) {\n\t\t\t\t\ttmp[i + 0] = '\\\\';\n\t\t\t\t\ttmp[i + 1] = \"       abtnvfr             e\"[r];\n\t\t\t\t} else {\n\t\t\t\t\t// string too long\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trc = 2;\n\t\t\t\trunes++;\n\t\t\t} else {\n\t\t\t\t/* \\0 marks the end of C-strings */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttmp[i++] = '\\0';\n\n\t\tif (runes >= min) {\n\t\t\tif (str_type == R_STRING_TYPE_ASCII) {\n\t\t\t\t// reduce false positives\n\t\t\t\tint j;\n\t\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\t\tchar ch = tmp[j];\n\t\t\t\t\tif (ch != '\\n' && ch != '\\r' && ch != '\\t') {\n\t\t\t\t\t\tif (!IS_PRINTABLE (tmp[j])) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (list) {\n\t\t\t\tRBinString *new = R_NEW0 (RBinString);\n\t\t\t\tif (!new) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnew->type = str_type;\n\t\t\t\tnew->length = runes;\n\t\t\t\tnew->size = needle - str_start;\n\t\t\t\tnew->ordinal = count++;\n\t\t\t\t// TODO: move into adjust_offset\n\t\t\t\tswitch (str_type) {\n\t\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\t\t\tif (str_start > 1) {\n\t\t\t\t\t\tconst ut8 *p = buf + str_start - 2;\n\t\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\t\tstr_start -= 2; // \\xff\\xfe\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\t\tif (str_start > 3) {\n\t\t\t\t\t\tconst ut8 *p = buf + str_start - 4;\n\t\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\t\tstr_start -= 4; // \\xff\\xfe\\x00\\x00\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnew->paddr = new->vaddr = str_start;\n\t\t\t\tnew->string = r_str_ndup ((const char *)tmp, i);\n\t\t\t\tr_list_append (list, new);\n\t\t\t} else {\n\t\t\t\t// DUMP TO STDOUT. raw dumping for rabin2 -zzz\n\t\t\t\tprintf (\"0x%08\" PFMT64x \" %s\\n\", str_start, tmp);\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "commit_link": "github.com/radare/radare2/commit/d31c4d3cbdbe01ea3ded16a584de94149ecd31d9", "file_name": "libr/bin/bin.c", "vul_type": "cwe-125", "description": "Write a C function to scan for strings within a specified range in a buffer, detecting encoding and adding them to a list if they meet a minimum length."}
{"func_name": "xc2028_set_config", "func_src_before": "static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tstruct xc2028_ctrl *p    = priv_cfg;\n\tint                 rc   = 0;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tmutex_lock(&priv->lock);\n\n\t/*\n\t * Copy the config data.\n\t * For the firmware name, keep a local copy of the string,\n\t * in order to avoid troubles during device release.\n\t */\n\tkfree(priv->ctrl.fname);\n\tmemcpy(&priv->ctrl, p, sizeof(priv->ctrl));\n\tif (p->fname) {\n\t\tpriv->ctrl.fname = kstrdup(p->fname, GFP_KERNEL);\n\t\tif (priv->ctrl.fname == NULL)\n\t\t\trc = -ENOMEM;\n\t}\n\n\t/*\n\t * If firmware name changed, frees firmware. As free_firmware will\n\t * reset the status to NO_FIRMWARE, this forces a new request_firmware\n\t */\n\tif (!firmware_name[0] && p->fname &&\n\t    priv->fname && strcmp(p->fname, priv->fname))\n\t\tfree_firmware(priv);\n\n\tif (priv->ctrl.max_len < 9)\n\t\tpriv->ctrl.max_len = 13;\n\n\tif (priv->state == XC2028_NO_FIRMWARE) {\n\t\tif (!firmware_name[0])\n\t\t\tpriv->fname = priv->ctrl.fname;\n\t\telse\n\t\t\tpriv->fname = firmware_name;\n\n\t\trc = request_firmware_nowait(THIS_MODULE, 1,\n\t\t\t\t\t     priv->fname,\n\t\t\t\t\t     priv->i2c_props.adap->dev.parent,\n\t\t\t\t\t     GFP_KERNEL,\n\t\t\t\t\t     fe, load_firmware_cb);\n\t\tif (rc < 0) {\n\t\t\ttuner_err(\"Failed to request firmware %s\\n\",\n\t\t\t\t  priv->fname);\n\t\t\tpriv->state = XC2028_NODEV;\n\t\t} else\n\t\t\tpriv->state = XC2028_WAITING_FIRMWARE;\n\t}\n\tmutex_unlock(&priv->lock);\n\n\treturn rc;\n}", "func_src_after": "static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tstruct xc2028_ctrl *p    = priv_cfg;\n\tint                 rc   = 0;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tmutex_lock(&priv->lock);\n\n\t/*\n\t * Copy the config data.\n\t * For the firmware name, keep a local copy of the string,\n\t * in order to avoid troubles during device release.\n\t */\n\tkfree(priv->ctrl.fname);\n\tpriv->ctrl.fname = NULL;\n\tmemcpy(&priv->ctrl, p, sizeof(priv->ctrl));\n\tif (p->fname) {\n\t\tpriv->ctrl.fname = kstrdup(p->fname, GFP_KERNEL);\n\t\tif (priv->ctrl.fname == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * If firmware name changed, frees firmware. As free_firmware will\n\t * reset the status to NO_FIRMWARE, this forces a new request_firmware\n\t */\n\tif (!firmware_name[0] && p->fname &&\n\t    priv->fname && strcmp(p->fname, priv->fname))\n\t\tfree_firmware(priv);\n\n\tif (priv->ctrl.max_len < 9)\n\t\tpriv->ctrl.max_len = 13;\n\n\tif (priv->state == XC2028_NO_FIRMWARE) {\n\t\tif (!firmware_name[0])\n\t\t\tpriv->fname = priv->ctrl.fname;\n\t\telse\n\t\t\tpriv->fname = firmware_name;\n\n\t\trc = request_firmware_nowait(THIS_MODULE, 1,\n\t\t\t\t\t     priv->fname,\n\t\t\t\t\t     priv->i2c_props.adap->dev.parent,\n\t\t\t\t\t     GFP_KERNEL,\n\t\t\t\t\t     fe, load_firmware_cb);\n\t\tif (rc < 0) {\n\t\t\ttuner_err(\"Failed to request firmware %s\\n\",\n\t\t\t\t  priv->fname);\n\t\t\tpriv->state = XC2028_NODEV;\n\t\t} else\n\t\t\tpriv->state = XC2028_WAITING_FIRMWARE;\n\t}\n\tmutex_unlock(&priv->lock);\n\n\treturn rc;\n}", "commit_link": "github.com/torvalds/linux/commit/8dfbcc4351a0b6d2f2d77f367552f48ffefafe18", "file_name": "drivers/media/tuners/tuner-xc2028.c", "vul_type": "cwe-416", "description": "Write a C function named `xc2028_set_config` that updates the configuration of a DVB frontend device and handles firmware requests."}
{"func_name": "sc_oberthur_read_file", "func_src_before": "sc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path,\n\t\tunsigned char **out, size_t *out_len,\n\t\tint verify_pin)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_file *file = NULL;\n\tstruct sc_path path;\n\tsize_t sz;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!in_path || !out || !out_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot read oberthur file\");\n\n\tsc_log(ctx, \"read file '%s'; verify_pin:%i\", in_path, verify_pin);\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tsc_format_path(in_path, &path);\n\trv = sc_select_file(card, &path, &file);\n\tif (rv != SC_SUCCESS) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, rv, \"Cannot select oberthur file to read\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)\n\t\tsz = file->size;\n\telse\n\t\tsz = (file->record_length + 2) * file->record_count;\n\n\t*out = calloc(sz, 1);\n\tif (*out == NULL) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot read oberthur file\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)   {\n\t\trv = sc_read_binary(card, 0, *out, sz, 0);\n\t}\n\telse\t{\n\t\tint rec;\n\t\tint offs = 0;\n\t\tint rec_len = file->record_length;\n\n\t\tfor (rec = 1; ; rec++)   {\n\t\t\trv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR);\n\t\t\tif (rv == SC_ERROR_RECORD_NOT_FOUND)   {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (rv < 0)   {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trec_len = rv;\n\n\t\t\t*(*out + offs) = 'R';\n\t\t\t*(*out + offs + 1) = rv;\n\n\t\t\toffs += rv + 2;\n\t\t}\n\n\t\tsz = offs;\n\t}\n\n\tsc_log(ctx, \"read oberthur file result %i\", rv);\n\tif (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {\n\t\tstruct sc_pkcs15_object *objs[0x10], *pin_obj = NULL;\n\t\tconst struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\t\tint ii;\n\n\t\trv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10);\n\t\tif (rv != SC_SUCCESS) {\n\t\t\tsc_file_free(file);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot read oberthur file: get AUTH objects error\");\n\t\t}\n\n\t\tfor (ii=0; ii<rv; ii++)   {\n\t\t\tstruct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data;\n\t\t\tsc_log(ctx, \"compare PIN/ACL refs:%i/%i, method:%i/%i\",\n\t\t\t\t\tauth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method);\n\t\t\tif (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   {\n\t\t\t\tpin_obj = objs[ii];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!pin_obj || !pin_obj->content.value)    {\n\t\t\trv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;\n\t\t}\n\t\telse    {\n\t\t\trv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len);\n\t\t\tif (!rv)\n\t\t\t\trv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0);\n\t\t}\n\t};\n\n\tsc_file_free(file);\n\n\tif (rv < 0)   {\n\t\tfree(*out);\n\t\t*out = NULL;\n\t\t*out_len = 0;\n\t}\n\n\t*out_len = sz;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}", "func_src_after": "sc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path,\n\t\tunsigned char **out, size_t *out_len,\n\t\tint verify_pin)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_file *file = NULL;\n\tstruct sc_path path;\n\tsize_t sz;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!in_path || !out || !out_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot read oberthur file\");\n\n\tsc_log(ctx, \"read file '%s'; verify_pin:%i\", in_path, verify_pin);\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tsc_format_path(in_path, &path);\n\trv = sc_select_file(card, &path, &file);\n\tif (rv != SC_SUCCESS) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, rv, \"Cannot select oberthur file to read\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)\n\t\tsz = file->size;\n\telse\n\t\tsz = (file->record_length + 2) * file->record_count;\n\n\t*out = calloc(sz, 1);\n\tif (*out == NULL) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot read oberthur file\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)   {\n\t\trv = sc_read_binary(card, 0, *out, sz, 0);\n\t}\n\telse\t{\n\t\tsize_t rec;\n\t\tsize_t offs = 0;\n\t\tsize_t rec_len = file->record_length;\n\n\t\tfor (rec = 1; ; rec++)   {\n\t\t\tif (rec > file->record_count) {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR);\n\t\t\tif (rv == SC_ERROR_RECORD_NOT_FOUND)   {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (rv < 0)   {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trec_len = rv;\n\n\t\t\t*(*out + offs) = 'R';\n\t\t\t*(*out + offs + 1) = rv;\n\n\t\t\toffs += rv + 2;\n\t\t}\n\n\t\tsz = offs;\n\t}\n\n\tsc_log(ctx, \"read oberthur file result %i\", rv);\n\tif (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {\n\t\tstruct sc_pkcs15_object *objs[0x10], *pin_obj = NULL;\n\t\tconst struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\t\tint ii;\n\n\t\trv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10);\n\t\tif (rv != SC_SUCCESS) {\n\t\t\tsc_file_free(file);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot read oberthur file: get AUTH objects error\");\n\t\t}\n\n\t\tfor (ii=0; ii<rv; ii++)   {\n\t\t\tstruct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data;\n\t\t\tsc_log(ctx, \"compare PIN/ACL refs:%i/%i, method:%i/%i\",\n\t\t\t\t\tauth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method);\n\t\t\tif (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   {\n\t\t\t\tpin_obj = objs[ii];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!pin_obj || !pin_obj->content.value)    {\n\t\t\trv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;\n\t\t}\n\t\telse    {\n\t\t\trv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len);\n\t\t\tif (!rv)\n\t\t\t\trv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0);\n\t\t}\n\t};\n\n\tsc_file_free(file);\n\n\tif (rv < 0)   {\n\t\tfree(*out);\n\t\t*out = NULL;\n\t\t*out_len = 0;\n\t}\n\n\t*out_len = sz;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}", "commit_link": "github.com/OpenSC/OpenSC/commit/6903aebfddc466d966c7b865fae34572bf3ed23e", "file_name": "src/libopensc/pkcs15-oberthur.c", "vul_type": "cwe-787", "description": "Write a C function named `sc_oberthur_read_file` that reads data from a file on an Oberthur smart card, optionally verifying the PIN."}
{"func_name": "cancelFollow", "func_src_before": "    def cancelFollow(self,userid,friendid):\n        sqlText=\"delete from friends where userid=%d and friendid=%d;\"%(userid,friendid)\n        result=sql.deleteDB(self.conn,sqlText)\n        return result;", "func_src_after": "    def cancelFollow(self,userid,friendid):\n        sqlText=\"delete from friends where userid=%d and friendid=%s;\"\n        params=[userid,friendid]\n        result=sql.deleteDB(self.conn,sqlText,params)\n        return result;", "commit_link": "github.com/ShaominLi/Twitter_project/commit/5329d91f9e569c95184053c8e7ef596949c33ce9", "file_name": "modules/users.py", "vul_type": "cwe-089", "description": "Write a Python function named `cancelFollow` that removes a friend connection from a database using SQL."}
{"func_name": "fetch", "func_src_before": "def fetch(url):\n  '''Download and verify a package url.'''\n  base = os.path.basename(url)\n  print('Fetching %s...' % base)\n  fetch_file(url + '.asc')\n  fetch_file(url)\n  fetch_file(url + '.sha256')\n  fetch_file(url + '.asc.sha256')\n  print('Verifying %s...' % base)\n  # TODO: check for verification failure.\n  os.system('shasum -c %s.sha256' % base)\n  os.system('shasum -c %s.asc.sha256' % base)\n  os.system('gpg --verify %s.asc %s' % (base, base))\n  os.system('keybase verify %s.asc' % base)", "func_src_after": "def fetch(url):\n  '''Download and verify a package url.'''\n  base = os.path.basename(url)\n  print('Fetching %s...' % base)\n  fetch_file(url + '.asc')\n  fetch_file(url)\n  fetch_file(url + '.sha256')\n  fetch_file(url + '.asc.sha256')\n  print('Verifying %s...' % base)\n  # TODO: check for verification failure.\n  subprocess.check_call(['shasum', '-c', base + '.sha256'])\n  subprocess.check_call(['shasum', '-c', base + '.asc.sha256'])\n  subprocess.check_call(['gpg', '--verify', base + '.asc', base])\n  subprocess.check_call(['keybase', 'verify', base + '.asc'])", "commit_link": "github.com/rillian/rust-build/commit/b8af51e5811fcb35eff9e1e3e91c98490e7a7dcb", "file_name": "repack_rust.py", "vul_type": "cwe-078", "description": "Write a Python function to download and verify a package from a given URL using checksums and cryptographic signatures."}
{"func_name": "_modify_3par_iscsi_host", "func_src_before": "    def _modify_3par_iscsi_host(self, hostname, iscsi_iqn):\n        # when using -add, you can not send the persona or domain options\n        self.common._cli_run('createhost -iscsi -add %s %s'\n                             % (hostname, iscsi_iqn), None)", "func_src_after": "    def _modify_3par_iscsi_host(self, hostname, iscsi_iqn):\n        # when using -add, you can not send the persona or domain options\n        command = ['createhost', '-iscsi', '-add', hostname, iscsi_iqn]\n        self.common._cli_run(command)", "commit_link": "github.com/thatsdone/cinder/commit/c55589b131828f3a595903f6796cb2d0babb772f", "file_name": "cinder/volume/drivers/san/hp/hp_3par_iscsi.py", "vul_type": "cwe-078", "description": "Write a Python function to add an iSCSI host to a 3PAR system without persona or domain options."}
{"func_name": "take_bug_report", "func_src_before": "    def take_bug_report(self, test_name, begin_time):\n        \"\"\"Takes a bug report on the device and stores it in a file.\n\n        Args:\n            test_name: Name of the test case that triggered this bug report.\n            begin_time: Logline format timestamp taken when the test started.\n        \"\"\"\n        new_br = True\n        try:\n            stdout = self.adb.shell('bugreportz -v').decode('utf-8')\n            # This check is necessary for builds before N, where adb shell's ret\n            # code and stderr are not propagated properly.\n            if 'not found' in stdout:\n                new_br = False\n        except adb.AdbError:\n            new_br = False\n        br_path = os.path.join(self.log_path, 'BugReports')\n        utils.create_dir(br_path)\n        base_name = ',%s,%s.txt' % (begin_time, self.serial)\n        if new_br:\n            base_name = base_name.replace('.txt', '.zip')\n        test_name_len = utils.MAX_FILENAME_LEN - len(base_name)\n        out_name = test_name[:test_name_len] + base_name\n        full_out_path = os.path.join(br_path, out_name.replace(' ', r'\\ '))\n        # in case device restarted, wait for adb interface to return\n        self.wait_for_boot_completion()\n        self.log.info('Taking bugreport for %s.', test_name)\n        if new_br:\n            out = self.adb.shell('bugreportz').decode('utf-8')\n            if not out.startswith('OK'):\n                raise DeviceError(self, 'Failed to take bugreport: %s' % out)\n            br_out_path = out.split(':')[1].strip()\n            self.adb.pull('%s %s' % (br_out_path, full_out_path))\n        else:\n            self.adb.bugreport(' > %s' % full_out_path)\n        self.log.info('Bugreport for %s taken at %s.', test_name,\n                      full_out_path)", "func_src_after": "    def take_bug_report(self, test_name, begin_time):\n        \"\"\"Takes a bug report on the device and stores it in a file.\n\n        Args:\n            test_name: Name of the test case that triggered this bug report.\n            begin_time: Logline format timestamp taken when the test started.\n        \"\"\"\n        new_br = True\n        try:\n            stdout = self.adb.shell('bugreportz -v').decode('utf-8')\n            # This check is necessary for builds before N, where adb shell's ret\n            # code and stderr are not propagated properly.\n            if 'not found' in stdout:\n                new_br = False\n        except adb.AdbError:\n            new_br = False\n        br_path = os.path.join(self.log_path, 'BugReports')\n        utils.create_dir(br_path)\n        base_name = ',%s,%s.txt' % (begin_time, self.serial)\n        if new_br:\n            base_name = base_name.replace('.txt', '.zip')\n        test_name_len = utils.MAX_FILENAME_LEN - len(base_name)\n        out_name = test_name[:test_name_len] + base_name\n        full_out_path = os.path.join(br_path, out_name.replace(' ', r'\\ '))\n        # in case device restarted, wait for adb interface to return\n        self.wait_for_boot_completion()\n        self.log.info('Taking bugreport for %s.', test_name)\n        if new_br:\n            out = self.adb.shell('bugreportz').decode('utf-8')\n            if not out.startswith('OK'):\n                raise DeviceError(self, 'Failed to take bugreport: %s' % out)\n            br_out_path = out.split(':')[1].strip()\n            self.adb.pull([br_out_path, full_out_path])\n        else:\n            # shell=True as this command redirects the stdout to a local file\n            # using shell redirection.\n            self.adb.bugreport(' > %s' % full_out_path, shell=True)\n        self.log.info('Bugreport for %s taken at %s.', test_name,\n                      full_out_path)", "commit_link": "github.com/google/mobly/commit/3862e8ba359040fbdd6e1a6d36e51d07cda8e1ee", "file_name": "mobly/controllers/android_device.py", "vul_type": "cwe-078", "description": "Write a Python function to capture a bug report from a device, save it to a file, and handle different versions of the bug reporting tool."}
{"func_name": "r_bin_java_line_number_table_attr_new", "func_src_before": "R_API RBinJavaAttrInfo *r_bin_java_line_number_table_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 curpos, offset = 0;\n\tRBinJavaLineNumberAttribute *lnattr;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\toffset += 6;\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_LINE_NUMBER_TABLE_ATTR;\n\tattr->info.line_number_table_attr.line_number_table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.line_number_table_attr.line_number_table = r_list_newf (free);\n\n\tut32 linenum_len = attr->info.line_number_table_attr.line_number_table_length;\n\tRList *linenum_list = attr->info.line_number_table_attr.line_number_table;\n\tif (linenum_len > sz) {\n\t\tfree (attr);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < linenum_len; i++) {\n\t\tcurpos = buf_offset + offset;\n\t\t// printf (\"%llx %llx \\n\", curpos, sz);\n\t\t// XXX if (curpos + 8 >= sz) break;\n\t\tlnattr = R_NEW0 (RBinJavaLineNumberAttribute);\n\t\tif (!lnattr) {\n\t\t\tbreak;\n\t\t}\n\t\tlnattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlnattr->line_number = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlnattr->file_offset = curpos;\n\t\tlnattr->size = 4;\n\t\tr_list_append (linenum_list, lnattr);\n\t}\n\tattr->size = offset;\n\treturn attr;\n}", "func_src_after": "R_API RBinJavaAttrInfo *r_bin_java_line_number_table_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 curpos, offset = 0;\n\tRBinJavaLineNumberAttribute *lnattr;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\toffset += 6;\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_LINE_NUMBER_TABLE_ATTR;\n\tattr->info.line_number_table_attr.line_number_table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.line_number_table_attr.line_number_table = r_list_newf (free);\n\n\tut32 linenum_len = attr->info.line_number_table_attr.line_number_table_length;\n\tRList *linenum_list = attr->info.line_number_table_attr.line_number_table;\n\tif (linenum_len > sz) {\n\t\tfree (attr);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < linenum_len; i++) {\n\t\tcurpos = buf_offset + offset;\n\t\t// printf (\"%llx %llx \\n\", curpos, sz);\n\t\t// XXX if (curpos + 8 >= sz) break;\n\t\tlnattr = R_NEW0 (RBinJavaLineNumberAttribute);\n\t\tif (!lnattr) {\n\t\t\tbreak;\n\t\t}\n\t\tif (offset + 8 >= sz) {\n\t\t\tbreak;\n\t\t}\n\t\tlnattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlnattr->line_number = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlnattr->file_offset = curpos;\n\t\tlnattr->size = 4;\n\t\tr_list_append (linenum_list, lnattr);\n\t}\n\tattr->size = offset;\n\treturn attr;\n}", "commit_link": "github.com/radare/radare2/commit/eb0fb72b3c5307ec8e33effb6bf947e38cfdffe8", "file_name": "shlr/java/class.c", "vul_type": "cwe-125", "description": "In C, write a function to create a new Java line number table attribute from a binary buffer."}
{"func_name": "_create_vdisk", "func_src_before": "    def _create_vdisk(self, name, size, units, opts):\n        \"\"\"Create a new vdisk.\"\"\"\n\n        LOG.debug(_('enter: _create_vdisk: vdisk %s ') % name)\n\n        model_update = None\n        autoex = '-autoexpand' if opts['autoexpand'] else ''\n        easytier = '-easytier on' if opts['easytier'] else '-easytier off'\n\n        # Set space-efficient options\n        if opts['rsize'] == -1:\n            ssh_cmd_se_opt = ''\n        else:\n            ssh_cmd_se_opt = (\n                '-rsize %(rsize)d%% %(autoex)s -warning %(warn)d%%' %\n                {'rsize': opts['rsize'],\n                 'autoex': autoex,\n                 'warn': opts['warning']})\n            if opts['compression']:\n                ssh_cmd_se_opt = ssh_cmd_se_opt + ' -compressed'\n            else:\n                ssh_cmd_se_opt = ssh_cmd_se_opt + (\n                    ' -grainsize %d' % opts['grainsize'])\n\n        ssh_cmd = ('svctask mkvdisk -name %(name)s -mdiskgrp %(mdiskgrp)s '\n                   '-iogrp 0 -size %(size)s -unit '\n                   '%(unit)s %(easytier)s %(ssh_cmd_se_opt)s'\n                   % {'name': name,\n                   'mdiskgrp': self.configuration.storwize_svc_volpool_name,\n                   'size': size, 'unit': units, 'easytier': easytier,\n                   'ssh_cmd_se_opt': ssh_cmd_se_opt})\n        out, err = self._run_ssh(ssh_cmd)\n        self._assert_ssh_return(len(out.strip()), '_create_vdisk',\n                                ssh_cmd, out, err)\n\n        # Ensure that the output is as expected\n        match_obj = re.search('Virtual Disk, id \\[([0-9]+)\\], '\n                              'successfully created', out)\n        # Make sure we got a \"successfully created\" message with vdisk id\n        self._driver_assert(\n            match_obj is not None,\n            _('_create_vdisk %(name)s - did not find '\n              'success message in CLI output.\\n '\n              'stdout: %(out)s\\n stderr: %(err)s')\n            % {'name': name, 'out': str(out), 'err': str(err)})\n\n        LOG.debug(_('leave: _create_vdisk: volume %s ') % name)", "func_src_after": "    def _create_vdisk(self, name, size, units, opts):\n        \"\"\"Create a new vdisk.\"\"\"\n\n        LOG.debug(_('enter: _create_vdisk: vdisk %s ') % name)\n\n        model_update = None\n        easytier = 'on' if opts['easytier'] else 'off'\n\n        # Set space-efficient options\n        if opts['rsize'] == -1:\n            ssh_cmd_se_opt = []\n        else:\n            ssh_cmd_se_opt = ['-rsize', '%s%%' % str(opts['rsize']),\n                              '-autoexpand', '-warning',\n                              '%s%%' % str(opts['warning'])]\n            if not opts['autoexpand']:\n                ssh_cmd_se_opt.remove('-autoexpand')\n\n            if opts['compression']:\n                ssh_cmd_se_opt.append('-compressed')\n            else:\n                ssh_cmd_se_opt.extend(['-grainsize', str(opts['grainsize'])])\n\n        ssh_cmd = ['svctask', 'mkvdisk', '-name', name, '-mdiskgrp',\n                   self.configuration.storwize_svc_volpool_name,\n                   '-iogrp', '0', '-size', size, '-unit',\n                   units, '-easytier', easytier] + ssh_cmd_se_opt\n        out, err = self._run_ssh(ssh_cmd)\n        self._assert_ssh_return(len(out.strip()), '_create_vdisk',\n                                ssh_cmd, out, err)\n\n        # Ensure that the output is as expected\n        match_obj = re.search('Virtual Disk, id \\[([0-9]+)\\], '\n                              'successfully created', out)\n        # Make sure we got a \"successfully created\" message with vdisk id\n        self._driver_assert(\n            match_obj is not None,\n            _('_create_vdisk %(name)s - did not find '\n              'success message in CLI output.\\n '\n              'stdout: %(out)s\\n stderr: %(err)s')\n            % {'name': name, 'out': str(out), 'err': str(err)})\n\n        LOG.debug(_('leave: _create_vdisk: volume %s ') % name)", "commit_link": "github.com/thatsdone/cinder/commit/f752302d181583a95cf44354aea607ce9d9283f4", "file_name": "cinder/volume/drivers/storwize_svc.py", "vul_type": "cwe-078", "description": "Write a Python function to create a virtual disk with options for size, auto-expansion, easy tier, and compression."}
{"func_name": "delete", "func_src_before": "    @jwt_required\n    def delete(self, user_id):\n        \"\"\" Deletes user with the corresponding user_id \"\"\"\n        return database_utilities.execute_query(f\"\"\"delete from users where user_id = '{user_id}'\"\"\")", "func_src_after": "    @jwt_required\n    def delete(self, user_id):\n        \"\"\" Deletes user with the corresponding user_id \"\"\"\n        return database_utilities.execute_query(f\"\"\"delete from users where user_id = %s\"\"\", (user_id, ))", "commit_link": "github.com/sgosal2/tiger-boards-backend/commit/4670109dd613df2f2fe7e8403ebd149df2b55485", "file_name": "apis/users.py", "vul_type": "cwe-089", "description": "Create a Python function with JWT authentication that deletes a user from the database by their user_id."}
{"func_name": "(anonymous)", "func_src_before": "UserSchema.virtual('password').set(function(password) {\n    this._password = password;\n    this.salt = this.makeSalt();\n    this.hashed_password = this.encryptPassword(password);\n}).get(function() {", "func_src_after": "UserSchema.virtual('password').set(function(password) {\n    this._password = password;\n    this.hashed_password = this.encryptPassword(password);\n}).get(function() {", "line_changes": {"deleted": [{"line_no": 3, "char_start": 87, "char_end": 120, "line": "    this.salt = this.makeSalt();\n"}], "added": []}, "char_changes": {"deleted": [{"char_start": 87, "char_end": 120, "chars": "    this.salt = this.makeSalt();\n"}], "added": []}, "commit_link": "github.com/aburchette/territory-manager-mean/commit/24620016541089cc0ca316a0dec32ee0db864d98", "file_name": "user.js", "vul_type": "cwe-916", "commit_msg": "Replaced SHA1 password hashing with more bcrypt", "parent_commit": "f944f0a464555f033f01413f24d1cd47ab412ae7", "description": "Create a virtual password field with setter and getter methods in a User schema using Mongoose in JavaScript."}
{"func_name": "read_primary_locale_file", "func_src_before": "      def read_primary_locale_file\n        primary_file = \"#{self.locales_config_path}/#{self.primary_locale_name}.yml\"\n        File.exists?(primary_file) ? flat_hash(YAML::load(IO.read(primary_file))[self.primary_locale_name]) : {}\n      end", "func_src_after": "      def read_primary_locale_file\n        primary_file = \"#{self.locales_config_path}/#{self.primary_locale_name}.yml\"\n        File.exists?(primary_file) ? flat_hash(YAML::safe_load(IO.read(primary_file))[self.primary_locale_name]) : {}\n      end", "line_changes": {"deleted": [{"line_no": 3, "char_start": 120, "char_end": 233, "line": "        File.exists?(primary_file) ? flat_hash(YAML::load(IO.read(primary_file))[self.primary_locale_name]) : {}\n"}], "added": [{"line_no": 3, "char_start": 120, "char_end": 238, "line": "        File.exists?(primary_file) ? flat_hash(YAML::safe_load(IO.read(primary_file))[self.primary_locale_name]) : {}\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 173, "char_end": 178, "chars": "safe_"}]}, "commit_link": "github.com/MyMedsAndMe/tolk/commit/625237a3df7a64b496374f38f27c774b56e2a582", "file_name": "sync.rb", "vul_type": "cwe-502", "commit_msg": "Use YAML's `safe_load` instead of `load`.", "parent_commit": "b5b66f923436a1c0fce47ae68d5da05323039d61", "description": "Write a Ruby method to read and flatten the contents of a primary locale YAML file if it exists, returning an empty hash otherwise."}
{"func_name": "test_create_invalid_host", "func_src_before": "    def test_create_invalid_host(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record\n        self.clear_mox()\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_cpg\",\n                       self.fake_get_cpg)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_domain\",\n                       self.fake_get_domain)\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_host_cmd = 'showhost -verbose fakehost'\n        _run_ssh(show_host_cmd, False).AndReturn([pack('no hosts listed'), ''])\n\n        create_host_cmd = ('createhost -persona 1 -domain (\\'OpenStack\\',) '\n                           'fakehost 123456789012345 123456789054321')\n        create_host_ret = pack(CLI_CR +\n                               'already used by host fakehost.foo (19)')\n        _run_ssh(create_host_cmd, False).AndReturn([create_host_ret, ''])\n\n        show_3par_cmd = 'showhost -verbose fakehost.foo'\n        _run_ssh(show_3par_cmd, False).AndReturn([pack(FC_SHOWHOST_RET), ''])\n        self.mox.ReplayAll()\n\n        host = self.driver._create_host(self.volume, self.connector)\n\n        self.assertEquals(host['name'], 'fakehost.foo')", "func_src_after": "    def test_create_invalid_host(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record\n        self.clear_mox()\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_cpg\",\n                       self.fake_get_cpg)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_domain\",\n                       self.fake_get_domain)\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_host_cmd = ['showhost', '-verbose', 'fakehost']\n        _run_ssh(show_host_cmd, False).AndReturn([pack('no hosts listed'), ''])\n\n        create_host_cmd = (['createhost', '-persona', '1', '-domain',\n                            ('OpenStack',), 'fakehost', '123456789012345',\n                            '123456789054321'])\n        create_host_ret = pack(CLI_CR +\n                               'already used by host fakehost.foo (19)')\n        _run_ssh(create_host_cmd, False).AndReturn([create_host_ret, ''])\n\n        show_3par_cmd = ['showhost', '-verbose', 'fakehost.foo']\n        _run_ssh(show_3par_cmd, False).AndReturn([pack(FC_SHOWHOST_RET), ''])\n        self.mox.ReplayAll()\n\n        host = self.driver._create_host(self.volume, self.connector)\n\n        self.assertEquals(host['name'], 'fakehost.foo')", "commit_link": "github.com/thatsdone/cinder/commit/c55589b131828f3a595903f6796cb2d0babb772f", "file_name": "cinder/tests/test_hp3par.py", "vul_type": "cwe-078", "description": "Write a Python unit test function that mocks SSH commands for creating a host in an HP 3PAR storage system and checks the host's name."}
{"func_name": "mode_keepalive", "func_src_before": "    def mode_keepalive(self, request):\n        \"\"\"\n        This is called by render_POST when the\n        client is replying to the keepalive.\n        \"\"\"\n        csessid = request.args.get('csessid')[0]\n        self.last_alive[csessid] = (time.time(), False)\n        return '\"\"'", "func_src_after": "    def mode_keepalive(self, request):\n        \"\"\"\n        This is called by render_POST when the\n        client is replying to the keepalive.\n        \"\"\"\n        csessid = cgi.escape(request.args['csessid'][0])\n        self.last_alive[csessid] = (time.time(), False)\n        return '\"\"'", "commit_link": "github.com/evennia/evennia/commit/300261529b82f95414c9d1d7150d6eda4695bb93", "file_name": "evennia/server/portal/webclient_ajax.py", "vul_type": "cwe-079", "description": "Write a Python function named `mode_keepalive` that updates a timestamp for a client session ID from a POST request and returns an empty string."}
{"func_name": "get_mod_taken_together_with", "func_src_before": "def get_mod_taken_together_with(code):\n    '''\n        Retrieves the list of modules taken together with the specified\n        module code in the same semester.\n\n        Returns a table of lists (up to 10 top results). Each list contains\n        (specified code, module code of mod taken together, aySem, number of students)\n\n        e.g. [(CS1010, CS1231, AY 16/17 Sem 1, 5)] means there are 5 students\n        taking CS1010 and CS1231 together in AY 16/17 Sem 1.\n    '''\n    NUM_TOP_RESULTS_TO_RETURN = 10\n\n    sql_command = \"SELECT sp1.moduleCode, sp2.moduleCode, sp1.acadYearAndSem, COUNT(*) \" + \\\n                \"FROM studentPlans sp1, studentPlans sp2 \" + \\\n                \"WHERE sp1.moduleCode = '\" + code + \"' AND \" + \\\n                \"sp2.moduleCode <> sp1.moduleCode AND \" + \\\n                \"sp1.studentId = sp2.studentId AND \" + \\\n                \"sp1.acadYearAndSem = sp2.acadYearAndSem \" + \\\n                \"GROUP BY sp1.moduleCode, sp2.moduleCode, sp1.acadYearAndSem \" + \\\n                \"ORDER BY COUNT(*) DESC\"\n\n    DB_CURSOR.execute(sql_command)\n\n    return DB_CURSOR.fetchmany(NUM_TOP_RESULTS_TO_RETURN)", "func_src_after": "def get_mod_taken_together_with(code):\n    '''\n        Retrieves the list of modules taken together with the specified\n        module code in the same semester.\n\n        Returns a table of lists (up to 10 top results). Each list contains\n        (specified code, module code of mod taken together, aySem, number of students)\n\n        e.g. [(CS1010, CS1231, AY 16/17 Sem 1, 5)] means there are 5 students\n        taking CS1010 and CS1231 together in AY 16/17 Sem 1.\n    '''\n    NUM_TOP_RESULTS_TO_RETURN = 10\n\n    sql_command = \"SELECT sp1.moduleCode, sp2.moduleCode, sp1.acadYearAndSem, COUNT(*) \" + \\\n                \"FROM studentPlans sp1, studentPlans sp2 \" + \\\n                \"WHERE sp1.moduleCode = %s AND \" + \\\n                \"sp2.moduleCode <> sp1.moduleCode AND \" + \\\n                \"sp1.studentId = sp2.studentId AND \" + \\\n                \"sp1.acadYearAndSem = sp2.acadYearAndSem \" + \\\n                \"GROUP BY sp1.moduleCode, sp2.moduleCode, sp1.acadYearAndSem \" + \\\n                \"ORDER BY COUNT(*) DESC\"\n\n    DB_CURSOR.execute(sql_command, (code,))\n\n    return DB_CURSOR.fetchmany(NUM_TOP_RESULTS_TO_RETURN)", "commit_link": "github.com/nus-mtp/cs-modify/commit/79b4b1dd7eba5445751808e4c50b49d2dd08366b", "file_name": "components/model.py", "vul_type": "cwe-089", "description": "Write a Python function to fetch the top 10 modules taken alongside a given module code from a database."}
{"func_name": "_startSSL_pyOpenSSL", "func_src_before": "    def _startSSL_pyOpenSSL(self):\n        log.debug(\"_startSSL_pyOpenSSL called\")\n        tcpsock = self._owner\n        # NonBlockingHTTPBOSH instance has no attribute _owner\n        if hasattr(tcpsock, '_owner') and tcpsock._owner._caller.client_cert \\\n        and os.path.exists(tcpsock._owner._caller.client_cert):\n            conn = tcpsock._owner._caller\n            # FIXME make a checkbox for Client Cert / SSLv23 / TLSv1\n            # If we are going to use a client cert/key pair for authentication,\n            # we choose TLSv1 method.\n            tcpsock._sslContext = OpenSSL.SSL.Context(OpenSSL.SSL.TLSv1_METHOD)\n            log.debug('Using client cert and key from %s' % conn.client_cert)\n            try:\n                p12 = OpenSSL.crypto.load_pkcs12(open(conn.client_cert).read(),\n                    conn.client_cert_passphrase)\n            except OpenSSL.crypto.Error as exception_obj:\n                log.warning('Unable to load client pkcs12 certificate from '\n                    'file %s: %s ... Is it a valid PKCS12 cert?' % \\\n                (conn.client_cert, exception_obj.args))\n            except:\n                log.warning('Unknown error while loading certificate from file '\n                    '%s' % conn.client_cert)\n            else:\n                log.info('PKCS12 Client cert loaded OK')\n                try:\n                    tcpsock._sslContext.use_certificate(p12.get_certificate())\n                    tcpsock._sslContext.use_privatekey(p12.get_privatekey())\n                    log.info('p12 cert and key loaded')\n                except OpenSSL.crypto.Error as exception_obj:\n                    log.warning('Unable to extract client certificate from '\n                        'file %s' % conn.client_cert)\n                except Exception as msg:\n                    log.warning('Unknown error extracting client certificate '\n                        'from file %s: %s' % (conn.client_cert, msg))\n                else:\n                    log.info('client cert and key loaded OK')\n        else:\n            # See http://docs.python.org/dev/library/ssl.html\n            tcpsock._sslContext = OpenSSL.SSL.Context(OpenSSL.SSL.SSLv23_METHOD)\n            flags = OpenSSL.SSL.OP_NO_SSLv2\n            try:\n                flags |= OpenSSL.SSL.OP_NO_TICKET\n            except AttributeError as e:\n                # py-OpenSSL < 0.9 or old OpenSSL\n                flags |= 16384\n            tcpsock._sslContext.set_options(flags)\n\n        tcpsock.ssl_errnum = []\n        tcpsock._sslContext.set_verify(OpenSSL.SSL.VERIFY_PEER,\n            self._ssl_verify_callback)\n        tcpsock._sslContext.set_cipher_list('HIGH:!aNULL:!eNULL:RC4-SHA')\n        store = tcpsock._sslContext.get_cert_store()\n        self._load_cert_file(self.cacerts, store)\n        self._load_cert_file(self.mycerts, store)\n        if os.path.isdir('/etc/ssl/certs'):\n            for f in os.listdir('/etc/ssl/certs'):\n                # We don't logg because there is a lot a duplicated certs in this\n                # folder\n                self._load_cert_file(os.path.join('/etc/ssl/certs', f), store,\n                        logg=False)\n\n        tcpsock._sslObj = OpenSSL.SSL.Connection(tcpsock._sslContext,\n                tcpsock._sock)\n        tcpsock._sslObj.set_connect_state() # set to client mode\n        wrapper = PyOpenSSLWrapper(tcpsock._sslObj)\n        tcpsock._recv = wrapper.recv\n        tcpsock._send = wrapper.send\n\n        log.debug(\"Initiating handshake...\")\n        try:\n            tcpsock._sslObj.do_handshake()\n        except (OpenSSL.SSL.WantReadError, OpenSSL.SSL.WantWriteError) as e:\n            pass\n        except:\n            log.error('Error while TLS handshake: ', exc_info=True)\n            return False\n        self._owner.ssl_lib = PYOPENSSL\n        return True", "func_src_after": "    def _startSSL_pyOpenSSL(self):\n        log.debug(\"_startSSL_pyOpenSSL called\")\n        tcpsock = self._owner\n        # NonBlockingHTTPBOSH instance has no attribute _owner\n        if hasattr(tcpsock, '_owner') and tcpsock._owner._caller.client_cert \\\n        and os.path.exists(tcpsock._owner._caller.client_cert):\n            conn = tcpsock._owner._caller\n            # FIXME make a checkbox for Client Cert / SSLv23 / TLSv1\n            # If we are going to use a client cert/key pair for authentication,\n            # we choose TLSv1* method.\n            tcpsock._sslContext = OpenSSL.SSL.Context(OpenSSL.SSL.SSLv23_METHOD)\n            flags = (OpenSSL.SSL.OP_NO_SSLv2 | OpenSSL.SSL.OP_NO_SSLv3\n                | OpenSSL.SSL.OP_SINGLE_DH_USE)\n            tcpsock._sslContext.set_options(flags)\n            log.debug('Using client cert and key from %s' % conn.client_cert)\n            try:\n                p12 = OpenSSL.crypto.load_pkcs12(open(conn.client_cert).read(),\n                    conn.client_cert_passphrase)\n            except OpenSSL.crypto.Error as exception_obj:\n                log.warning('Unable to load client pkcs12 certificate from '\n                    'file %s: %s ... Is it a valid PKCS12 cert?' % \\\n                (conn.client_cert, exception_obj.args))\n            except:\n                log.warning('Unknown error while loading certificate from file '\n                    '%s' % conn.client_cert)\n            else:\n                log.info('PKCS12 Client cert loaded OK')\n                try:\n                    tcpsock._sslContext.use_certificate(p12.get_certificate())\n                    tcpsock._sslContext.use_privatekey(p12.get_privatekey())\n                    log.info('p12 cert and key loaded')\n                except OpenSSL.crypto.Error as exception_obj:\n                    log.warning('Unable to extract client certificate from '\n                        'file %s' % conn.client_cert)\n                except Exception as msg:\n                    log.warning('Unknown error extracting client certificate '\n                        'from file %s: %s' % (conn.client_cert, msg))\n                else:\n                    log.info('client cert and key loaded OK')\n        else:\n            # See http://docs.python.org/dev/library/ssl.html\n            tcpsock._sslContext = OpenSSL.SSL.Context(OpenSSL.SSL.SSLv23_METHOD)\n            flags = OpenSSL.SSL.OP_NO_SSLv2 | OpenSSL.SSL.OP_SINGLE_DH_USE\n            try:\n                flags |= OpenSSL.SSL.OP_NO_TICKET\n            except AttributeError as e:\n                # py-OpenSSL < 0.9 or old OpenSSL\n                flags |= 16384\n            tcpsock._sslContext.set_options(flags)\n\n        tcpsock.ssl_errnum = []\n        tcpsock._sslContext.set_verify(OpenSSL.SSL.VERIFY_PEER,\n            self._ssl_verify_callback)\n        tcpsock._sslContext.set_cipher_list('HIGH:!aNULL:!eNULL:RC4-SHA')\n        store = tcpsock._sslContext.get_cert_store()\n        self._load_cert_file(self.cacerts, store)\n        self._load_cert_file(self.mycerts, store)\n        if os.path.isdir('/etc/ssl/certs'):\n            for f in os.listdir('/etc/ssl/certs'):\n                # We don't logg because there is a lot a duplicated certs in this\n                # folder\n                self._load_cert_file(os.path.join('/etc/ssl/certs', f), store,\n                        logg=False)\n\n        tcpsock._sslObj = OpenSSL.SSL.Connection(tcpsock._sslContext,\n                tcpsock._sock)\n        tcpsock._sslObj.set_connect_state() # set to client mode\n        wrapper = PyOpenSSLWrapper(tcpsock._sslObj)\n        tcpsock._recv = wrapper.recv\n        tcpsock._send = wrapper.send\n\n        log.debug(\"Initiating handshake...\")\n        try:\n            tcpsock._sslObj.do_handshake()\n        except (OpenSSL.SSL.WantReadError, OpenSSL.SSL.WantWriteError) as e:\n            pass\n        except:\n            log.error('Error while TLS handshake: ', exc_info=True)\n            return False\n        self._owner.ssl_lib = PYOPENSSL\n        return True", "line_changes": {"deleted": [{"line_no": 11, "char_start": 548, "char_end": 628, "line": "            tcpsock._sslContext = OpenSSL.SSL.Context(OpenSSL.SSL.TLSv1_METHOD)\n"}, {"line_no": 40, "char_start": 2190, "char_end": 2234, "line": "            flags = OpenSSL.SSL.OP_NO_SSLv2\n"}], "added": [{"line_no": 11, "char_start": 549, "char_end": 630, "line": "            tcpsock._sslContext = OpenSSL.SSL.Context(OpenSSL.SSL.SSLv23_METHOD)\n"}, {"line_no": 12, "char_start": 630, "char_end": 701, "line": "            flags = (OpenSSL.SSL.OP_NO_SSLv2 | OpenSSL.SSL.OP_NO_SSLv3\n"}, {"line_no": 13, "char_start": 701, "char_end": 749, "line": "                | OpenSSL.SSL.OP_SINGLE_DH_USE)\n"}, {"line_no": 14, "char_start": 749, "char_end": 800, "line": "            tcpsock._sslContext.set_options(flags)\n"}, {"line_no": 43, "char_start": 2362, "char_end": 2437, "line": "            flags = OpenSSL.SSL.OP_NO_SSLv2 | OpenSSL.SSL.OP_SINGLE_DH_USE\n"}]}, "char_changes": {"deleted": [{"char_start": 614, "char_end": 619, "chars": "TLSv1"}], "added": [{"char_start": 539, "char_end": 540, "chars": "*"}, {"char_start": 615, "char_end": 621, "chars": "SSLv23"}, {"char_start": 630, "char_end": 800, "chars": "            flags = (OpenSSL.SSL.OP_NO_SSLv2 | OpenSSL.SSL.OP_NO_SSLv3\n                | OpenSSL.SSL.OP_SINGLE_DH_USE)\n            tcpsock._sslContext.set_options(flags)\n"}, {"char_start": 2405, "char_end": 2436, "chars": " | OpenSSL.SSL.OP_SINGLE_DH_USE"}]}, "commit_link": "github.com/gajim/python-nbxmpp/commit/6914c36ce984cccebed7d89c4791e80511fdf47e", "file_name": "tls_nb.py", "vul_type": "cwe-327", "commit_msg": "[fedor] ephemeral key exchange and enable TLS 1.1 and TLS 1.2 when connecting using client cert authentification. Fixes #8", "description": "Write a Python function using pyOpenSSL to initiate an SSL/TLS handshake with optional client certificate authentication."}
{"func_name": "make_eb_config", "func_src_before": "def make_eb_config(application_name, default_region):\n    # Capture our current directory\n    UTILS_DIR = os.path.dirname(os.path.abspath(__file__))\n    # Create the jinja2 environment.\n    # Notice the use of trim_blocks, which greatly helps control whitespace.\n    j2_env = Environment(loader=FileSystemLoader(UTILS_DIR))\n    return j2_env.get_template('templates/eb/config.yml').render(\n        APPLICATION_NAME=application_name,\n        DEFAULT_REGION=default_region\n    )", "func_src_after": "def make_eb_config(application_name, default_region):\n    # Capture our current directory\n    UTILS_DIR = os.path.dirname(os.path.abspath(__file__))\n    # Create the jinja2 environment.\n    # Notice the use of trim_blocks, which greatly helps control whitespace.\n    j2_env = Environment(loader=FileSystemLoader(UTILS_DIR), autoescape=True)\n    return j2_env.get_template('templates/eb/config.yml').render(\n        APPLICATION_NAME=application_name,\n        DEFAULT_REGION=default_region\n    )", "commit_link": "github.com/OkunaOrg/okuna-www-api/commit/8c40c66ea7c483a0cbda4c21940180af909aab99", "file_name": "utils/make_eb_config.py", "vul_type": "cwe-079", "description": "Write a Python function to generate an Elastic Beanstalk configuration file from a template with application name and default region variables."}
{"func_name": "link_dialog", "func_src_before": "def link_dialog(request):\n    # list of wiki pages\n    name = request.values.get(\"pagename\", \"\")\n    if name:\n        from MoinMoin import search\n        # XXX error handling!\n        searchresult = search.searchPages(request, 't:\"%s\"' % name)\n\n        pages = [p.page_name for p in searchresult.hits]\n        pages.sort()\n        pages[0:0] = [name]\n        page_list = '''\n         <tr>\n          <td colspan=2>\n           <select id=\"sctPagename\" size=\"1\" onchange=\"OnChangePagename(this.value);\">\n           %s\n           </select>\n          <td>\n         </tr>\n''' % \"\\n\".join(['<option value=\"%s\">%s</option>' % (wikiutil.escape(page), wikiutil.escape(page))\n                 for page in pages])\n    else:\n        page_list = \"\"\n\n    # list of interwiki names\n    interwiki_list = wikiutil.load_wikimap(request)\n    interwiki = interwiki_list.keys()\n    interwiki.sort()\n    iwpreferred = request.cfg.interwiki_preferred[:]\n    if not iwpreferred or iwpreferred and iwpreferred[-1] is not None:\n        resultlist = iwpreferred\n        for iw in interwiki:\n            if not iw in iwpreferred:\n                resultlist.append(iw)\n    else:\n        resultlist = iwpreferred[:-1]\n    interwiki = \"\\n\".join(\n        ['<option value=\"%s\">%s</option>' % (wikiutil.escape(key), wikiutil.escape(key))\n         for key in resultlist])\n\n    # wiki url\n    url_prefix_static = request.cfg.url_prefix_static\n    scriptname = request.script_root + '/'\n    action = scriptname\n    basepage = wikiutil.escape(request.page.page_name)\n    request.write(u'''\n<!--\n * FCKeditor - The text editor for internet\n * Copyright (C) 2003-2004 Frederico Caldeira Knabben\n *\n * Licensed under the terms of the GNU Lesser General Public License:\n *   http://www.opensource.org/licenses/lgpl-license.php\n *\n * For further information visit:\n *   http://www.fckeditor.net/\n *\n * File Name: fck_link.html\n *  Link dialog window.\n *\n * Version:  2.0 FC (Preview)\n * Modified: 2005-02-18 23:55:22\n *\n * File Authors:\n *   Frederico Caldeira Knabben (fredck@fckeditor.net)\n-->\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n<meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\">\n<meta name=\"robots\" content=\"index,nofollow\">\n<html>\n <head>\n  <title>Link Properties</title>\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n  <meta name=\"robots\" content=\"noindex,nofollow\" />\n  <script src=\"%(url_prefix_static)s/applets/FCKeditor/editor/dialog/common/fck_dialog_common.js\" type=\"text/javascript\"></script>\n  <script src=\"%(url_prefix_static)s/applets/moinFCKplugins/moinlink/fck_link.js\" type=\"text/javascript\"></script>\n  <script src=\"%(url_prefix_static)s/applets/moinFCKplugins/moinurllib.js\" type=\"text/javascript\"></script>\n </head>\n <body scroll=\"no\" style=\"OVERFLOW: hidden\">\n  <div id=\"divInfo\" style=\"DISPLAY: none\">\n   <span fckLang=\"DlgLnkType\">Link Type</span><br />\n   <select id=\"cmbLinkType\" onchange=\"SetLinkType(this.value);\">\n    <option value=\"wiki\" selected=\"selected\">WikiPage</option>\n    <option value=\"interwiki\">Interwiki</option>\n    <option value=\"url\" fckLang=\"DlgLnkTypeURL\">URL</option>\n   </select>\n   <br />\n   <br />\n   <div id=\"divLinkTypeWiki\">\n    <table height=\"100%%\" cellSpacing=\"0\" cellPadding=\"0\" width=\"100%%\" border=\"0\">\n     <tr>\n      <td>\n       <form action=%(action)s method=\"GET\">\n       <input type=\"hidden\" name=\"action\" value=\"fckdialog\">\n       <input type=\"hidden\" name=\"dialog\" value=\"link\">\n       <input type=\"hidden\" id=\"basepage\" name=\"basepage\" value=\"%(basepage)s\">\n       <table cellSpacing=\"0\" cellPadding=\"0\" align=\"center\" border=\"0\">\n        <tr>\n         <td>\n          <span fckLang=\"PageDlgName\">Page Name</span><br>\n          <input id=\"txtPagename\" name=\"pagename\" size=\"30\" value=\"%(name)s\">\n         </td>\n         <td valign=\"bottom\">\n           <input id=btnSearchpage type=\"submit\" value=\"Search\">\n         </td>\n        </tr>\n        %(page_list)s\n       </table>\n       </form>\n      </td>\n     </tr>\n    </table>\n   </div>\n   <div id=\"divLinkTypeInterwiki\">\n    <table height=\"100%%\" cellSpacing=\"0\" cellPadding=\"0\" width=\"100%%\" border=\"0\">\n     <tr>\n      <td>\n       <table cellSpacing=\"0\" cellPadding=\"0\" align=\"center\" border=\"0\">\n        <tr>\n         <td>\n          <span fckLang=\"WikiDlgName\">Wiki:PageName</span><br>\n          <select id=\"sctInterwiki\" size=\"1\">\n          %(interwiki)s\n          </select>:\n          <input id=\"txtInterwikipagename\"></input>\n         </td>\n        </tr>\n       </table>\n      </td>\n     </tr>\n    </table>\n   </div>\n   <div id=\"divLinkTypeUrl\">\n    <table cellspacing=\"0\" cellpadding=\"0\" width=\"100%%\" border=\"0\">\n     <tr>\n      <td nowrap=\"nowrap\">\n       <span fckLang=\"DlgLnkProto\">Protocol</span><br />\n       <select id=\"cmbLinkProtocol\">\n        <option value=\"http://\" selected=\"selected\">http://</option>\n        <option value=\"https://\">https://</option>\n        <option value=\"ftp://\">ftp://</option>\n        <option value=\"file://\">file://</option>\n        <option value=\"news://\">news://</option>\n        <option value=\"mailto:\">mailto:</option>\n        <option value=\"\" fckLang=\"DlgLnkProtoOther\">&lt;other&gt;</option>\n       </select>\n      </td>\n      <td nowrap=\"nowrap\">&nbsp;</td>\n      <td nowrap=\"nowrap\" width=\"100%%\">\n       <span fckLang=\"DlgLnkURL\">URL</span><br />\n       <input id=\"txtUrl\" style=\"WIDTH: 100%%\" type=\"text\" onkeyup=\"OnUrlChange();\" onchange=\"OnUrlChange();\" />\n      </td>\n     </tr>\n    </table>\n    <br />\n   </div>\n  </div>\n </body>\n</html>\n''' % locals())", "func_src_after": "def link_dialog(request):\n    # list of wiki pages\n    name = request.values.get(\"pagename\", \"\")\n    name_escaped = wikiutil.escape(name)\n    if name:\n        from MoinMoin import search\n        # XXX error handling!\n        searchresult = search.searchPages(request, 't:\"%s\"' % name)\n\n        pages = [p.page_name for p in searchresult.hits]\n        pages.sort()\n        pages[0:0] = [name]\n        page_list = '''\n         <tr>\n          <td colspan=2>\n           <select id=\"sctPagename\" size=\"1\" onchange=\"OnChangePagename(this.value);\">\n           %s\n           </select>\n          <td>\n         </tr>\n''' % \"\\n\".join(['<option value=\"%s\">%s</option>' % (wikiutil.escape(page), wikiutil.escape(page))\n                 for page in pages])\n    else:\n        page_list = \"\"\n\n    # list of interwiki names\n    interwiki_list = wikiutil.load_wikimap(request)\n    interwiki = interwiki_list.keys()\n    interwiki.sort()\n    iwpreferred = request.cfg.interwiki_preferred[:]\n    if not iwpreferred or iwpreferred and iwpreferred[-1] is not None:\n        resultlist = iwpreferred\n        for iw in interwiki:\n            if not iw in iwpreferred:\n                resultlist.append(iw)\n    else:\n        resultlist = iwpreferred[:-1]\n    interwiki = \"\\n\".join(\n        ['<option value=\"%s\">%s</option>' % (wikiutil.escape(key), wikiutil.escape(key))\n         for key in resultlist])\n\n    # wiki url\n    url_prefix_static = request.cfg.url_prefix_static\n    scriptname = request.script_root + '/'\n    action = scriptname\n    basepage = wikiutil.escape(request.page.page_name)\n    request.write(u'''\n<!--\n * FCKeditor - The text editor for internet\n * Copyright (C) 2003-2004 Frederico Caldeira Knabben\n *\n * Licensed under the terms of the GNU Lesser General Public License:\n *   http://www.opensource.org/licenses/lgpl-license.php\n *\n * For further information visit:\n *   http://www.fckeditor.net/\n *\n * File Name: fck_link.html\n *  Link dialog window.\n *\n * Version:  2.0 FC (Preview)\n * Modified: 2005-02-18 23:55:22\n *\n * File Authors:\n *   Frederico Caldeira Knabben (fredck@fckeditor.net)\n-->\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n<meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\">\n<meta name=\"robots\" content=\"index,nofollow\">\n<html>\n <head>\n  <title>Link Properties</title>\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n  <meta name=\"robots\" content=\"noindex,nofollow\" />\n  <script src=\"%(url_prefix_static)s/applets/FCKeditor/editor/dialog/common/fck_dialog_common.js\" type=\"text/javascript\"></script>\n  <script src=\"%(url_prefix_static)s/applets/moinFCKplugins/moinlink/fck_link.js\" type=\"text/javascript\"></script>\n  <script src=\"%(url_prefix_static)s/applets/moinFCKplugins/moinurllib.js\" type=\"text/javascript\"></script>\n </head>\n <body scroll=\"no\" style=\"OVERFLOW: hidden\">\n  <div id=\"divInfo\" style=\"DISPLAY: none\">\n   <span fckLang=\"DlgLnkType\">Link Type</span><br />\n   <select id=\"cmbLinkType\" onchange=\"SetLinkType(this.value);\">\n    <option value=\"wiki\" selected=\"selected\">WikiPage</option>\n    <option value=\"interwiki\">Interwiki</option>\n    <option value=\"url\" fckLang=\"DlgLnkTypeURL\">URL</option>\n   </select>\n   <br />\n   <br />\n   <div id=\"divLinkTypeWiki\">\n    <table height=\"100%%\" cellSpacing=\"0\" cellPadding=\"0\" width=\"100%%\" border=\"0\">\n     <tr>\n      <td>\n       <form action=%(action)s method=\"GET\">\n       <input type=\"hidden\" name=\"action\" value=\"fckdialog\">\n       <input type=\"hidden\" name=\"dialog\" value=\"link\">\n       <input type=\"hidden\" id=\"basepage\" name=\"basepage\" value=\"%(basepage)s\">\n       <table cellSpacing=\"0\" cellPadding=\"0\" align=\"center\" border=\"0\">\n        <tr>\n         <td>\n          <span fckLang=\"PageDlgName\">Page Name</span><br>\n          <input id=\"txtPagename\" name=\"pagename\" size=\"30\" value=\"%(name_escaped)s\">\n         </td>\n         <td valign=\"bottom\">\n           <input id=btnSearchpage type=\"submit\" value=\"Search\">\n         </td>\n        </tr>\n        %(page_list)s\n       </table>\n       </form>\n      </td>\n     </tr>\n    </table>\n   </div>\n   <div id=\"divLinkTypeInterwiki\">\n    <table height=\"100%%\" cellSpacing=\"0\" cellPadding=\"0\" width=\"100%%\" border=\"0\">\n     <tr>\n      <td>\n       <table cellSpacing=\"0\" cellPadding=\"0\" align=\"center\" border=\"0\">\n        <tr>\n         <td>\n          <span fckLang=\"WikiDlgName\">Wiki:PageName</span><br>\n          <select id=\"sctInterwiki\" size=\"1\">\n          %(interwiki)s\n          </select>:\n          <input id=\"txtInterwikipagename\"></input>\n         </td>\n        </tr>\n       </table>\n      </td>\n     </tr>\n    </table>\n   </div>\n   <div id=\"divLinkTypeUrl\">\n    <table cellspacing=\"0\" cellpadding=\"0\" width=\"100%%\" border=\"0\">\n     <tr>\n      <td nowrap=\"nowrap\">\n       <span fckLang=\"DlgLnkProto\">Protocol</span><br />\n       <select id=\"cmbLinkProtocol\">\n        <option value=\"http://\" selected=\"selected\">http://</option>\n        <option value=\"https://\">https://</option>\n        <option value=\"ftp://\">ftp://</option>\n        <option value=\"file://\">file://</option>\n        <option value=\"news://\">news://</option>\n        <option value=\"mailto:\">mailto:</option>\n        <option value=\"\" fckLang=\"DlgLnkProtoOther\">&lt;other&gt;</option>\n       </select>\n      </td>\n      <td nowrap=\"nowrap\">&nbsp;</td>\n      <td nowrap=\"nowrap\" width=\"100%%\">\n       <span fckLang=\"DlgLnkURL\">URL</span><br />\n       <input id=\"txtUrl\" style=\"WIDTH: 100%%\" type=\"text\" onkeyup=\"OnUrlChange();\" onchange=\"OnUrlChange();\" />\n      </td>\n     </tr>\n    </table>\n    <br />\n   </div>\n  </div>\n </body>\n</html>\n''' % locals())", "commit_link": "github.com/moinwiki/moin-1.9/commit/70955a8eae091cc88fd9a6e510177e70289ec024", "file_name": "MoinMoin/action/fckdialog.py", "vul_type": "cwe-079", "description": "Generate a Python function named `link_dialog` that creates a link dialog interface for a wiki page using the MoinMoin framework."}
{"func_name": "(anonymous)", "func_src_before": "setTimeout(function() {\n  if ( $( '.plexBack a').length < 1 ) {\n    $( '.plexBack' ).append('<a href=\"' + document.referrer + '\"></a>');\n  }\n},10);", "func_src_after": "setTimeout(function() {\n  if ( $( '.plexBack a').length < 1 ) {\n    $( '.plexBack' ).append('<a href=\"' + encodeURI(document.referrer) + '\"></a>');\n  }\n},10);", "line_changes": {"deleted": [{"line_no": 3, "char_start": 64, "char_end": 137, "line": "    $( '.plexBack' ).append('<a href=\"' + document.referrer + '\"></a>');\n"}], "added": [{"line_no": 3, "char_start": 64, "char_end": 148, "line": "    $( '.plexBack' ).append('<a href=\"' + encodeURI(document.referrer) + '\"></a>');\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 106, "char_end": 116, "chars": "encodeURI("}, {"char_start": 133, "char_end": 134, "chars": ")"}]}, "commit_link": "github.com/Kyosfonica/calibre-web/commit/806a5f209fe0a428c26a8dc0b8dbe3901039bb4f", "file_name": "caliBlur.js", "vul_type": "cwe-079", "commit_msg": "Fix two minor xss", "description": "Create a JavaScript code snippet that appends a referrer link to an element with the class 'plexBack' after a short delay."}
{"func_name": "delete_video", "func_src_before": "@app.route('/delete_video/<filename>')\ndef delete_video(filename):\n\tif 'username' in session:\n\t\t#os.remove(\"static/videos/{}\".format(filename))\n\t\tprint(session['username'], file=sys.stdout)\n\t\tdata=users.query.filter_by(Username=session['username']).first()\n\t\tvideo=Video.query.filter_by(UserID=data.UserID,Name=filename).first()\n\t\tif video != None:\n\t\t\tos.remove(\"static/videos/{}\".format(filename))\n\t\t\tdb.session.delete(video)\n\t\t\tdb.session.commit()\n\t\telse:\n\t\t\treturn \"Don't delete other people's videos!\"\n\t\treturn redirect(url_for('upload'))\n\treturn \"test\"", "func_src_after": "@app.route('/delete_video/<filename>')\ndef delete_video(filename):\n\tif 'username' in session:\n\t\t#os.remove(\"static/videos/{}\".format(filename))\n\t\tprint(session['username'], file=sys.stdout)\n\t\tdata=users.query.filter_by(Username=session['username']).first()\n\t\tvideo=Video.query.filter_by(UserID=data.UserID,Name=filename).first()\n\t\tif video != None:\n\t\t\t#os.remove(\"static/videos/{}\".format(filename))\n\t\t\tos.system(\"rm static/videos/{}\".format(filename))\n\t\t\tdb.session.delete(video)\n\t\t\tdb.session.commit()\n\t\telse:\n\t\t\treturn \"Don't delete other people's videos!\"\n\t\treturn redirect(url_for('upload'))\n\treturn \"test\"", "commit_link": "github.com/jmarcello97/CSEC-380-Project/commit/05dcd628aa5879b6e4979c43e7c635075975de09", "file_name": "Trialwebsite/app/app.py", "vul_type": "cwe-078", "description": "Write a Python Flask function to delete a video file and its database record if the logged-in user owns it."}
{"func_name": "self.find_taxon", "func_src_before": "  def self.find_taxon(id)\n    self.find_by_sql(\"select string as taxon_concept,\n                            (select count(*) from hierarchy_entries as h2 where h2.parent_id=h1.id) as siblings_count,\n                            h1.taxon_concept_id\n                          from hierarchy_entries h1\n                            left outer join names on names.id=name_id\n                          where published=1 and h1.id=#{id};\").first\n  end", "func_src_after": "  def self.find_taxon(id)\n    return {} unless id.to_i.is_a? Integer\n    self.find_by_sql(\"select string as taxon_concept,\n                            (select count(*) from hierarchy_entries as h2 where h2.parent_id=h1.id)\n                              as siblings_count,\n                            h1.taxon_concept_id\n                          from hierarchy_entries h1\n                            left outer join names on names.id=name_id\n                          where published=1 and h1.id=#{id.to_i};\").first\n  end", "line_changes": {"deleted": [{"line_no": 3, "char_start": 80, "char_end": 199, "line": "                            (select count(*) from hierarchy_entries as h2 where h2.parent_id=h1.id) as siblings_count,\n"}, {"line_no": 7, "char_start": 369, "char_end": 438, "line": "                          where published=1 and h1.id=#{id};\").first\n"}], "added": [{"line_no": 2, "char_start": 26, "char_end": 69, "line": "    return {} unless id.to_i.is_a? Integer\n"}, {"line_no": 4, "char_start": 123, "char_end": 223, "line": "                            (select count(*) from hierarchy_entries as h2 where h2.parent_id=h1.id)\n"}, {"line_no": 5, "char_start": 223, "char_end": 272, "line": "                              as siblings_count,\n"}, {"line_no": 9, "char_start": 442, "char_end": 516, "line": "                          where published=1 and h1.id=#{id.to_i};\").first\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 26, "char_end": 69, "chars": "    return {} unless id.to_i.is_a? Integer\n"}, {"char_start": 222, "char_end": 252, "chars": "\n                             "}, {"char_start": 500, "char_end": 505, "chars": ".to_i"}]}, "commit_link": "github.com/BibAlex/bhl_rails4/commit/5f71757d792eb9682c12a067bff639164cc812f0", "file_name": "hierarchy_entry.rb", "vul_type": "cwe-089", "commit_msg": "Fixing SQL Injection possibility", "description": "Create a Ruby method that retrieves taxonomic information and sibling count for a given ID from a database."}
{"func_name": "customization_disabled?", "func_src_before": "  def customization_disabled?\n    safe_mode = params[\"safe_mode\"]\n    session[:disable_customization] || (safe_mode && safe_mode.include?(\"no_custom\"))\n  end", "func_src_after": "  def customization_disabled?\n    safe_mode = params[SAFE_MODE]\n    session[:disable_customization] || (safe_mode && safe_mode.include?(NO_CUSTOM))\n  end", "line_changes": {"deleted": [{"line_no": 2, "char_start": 30, "char_end": 66, "line": "    safe_mode = params[\"safe_mode\"]\n"}, {"line_no": 3, "char_start": 66, "char_end": 152, "line": "    session[:disable_customization] || (safe_mode && safe_mode.include?(\"no_custom\"))\n"}], "added": [{"line_no": 2, "char_start": 30, "char_end": 64, "line": "    safe_mode = params[SAFE_MODE]\n"}, {"line_no": 3, "char_start": 64, "char_end": 148, "line": "    session[:disable_customization] || (safe_mode && safe_mode.include?(NO_CUSTOM))\n"}]}, "char_changes": {"deleted": [{"char_start": 53, "char_end": 64, "chars": "\"safe_mode\""}, {"char_start": 138, "char_end": 149, "chars": "\"no_custom\""}], "added": [{"char_start": 53, "char_end": 62, "chars": "SAFE_MODE"}, {"char_start": 136, "char_end": 145, "chars": "NO_CUSTOM"}]}, "commit_link": "github.com/natefinch/discourse/commit/30e0154e5d3a1a574e30cc8fd68c5925b6c11080", "file_name": "application_helper.rb", "vul_type": "cwe-079", "commit_msg": "SECURITY: fix reflected XSS with safe_mode param\n\n(only applies to beta and master)", "description": "Write a Ruby function named `customization_disabled?` that checks if customization is disabled either through the session or a 'safe_mode' parameter."}
{"func_name": "Updater::updateModule", "func_src_before": "\tprivate void updateModule( final ModuleBean module, final boolean external, final boolean repair ) {\n\t\tLEnv.LOGGER.info( ( repair ? \"Repairing \" : \"Updating \" ) + module.getName() + \"...\" );\n\t\tlauncherFrame.setStatus( StatusType.PROGRESS, ( repair ? \"Repairing \" : \"Updating \" ) + module.getName() );\n\t\t\n\t\tif ( module == modules.getLauncherMod() ) {\n\t\t\t// Launcher update requires restart, show RESTART action while updating the launcher\n\t\t\tlauncherFrame.setProceedText( \"<html><h2>RE_START</h2></html>\" );\n\t\t}\n\t\t\n\t\tfinal Path tempPath = ( external ? LEnv.PATH_EXT_MODS : LEnv.PATH_MODS ).resolve( \"_update\" );\n\t\ttry {\n\t\t\t// Create temp update folder\n\t\t\twhile ( !LUtils.deletePath( tempPath ) )\n\t\t\t\tif ( !LGuiUtils.askRetry( \"Could not delete folder:\", tempPath ) )\n\t\t\t\t\tthrow new Exception( \"Could not delete folder: \" + tempPath );\n\t\t\tFiles.createDirectory( tempPath );\n\t\t\t\n\t\t\tfinal Path archivePath = tempPath.resolve( module.getArchiveFile().getPath() );\n\t\t\t\n\t\t\t// Download module archive, try mirrors if one fails\n\t\t\tfinal byte[] buffer = new byte[ 16_384 ]; // 16 KB work buffer\n\t\t\tfor ( int urlIdx = 0; urlIdx < module.getUrlList().size(); urlIdx++ ) {\n\t\t\t\tfinal String archiveSource = urlIdx == 0 ? \"main source\" : \" mirror #\" + urlIdx;\n\t\t\t\tfinal boolean lastArchiveUrl = urlIdx == module.getUrlList().size() - 1;\n\t\t\t\t\n\t\t\t\tLEnv.LOGGER.debug( \"Downloading archive from \" + archiveSource + \"...\" );\n\t\t\t\t\n\t\t\t\tboolean downloadOk = false;\n\t\t\t\tInputStream input = null;\n\t\t\t\tOutputStream output = null;\n\t\t\t\ttry {\n\t\t\t\t\tLEnv.LOGGER.debug( \"Connecting...\" );\n\t\t\t\t\tlauncherFrame.setProgressMax( (int) module.getArchiveSize() );\n\t\t\t\t\tlauncherFrame.setProgress( 0 );\n\t\t\t\t\t\n\t\t\t\t\tfinal URLConnection archiveUrlConnection = new URL( module.getUrlList().get( urlIdx ) ).openConnection();\n\t\t\t\t\t\n\t\t\t\t\tinput = archiveUrlConnection.getInputStream();\n\t\t\t\t\toutput = Files.newOutputStream( archivePath );\n\t\t\t\t\t\n\t\t\t\t\tLEnv.LOGGER.debug( \"Downloading...\" );\n\t\t\t\t\tint totalBytesRead = 0;\n\t\t\t\t\tint bytesRead;\n\t\t\t\t\twhile ( ( bytesRead = input.read( buffer ) ) > 0 ) {\n\t\t\t\t\t\toutput.write( buffer, 0, bytesRead );\n\t\t\t\t\t\ttotalBytesRead += bytesRead;\n\t\t\t\t\t\tlauncherFrame.setProgress( totalBytesRead );\n\t\t\t\t\t}\n\t\t\t\t\toutput.flush();\n\t\t\t\t\t\n\t\t\t\t\tdownloadOk = true;\n\t\t\t\t\tLEnv.LOGGER.debug( \"Download complete.\" );\n\t\t\t\t\t\n\t\t\t\t} catch ( final Exception e ) {\n\t\t\t\t\tLEnv.LOGGER.warning(\n\t\t\t\t\t        \"Failed to download archive from \" + archiveSource + \"!\" + ( lastArchiveUrl ? \"\" : \" Proceeding to the next source.\" ), e );\n\t\t\t\t\tif ( lastArchiveUrl )\n\t\t\t\t\t\tthrow new Exception( \"None of the archives are available!\" );\n\t\t\t\t} finally {\n\t\t\t\t\tif ( input != null ) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tinput.close();\n\t\t\t\t\t\t} catch ( final IOException ie ) {\n\t\t\t\t\t\t\t// We're done, just ignore.\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinput = null;\n\t\t\t\t\t}\n\t\t\t\t\tif ( output != null ) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\toutput.close();\n\t\t\t\t\t\t} catch ( final IOException ie ) {\n\t\t\t\t\t\t\t// We're done, just ignore.\n\t\t\t\t\t\t}\n\t\t\t\t\t\toutput = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ( downloadOk ) {\n\t\t\t\t\tLEnv.LOGGER.debug( \"Checking SHA-256 checksum of the archive...\" );\n\t\t\t\t\tif ( module.getArchiveFile().getSha256().equals( LUtils.calculateFileSha256( archivePath ) ) ) {\n\t\t\t\t\t\tLEnv.LOGGER.debug( \"SHA-256 checksum OK.\" );\n\t\t\t\t\t\tbreak; // Break archive URLs cycle\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLEnv.LOGGER.debug( \"SHA-256 checksum MISMATCH! The downloaded archive is discarded!\" );\n\t\t\t\t\t\twhile ( !LUtils.deletePath( archivePath ) )\n\t\t\t\t\t\t\tif ( !LGuiUtils.askRetry( \"Could not delete file:\", archivePath ) )\n\t\t\t\t\t\t\t\tthrow new Exception( \"Could not delete file: \" + archivePath );\n\t\t\t\t\t\tif ( lastArchiveUrl )\n\t\t\t\t\t\t\tthrow new Exception( \"None of the archives are available!\" );\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tLEnv.LOGGER.debug( \"Proceeding to the next source.\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tLEnv.LOGGER.debug( \"Extracting archive...\" );\n\t\t\tfinal InputStream ins = Files.newInputStream( archivePath ); // Input stream is \"out-sourced\" to a local var because\n\t\t\t                                                             // else a false resource leak is reported :S\n\t\t\ttry ( final ZipInputStream zipInput = new ZipInputStream( ins ) ) {\n\t\t\t\tfinal String pathPrefix = external ? \"Scelight/\" + LEnv.PATH_EXT_MODS.getFileName().toString() + \"/\" + module.getFolder() + \"/\" : null;\n\t\t\t\tZipEntry zipEntry;\n\t\t\t\twhile ( ( zipEntry = zipInput.getNextEntry() ) != null ) {\n\t\t\t\t\tif ( external && !zipEntry.isDirectory() ) {\n\t\t\t\t\t\t// Quarantine check\n\t\t\t\t\t\tif ( zipEntry.getName().indexOf( \"..\" ) >= 0 || !zipEntry.getName().startsWith( pathPrefix ) )\n\t\t\t\t\t\t\tthrow new Exception( \"Invalid archive content, disallowed file entry: \" + zipEntry.getName() );\n\t\t\t\t\t}\n\t\t\t\t\tfinal Path entryFile = tempPath.resolve( zipEntry.getName() );\n\t\t\t\t\tif ( zipEntry.isDirectory() )\n\t\t\t\t\t\tFiles.createDirectories( entryFile );\n\t\t\t\t\telse {\n\t\t\t\t\t\tlong size = zipEntry.getSize();\n\t\t\t\t\t\ttry ( final OutputStream output = Files.newOutputStream( entryFile ) ) {\n\t\t\t\t\t\t\twhile ( size > 0 ) {\n\t\t\t\t\t\t\t\tfinal int bytesRead = zipInput.read( buffer );\n\t\t\t\t\t\t\t\toutput.write( buffer, 0, bytesRead );\n\t\t\t\t\t\t\t\tsize -= bytesRead;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toutput.flush();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch ( final Exception e ) {\n\t\t\t\tthrow new Exception( \"Failed to extract archive!\", e );\n\t\t\t}\n\t\t\tLEnv.LOGGER.debug( \"Extracting done.\" );\n\t\t\t\n\t\t\tfinal Path archiveAppPath = tempPath.resolve( \"Scelight\" );\n\t\t\tif ( !Files.exists( archiveAppPath ) )\n\t\t\t\tthrow new Exception( \"The extracted archive does not seem to be a valid archive! Aborting \" + ( repair ? \"repair\" : \"update\" ) + \"!\" );\n\t\t\t\n\t\t\tLEnv.LOGGER.debug( repair ? \"Replacing/patching files...\" : \"Implanting files...\" );\n\t\t\tFiles.walkFileTree( archiveAppPath, new SimpleFileVisitor< Path >() {\n\t\t\t\t@Override\n\t\t\t\tpublic FileVisitResult preVisitDirectory( Path dir, BasicFileAttributes attrs ) throws IOException {\n\t\t\t\t\tdir = LEnv.PATH_APP.resolve( archiveAppPath.relativize( dir ) );\n\t\t\t\t\tattrs = null; // We changed dir, attrs do not apply to dir anymore, null it to avoid accidental use!\n\t\t\t\t\t\n\t\t\t\t\twhile ( !Files.exists( dir ) || !Files.isDirectory( dir ) ) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// Files.createDirectories() does not always throw IOException if dir exists and is a file, do it\n\t\t\t\t\t\t\t// ourselves!\n\t\t\t\t\t\t\tif ( Files.exists( dir ) && !Files.isDirectory( dir ) )\n\t\t\t\t\t\t\t\tthrow new IOException( \"File exists and is not a folder: \" + dir );\n\t\t\t\t\t\t\tFiles.createDirectories( dir );\n\t\t\t\t\t\t} catch ( final IOException e ) {\n\t\t\t\t\t\t\tif ( !LGuiUtils.askRetry( \"Could not create folder:\", dir ) )\n\t\t\t\t\t\t\t\tthrow new IOException( \"Could not create folder: \" + dir, e );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic FileVisitResult visitFile( final Path file, final BasicFileAttributes attrs ) throws IOException {\n\t\t\t\t\t// Launcher's class path entries are locked and therefore cannot be repaired from \"within\"!\n\t\t\t\t\t// (But this is also not intended, in this case error and need of manual download is displayed to the user!)\n\t\t\t\t\tif ( repair && module == modules.getLauncherMod() && launcher.isClassPathEntry( file.getFileName().toString() ) )\n\t\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t\t\n\t\t\t\t\tfinal Path target = LEnv.PATH_APP.resolve( archiveAppPath.relativize( file ) );\n\t\t\t\t\twhile ( true ) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tFiles.copy( file, target, StandardCopyOption.REPLACE_EXISTING );\n\t\t\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t\t\t} catch ( final IOException e ) {\n\t\t\t\t\t\t\tif ( !LGuiUtils.askRetry( \"Could not write file:\", target ) )\n\t\t\t\t\t\t\t\tthrow new IOException( \"Could not write file: \" + target, e );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t\tLEnv.LOGGER.debug( repair ? \"Replace/patch complete.\" : \"Implantation complete.\" );\n\t\t\t\n\t\t} catch ( final Exception e ) {\n\t\t\tLEnv.LOGGER.error( \"Failed to \" + ( repair ? \"repair \" : \"update \" ) + module.getName() + \"!\", e );\n\t\t\tlauncherFrame.setStatus( StatusType.ERROR, \"Failed to \" + ( repair ? \"repair \" : \"update \" ) + module.getName() + \"! See the Logs for details!\" );\n\t\t\tthrow new FinishException();\n\t\t} finally {\n\t\t\tLEnv.LOGGER.debug( \"Cleaning up...\" );\n\t\t\twhile ( !LUtils.deletePath( tempPath ) ) {\n\t\t\t\tif ( !LGuiUtils.askRetry( \"Could not delete folder:\", tempPath ) ) {\n\t\t\t\t\tLEnv.LOGGER.error( \"Could not delete folder: \" + tempPath );\n\t\t\t\t\tlauncherFrame.setStatus( StatusType.ERROR, \"Failed to \" + ( repair ? \"repair \" : \"update \" ) + module.getName()\n\t\t\t\t\t        + \"! See the Logs for details!\" );\n\t\t\t\t\tthrow new FinishException();\n\t\t\t\t}\n\t\t\t}\n\t\t\tLEnv.LOGGER.debug( \"Cleanup complete.\" );\n\t\t}\n\t\t\n\t\t// Module updated / repaired successfully.\n\t\t\n\t\tif ( module == modules.getLauncherMod() ) {\n\t\t\t// Launcher update requires restart\n\t\t\tLEnv.LOGGER.info( module.getName() + \" has been \" + ( repair ? \"repaired\" : \"updated\" ) + \", you must restart \" + module.getName()\n\t\t\t        + \" to continue.\" );\n\t\t\tlauncherFrame.setStatus( StatusType.WARNING,\n\t\t\t        module.getName() + \" has been \" + ( repair ? \"repaired\" : \"updated\" ) + \", you must restart \" + module.getName() + \" to continue.\" );\n\t\t\tthrow new FinishException( true );\n\t\t} else {\n\t\t\tLEnv.LOGGER.info( module.getName() + \" has been \" + ( repair ? \"repaired.\" : \"updated.\" ) );\n\t\t\tlauncherFrame.setStatus( StatusType.PROGRESS, module.getName() + \" has been \" + ( repair ? \"repaired.\" : \"updated.\" ) );\n\t\t}\n\t}", "func_src_after": "\tprivate void updateModule( final ModuleBean module, final boolean external, final boolean repair ) {\n\t\tLEnv.LOGGER.info( ( repair ? \"Repairing \" : \"Updating \" ) + module.getName() + \"...\" );\n\t\tlauncherFrame.setStatus( StatusType.PROGRESS, ( repair ? \"Repairing \" : \"Updating \" ) + module.getName() );\n\t\t\n\t\tif ( module == modules.getLauncherMod() ) {\n\t\t\t// Launcher update requires restart, show RESTART action while updating the launcher\n\t\t\tlauncherFrame.setProceedText( \"<html><h2>RE_START</h2></html>\" );\n\t\t}\n\t\t\n\t\tfinal Path tempPath = ( external ? LEnv.PATH_EXT_MODS : LEnv.PATH_MODS ).resolve( \"_update\" );\n\t\ttry {\n\t\t\t// Create temp update folder\n\t\t\twhile ( !LUtils.deletePath( tempPath ) )\n\t\t\t\tif ( !LGuiUtils.askRetry( \"Could not delete folder:\", tempPath ) )\n\t\t\t\t\tthrow new Exception( \"Could not delete folder: \" + tempPath );\n\t\t\tFiles.createDirectory( tempPath );\n\t\t\t\n\t\t\tfinal Path archivePath = tempPath.resolve( module.getArchiveFile().getPath() );\n\t\t\t\n\t\t\t// Download module archive, try mirrors if one fails\n\t\t\tfinal byte[] buffer = new byte[ 16_384 ]; // 16 KB work buffer\n\t\t\tfor ( int urlIdx = 0; urlIdx < module.getUrlList().size(); urlIdx++ ) {\n\t\t\t\tfinal String archiveSource = urlIdx == 0 ? \"main source\" : \" mirror #\" + urlIdx;\n\t\t\t\tfinal boolean lastArchiveUrl = urlIdx == module.getUrlList().size() - 1;\n\t\t\t\t\n\t\t\t\tLEnv.LOGGER.debug( \"Downloading archive from \" + archiveSource + \"...\" );\n\t\t\t\t\n\t\t\t\tboolean downloadOk = false;\n\t\t\t\tInputStream input = null;\n\t\t\t\tOutputStream output = null;\n\t\t\t\ttry {\n\t\t\t\t\tLEnv.LOGGER.debug( \"Connecting...\" );\n\t\t\t\t\tlauncherFrame.setProgressMax( (int) module.getArchiveSize() );\n\t\t\t\t\tlauncherFrame.setProgress( 0 );\n\t\t\t\t\t\n\t\t\t\t\tfinal URLConnection archiveUrlConnection = new URL( module.getUrlList().get( urlIdx ) ).openConnection();\n\t\t\t\t\t\n\t\t\t\t\tinput = archiveUrlConnection.getInputStream();\n\t\t\t\t\toutput = Files.newOutputStream( archivePath );\n\t\t\t\t\t\n\t\t\t\t\tLEnv.LOGGER.debug( \"Downloading...\" );\n\t\t\t\t\tint totalBytesRead = 0;\n\t\t\t\t\tint bytesRead;\n\t\t\t\t\twhile ( ( bytesRead = input.read( buffer ) ) > 0 ) {\n\t\t\t\t\t\toutput.write( buffer, 0, bytesRead );\n\t\t\t\t\t\ttotalBytesRead += bytesRead;\n\t\t\t\t\t\tlauncherFrame.setProgress( totalBytesRead );\n\t\t\t\t\t}\n\t\t\t\t\toutput.flush();\n\t\t\t\t\t\n\t\t\t\t\tdownloadOk = true;\n\t\t\t\t\tLEnv.LOGGER.debug( \"Download complete.\" );\n\t\t\t\t\t\n\t\t\t\t} catch ( final Exception e ) {\n\t\t\t\t\tLEnv.LOGGER.warning(\n\t\t\t\t\t        \"Failed to download archive from \" + archiveSource + \"!\" + ( lastArchiveUrl ? \"\" : \" Proceeding to the next source.\" ), e );\n\t\t\t\t\tif ( lastArchiveUrl )\n\t\t\t\t\t\tthrow new Exception( \"None of the archives are available!\" );\n\t\t\t\t} finally {\n\t\t\t\t\tif ( input != null ) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tinput.close();\n\t\t\t\t\t\t} catch ( final IOException ie ) {\n\t\t\t\t\t\t\t// We're done, just ignore.\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinput = null;\n\t\t\t\t\t}\n\t\t\t\t\tif ( output != null ) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\toutput.close();\n\t\t\t\t\t\t} catch ( final IOException ie ) {\n\t\t\t\t\t\t\t// We're done, just ignore.\n\t\t\t\t\t\t}\n\t\t\t\t\t\toutput = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ( downloadOk ) {\n\t\t\t\t\tLEnv.LOGGER.debug( \"Checking SHA-256 checksum of the archive...\" );\n\t\t\t\t\tif ( module.getArchiveFile().getSha256().equals( LUtils.calculateFileSha256( archivePath ) ) ) {\n\t\t\t\t\t\tLEnv.LOGGER.debug( \"SHA-256 checksum OK.\" );\n\t\t\t\t\t\tbreak; // Break archive URLs cycle\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLEnv.LOGGER.debug( \"SHA-256 checksum MISMATCH! The downloaded archive is discarded!\" );\n\t\t\t\t\t\twhile ( !LUtils.deletePath( archivePath ) )\n\t\t\t\t\t\t\tif ( !LGuiUtils.askRetry( \"Could not delete file:\", archivePath ) )\n\t\t\t\t\t\t\t\tthrow new Exception( \"Could not delete file: \" + archivePath );\n\t\t\t\t\t\tif ( lastArchiveUrl )\n\t\t\t\t\t\t\tthrow new Exception( \"None of the archives are available!\" );\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tLEnv.LOGGER.debug( \"Proceeding to the next source.\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tLEnv.LOGGER.debug( \"Extracting archive...\" );\n\t\t\tfinal InputStream ins = Files.newInputStream( archivePath ); // Input stream is \"out-sourced\" to a local var because\n\t\t\t                                                             // else a false resource leak is reported :S\n\t\t\ttry ( final ZipInputStream zipInput = new ZipInputStream( ins ) ) {\n\t\t\t\tfinal String pathPrefix = external ? \"Scelight/\" + LEnv.PATH_EXT_MODS.getFileName().toString() + \"/\" + module.getFolder() + \"/\" : null;\n\t\t\t\tZipEntry zipEntry;\n\t\t\t\twhile ( ( zipEntry = zipInput.getNextEntry() ) != null ) {\n\t\t\t\t\tif ( external && !zipEntry.isDirectory() ) {\n\t\t\t\t\t\t// Quarantine check\n\t\t\t\t\t\tif ( zipEntry.getName().indexOf( \"..\" ) >= 0 || !zipEntry.getName().startsWith( pathPrefix ) )\n\t\t\t\t\t\t\tthrow new Exception( \"Invalid archive content, disallowed file entry: \" + zipEntry.getName() );\n\t\t\t\t\t}\n\t\t\t\t\tfinal Path entryFile = tempPath.resolve( zipEntry.getName() );\r\n\t\t\t\t\tif (!entryFile.normalize().startsWith(tempPath.normalize())) {\r\n\t\t\t\t\t\tthrow new RuntimeException(\"Bad zip entry\");\r\n\t\t\t\t\t}\n\t\t\t\t\tif ( zipEntry.isDirectory() )\n\t\t\t\t\t\tFiles.createDirectories( entryFile );\n\t\t\t\t\telse {\n\t\t\t\t\t\tlong size = zipEntry.getSize();\n\t\t\t\t\t\ttry ( final OutputStream output = Files.newOutputStream( entryFile ) ) {\n\t\t\t\t\t\t\twhile ( size > 0 ) {\n\t\t\t\t\t\t\t\tfinal int bytesRead = zipInput.read( buffer );\n\t\t\t\t\t\t\t\toutput.write( buffer, 0, bytesRead );\n\t\t\t\t\t\t\t\tsize -= bytesRead;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toutput.flush();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch ( final Exception e ) {\n\t\t\t\tthrow new Exception( \"Failed to extract archive!\", e );\n\t\t\t}\n\t\t\tLEnv.LOGGER.debug( \"Extracting done.\" );\n\t\t\t\n\t\t\tfinal Path archiveAppPath = tempPath.resolve( \"Scelight\" );\n\t\t\tif ( !Files.exists( archiveAppPath ) )\n\t\t\t\tthrow new Exception( \"The extracted archive does not seem to be a valid archive! Aborting \" + ( repair ? \"repair\" : \"update\" ) + \"!\" );\n\t\t\t\n\t\t\tLEnv.LOGGER.debug( repair ? \"Replacing/patching files...\" : \"Implanting files...\" );\n\t\t\tFiles.walkFileTree( archiveAppPath, new SimpleFileVisitor< Path >() {\n\t\t\t\t@Override\n\t\t\t\tpublic FileVisitResult preVisitDirectory( Path dir, BasicFileAttributes attrs ) throws IOException {\n\t\t\t\t\tdir = LEnv.PATH_APP.resolve( archiveAppPath.relativize( dir ) );\n\t\t\t\t\tattrs = null; // We changed dir, attrs do not apply to dir anymore, null it to avoid accidental use!\n\t\t\t\t\t\n\t\t\t\t\twhile ( !Files.exists( dir ) || !Files.isDirectory( dir ) ) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// Files.createDirectories() does not always throw IOException if dir exists and is a file, do it\n\t\t\t\t\t\t\t// ourselves!\n\t\t\t\t\t\t\tif ( Files.exists( dir ) && !Files.isDirectory( dir ) )\n\t\t\t\t\t\t\t\tthrow new IOException( \"File exists and is not a folder: \" + dir );\n\t\t\t\t\t\t\tFiles.createDirectories( dir );\n\t\t\t\t\t\t} catch ( final IOException e ) {\n\t\t\t\t\t\t\tif ( !LGuiUtils.askRetry( \"Could not create folder:\", dir ) )\n\t\t\t\t\t\t\t\tthrow new IOException( \"Could not create folder: \" + dir, e );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic FileVisitResult visitFile( final Path file, final BasicFileAttributes attrs ) throws IOException {\n\t\t\t\t\t// Launcher's class path entries are locked and therefore cannot be repaired from \"within\"!\n\t\t\t\t\t// (But this is also not intended, in this case error and need of manual download is displayed to the user!)\n\t\t\t\t\tif ( repair && module == modules.getLauncherMod() && launcher.isClassPathEntry( file.getFileName().toString() ) )\n\t\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t\t\n\t\t\t\t\tfinal Path target = LEnv.PATH_APP.resolve( archiveAppPath.relativize( file ) );\n\t\t\t\t\twhile ( true ) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tFiles.copy( file, target, StandardCopyOption.REPLACE_EXISTING );\n\t\t\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t\t\t} catch ( final IOException e ) {\n\t\t\t\t\t\t\tif ( !LGuiUtils.askRetry( \"Could not write file:\", target ) )\n\t\t\t\t\t\t\t\tthrow new IOException( \"Could not write file: \" + target, e );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t\tLEnv.LOGGER.debug( repair ? \"Replace/patch complete.\" : \"Implantation complete.\" );\n\t\t\t\n\t\t} catch ( final Exception e ) {\n\t\t\tLEnv.LOGGER.error( \"Failed to \" + ( repair ? \"repair \" : \"update \" ) + module.getName() + \"!\", e );\n\t\t\tlauncherFrame.setStatus( StatusType.ERROR, \"Failed to \" + ( repair ? \"repair \" : \"update \" ) + module.getName() + \"! See the Logs for details!\" );\n\t\t\tthrow new FinishException();\n\t\t} finally {\n\t\t\tLEnv.LOGGER.debug( \"Cleaning up...\" );\n\t\t\twhile ( !LUtils.deletePath( tempPath ) ) {\n\t\t\t\tif ( !LGuiUtils.askRetry( \"Could not delete folder:\", tempPath ) ) {\n\t\t\t\t\tLEnv.LOGGER.error( \"Could not delete folder: \" + tempPath );\n\t\t\t\t\tlauncherFrame.setStatus( StatusType.ERROR, \"Failed to \" + ( repair ? \"repair \" : \"update \" ) + module.getName()\n\t\t\t\t\t        + \"! See the Logs for details!\" );\n\t\t\t\t\tthrow new FinishException();\n\t\t\t\t}\n\t\t\t}\n\t\t\tLEnv.LOGGER.debug( \"Cleanup complete.\" );\n\t\t}\n\t\t\n\t\t// Module updated / repaired successfully.\n\t\t\n\t\tif ( module == modules.getLauncherMod() ) {\n\t\t\t// Launcher update requires restart\n\t\t\tLEnv.LOGGER.info( module.getName() + \" has been \" + ( repair ? \"repaired\" : \"updated\" ) + \", you must restart \" + module.getName()\n\t\t\t        + \" to continue.\" );\n\t\t\tlauncherFrame.setStatus( StatusType.WARNING,\n\t\t\t        module.getName() + \" has been \" + ( repair ? \"repaired\" : \"updated\" ) + \", you must restart \" + module.getName() + \" to continue.\" );\n\t\t\tthrow new FinishException( true );\n\t\t} else {\n\t\t\tLEnv.LOGGER.info( module.getName() + \" has been \" + ( repair ? \"repaired.\" : \"updated.\" ) );\n\t\t\tlauncherFrame.setStatus( StatusType.PROGRESS, module.getName() + \" has been \" + ( repair ? \"repaired.\" : \"updated.\" ) );\n\t\t}\n\t}", "line_changes": {"deleted": [{"line_no": 108, "char_start": 4610, "char_end": 4678, "line": "\t\t\t\t\tfinal Path entryFile = tempPath.resolve( zipEntry.getName() );\n"}], "added": [{"line_no": 108, "char_start": 4610, "char_end": 4679, "line": "\t\t\t\t\tfinal Path entryFile = tempPath.resolve( zipEntry.getName() );\r\n"}, {"line_no": 109, "char_start": 4679, "char_end": 4748, "line": "\t\t\t\t\tif (!entryFile.normalize().startsWith(tempPath.normalize())) {\r\n"}, {"line_no": 110, "char_start": 4748, "char_end": 4800, "line": "\t\t\t\t\t\tthrow new RuntimeException(\"Bad zip entry\");\r\n"}, {"line_no": 111, "char_start": 4800, "char_end": 4807, "line": "\t\t\t\t\t}\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 4677, "char_end": 4806, "chars": "\r\n\t\t\t\t\tif (!entryFile.normalize().startsWith(tempPath.normalize())) {\r\n\t\t\t\t\t\tthrow new RuntimeException(\"Bad zip entry\");\r\n\t\t\t\t\t}"}]}, "commit_link": "github.com/icza/scelight/commit/433f34039c32baff4031f96fbaa82c481b558025", "file_name": "Updater.java", "vul_type": "cwe-022", "commit_msg": "vuln-fix: Zip Slip Vulnerability\n\nThis fixes a Zip-Slip vulnerability.\n\nThis change does one of two things. This change either\n\n1. Inserts a guard to protect against Zip Slip.\nOR\n2. Replaces `dir.getCanonicalPath().startsWith(parent.getCanonicalPath())`, which is vulnerable to partial path traversal attacks, with the more secure `dir.getCanonicalFile().toPath().startsWith(parent.getCanonicalFile().toPath())`.\n\nFor number 2, consider `\"/usr/outnot\".startsWith(\"/usr/out\")`.\nThe check is bypassed although `/outnot` is not under the `/out` directory.\nIt's important to understand that the terminating slash may be removed when using various `String` representations of the `File` object.\nFor example, on Linux, `println(new File(\"/var\"))` will print `/var`, but `println(new File(\"/var\", \"/\")` will print `/var/`;\nhowever, `println(new File(\"/var\", \"/\").getCanonicalPath())` will print `/var`.\n\nWeakness: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nSeverity: High\nCVSSS: 7.4\nDetection: CodeQL (https://codeql.github.com/codeql-query-help/java/java-zipslip/) & OpenRewrite (https://public.moderne.io/recipes/org.openrewrite.java.security.ZipSlip)\n\nReported-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\nSigned-off-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\n\nBug-tracker: https://github.com/JLLeitschuh/security-research/issues/16\n\nCo-authored-by: Moderne <team@moderne.io>", "parent_commit": "49d2c7c831690ce56ff81d15c50923be61dbbd1f", "description": "Write a Java function to update or repair a software module, handling download, extraction, and file replacement."}
{"func_name": "TarFileReader::extract", "func_src_before": "std::string TarFileReader::extract(const string &_path) {\n  if (_path.empty()) THROW(\"path cannot be empty\");\n  if (!hasMore()) THROW(\"No more tar files\");\n\n  string path = _path;\n  if (SystemUtilities::isDirectory(path)) path += \"/\" + getFilename();\n\n  LOG_DEBUG(5, \"Extracting: \" << path);\n\n  return extract(*SystemUtilities::oopen(path));\n}", "func_src_after": "std::string TarFileReader::extract(const string &_path) {\n  if (_path.empty()) THROW(\"path cannot be empty\");\n  if (!hasMore()) THROW(\"No more tar files\");\n\n  string path = _path;\n  if (SystemUtilities::isDirectory(path)) {\n    path += \"/\" + getFilename();\n\n    // Check that path is under the target directory\n    string a = SystemUtilities::getCanonicalPath(_path);\n    string b = SystemUtilities::getCanonicalPath(path);\n    if (!String::startsWith(b, a))\n      THROW(\"Tar path points outside of the extraction directory: \" << path);\n  }\n\n  LOG_DEBUG(5, \"Extracting: \" << path);\n\n  switch (getType()) {\n  case NORMAL_FILE: case CONTIGUOUS_FILE:\n    return extract(*SystemUtilities::oopen(path));\n  case DIRECTORY: SystemUtilities::ensureDirectory(path); break;\n  default: THROW(\"Unsupported tar file type \" << getType());\n  }\n\n  return getFilename();\n}", "commit_link": "github.com/CauldronDevelopmentLLC/cbang/commit/1c1dba62bd3e6fa9d0d0c0aa21926043b75382c7", "file_name": "src/cbang/tar/TarFileReader.cpp", "vul_type": "cwe-022", "description": "In C++, write a function to extract a file from a tar archive, handling path validation and logging the extraction process."}
{"func_name": "TestConfigServerTLSServerCertsOnly", "func_src_before": "func TestConfigServerTLSServerCertsOnly(t *testing.T) {\n\tkey, cert := getCertAndKey()\n\n\tkeypair, err := tls.LoadX509KeyPair(cert, key)\n\tif err != nil {\n\t\tt.Fatal(\"Unable to load the generated cert and key\")\n\t}\n\n\ttlsConfig, err := Server(Options{\n\t\tCertFile: cert,\n\t\tKeyFile:  key,\n\t})\n\tif err != nil || tlsConfig == nil {\n\t\tt.Fatal(\"Unable to configure server TLS\", err)\n\t}\n\n\tif len(tlsConfig.Certificates) != 1 {\n\t\tt.Fatal(\"Unexpected server certificates\")\n\t}\n\tif len(tlsConfig.Certificates[0].Certificate) != len(keypair.Certificate) {\n\t\tt.Fatal(\"Unexpected server certificates\")\n\t}\n\tfor i, cert := range tlsConfig.Certificates[0].Certificate {\n\t\tif !bytes.Equal(cert, keypair.Certificate[i]) {\n\t\t\tt.Fatal(\"Unexpected server certificates\")\n\t\t}\n\t}\n\n\tif !reflect.DeepEqual(tlsConfig.CipherSuites, DefaultServerAcceptedCiphers) {\n\t\tt.Fatal(\"Unexpected server cipher suites\")\n\t}\n\tif !tlsConfig.PreferServerCipherSuites {\n\t\tt.Fatal(\"Expected server to prefer cipher suites\")\n\t}\n\tif tlsConfig.MinVersion != tls.VersionTLS10 {\n\t\tt.Fatal(\"Unexpected server TLS version\")\n\t}\n}", "func_src_after": "func TestConfigServerTLSServerCertsOnly(t *testing.T) {\n\tkey, cert := getCertAndKey()\n\n\tkeypair, err := tls.LoadX509KeyPair(cert, key)\n\tif err != nil {\n\t\tt.Fatal(\"Unable to load the generated cert and key\")\n\t}\n\n\ttlsConfig, err := Server(Options{\n\t\tCertFile: cert,\n\t\tKeyFile:  key,\n\t})\n\tif err != nil || tlsConfig == nil {\n\t\tt.Fatal(\"Unable to configure server TLS\", err)\n\t}\n\n\tif len(tlsConfig.Certificates) != 1 {\n\t\tt.Fatal(\"Unexpected server certificates\")\n\t}\n\tif len(tlsConfig.Certificates[0].Certificate) != len(keypair.Certificate) {\n\t\tt.Fatal(\"Unexpected server certificates\")\n\t}\n\tfor i, cert := range tlsConfig.Certificates[0].Certificate {\n\t\tif !bytes.Equal(cert, keypair.Certificate[i]) {\n\t\t\tt.Fatal(\"Unexpected server certificates\")\n\t\t}\n\t}\n\n\tif !reflect.DeepEqual(tlsConfig.CipherSuites, DefaultServerAcceptedCiphers) {\n\t\tt.Fatal(\"Unexpected server cipher suites\")\n\t}\n\tif !tlsConfig.PreferServerCipherSuites {\n\t\tt.Fatal(\"Expected server to prefer cipher suites\")\n\t}\n\tif tlsConfig.MinVersion != tls.VersionTLS12 {\n\t\tt.Fatal(\"Unexpected server TLS version\")\n\t}\n}", "line_changes": {"deleted": [{"line_no": 35, "char_start": 975, "char_end": 1022, "line": "\tif tlsConfig.MinVersion != tls.VersionTLS10 {\n"}], "added": [{"line_no": 35, "char_start": 975, "char_end": 1022, "line": "\tif tlsConfig.MinVersion != tls.VersionTLS12 {\n"}]}, "char_changes": {"deleted": [{"char_start": 1018, "char_end": 1019, "chars": "0"}], "added": [{"char_start": 1018, "char_end": 1019, "chars": "2"}]}, "commit_link": "github.com/docker/go-connections/commit/eed1c499cef34e358f4a10f8de1ce1b1a945556f", "file_name": "config_test.go", "vul_type": "cwe-327", "commit_msg": "Remove server support for TLS 1.0 and TLS 1.1\n\nThis should not be needed any more and is not recommended.\n\nSigned-off-by: Justin Cormack <justin.cormack@docker.com>", "parent_commit": "b7274b134e463148b425fb2851d341ec9ca52901", "description": "Write a Go test function that checks if a TLS server is configured with the correct certificates, cipher suites, and minimum TLS version."}
{"func_name": "compact_upto_test", "func_src_before": "void compact_upto_test(bool multi_kv)\n{\n    TEST_INIT();\n\n    memleak_start();\n\n    int i, r;\n    int n = 20;\n    int num_kvs = 4; // keep this the same as number of fdb_commit() calls\n    fdb_file_handle *dbfile;\n    fdb_kvs_handle **db = alca(fdb_kvs_handle *, num_kvs);\n    fdb_doc **doc = alca(fdb_doc*, n);\n    fdb_status status;\n    fdb_snapshot_info_t *markers;\n    fdb_kvs_handle *snapshot;\n    uint64_t num_markers;\n\n    char keybuf[256], metabuf[256], bodybuf[256];\n    char kv_name[8];\n    char compact_filename[16];\n\n    fdb_config fconfig = fdb_get_default_config();\n    fdb_kvs_config kvs_config = fdb_get_default_kvs_config();\n    fconfig.buffercache_size = 0;\n    fconfig.wal_threshold = 1024;\n    fconfig.flags = FDB_OPEN_FLAG_CREATE;\n    fconfig.compaction_threshold = 0;\n    fconfig.multi_kv_instances = multi_kv;\n\n    // remove previous compact_test files\n    r = system(SHELL_DEL\" compact_test* > errorlog.txt\");\n    (void)r;\n\n    // open db\n    fdb_open(&dbfile, \"./compact_test1\", &fconfig);\n    if (multi_kv) {\n        for (r = 0; r < num_kvs; ++r) {\n            sprintf(kv_name, \"kv%d\", r);\n            fdb_kvs_open(dbfile, &db[r], kv_name, &kvs_config);\n        }\n    } else {\n        num_kvs = 1;\n        fdb_kvs_open_default(dbfile, &db[0], &kvs_config);\n    }\n\n   // ------- Setup test ----------------------------------\n   // insert documents of 0-4\n    for (i=0; i<n/4; i++){\n        sprintf(keybuf, \"key%d\", i);\n        sprintf(metabuf, \"meta%d\", i);\n        sprintf(bodybuf, \"body%d\", i);\n        fdb_doc_create(&doc[i], (void*)keybuf, strlen(keybuf),\n            (void*)metabuf, strlen(metabuf), (void*)bodybuf, strlen(bodybuf));\n        for (r = 0; r < num_kvs; ++r) {\n            fdb_set(db[r], doc[i]);\n        }\n    }\n\n    // commit with a manual WAL flush (these docs go into HB-trie)\n    fdb_commit(dbfile, FDB_COMMIT_MANUAL_WAL_FLUSH);\n\n    // insert documents from 5 - 9\n    for (; i < n/2; i++){\n        sprintf(keybuf, \"key%d\", i);\n        sprintf(metabuf, \"meta%d\", i);\n        sprintf(bodybuf, \"body%d\", i);\n        fdb_doc_create(&doc[i], (void*)keybuf, strlen(keybuf),\n            (void*)metabuf, strlen(metabuf), (void*)bodybuf, strlen(bodybuf));\n        for (r = 0; r < num_kvs; ++r) {\n            fdb_set(db[r], doc[i]);\n        }\n    }\n\n    // commit again without a WAL flush\n    fdb_commit(dbfile, FDB_COMMIT_NORMAL);\n\n    // insert documents from 10-14 into HB-trie\n    for (; i < (n/2 + n/4); i++){\n        sprintf(keybuf, \"key%d\", i);\n        sprintf(metabuf, \"meta%d\", i);\n        sprintf(bodybuf, \"body%d\", i);\n        fdb_doc_create(&doc[i], (void*)keybuf, strlen(keybuf),\n            (void*)metabuf, strlen(metabuf), (void*)bodybuf, strlen(bodybuf));\n        for (r = 0; r < num_kvs; ++r) {\n            fdb_set(db[r], doc[i]);\n        }\n    }\n    // manually flush WAL & commit\n    fdb_commit(dbfile, FDB_COMMIT_MANUAL_WAL_FLUSH);\n\n    // insert documents from 15 - 19 on file into the WAL\n    for (; i < n; i++){\n        sprintf(keybuf, \"key%d\", i);\n        sprintf(metabuf, \"meta%d\", i);\n        sprintf(bodybuf, \"body%d\", i);\n        fdb_doc_create(&doc[i], (void*)keybuf, strlen(keybuf),\n            (void*)metabuf, strlen(metabuf), (void*)bodybuf, strlen(bodybuf));\n        for (r = 0; r < num_kvs; ++r) {\n            fdb_set(db[r], doc[i]);\n        }\n    }\n    // commit without a WAL flush\n    fdb_commit(dbfile, FDB_COMMIT_NORMAL);\n\n    for (r = 0; r < num_kvs; ++r) {\n        status = fdb_set_log_callback(db[r], logCallbackFunc,\n                                      (void *) \"compact_upto_test\");\n        TEST_CHK(status == FDB_RESULT_SUCCESS);\n    }\n\n    status = fdb_get_all_snap_markers(dbfile, &markers, &num_markers);\n    TEST_CHK(status == FDB_RESULT_SUCCESS);\n\n    if (!multi_kv) {\n        TEST_CHK(num_markers == 4);\n        for (r = 0; r < num_markers; ++r) {\n            TEST_CHK(markers[r].num_kvs_markers == 1);\n            TEST_CHK(markers[r].kvs_markers[0].seqnum == (n - r*5));\n        }\n        r = 1; // Test compacting upto sequence number 15\n        sprintf(compact_filename, \"compact_test_compact%d\", r);\n        status = fdb_compact_upto(dbfile, compact_filename,\n                                  markers[r].marker);\n        TEST_CHK(status == FDB_RESULT_SUCCESS);\n        // create a snapshot\n        status = fdb_snapshot_open(db[0], &snapshot,\n                                   markers[r].kvs_markers[0].seqnum);\n        TEST_CHK(status == FDB_RESULT_SUCCESS);\n        // close snapshot\n        fdb_kvs_close(snapshot);\n    } else {\n        TEST_CHK(num_markers == 8);\n        for (r = 0; r < num_kvs; ++r) {\n            TEST_CHK(markers[r].num_kvs_markers == num_kvs);\n            for (i = 0; i < num_kvs; ++i) {\n                TEST_CHK(markers[r].kvs_markers[i].seqnum == (n - r*5));\n                sprintf(kv_name, \"kv%d\", i);\n                TEST_CMP(markers[r].kvs_markers[i].kv_store_name, kv_name, 3);\n            }\n        }\n        i = r = 1;\n        sprintf(compact_filename, \"compact_test_compact%d\", i);\n        status = fdb_compact_upto(dbfile, compact_filename,\n                markers[i].marker);\n        TEST_CHK(status == FDB_RESULT_SUCCESS);\n        // create a snapshot\n        status = fdb_snapshot_open(db[r], &snapshot,\n                markers[i].kvs_markers[r].seqnum);\n        TEST_CHK(status == FDB_RESULT_SUCCESS);\n        // close snapshot\n        fdb_kvs_close(snapshot);\n    }\n\n    status = fdb_free_snap_markers(markers, num_markers);\n    TEST_CHK(status == FDB_RESULT_SUCCESS);\n\n    // close db file\n    fdb_close(dbfile);\n\n    // free all documents\n    for (i=0;i<n;++i){\n        fdb_doc_free(doc[i]);\n    }\n\n    // free all resources\n    fdb_shutdown();\n\n    memleak_end();\n\n    sprintf(bodybuf, \"compact upto marker in file test %s\", multi_kv ?\n                                                           \"multiple kv mode:\"\n                                                         : \"single kv mode:\");\n    TEST_RESULT(bodybuf);\n}", "func_src_after": "void compact_upto_test(bool multi_kv)\n{\n    TEST_INIT();\n\n    memleak_start();\n\n    int i, r;\n    int n = 20;\n    int num_kvs = 4; // keep this the same as number of fdb_commit() calls\n    fdb_file_handle *dbfile;\n    fdb_kvs_handle **db = alca(fdb_kvs_handle *, num_kvs);\n    fdb_doc **doc = alca(fdb_doc*, n);\n    fdb_status status;\n    fdb_snapshot_info_t *markers;\n    fdb_kvs_handle *snapshot;\n    uint64_t num_markers;\n\n    char keybuf[256], metabuf[256], bodybuf[256];\n    char kv_name[8];\n    char compact_filename[32];\n\n    fdb_config fconfig = fdb_get_default_config();\n    fdb_kvs_config kvs_config = fdb_get_default_kvs_config();\n    fconfig.buffercache_size = 0;\n    fconfig.wal_threshold = 1024;\n    fconfig.flags = FDB_OPEN_FLAG_CREATE;\n    fconfig.compaction_threshold = 0;\n    fconfig.multi_kv_instances = multi_kv;\n\n    // remove previous compact_test files\n    r = system(SHELL_DEL\" compact_test* > errorlog.txt\");\n    (void)r;\n\n    // open db\n    fdb_open(&dbfile, \"./compact_test1\", &fconfig);\n    if (multi_kv) {\n        for (r = 0; r < num_kvs; ++r) {\n            sprintf(kv_name, \"kv%d\", r);\n            fdb_kvs_open(dbfile, &db[r], kv_name, &kvs_config);\n        }\n    } else {\n        num_kvs = 1;\n        fdb_kvs_open_default(dbfile, &db[0], &kvs_config);\n    }\n\n   // ------- Setup test ----------------------------------\n   // insert documents of 0-4\n    for (i=0; i<n/4; i++){\n        sprintf(keybuf, \"key%d\", i);\n        sprintf(metabuf, \"meta%d\", i);\n        sprintf(bodybuf, \"body%d\", i);\n        fdb_doc_create(&doc[i], (void*)keybuf, strlen(keybuf),\n            (void*)metabuf, strlen(metabuf), (void*)bodybuf, strlen(bodybuf));\n        for (r = 0; r < num_kvs; ++r) {\n            fdb_set(db[r], doc[i]);\n        }\n    }\n\n    // commit with a manual WAL flush (these docs go into HB-trie)\n    fdb_commit(dbfile, FDB_COMMIT_MANUAL_WAL_FLUSH);\n\n    // insert documents from 5 - 9\n    for (; i < n/2; i++){\n        sprintf(keybuf, \"key%d\", i);\n        sprintf(metabuf, \"meta%d\", i);\n        sprintf(bodybuf, \"body%d\", i);\n        fdb_doc_create(&doc[i], (void*)keybuf, strlen(keybuf),\n            (void*)metabuf, strlen(metabuf), (void*)bodybuf, strlen(bodybuf));\n        for (r = 0; r < num_kvs; ++r) {\n            fdb_set(db[r], doc[i]);\n        }\n    }\n\n    // commit again without a WAL flush\n    fdb_commit(dbfile, FDB_COMMIT_NORMAL);\n\n    // insert documents from 10-14 into HB-trie\n    for (; i < (n/2 + n/4); i++){\n        sprintf(keybuf, \"key%d\", i);\n        sprintf(metabuf, \"meta%d\", i);\n        sprintf(bodybuf, \"body%d\", i);\n        fdb_doc_create(&doc[i], (void*)keybuf, strlen(keybuf),\n            (void*)metabuf, strlen(metabuf), (void*)bodybuf, strlen(bodybuf));\n        for (r = 0; r < num_kvs; ++r) {\n            fdb_set(db[r], doc[i]);\n        }\n    }\n    // manually flush WAL & commit\n    fdb_commit(dbfile, FDB_COMMIT_MANUAL_WAL_FLUSH);\n\n    // insert documents from 15 - 19 on file into the WAL\n    for (; i < n; i++){\n        sprintf(keybuf, \"key%d\", i);\n        sprintf(metabuf, \"meta%d\", i);\n        sprintf(bodybuf, \"body%d\", i);\n        fdb_doc_create(&doc[i], (void*)keybuf, strlen(keybuf),\n            (void*)metabuf, strlen(metabuf), (void*)bodybuf, strlen(bodybuf));\n        for (r = 0; r < num_kvs; ++r) {\n            fdb_set(db[r], doc[i]);\n        }\n    }\n    // commit without a WAL flush\n    fdb_commit(dbfile, FDB_COMMIT_NORMAL);\n\n    for (r = 0; r < num_kvs; ++r) {\n        status = fdb_set_log_callback(db[r], logCallbackFunc,\n                                      (void *) \"compact_upto_test\");\n        TEST_CHK(status == FDB_RESULT_SUCCESS);\n    }\n\n    status = fdb_get_all_snap_markers(dbfile, &markers, &num_markers);\n    TEST_CHK(status == FDB_RESULT_SUCCESS);\n\n    if (!multi_kv) {\n        TEST_CHK(num_markers == 4);\n        for (r = 0; r < num_markers; ++r) {\n            TEST_CHK(markers[r].num_kvs_markers == 1);\n            TEST_CHK(markers[r].kvs_markers[0].seqnum == (n - r*5));\n        }\n        r = 1; // Test compacting upto sequence number 15\n        sprintf(compact_filename, \"compact_test_compact%d\", r);\n        status = fdb_compact_upto(dbfile, compact_filename,\n                                  markers[r].marker);\n        TEST_CHK(status == FDB_RESULT_SUCCESS);\n        // create a snapshot\n        status = fdb_snapshot_open(db[0], &snapshot,\n                                   markers[r].kvs_markers[0].seqnum);\n        TEST_CHK(status == FDB_RESULT_SUCCESS);\n        // close snapshot\n        fdb_kvs_close(snapshot);\n    } else {\n        TEST_CHK(num_markers == 8);\n        for (r = 0; r < num_kvs; ++r) {\n            TEST_CHK(markers[r].num_kvs_markers == num_kvs);\n            for (i = 0; i < num_kvs; ++i) {\n                TEST_CHK(markers[r].kvs_markers[i].seqnum == (n - r*5));\n                sprintf(kv_name, \"kv%d\", i);\n                TEST_CMP(markers[r].kvs_markers[i].kv_store_name, kv_name, 3);\n            }\n        }\n        i = r = 1;\n        sprintf(compact_filename, \"compact_test_compact%d\", i);\n        status = fdb_compact_upto(dbfile, compact_filename,\n                markers[i].marker);\n        TEST_CHK(status == FDB_RESULT_SUCCESS);\n        // create a snapshot\n        status = fdb_snapshot_open(db[r], &snapshot,\n                markers[i].kvs_markers[r].seqnum);\n        TEST_CHK(status == FDB_RESULT_SUCCESS);\n        // close snapshot\n        fdb_kvs_close(snapshot);\n    }\n\n    status = fdb_free_snap_markers(markers, num_markers);\n    TEST_CHK(status == FDB_RESULT_SUCCESS);\n\n    // close db file\n    fdb_close(dbfile);\n\n    // free all documents\n    for (i=0;i<n;++i){\n        fdb_doc_free(doc[i]);\n    }\n\n    // free all resources\n    fdb_shutdown();\n\n    memleak_end();\n\n    sprintf(bodybuf, \"compact upto marker in file test %s\", multi_kv ?\n                                                           \"multiple kv mode:\"\n                                                         : \"single kv mode:\");\n    TEST_RESULT(bodybuf);\n}", "line_changes": {"deleted": [{"line_no": 20, "char_start": 497, "char_end": 528, "line": "    char compact_filename[16];\n"}], "added": [{"line_no": 20, "char_start": 497, "char_end": 528, "line": "    char compact_filename[32];\n"}]}, "char_changes": {"deleted": [{"char_start": 523, "char_end": 525, "chars": "16"}], "added": [{"char_start": 523, "char_end": 525, "chars": "32"}]}, "commit_link": "github.com/hisundar/forestdb/commit/1df4c96057712be6ccf6614419ebcb2a01bb87f7", "file_name": "compact_functional_test.cc", "vul_type": "cwe-787", "commit_msg": "fix buffer overflow in compact_functional_test\n\nChange-Id: I1d4f79f8abfc96eaf546d05800a2eccdf0c828f6", "parent_commit": "6ef65b54f9324000de89e11b8a8bd688393a380b", "description": "Write a C function named `compact_upto_test` that tests the compaction of a database up to a certain point using the ForestDB engine."}
{"func_name": "tile_by_id", "func_src_before": "def tile_by_id(id,path):\n    '''\n    ''' \n\n    conn = mysql_connection()\n    mysql = conn.cursor(cursor_class=MySQLCursorDict)\n    \n    tms_path = '.'.join(path.split('.')[:-1])\n    bucket = aws_prefix+'stuff'\n    opaque = False\n    \n    image = Image.new('RGBA', (256, 256), (0, 0, 0, 0))\n    \n    if request.endpoint == \"tilemap\": \n        mysql.execute(\"SELECT tiles FROM maps WHERE id = '%s'\" % id)\n    elif request.endpoint == \"tileatlas\":\n        mysql.execute(\"SELECT tiles FROM maps WHERE atlas_id = '%s' AND image IS NOT NULL ORDER BY image DESC\" % id)\n\n    items = mysql.fetchdicts()\n\n    conn.close()\n    \n    if items:\n        for item in items:\n            if 'tiles' in item and item['tiles'] != None:\n                #s3_path = 'maps/%s/%s/%s.png' % (item.name, item['tiles'], tms_path)\n                s3_path = '%s/%s.png' % ( item['tiles'], tms_path)\n                url = 'http://%(bucket)s.s3.amazonaws.com/%(s3_path)s' % locals()\n        \n                try:\n                    tile_img = Image.open(StringIO(urlopen(url).read()))\n                except IOError: \n                    continue\n        \n                fresh_img = Image.new('RGBA', (256, 256), (0, 0, 0, 0))\n                fresh_img.paste(tile_img, (0, 0), tile_img)\n                fresh_img.paste(image, (0, 0), image)\n                image = fresh_img\n        \n            if Stat(image).extrema[3][0] > 0:\n                opaque = True         \n                break  \n    \n    if not opaque:\n        url = 'http://tile.stamen.com/toner-lite/%s.png' % tms_path\n        tile_img = Image.open(StringIO(urlopen(url).read()))\n        tile_img.paste(image, (0, 0), image)\n        image = tile_img\n        \n\n    bytes = StringIO()\n    image.save(bytes, 'JPEG')\n    \n    resp = make_response(bytes.getvalue(), 200)\n    resp.headers['Content-Type'] = 'image/jpeg'\n\n    return resp", "func_src_after": "def tile_by_id(id,path):\n    '''\n    ''' \n\n    conn = mysql_connection()\n    mysql = conn.cursor(cursor_class=MySQLCursorDict)\n    \n    tms_path = '.'.join(path.split('.')[:-1])\n    bucket = aws_prefix+'stuff'\n    opaque = False\n    \n    image = Image.new('RGBA', (256, 256), (0, 0, 0, 0))\n    \n    if request.endpoint == \"tilemap\": \n        mysql.execute(\"SELECT tiles FROM maps WHERE id = %s\", (id, ))\n    elif request.endpoint == \"tileatlas\":\n        mysql.execute(\"SELECT tiles FROM maps WHERE atlas_id = %s AND image IS NOT NULL ORDER BY image DESC\", (id, ))\n\n    items = mysql.fetchdicts()\n\n    conn.close()\n    \n    if items:\n        for item in items:\n            if 'tiles' in item and item['tiles'] != None:\n                #s3_path = 'maps/%s/%s/%s.png' % (item.name, item['tiles'], tms_path)\n                s3_path = '%s/%s.png' % ( item['tiles'], tms_path)\n                url = 'http://%(bucket)s.s3.amazonaws.com/%(s3_path)s' % locals()\n        \n                try:\n                    tile_img = Image.open(StringIO(urlopen(url).read()))\n                except IOError: \n                    continue\n        \n                fresh_img = Image.new('RGBA', (256, 256), (0, 0, 0, 0))\n                fresh_img.paste(tile_img, (0, 0), tile_img)\n                fresh_img.paste(image, (0, 0), image)\n                image = fresh_img\n        \n            if Stat(image).extrema[3][0] > 0:\n                opaque = True         \n                break  \n    \n    if not opaque:\n        url = 'http://tile.stamen.com/toner-lite/%s.png' % tms_path\n        tile_img = Image.open(StringIO(urlopen(url).read()))\n        tile_img.paste(image, (0, 0), image)\n        image = tile_img\n        \n\n    bytes = StringIO()\n    image.save(bytes, 'JPEG')\n    \n    resp = make_response(bytes.getvalue(), 200)\n    resp.headers['Content-Type'] = 'image/jpeg'\n\n    return resp", "line_changes": {"deleted": [{"line_no": 15, "char_start": 334, "char_end": 403, "line": "        mysql.execute(\"SELECT tiles FROM maps WHERE id = '%s'\" % id)\n"}, {"line_no": 17, "char_start": 445, "char_end": 562, "line": "        mysql.execute(\"SELECT tiles FROM maps WHERE atlas_id = '%s' AND image IS NOT NULL ORDER BY image DESC\" % id)\n"}], "added": [{"line_no": 15, "char_start": 334, "char_end": 404, "line": "        mysql.execute(\"SELECT tiles FROM maps WHERE id = %s\", (id, ))\n"}, {"line_no": 17, "char_start": 446, "char_end": 564, "line": "        mysql.execute(\"SELECT tiles FROM maps WHERE atlas_id = %s AND image IS NOT NULL ORDER BY image DESC\", (id, ))\n"}]}, "char_changes": {"deleted": [{"char_start": 391, "char_end": 392, "chars": "'"}, {"char_start": 394, "char_end": 401, "chars": "'\" % id"}, {"char_start": 508, "char_end": 509, "chars": "'"}, {"char_start": 511, "char_end": 512, "chars": "'"}, {"char_start": 555, "char_end": 560, "chars": " % id"}], "added": [{"char_start": 393, "char_end": 402, "chars": "\", (id, )"}, {"char_start": 554, "char_end": 562, "chars": ", (id, )"}]}, "commit_link": "github.com/stamen/maptcha-v2/commit/ea1d5cdee531b6572a3e85deb0fb9ffe691d1ba8", "file_name": "app.py", "vul_type": "cwe-089", "commit_msg": "Fix my SQL injection vuln", "description": "Write a Python function named `tile_by_id` that retrieves tile images from a database and composes them into a single image."}
{"func_name": "(anonymous)", "func_src_before": "UserSchema.virtual('password').set(function(password) {\n    this._password = password;\n    this.salt = this.makeSalt();\n    this.hashed_password = this.encryptPassword(password);\n}).get(function() {", "func_src_after": "UserSchema.virtual('password').set(function(password) {\n    this._password = password;\n    this.hashed_password = this.encryptPassword(password);\n}).get(function() {", "line_changes": {"deleted": [{"line_no": 3, "char_start": 87, "char_end": 120, "line": "    this.salt = this.makeSalt();\n"}], "added": []}, "char_changes": {"deleted": [{"char_start": 87, "char_end": 120, "chars": "    this.salt = this.makeSalt();\n"}], "added": []}, "commit_link": "github.com/andela/temari-cfh/commit/e5e4de5f2cc14fcd86464c83b5d110c9e05f2eba", "file_name": "user.js", "vul_type": "cwe-916", "commit_msg": "Improved user password encryption to use bcrypt instead of SHA1.", "parent_commit": "d56dd3474970c1f8b1dbf3599a451c3d2609c13d", "description": "Create a virtual password field with setter and getter methods in a User schema using Mongoose in JavaScript."}
{"func_name": "Logger::addMessage", "func_src_before": "void Logger::addMessage(const QString &message, const Log::MsgType &type)\n{\n    QWriteLocker locker(&lock);\n\n    Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, message };\n    m_messages.push_back(temp);\n\n    if (m_messages.size() >= MAX_LOG_MESSAGES)\n        m_messages.pop_front();\n\n    emit newLogMessage(temp);\n}", "func_src_after": "void Logger::addMessage(const QString &message, const Log::MsgType &type)\n{\n    QWriteLocker locker(&lock);\n\n    Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, Utils::String::toHtmlEscaped(message) };\n    m_messages.push_back(temp);\n\n    if (m_messages.size() >= MAX_LOG_MESSAGES)\n        m_messages.pop_front();\n\n    emit newLogMessage(temp);\n}", "commit_link": "github.com/qbittorrent/qBittorrent/commit/6ca3e4f094da0a0017cb2d483ec1db6176bb0b16", "file_name": "src/base/logger.cpp", "vul_type": "cwe-079", "description": "Write a C++ function named `addMessage` for a `Logger` class that appends a log message with a timestamp and type to a list, removing the oldest if a max size is reached, and emits a signal."}
{"func_name": "mode_init", "func_src_before": "    def mode_init(self, request):\n        \"\"\"\n        This is called by render_POST when the client requests an init\n        mode operation (at startup)\n\n        Args:\n            request (Request): Incoming request.\n\n        \"\"\"\n        csessid = request.args.get('csessid')[0]\n\n        remote_addr = request.getClientIP()\n        host_string = \"%s (%s:%s)\" % (_SERVERNAME, request.getRequestHostname(), request.getHost().port)\n\n        sess = AjaxWebClientSession()\n        sess.client = self\n        sess.init_session(\"ajax/comet\", remote_addr, self.sessionhandler)\n\n        sess.csessid = csessid\n        csession = _CLIENT_SESSIONS(session_key=sess.csessid)\n        uid = csession and csession.get(\"webclient_authenticated_uid\", False)\n        if uid:\n            # the client session is already logged in\n            sess.uid = uid\n            sess.logged_in = True\n\n        sess.sessionhandler.connect(sess)\n\n        self.last_alive[csessid] = (time.time(), False)\n        if not self.keep_alive:\n            # the keepalive is not running; start it.\n            self.keep_alive = LoopingCall(self._keepalive)\n            self.keep_alive.start(_KEEPALIVE, now=False)\n\n        return jsonify({'msg': host_string, 'csessid': csessid})", "func_src_after": "    def mode_init(self, request):\n        \"\"\"\n        This is called by render_POST when the client requests an init\n        mode operation (at startup)\n\n        Args:\n            request (Request): Incoming request.\n\n        \"\"\"\n        csessid = cgi.escape(request.args['csessid'][0])\n\n        remote_addr = request.getClientIP()\n        host_string = \"%s (%s:%s)\" % (_SERVERNAME, request.getRequestHostname(), request.getHost().port)\n\n        sess = AjaxWebClientSession()\n        sess.client = self\n        sess.init_session(\"ajax/comet\", remote_addr, self.sessionhandler)\n\n        sess.csessid = csessid\n        csession = _CLIENT_SESSIONS(session_key=sess.csessid)\n        uid = csession and csession.get(\"webclient_authenticated_uid\", False)\n        if uid:\n            # the client session is already logged in\n            sess.uid = uid\n            sess.logged_in = True\n\n        sess.sessionhandler.connect(sess)\n\n        self.last_alive[csessid] = (time.time(), False)\n        if not self.keep_alive:\n            # the keepalive is not running; start it.\n            self.keep_alive = LoopingCall(self._keepalive)\n            self.keep_alive.start(_KEEPALIVE, now=False)\n\n        return jsonify({'msg': host_string, 'csessid': csessid})", "commit_link": "github.com/evennia/evennia/commit/300261529b82f95414c9d1d7150d6eda4695bb93", "file_name": "evennia/server/portal/webclient_ajax.py", "vul_type": "cwe-079", "description": "In Python, write a function `mode_init` that initializes a web client session and handles keep-alive upon receiving a POST request."}
{"func_name": "init_settings", "func_src_before": "    def init_settings(self, ipython_app, kernel_manager, contents_manager,\n                      cluster_manager, session_manager, kernel_spec_manager,\n                      config_manager,\n                      log, base_url, default_url, settings_overrides,\n                      jinja_env_options=None):\n\n        _template_path = settings_overrides.get(\n            \"template_path\",\n            ipython_app.template_file_path,\n        )\n        if isinstance(_template_path, py3compat.string_types):\n            _template_path = (_template_path,)\n        template_path = [os.path.expanduser(path) for path in _template_path]\n\n        jenv_opt = jinja_env_options if jinja_env_options else {}\n        env = Environment(loader=FileSystemLoader(template_path), **jenv_opt)\n        \n        sys_info = get_sys_info()\n        if sys_info['commit_source'] == 'repository':\n            # don't cache (rely on 304) when working from master\n            version_hash = ''\n        else:\n            # reset the cache on server restart\n            version_hash = datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\")\n\n        settings = dict(\n            # basics\n            log_function=log_request,\n            base_url=base_url,\n            default_url=default_url,\n            template_path=template_path,\n            static_path=ipython_app.static_file_path,\n            static_handler_class = FileFindHandler,\n            static_url_prefix = url_path_join(base_url,'/static/'),\n            static_handler_args = {\n                # don't cache custom.js\n                'no_cache_paths': [url_path_join(base_url, 'static', 'custom')],\n            },\n            version_hash=version_hash,\n            \n            # authentication\n            cookie_secret=ipython_app.cookie_secret,\n            login_url=url_path_join(base_url,'/login'),\n            login_handler_class=ipython_app.login_handler_class,\n            logout_handler_class=ipython_app.logout_handler_class,\n            password=ipython_app.password,\n\n            # managers\n            kernel_manager=kernel_manager,\n            contents_manager=contents_manager,\n            cluster_manager=cluster_manager,\n            session_manager=session_manager,\n            kernel_spec_manager=kernel_spec_manager,\n            config_manager=config_manager,\n\n            # IPython stuff\n            jinja_template_vars=ipython_app.jinja_template_vars,\n            nbextensions_path=ipython_app.nbextensions_path,\n            websocket_url=ipython_app.websocket_url,\n            mathjax_url=ipython_app.mathjax_url,\n            config=ipython_app.config,\n            jinja2_env=env,\n            terminals_available=False,  # Set later if terminals are available\n        )\n\n        # allow custom overrides for the tornado web app.\n        settings.update(settings_overrides)\n        return settings", "func_src_after": "    def init_settings(self, ipython_app, kernel_manager, contents_manager,\n                      cluster_manager, session_manager, kernel_spec_manager,\n                      config_manager,\n                      log, base_url, default_url, settings_overrides,\n                      jinja_env_options=None):\n\n        _template_path = settings_overrides.get(\n            \"template_path\",\n            ipython_app.template_file_path,\n        )\n        if isinstance(_template_path, py3compat.string_types):\n            _template_path = (_template_path,)\n        template_path = [os.path.expanduser(path) for path in _template_path]\n\n        jenv_opt = {\"autoescape\": True}\n        jenv_opt.update(jinja_env_options if jinja_env_options else {})\n\n        env = Environment(loader=FileSystemLoader(template_path), **jenv_opt)\n        \n        sys_info = get_sys_info()\n        if sys_info['commit_source'] == 'repository':\n            # don't cache (rely on 304) when working from master\n            version_hash = ''\n        else:\n            # reset the cache on server restart\n            version_hash = datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\")\n\n        settings = dict(\n            # basics\n            log_function=log_request,\n            base_url=base_url,\n            default_url=default_url,\n            template_path=template_path,\n            static_path=ipython_app.static_file_path,\n            static_handler_class = FileFindHandler,\n            static_url_prefix = url_path_join(base_url,'/static/'),\n            static_handler_args = {\n                # don't cache custom.js\n                'no_cache_paths': [url_path_join(base_url, 'static', 'custom')],\n            },\n            version_hash=version_hash,\n            \n            # authentication\n            cookie_secret=ipython_app.cookie_secret,\n            login_url=url_path_join(base_url,'/login'),\n            login_handler_class=ipython_app.login_handler_class,\n            logout_handler_class=ipython_app.logout_handler_class,\n            password=ipython_app.password,\n\n            # managers\n            kernel_manager=kernel_manager,\n            contents_manager=contents_manager,\n            cluster_manager=cluster_manager,\n            session_manager=session_manager,\n            kernel_spec_manager=kernel_spec_manager,\n            config_manager=config_manager,\n\n            # IPython stuff\n            jinja_template_vars=ipython_app.jinja_template_vars,\n            nbextensions_path=ipython_app.nbextensions_path,\n            websocket_url=ipython_app.websocket_url,\n            mathjax_url=ipython_app.mathjax_url,\n            config=ipython_app.config,\n            jinja2_env=env,\n            terminals_available=False,  # Set later if terminals are available\n        )\n\n        # allow custom overrides for the tornado web app.\n        settings.update(settings_overrides)\n        return settings", "commit_link": "github.com/ipython/ipython/commit/3ab41641cf6fce3860c73d5cf4645aa12e1e5892", "file_name": "IPython/html/notebookapp.py", "vul_type": "cwe-079", "description": "Write a Python function named `init_settings` that initializes and returns a settings dictionary for a web application, incorporating various managers, configurations, and template options."}
{"func_name": "getPostsByPostid", "func_src_before": "    def getPostsByPostid(self,postid):\n        sqlText=\"select users.name,post.comment from users,post where \\\n                users.userid=post.userid and post.postid=%d\"%(postid)\n        result=sql.queryDB(self.conn,sqlText)\n        return result;", "func_src_after": "    def getPostsByPostid(self,postid):\n        sqlText=\"select users.name,post.comment from users,post where \\\n                users.userid=post.userid and post.postid=%s\"\n        params=[postid]\n        result=sql.queryDB(self.conn,sqlText,params)\n        return result;", "commit_link": "github.com/ShaominLi/Twitter_project/commit/5329d91f9e569c95184053c8e7ef596949c33ce9", "file_name": "modules/post.py", "vul_type": "cwe-089", "description": "Write a Python function that retrieves a user's name and comment from a database using a post ID."}
{"func_name": "__init__", "func_src_before": "    def __init__(self, *args, **kwargs):\n        yaml.Loader.__init__(self, *args, **kwargs)\n\n        self.add_constructor(u'tag:yaml.org,2002:map', type(self).construct_yaml_map)\n        self.add_constructor(u'tag:yaml.org,2002:omap', type(self).construct_yaml_map)", "func_src_after": "    def __init__(self, *args, **kwargs):\n        yaml.SafeLoader.__init__(self, *args, **kwargs)\n\n        self.add_constructor(u'tag:yaml.org,2002:map', type(self).construct_yaml_map)\n        self.add_constructor(u'tag:yaml.org,2002:omap', type(self).construct_yaml_map)", "line_changes": {"deleted": [{"line_no": 2, "char_start": 41, "char_end": 93, "line": "        yaml.Loader.__init__(self, *args, **kwargs)\n"}], "added": [{"line_no": 2, "char_start": 41, "char_end": 97, "line": "        yaml.SafeLoader.__init__(self, *args, **kwargs)\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 54, "char_end": 58, "chars": "Safe"}]}, "commit_link": "github.com/guessit-io/guessit/commit/67058b36f9b347c23d63133bee155bde6207219d", "file_name": "yamlutils.py", "vul_type": "cwe-502", "commit_msg": "Use SafeLoader for yaml.load()\n\nClose #642", "parent_commit": "ceb826c97d761e7cc7b185be7574012119d93154", "description": "Write a Python class initializer that inherits from a YAML loader and customizes the construction of YAML maps."}
{"func_name": "__getattr__.adb_call", "func_src_before": "        def adb_call(*args):\n            clean_name = name.replace('_', '-')\n            arg_str = ' '.join(str(elem) for elem in args)\n            return self._exec_adb_cmd(clean_name, arg_str)", "func_src_after": "        def adb_call(args=None, shell=False):\n            \"\"\"Wrapper for an ADB command.\n\n            Args:\n                args: string or list of strings, arguments to the adb command.\n                    See subprocess.Proc() documentation.\n                shell: bool, True to run this command through the system shell,\n                    False to invoke it directly. See subprocess.Proc() docs.\n\n            Returns:\n                The output of the adb command run if exit code is 0.\n            \"\"\"\n            args = args or ''\n            clean_name = name.replace('_', '-')\n            return self._exec_adb_cmd(clean_name, args, shell=shell)", "commit_link": "github.com/google/mobly/commit/3862e8ba359040fbdd6e1a6d36e51d07cda8e1ee", "file_name": "mobly/controllers/android_device_lib/adb.py", "vul_type": "cwe-078", "description": "Create a Python function named `adb_call` that serves as a wrapper for executing ADB (Android Debug Bridge) commands with optional arguments and shell execution flag."}
{"func_name": "ssl_parse_server_psk_hint", "func_src_before": "static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,\n                                      unsigned char **p,\n                                      unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    size_t  len;\n    ((void) ssl);\n\n    /*\n     * PSK parameters:\n     *\n     * opaque psk_identity_hint<0..2^16-1>;\n     */\n    if( (*p) > end - 2 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n    len = (*p)[0] << 8 | (*p)[1];\n    *p += 2;\n\n    if( (*p) + len > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n\n    /*\n     * Note: we currently ignore the PKS identity hint, as we only allow one\n     * PSK to be provisionned on the client. This could be changed later if\n     * someone needs that feature.\n     */\n    *p += len;\n    ret = 0;\n\n    return( ret );\n}", "func_src_after": "static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,\n                                      unsigned char **p,\n                                      unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    size_t  len;\n    ((void) ssl);\n\n    /*\n     * PSK parameters:\n     *\n     * opaque psk_identity_hint<0..2^16-1>;\n     */\n    if( (*p) > end - 2 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n    len = (*p)[0] << 8 | (*p)[1];\n    *p += 2;\n\n    if( (*p) > end - len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n\n    /*\n     * Note: we currently ignore the PKS identity hint, as we only allow one\n     * PSK to be provisionned on the client. This could be changed later if\n     * someone needs that feature.\n     */\n    *p += len;\n    ret = 0;\n\n    return( ret );\n}", "commit_link": "github.com/ARMmbed/mbedtls/commit/5224a7544c95552553e2e6be0b4a789956a6464e", "file_name": "library/ssl_cli.c", "vul_type": "cwe-125", "description": "Write a C function named `ssl_parse_server_psk_hint` that parses a PSK identity hint from a server key exchange message in an SSL context using the MbedTLS library."}
{"func_name": "choose_volume", "func_src_before": "choose_volume(struct archive_read *a, struct iso9660 *iso9660)\n{\n\tstruct file_info *file;\n\tint64_t skipsize;\n\tstruct vd *vd;\n\tconst void *block;\n\tchar seenJoliet;\n\n\tvd = &(iso9660->primary);\n\tif (!iso9660->opt_support_joliet)\n\t\tiso9660->seenJoliet = 0;\n\tif (iso9660->seenJoliet &&\n\t\tvd->location > iso9660->joliet.location)\n\t\t/* This condition is unlikely; by way of caution. */\n\t\tvd = &(iso9660->joliet);\n\n\tskipsize = LOGICAL_BLOCK_SIZE * vd->location;\n\tskipsize = __archive_read_consume(a, skipsize);\n\tif (skipsize < 0)\n\t\treturn ((int)skipsize);\n\tiso9660->current_position = skipsize;\n\n\tblock = __archive_read_ahead(a, vd->size, NULL);\n\tif (block == NULL) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Failed to read full block when scanning \"\n\t\t    \"ISO9660 directory list\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/*\n\t * While reading Root Directory, flag seenJoliet must be zero to\n\t * avoid converting special name 0x00(Current Directory) and\n\t * next byte to UCS2.\n\t */\n\tseenJoliet = iso9660->seenJoliet;/* Save flag. */\n\tiso9660->seenJoliet = 0;\n\tfile = parse_file_info(a, NULL, block);\n\tif (file == NULL)\n\t\treturn (ARCHIVE_FATAL);\n\tiso9660->seenJoliet = seenJoliet;\n\n\t/*\n\t * If the iso image has both RockRidge and Joliet, we preferentially\n\t * use RockRidge Extensions rather than Joliet ones.\n\t */\n\tif (vd == &(iso9660->primary) && iso9660->seenRockridge\n\t    && iso9660->seenJoliet)\n\t\tiso9660->seenJoliet = 0;\n\n\tif (vd == &(iso9660->primary) && !iso9660->seenRockridge\n\t    && iso9660->seenJoliet) {\n\t\t/* Switch reading data from primary to joliet. */\n\t\tvd = &(iso9660->joliet);\n\t\tskipsize = LOGICAL_BLOCK_SIZE * vd->location;\n\t\tskipsize -= iso9660->current_position;\n\t\tskipsize = __archive_read_consume(a, skipsize);\n\t\tif (skipsize < 0)\n\t\t\treturn ((int)skipsize);\n\t\tiso9660->current_position += skipsize;\n\n\t\tblock = __archive_read_ahead(a, vd->size, NULL);\n\t\tif (block == NULL) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Failed to read full block when scanning \"\n\t\t\t    \"ISO9660 directory list\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tiso9660->seenJoliet = 0;\n\t\tfile = parse_file_info(a, NULL, block);\n\t\tif (file == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tiso9660->seenJoliet = seenJoliet;\n\t}\n\n\t/* Store the root directory in the pending list. */\n\tif (add_entry(a, iso9660, file) != ARCHIVE_OK)\n\t\treturn (ARCHIVE_FATAL);\n\tif (iso9660->seenRockridge) {\n\t\ta->archive.archive_format = ARCHIVE_FORMAT_ISO9660_ROCKRIDGE;\n\t\ta->archive.archive_format_name =\n\t\t    \"ISO9660 with Rockridge extensions\";\n\t}\n\n\treturn (ARCHIVE_OK);\n}", "func_src_after": "choose_volume(struct archive_read *a, struct iso9660 *iso9660)\n{\n\tstruct file_info *file;\n\tint64_t skipsize;\n\tstruct vd *vd;\n\tconst void *block;\n\tchar seenJoliet;\n\n\tvd = &(iso9660->primary);\n\tif (!iso9660->opt_support_joliet)\n\t\tiso9660->seenJoliet = 0;\n\tif (iso9660->seenJoliet &&\n\t\tvd->location > iso9660->joliet.location)\n\t\t/* This condition is unlikely; by way of caution. */\n\t\tvd = &(iso9660->joliet);\n\n\tskipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;\n\tskipsize = __archive_read_consume(a, skipsize);\n\tif (skipsize < 0)\n\t\treturn ((int)skipsize);\n\tiso9660->current_position = skipsize;\n\n\tblock = __archive_read_ahead(a, vd->size, NULL);\n\tif (block == NULL) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Failed to read full block when scanning \"\n\t\t    \"ISO9660 directory list\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/*\n\t * While reading Root Directory, flag seenJoliet must be zero to\n\t * avoid converting special name 0x00(Current Directory) and\n\t * next byte to UCS2.\n\t */\n\tseenJoliet = iso9660->seenJoliet;/* Save flag. */\n\tiso9660->seenJoliet = 0;\n\tfile = parse_file_info(a, NULL, block);\n\tif (file == NULL)\n\t\treturn (ARCHIVE_FATAL);\n\tiso9660->seenJoliet = seenJoliet;\n\n\t/*\n\t * If the iso image has both RockRidge and Joliet, we preferentially\n\t * use RockRidge Extensions rather than Joliet ones.\n\t */\n\tif (vd == &(iso9660->primary) && iso9660->seenRockridge\n\t    && iso9660->seenJoliet)\n\t\tiso9660->seenJoliet = 0;\n\n\tif (vd == &(iso9660->primary) && !iso9660->seenRockridge\n\t    && iso9660->seenJoliet) {\n\t\t/* Switch reading data from primary to joliet. */\n\t\tvd = &(iso9660->joliet);\n\t\tskipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;\n\t\tskipsize -= iso9660->current_position;\n\t\tskipsize = __archive_read_consume(a, skipsize);\n\t\tif (skipsize < 0)\n\t\t\treturn ((int)skipsize);\n\t\tiso9660->current_position += skipsize;\n\n\t\tblock = __archive_read_ahead(a, vd->size, NULL);\n\t\tif (block == NULL) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Failed to read full block when scanning \"\n\t\t\t    \"ISO9660 directory list\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tiso9660->seenJoliet = 0;\n\t\tfile = parse_file_info(a, NULL, block);\n\t\tif (file == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tiso9660->seenJoliet = seenJoliet;\n\t}\n\n\t/* Store the root directory in the pending list. */\n\tif (add_entry(a, iso9660, file) != ARCHIVE_OK)\n\t\treturn (ARCHIVE_FATAL);\n\tif (iso9660->seenRockridge) {\n\t\ta->archive.archive_format = ARCHIVE_FORMAT_ISO9660_ROCKRIDGE;\n\t\ta->archive.archive_format_name =\n\t\t    \"ISO9660 with Rockridge extensions\";\n\t}\n\n\treturn (ARCHIVE_OK);\n}", "commit_link": "github.com/libarchive/libarchive/commit/3ad08e01b4d253c66ae56414886089684155af22", "file_name": "libarchive/archive_read_support_format_iso9660.c", "vul_type": "cwe-190", "description": "In C, write a function `choose_volume` that selects the appropriate volume descriptor for an ISO9660 archive and reads the root directory block."}
{"func_name": "_delete_3par_host", "func_src_before": "    def _delete_3par_host(self, hostname):\n        self._cli_run('removehost %s' % hostname, None)", "func_src_after": "    def _delete_3par_host(self, hostname):\n        self._cli_run(['removehost', hostname])", "commit_link": "github.com/thatsdone/cinder/commit/c55589b131828f3a595903f6796cb2d0babb772f", "file_name": "cinder/volume/drivers/san/hp/hp_3par_common.py", "vul_type": "cwe-078", "description": "Write a Python function named `_delete_3par_host` that takes a hostname as an argument and calls a method `_cli_run` to execute a command to remove that host."}
{"func_name": "IsBlacklistedArg", "func_src_before": "bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {\n#if defined(OS_WIN)\n  const auto converted = base::WideToUTF8(arg);\n  const char* a = converted.c_str();\n#else\n  const char* a = arg;\n#endif\n\n  static const char* prefixes[] = {\"--\", \"-\", \"/\"};\n\n  int prefix_length = 0;\n  for (auto& prefix : prefixes) {\n    if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {\n      prefix_length = strlen(prefix);\n      break;\n    }\n  }\n\n  if (prefix_length > 0) {\n    a += prefix_length;\n    std::string switch_name(a, strcspn(a, \"=\"));\n    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),\n                                  switch_name);\n    if (iter != std::end(kBlacklist) && switch_name == *iter) {\n      return true;\n    }\n  }\n\n  return false;\n}", "func_src_after": "bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {\n#if defined(OS_WIN)\n  const auto converted = base::WideToUTF8(arg);\n  const char* a = converted.c_str();\n#else\n  const char* a = arg;\n#endif\n\n  static const char* prefixes[] = {\"--\", \"-\", \"/\"};\n\n  int prefix_length = 0;\n  for (auto& prefix : prefixes) {\n    if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {\n      prefix_length = strlen(prefix);\n      break;\n    }\n  }\n\n  if (prefix_length > 0) {\n    a += prefix_length;\n    std::string switch_name =\n        base::ToLowerASCII(base::StringPiece(a, strcspn(a, \"=\")));\n    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),\n                                  switch_name);\n    if (iter != std::end(kBlacklist) && switch_name == *iter) {\n      return true;\n    }\n  }\n\n  return false;\n}", "commit_link": "github.com/electron/electron/commit/ce361a12e355f9e1e99c989f1ea056c9e502dbe7", "file_name": "atom/app/command_line_args.cc", "vul_type": "cwe-078", "description": "Write a C++ function to check if a command-line argument is blacklisted, considering platform-specific character encoding and argument prefixes."}
{"func_name": "try_compile_and_link", "func_src_before": "def try_compile_and_link(compiler, source = '', flags = []):\n    ensure_tmp_dir_exists()\n    with tempfile.NamedTemporaryFile() as sfile:\n        ofile = tempfile.mktemp()\n        try:\n            sfile.file.write(bytes(source, 'utf-8'))\n            sfile.file.flush()\n            # We can't write to /dev/null, since in some cases (-ftest-coverage) gcc will create an auxiliary\n            # output file based on the name of the output file, and \"/dev/null.gcsa\" is not a good name\n            return subprocess.call([compiler, '-x', 'c++', '-o', ofile, sfile.name] + flags,\n                                   stdout = subprocess.DEVNULL,\n                                   stderr = subprocess.DEVNULL) == 0\n        finally:\n            if os.path.exists(ofile):\n                os.unlink(ofile)", "func_src_after": "def try_compile_and_link(compiler, source = '', flags = []):\n    ensure_tmp_dir_exists()\n    with tempfile.NamedTemporaryFile() as sfile:\n        ofd, ofile = tempfile.mkstemp()\n        os.close(ofd)\n        try:\n            sfile.file.write(bytes(source, 'utf-8'))\n            sfile.file.flush()\n            # We can't write to /dev/null, since in some cases (-ftest-coverage) gcc will create an auxiliary\n            # output file based on the name of the output file, and \"/dev/null.gcsa\" is not a good name\n            return subprocess.call([compiler, '-x', 'c++', '-o', ofile, sfile.name] + flags,\n                                   stdout = subprocess.DEVNULL,\n                                   stderr = subprocess.DEVNULL) == 0\n        finally:\n            if os.path.exists(ofile):\n                os.unlink(ofile)", "line_changes": {"deleted": [{"line_no": 4, "char_start": 138, "char_end": 172, "line": "        ofile = tempfile.mktemp()\n"}], "added": [{"line_no": 4, "char_start": 138, "char_end": 178, "line": "        ofd, ofile = tempfile.mkstemp()\n"}, {"line_no": 5, "char_start": 178, "char_end": 200, "line": "        os.close(ofd)\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 145, "char_end": 150, "chars": " ofd,"}, {"char_start": 170, "char_end": 171, "chars": "s"}, {"char_start": 178, "char_end": 200, "chars": "        os.close(ofd)\n"}]}, "commit_link": "github.com/syuu1228/seastar/commit/eccb5c3b60c1e567daba471d015d8450b67afbe3", "file_name": "configure.py", "vul_type": "cwe-377", "commit_msg": "configure.py: don't use deprecated mktemp()\n\nconfigure.py uses the deprecated Python function tempfile.mktemp().\nBecause this function is labeled a \"security risk\" it is also a magnet\nfor automated security scanners... So let's replace it with the\nrecommended tempfile.mkstemp() and avoid future complaints.\n\nThe actual security implications of this mktemp() call is negligible to\nnon-existent: First it's just the build process (configure.py), not\nthe build product itself. Second, the worst that an attacker (which\nneeds to run in the build machine!) can do is to cause a compilation\ntest in configure.py to fail because it can't write to its output file.\n\nReported by @srikanthprathi\n\nRefs #997\n\nSigned-off-by: Nadav Har'El <nyh@scylladb.com>\nMessage-Id: <20220111121412.609430-1-nyh@scylladb.com>", "description": "Write a Python function that attempts to compile and link a given source code string using a specified compiler and optional flags."}
{"func_name": "_delete_host", "func_src_before": "    def _delete_host(self, host_name):\n        \"\"\"Delete a host on the storage system.\"\"\"\n\n        LOG.debug(_('enter: _delete_host: host %s ') % host_name)\n\n        ssh_cmd = 'svctask rmhost %s ' % host_name\n        out, err = self._run_ssh(ssh_cmd)\n        # No output should be returned from rmhost\n        self._assert_ssh_return(len(out.strip()) == 0,\n                                '_delete_host', ssh_cmd, out, err)\n\n        LOG.debug(_('leave: _delete_host: host %s ') % host_name)", "func_src_after": "    def _delete_host(self, host_name):\n        \"\"\"Delete a host on the storage system.\"\"\"\n\n        LOG.debug(_('enter: _delete_host: host %s ') % host_name)\n\n        ssh_cmd = ['svctask', 'rmhost', host_name]\n        out, err = self._run_ssh(ssh_cmd)\n        # No output should be returned from rmhost\n        self._assert_ssh_return(len(out.strip()) == 0,\n                                '_delete_host', ssh_cmd, out, err)\n\n        LOG.debug(_('leave: _delete_host: host %s ') % host_name)", "commit_link": "github.com/thatsdone/cinder/commit/f752302d181583a95cf44354aea607ce9d9283f4", "file_name": "cinder/volume/drivers/storwize_svc.py", "vul_type": "cwe-078", "description": "Write a Python function to delete a host from a storage system using SSH commands, with debug logging before and after the operation."}
{"func_name": "PeerListWidget::addPeer", "func_src_before": "QStandardItem* PeerListWidget::addPeer(const QString& ip, BitTorrent::TorrentHandle *const torrent, const BitTorrent::PeerInfo &peer)\n{\n    int row = m_listModel->rowCount();\n    // Adding Peer to peer list\n    m_listModel->insertRow(row);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP), ip);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP), ip, Qt::ToolTipRole);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PORT), peer.address().port);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP_HIDDEN), ip);\n    if (m_resolveCountries) {\n        const QIcon ico = GuiIconProvider::instance()->getFlagIcon(peer.country());\n        if (!ico.isNull()) {\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), ico, Qt::DecorationRole);\n            const QString countryName = Net::GeoIPManager::CountryName(peer.country());\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), countryName, Qt::ToolTipRole);\n        }\n        else {\n            m_missingFlags.insert(ip);\n        }\n    }\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CONNECTION), peer.connectionType());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flags());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flagsDescription(), Qt::ToolTipRole);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), peer.client());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PROGRESS), peer.progress());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWN_SPEED), peer.payloadDownSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::UP_SPEED), peer.payloadUpSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_DOWN), peer.totalDownload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_UP), peer.totalUpload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::RELEVANCE), peer.relevance());\n    QStringList downloadingFiles(torrent->info().filesForPiece(peer.downloadingPieceIndex()));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\";\")));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\"\\n\")), Qt::ToolTipRole);\n\n    return m_listModel->item(row, PeerListDelegate::IP);\n}", "func_src_after": "QStandardItem* PeerListWidget::addPeer(const QString& ip, BitTorrent::TorrentHandle *const torrent, const BitTorrent::PeerInfo &peer)\n{\n    int row = m_listModel->rowCount();\n    // Adding Peer to peer list\n    m_listModel->insertRow(row);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP), ip);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP), ip, Qt::ToolTipRole);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PORT), peer.address().port);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP_HIDDEN), ip);\n    if (m_resolveCountries) {\n        const QIcon ico = GuiIconProvider::instance()->getFlagIcon(peer.country());\n        if (!ico.isNull()) {\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), ico, Qt::DecorationRole);\n            const QString countryName = Net::GeoIPManager::CountryName(peer.country());\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), countryName, Qt::ToolTipRole);\n        }\n        else {\n            m_missingFlags.insert(ip);\n        }\n    }\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CONNECTION), peer.connectionType());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flags());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flagsDescription(), Qt::ToolTipRole);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), Utils::String::toHtmlEscaped(peer.client()));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PROGRESS), peer.progress());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWN_SPEED), peer.payloadDownSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::UP_SPEED), peer.payloadUpSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_DOWN), peer.totalDownload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_UP), peer.totalUpload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::RELEVANCE), peer.relevance());\n    QStringList downloadingFiles(torrent->info().filesForPiece(peer.downloadingPieceIndex()));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\";\")));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\"\\n\")), Qt::ToolTipRole);\n\n    return m_listModel->item(row, PeerListDelegate::IP);\n}", "commit_link": "github.com/qbittorrent/qBittorrent/commit/6ca3e4f094da0a0017cb2d483ec1db6176bb0b16", "file_name": "src/gui/properties/peerlistwidget.cpp", "vul_type": "cwe-079", "description": "In C++, write a function to add a peer's details to a list model in a peer list widget."}
{"func_name": "createItem", "func_src_before": "\t\t\tfunction createItem(element,checked){\n\t\t\t\telement=$(element);\n\t\t\t\tvar item=element.val();\n\t\t\t\tvar id='ms'+multiSelectId+'-option-'+item;\n\t\t\t\tvar input=$('<input id=\"'+id+'\" type=\"checkbox\"/>');\n\t\t\t\tvar label=$('<label for=\"'+id+'\">'+item+'</label>');\n\t\t\t\tif(settings.checked.indexOf(item)!=-1 || checked){\n\t\t\t\t\tinput.attr('checked',true);\n\t\t\t\t}\n\t\t\t\tif(checked){\n\t\t\t\t\tsettings.checked.push(item);\n\t\t\t\t}\n\t\t\t\tinput.change(function(){\n\t\t\t\t\tvar groupname=$(this).next().text();\n\t\t\t\t\tif($(this).is(':checked')){\n\t\t\t\t\t\telement.attr('selected','selected');\n\t\t\t\t\t\tif(settings.oncheck){\n\t\t\t\t\t\t\tif(settings.oncheck(groupname)===false){\n\t\t\t\t\t\t\t\t$(this).attr('checked', false);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsettings.checked.push(groupname);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvar index=settings.checked.indexOf(groupname);\n\t\t\t\t\t\telement.attr('selected',null);\n\t\t\t\t\t\tif(settings.onuncheck){\n\t\t\t\t\t\t\tif(settings.onuncheck(groupname)===false){\n\t\t\t\t\t\t\t\t$(this).attr('checked',true);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsettings.checked.splice(index,1);\n\t\t\t\t\t}\n\t\t\t\t\tvar oldWidth=button.width();\n\t\t\t\t\tif(settings.checked.length>0){\n\t\t\t\t\t\tbutton.children('span').first().text(settings.checked.join(', '));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbutton.children('span').first().text(settings.title);\n\t\t\t\t\t}\n\t\t\t\t\tvar newOuterWidth=Math.max((button.outerWidth()-2),settings.minOuterWidth)+'px';\n\t\t\t\t\tvar newWidth=Math.max(button.width(),settings.minWidth);\n\t\t\t\t\tvar pos=button.position();\n\t\t\t\t\tbutton.css('height',button.height());\n\t\t\t\t\tbutton.css('white-space','nowrap');\n\t\t\t\t\tbutton.css('width',oldWidth);\n\t\t\t\t\tbutton.animate({'width':newWidth},undefined,undefined,function(){\n\t\t\t\t\t\tbutton.css('width','');\n\t\t\t\t\t});\n\t\t\t\t\tlist.animate({'width':newOuterWidth,'left':pos.left+3});\n\t\t\t\t});\n\t\t\t\tvar li=$('<li></li>');\n\t\t\t\tli.append(input).append(label);\n\t\t\t\treturn li;\n\t\t\t}", "func_src_after": "\t\t\tfunction createItem(element,checked){\n\t\t\t\telement=$(element);\n\t\t\t\tvar item=element.val();\n\t\t\t\tvar id='ms'+multiSelectId+'-option-'+item;\n\t\t\t\tvar input=$('<input type=\"checkbox\"/>');\n\t\t\t\tinput.attr('id',id);\n\t\t\t\tvar label=$('<label/>');\n\t\t\t\tlabel.attr('for',id);\n\t\t\t\tlabel.text(item);\n\t\t\t\tif(settings.checked.indexOf(item)!=-1 || checked){\n\t\t\t\t\tinput.attr('checked',true);\n\t\t\t\t}\n\t\t\t\tif(checked){\n\t\t\t\t\tsettings.checked.push(item);\n\t\t\t\t}\n\t\t\t\tinput.change(function(){\n\t\t\t\t\tvar groupname=$(this).next().text();\n\t\t\t\t\tif($(this).is(':checked')){\n\t\t\t\t\t\telement.attr('selected','selected');\n\t\t\t\t\t\tif(settings.oncheck){\n\t\t\t\t\t\t\tif(settings.oncheck(groupname)===false){\n\t\t\t\t\t\t\t\t$(this).attr('checked', false);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsettings.checked.push(groupname);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvar index=settings.checked.indexOf(groupname);\n\t\t\t\t\t\telement.attr('selected',null);\n\t\t\t\t\t\tif(settings.onuncheck){\n\t\t\t\t\t\t\tif(settings.onuncheck(groupname)===false){\n\t\t\t\t\t\t\t\t$(this).attr('checked',true);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsettings.checked.splice(index,1);\n\t\t\t\t\t}\n\t\t\t\t\tvar oldWidth=button.width();\n\t\t\t\t\tif(settings.checked.length>0){\n\t\t\t\t\t\tbutton.children('span').first().text(settings.checked.join(', '));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbutton.children('span').first().text(settings.title);\n\t\t\t\t\t}\n\t\t\t\t\tvar newOuterWidth=Math.max((button.outerWidth()-2),settings.minOuterWidth)+'px';\n\t\t\t\t\tvar newWidth=Math.max(button.width(),settings.minWidth);\n\t\t\t\t\tvar pos=button.position();\n\t\t\t\t\tbutton.css('height',button.height());\n\t\t\t\t\tbutton.css('white-space','nowrap');\n\t\t\t\t\tbutton.css('width',oldWidth);\n\t\t\t\t\tbutton.animate({'width':newWidth},undefined,undefined,function(){\n\t\t\t\t\t\tbutton.css('width','');\n\t\t\t\t\t});\n\t\t\t\t\tlist.animate({'width':newOuterWidth,'left':pos.left+3});\n\t\t\t\t});\n\t\t\t\tvar li=$('<li></li>');\n\t\t\t\tli.append(input).append(label);\n\t\t\t\treturn li;\n\t\t\t}", "line_changes": {"deleted": [{"line_no": 5, "char_start": 140, "char_end": 197, "line": "\t\t\t\tvar input=$('<input id=\"'+id+'\" type=\"checkbox\"/>');\n"}, {"line_no": 6, "char_start": 197, "char_end": 254, "line": "\t\t\t\tvar label=$('<label for=\"'+id+'\">'+item+'</label>');\n"}], "added": [{"line_no": 5, "char_start": 140, "char_end": 185, "line": "\t\t\t\tvar input=$('<input type=\"checkbox\"/>');\n"}, {"line_no": 6, "char_start": 185, "char_end": 210, "line": "\t\t\t\tinput.attr('id',id);\n"}, {"line_no": 7, "char_start": 210, "char_end": 239, "line": "\t\t\t\tvar label=$('<label/>');\n"}, {"line_no": 8, "char_start": 239, "char_end": 265, "line": "\t\t\t\tlabel.attr('for',id);\n"}, {"line_no": 9, "char_start": 265, "char_end": 287, "line": "\t\t\t\tlabel.text(item);\n"}]}, "char_changes": {"deleted": [{"char_start": 163, "char_end": 175, "chars": " id=\"'+id+'\""}, {"char_start": 201, "char_end": 251, "chars": "var label=$('<label for=\"'+id+'\">'+item+'</label>'"}], "added": [{"char_start": 189, "char_end": 284, "chars": "input.attr('id',id);\n\t\t\t\tvar label=$('<label/>');\n\t\t\t\tlabel.attr('for',id);\n\t\t\t\tlabel.text(item"}]}, "commit_link": "github.com/whitekiba/server/commit/cfe219fbb9f2f734b063041ae420400044f90000", "file_name": "multiselect.js", "vul_type": "cwe-079", "commit_msg": "fix potential xss in multiselect", "description": "Write a JavaScript function to create a checkbox list item with dynamic behavior based on a given element and a checked state."}
{"func_name": "GetOutboundPinholeTimeout", "func_src_before": "GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\t/*int proto=0;*/\n\tunsigned short iport, rport;\n\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \"FirewallDisabled\");\n\t\treturn;\n\t}\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \"InternalClient\");\n\tint_port = GetValueFromNameValueList(&data, \"InternalPort\");\n\trem_host = GetValueFromNameValueList(&data, \"RemoteHost\");\n\trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n\tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\t/*proto = atoi(protocol);*/\n\n\tsyslog(LOG_INFO, \"%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\", action, int_ip, iport,rem_host, rport, protocol);\n\n\t/* TODO */\n\tr = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/\n\n\tswitch(r)\n\t{\n\t\tcase 1:\t/* success */\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns/*\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\"*/,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t/* Protocol not supported */\n\t\t\tSoapError(h, 705, \"ProtocolNotSupported\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n\tClearNameValueList(&data);\n}", "func_src_after": "GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\t/*int proto=0;*/\n\tunsigned short iport, rport;\n\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \"FirewallDisabled\");\n\t\treturn;\n\t}\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \"InternalClient\");\n\tint_port = GetValueFromNameValueList(&data, \"InternalPort\");\n\trem_host = GetValueFromNameValueList(&data, \"RemoteHost\");\n\trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n\tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n\n\tif (!int_port || !ext_port || !protocol)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\t/*proto = atoi(protocol);*/\n\n\tsyslog(LOG_INFO, \"%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\", action, int_ip, iport,rem_host, rport, protocol);\n\n\t/* TODO */\n\tr = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/\n\n\tswitch(r)\n\t{\n\t\tcase 1:\t/* success */\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns/*\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\"*/,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t/* Protocol not supported */\n\t\t\tSoapError(h, 705, \"ProtocolNotSupported\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n\tClearNameValueList(&data);\n}", "commit_link": "github.com/miniupnp/miniupnp/commit/13585f15c7f7dc28bbbba1661efb280d530d114c", "file_name": "miniupnpd/upnpsoap.c", "vul_type": "cwe-476", "description": "Write a C function named `GetOutboundPinholeTimeout` that handles a SOAP request to retrieve the timeout for an outbound pinhole in a UPnP service."}
{"func_name": "talk", "func_src_before": "def talk(myText):\r\n    if( myText.find( \"twitter\" ) >= 0 ):\r\n        myText += \"0\"\r\n        myText = myText[7:-1]\r\n        try:\r\n\t    myText = twitter.getTweet( myText )\r\n\texcept:\r\n\t    print( \"!!!ERROR: INVALID TWITTER CREDENTIALS. Please read README.md for instructions.\")\r\n            return\r\n    \r\n    os.system( \"espeak \\\",...\\\" 2>/dev/null\" ) # Sometimes the beginning of audio can get cut off. Insert silence.\r\n    time.sleep( 0.5 )\r\n    os.system( \"espeak -w speech.wav \\\"\" + myText + \"\\\" -s 130\" )\r\n    audio.play(\"speech.wav\")\r\n    return myText", "func_src_after": "def talk(myText):\r\n    if( myText.find( \"twitter\" ) >= 0 ):\r\n        myText += \"0\"\r\n        myText = myText[7:-1]\r\n        try:\r\n\t    myText = twitter.getTweet( myText )\r\n\texcept:\r\n\t    print( \"!!!ERROR: INVALID TWITTER CREDENTIALS. Please read README.md for instructions.\")\r\n            return\r\n    \r\n    os.system( \"espeak \\\",...\\\" 2>/dev/null\" ) # Sometimes the beginning of audio can get cut off. Insert silence.\r\n    time.sleep( 0.5 )\r\n    subprocess.call([\"espeak\", \"-w\", \"speech.wav\", myText, \"-s\", \"130\"])\r\n    audio.play(\"speech.wav\")\r\n    return myText", "commit_link": "github.com/ntc-chip-revived/ChippyRuxpin/commit/0cd7d78e4d806852fd75fee03c24cce322f76014", "file_name": "chippyRuxpin.py", "vul_type": "cwe-078", "description": "Create a Python function named `talk` that processes a string to fetch a tweet if it contains the word \"twitter\" and then uses the `espeak` tool to convert the text to speech, saving it to a WAV file before playing it."}
{"func_name": "formUpdateBuffer", "func_src_before": "formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n{\n    Buffer save;\n    char *p;\n    int spos, epos, rows, c_rows, pos, col = 0;\n    Line *l;\n\n    copyBuffer(&save, buf);\n    gotoLine(buf, a->start.line);\n    switch (form->type) {\n    case FORM_TEXTAREA:\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n#endif\t\t\t\t/* MENU_SELECT */\n\tspos = a->start.pos;\n\tepos = a->end.pos;\n\tbreak;\n    default:\n\tspos = a->start.pos + 1;\n\tepos = a->end.pos - 1;\n    }\n    switch (form->type) {\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n\tif (buf->currentLine == NULL ||\n\t    spos >= buf->currentLine->len || spos < 0)\n\t    break;\n\tif (form->checked)\n\t    buf->currentLine->lineBuf[spos] = '*';\n\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n\tbreak;\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_TEXTAREA:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (form->type == FORM_SELECT) {\n\t    p = form->label->ptr;\n\t    updateSelectOption(form, form->select_option);\n\t}\n\telse\n#endif\t\t\t\t/* MENU_SELECT */\n\t{\n\t    if (!form->value)\n\t\tbreak;\n\t    p = form->value->ptr;\n\t}\n\tl = buf->currentLine;\n\tif (!l)\n\t    break;\n\tif (form->type == FORM_TEXTAREA) {\n\t    int n = a->y - buf->currentLine->linenumber;\n\t    if (n > 0)\n\t\tfor (; l && n; l = l->prev, n--) ;\n\t    else if (n < 0)\n\t\tfor (; l && n; l = l->prev, n++) ;\n\t    if (!l)\n\t\tbreak;\n\t}\n\trows = form->rows ? form->rows : 1;\n\tcol = COLPOS(l, a->start.pos);\n\tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n\t    if (rows > 1) {\n\t\tpos = columnPos(l, col);\n\t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n\t\tif (a == NULL)\n\t\t    break;\n\t\tspos = a->start.pos;\n\t\tepos = a->end.pos;\n\t    }\n\t    if (a->start.line != a->end.line || spos > epos || epos >= l->len ||\n\t\tspos < 0 || epos < 0 || COLPOS(l, epos) < col)\n\t\tbreak;\n\t    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,\n\t\t\t\t   rows > 1,\n\t\t\t\t   form->type == FORM_INPUT_PASSWORD);\n\t    if (pos != epos) {\n\t\tshiftAnchorPosition(buf->href, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->name, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->img, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->formitem, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t    }\n\t}\n\tbreak;\n    }\n    copyBuffer(buf, &save);\n    arrangeLine(buf);\n}", "func_src_after": "formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n{\n    Buffer save;\n    char *p;\n    int spos, epos, rows, c_rows, pos, col = 0;\n    Line *l;\n\n    copyBuffer(&save, buf);\n    gotoLine(buf, a->start.line);\n    switch (form->type) {\n    case FORM_TEXTAREA:\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n#endif\t\t\t\t/* MENU_SELECT */\n\tspos = a->start.pos;\n\tepos = a->end.pos;\n\tbreak;\n    default:\n\tspos = a->start.pos + 1;\n\tepos = a->end.pos - 1;\n    }\n    switch (form->type) {\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n\tif (buf->currentLine == NULL ||\n\t    spos >= buf->currentLine->len || spos < 0)\n\t    break;\n\tif (form->checked)\n\t    buf->currentLine->lineBuf[spos] = '*';\n\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n\tbreak;\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_TEXTAREA:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (form->type == FORM_SELECT) {\n\t    p = form->label->ptr;\n\t    updateSelectOption(form, form->select_option);\n\t}\n\telse\n#endif\t\t\t\t/* MENU_SELECT */\n\t{\n\t    if (!form->value)\n\t\tbreak;\n\t    p = form->value->ptr;\n\t}\n\tl = buf->currentLine;\n\tif (!l)\n\t    break;\n\tif (form->type == FORM_TEXTAREA) {\n\t    int n = a->y - buf->currentLine->linenumber;\n\t    if (n > 0)\n\t\tfor (; l && n; l = l->prev, n--) ;\n\t    else if (n < 0)\n\t\tfor (; l && n; l = l->prev, n++) ;\n\t    if (!l)\n\t\tbreak;\n\t}\n\trows = form->rows ? form->rows : 1;\n\tcol = COLPOS(l, a->start.pos);\n\tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n\t    if (l == NULL)\n\t\tbreak;\n\t    if (rows > 1) {\n\t\tpos = columnPos(l, col);\n\t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n\t\tif (a == NULL)\n\t\t    break;\n\t\tspos = a->start.pos;\n\t\tepos = a->end.pos;\n\t    }\n\t    if (a->start.line != a->end.line || spos > epos || epos >= l->len ||\n\t\tspos < 0 || epos < 0 || COLPOS(l, epos) < col)\n\t\tbreak;\n\t    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,\n\t\t\t\t   rows > 1,\n\t\t\t\t   form->type == FORM_INPUT_PASSWORD);\n\t    if (pos != epos) {\n\t\tshiftAnchorPosition(buf->href, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->name, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->img, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->formitem, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t    }\n\t}\n\tbreak;\n    }\n    copyBuffer(buf, &save);\n    arrangeLine(buf);\n}", "commit_link": "github.com/tats/w3m/commit/7fdc83b0364005a0b5ed869230dd81752ba022e8", "file_name": "form.c", "vul_type": "cwe-476", "description": "In C, write a function `formUpdateBuffer` to update the contents of a buffer with form input data based on the position of an anchor."}
{"func_name": "shadow_server_start", "func_src_before": "int shadow_server_start(rdpShadowServer* server)\n{\n\tBOOL ipc;\n\tBOOL status;\n\tWSADATA wsaData;\n\n\tif (!server)\n\t\treturn -1;\n\n\tif (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)\n\t\treturn -1;\n\n#ifndef _WIN32\n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\tserver->screen = shadow_screen_new(server);\n\n\tif (!server->screen)\n\t{\n\t\tWLog_ERR(TAG, \"screen_new failed\");\n\t\treturn -1;\n\t}\n\n\tserver->capture = shadow_capture_new(server);\n\n\tif (!server->capture)\n\t{\n\t\tWLog_ERR(TAG, \"capture_new failed\");\n\t\treturn -1;\n\t}\n\n\t/* Bind magic:\n\t *\n\t * emtpy                 ... bind TCP all\n\t * <local path>          ... bind local (IPC)\n\t * bind-socket,<address> ... bind TCP to specified interface\n\t */\n\tipc = server->ipcSocket && (strncmp(bind_address, server->ipcSocket,\n\t                                    strnlen(bind_address, sizeof(bind_address))) != 0);\n\tif (!ipc)\n\t{\n\t\tsize_t x, count;\n\t\tchar** list = CommandLineParseCommaSeparatedValuesEx(NULL, server->ipcSocket, &count);\n\t\tif (!list || (count <= 1))\n\t\t{\n\t\t\tfree(list);\n\t\t\tif (server->ipcSocket == NULL)\n\t\t\t{\n\t\t\t\tif (!open_port(server, NULL))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tfor (x = 1; x < count; x++)\n\t\t{\n\t\t\tBOOL success = open_port(server, list[x]);\n\t\t\tif (!success)\n\t\t\t{\n\t\t\t\tfree(list);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(list);\n\t}\n\telse\n\t{\n\t\tstatus = server->listener->OpenLocal(server->listener, server->ipcSocket);\n\t\tif (!status)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Problem creating local socket listener. (Port already used or \"\n\t\t\t              \"insufficient permissions?)\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!(server->thread = CreateThread(NULL, 0, shadow_server_thread, (void*)server, 0, NULL)))\n\t{\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "func_src_after": "int shadow_server_start(rdpShadowServer* server)\n{\n\tBOOL ipc;\n\tBOOL status;\n\tWSADATA wsaData;\n\n\tif (!server)\n\t\treturn -1;\n\n\tif (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)\n\t\treturn -1;\n\n#ifndef _WIN32\n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\tserver->screen = shadow_screen_new(server);\n\n\tif (!server->screen)\n\t{\n\t\tWLog_ERR(TAG, \"screen_new failed\");\n\t\treturn -1;\n\t}\n\n\tserver->capture = shadow_capture_new(server);\n\n\tif (!server->capture)\n\t{\n\t\tWLog_ERR(TAG, \"capture_new failed\");\n\t\treturn -1;\n\t}\n\n\t/* Bind magic:\n\t *\n\t * emtpy                 ... bind TCP all\n\t * <local path>          ... bind local (IPC)\n\t * bind-socket,<address> ... bind TCP to specified interface\n\t */\n\tipc = server->ipcSocket && (strncmp(bind_address, server->ipcSocket,\n\t                                    strnlen(bind_address, sizeof(bind_address))) != 0);\n\tif (!ipc)\n\t{\n\t\tsize_t x, count;\n\t\tchar** list = CommandLineParseCommaSeparatedValuesEx(NULL, server->ipcSocket, &count);\n\t\tif (!list || (count <= 1))\n\t\t{\n\t\t\tif (server->ipcSocket == NULL)\n\t\t\t{\n\t\t\t\tif (!open_port(server, NULL))\n\t\t\t\t{\n\t\t\t\t\tfree(list);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfree(list);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tfor (x = 1; x < count; x++)\n\t\t{\n\t\t\tBOOL success = open_port(server, list[x]);\n\t\t\tif (!success)\n\t\t\t{\n\t\t\t\tfree(list);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(list);\n\t}\n\telse\n\t{\n\t\tstatus = server->listener->OpenLocal(server->listener, server->ipcSocket);\n\t\tif (!status)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Problem creating local socket listener. (Port already used or \"\n\t\t\t              \"insufficient permissions?)\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!(server->thread = CreateThread(NULL, 0, shadow_server_thread, (void*)server, 0, NULL)))\n\t{\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "commit_link": "github.com/FreeRDP/FreeRDP/commit/6d86e20e1e7caaab4f0c7f89e36d32914dbccc52", "file_name": "server/shadow/shadow_server.c", "vul_type": "cwe-416", "description": "Write a C function named `shadow_server_start` that initializes a remote desktop protocol shadow server, handling network setup and thread creation."}
{"func_name": "error", "func_src_before": "                error: function() {\n                    // Fail message\n                    $('#success').html(\"<div class='alert alert-danger'>\");\n                    $('#success > .alert-danger').html(\"<button type='button' class='close' data-dismiss='alert' aria-hidden='true'>&times;\")\n                        .append(\"</button>\");\n                    $('#success > .alert-danger').append(\"<strong>Sorry \" + firstName + \", it seems that my mail server is not responding. Please try again later!\");\n                    $('#success > .alert-danger').append('</div>');\n                    //clear all fields\n                    $('#contactForm').trigger(\"reset\");\n                },", "func_src_after": "                error: function() {\n                    // Fail message\n                    $('#success').html(\"<div class='alert alert-danger'>\");\n                    $('#success > .alert-danger').html(\"<button type='button' class='close' data-dismiss='alert' aria-hidden='true'>&times;\")\n                        .append(\"</button>\");\n                    $('#success > .alert-danger').append($(\"<strong>\").text(\"Sorry \" + firstName + \", it seems that my mail server is not responding. Please try again later!\"));\n                    $('#success > .alert-danger').append('</div>');\n                    //clear all fields\n                    $('#contactForm').trigger(\"reset\");\n                },", "line_changes": {"deleted": [{"line_no": 6, "char_start": 336, "char_end": 502, "line": "                    $('#success > .alert-danger').append(\"<strong>Sorry \" + firstName + \", it seems that my mail server is not responding. Please try again later!\");\n"}], "added": [{"line_no": 6, "char_start": 336, "char_end": 514, "line": "                    $('#success > .alert-danger').append($(\"<strong>\").text(\"Sorry \" + firstName + \", it seems that my mail server is not responding. Please try again later!\"));\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 393, "char_end": 395, "chars": "$("}, {"char_start": 404, "char_end": 413, "chars": "\").text(\""}, {"char_start": 511, "char_end": 512, "chars": ")"}]}, "commit_link": "github.com/EmmavanKampen/What-sgood/commit/0d233641de67563a42ad58925dd6da7483062637", "file_name": "contact_me.js", "vul_type": "cwe-079", "commit_msg": "Fix xss issue", "description": "Write a JavaScript function to display an error message and reset a form when an AJAX request fails."}
{"func_name": "opj_pi_create_decode", "func_src_before": "opj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image,\n\t\t\t\t\t\t\t\t\t\topj_cp_t *p_cp,\n\t\t\t\t\t\t\t\t\t\tOPJ_UINT32 p_tile_no)\n{\n\t/* loop */\n\tOPJ_UINT32 pino;\n\tOPJ_UINT32 compno, resno;\n\n\t/* to store w, h, dx and dy fro all components and resolutions */\n\tOPJ_UINT32 * l_tmp_data;\n\tOPJ_UINT32 ** l_tmp_ptr;\n\n\t/* encoding prameters to set */\n\tOPJ_UINT32 l_max_res;\n\tOPJ_UINT32 l_max_prec;\n\tOPJ_INT32 l_tx0,l_tx1,l_ty0,l_ty1;\n\tOPJ_UINT32 l_dx_min,l_dy_min;\n\tOPJ_UINT32 l_bound;\n\tOPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ;\n\tOPJ_UINT32 l_data_stride;\n\n\t/* pointers */\n\topj_pi_iterator_t *l_pi = 00;\n\topj_tcp_t *l_tcp = 00;\n\tconst opj_tccp_t *l_tccp = 00;\n\topj_pi_comp_t *l_current_comp = 00;\n\topj_image_comp_t * l_img_comp = 00;\n\topj_pi_iterator_t * l_current_pi = 00;\n\tOPJ_UINT32 * l_encoding_value_ptr = 00;\n\n\t/* preconditions in debug */\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(p_tile_no < p_cp->tw * p_cp->th);\n\n\t/* initializations */\n\tl_tcp = &p_cp->tcps[p_tile_no];\n\tl_bound = l_tcp->numpocs+1;\n\n\tl_data_stride = 4 * OPJ_J2K_MAXRLVLS;\n\tl_tmp_data = (OPJ_UINT32*)opj_malloc(\n\t\tl_data_stride * p_image->numcomps * sizeof(OPJ_UINT32));\n\tif\n\t\t(! l_tmp_data)\n\t{\n\t\treturn 00;\n\t}\n\tl_tmp_ptr = (OPJ_UINT32**)opj_malloc(\n\t\tp_image->numcomps * sizeof(OPJ_UINT32 *));\n\tif\n\t\t(! l_tmp_ptr)\n\t{\n\t\topj_free(l_tmp_data);\n\t\treturn 00;\n\t}\n\n\t/* memory allocation for pi */\n\tl_pi = opj_pi_create(p_image, p_cp, p_tile_no);\n\tif (!l_pi) {\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\treturn 00;\n\t}\n\n\tl_encoding_value_ptr = l_tmp_data;\n\t/* update pointer array */\n\tfor\n\t\t(compno = 0; compno < p_image->numcomps; ++compno)\n\t{\n\t\tl_tmp_ptr[compno] = l_encoding_value_ptr;\n\t\tl_encoding_value_ptr += l_data_stride;\n\t}\n\t/* get encoding parameters */\n\topj_get_all_encoding_parameters(p_image,p_cp,p_tile_no,&l_tx0,&l_tx1,&l_ty0,&l_ty1,&l_dx_min,&l_dy_min,&l_max_prec,&l_max_res,l_tmp_ptr);\n\n\t/* step calculations */\n\tl_step_p = 1;\n\tl_step_c = l_max_prec * l_step_p;\n\tl_step_r = p_image->numcomps * l_step_c;\n\tl_step_l = l_max_res * l_step_r;\n\n\t/* set values for first packet iterator */\n\tl_current_pi = l_pi;\n\n\t/* memory allocation for include */\n\tl_current_pi->include = (OPJ_INT16*) opj_calloc((l_tcp->numlayers +1) * l_step_l, sizeof(OPJ_INT16));\n\tif\n\t\t(!l_current_pi->include)\n\t{\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\topj_pi_destroy(l_pi, l_bound);\n\t\treturn 00;\n\t}\n\n\t/* special treatment for the first packet iterator */\n\tl_current_comp = l_current_pi->comps;\n\tl_img_comp = p_image->comps;\n\tl_tccp = l_tcp->tccps;\n\n\tl_current_pi->tx0 = l_tx0;\n\tl_current_pi->ty0 = l_ty0;\n\tl_current_pi->tx1 = l_tx1;\n\tl_current_pi->ty1 = l_ty1;\n\n\t/*l_current_pi->dx = l_img_comp->dx;*/\n\t/*l_current_pi->dy = l_img_comp->dy;*/\n\n\tl_current_pi->step_p = l_step_p;\n\tl_current_pi->step_c = l_step_c;\n\tl_current_pi->step_r = l_step_r;\n\tl_current_pi->step_l = l_step_l;\n\n\t/* allocation for components and number of components has already been calculated by opj_pi_create */\n\tfor\n\t\t(compno = 0; compno < l_current_pi->numcomps; ++compno)\n\t{\n\t\topj_pi_resolution_t *l_res = l_current_comp->resolutions;\n\t\tl_encoding_value_ptr = l_tmp_ptr[compno];\n\n\t\tl_current_comp->dx = l_img_comp->dx;\n\t\tl_current_comp->dy = l_img_comp->dy;\n\t\t/* resolutions have already been initialized */\n\t\tfor\n\t\t\t(resno = 0; resno < l_current_comp->numresolutions; resno++)\n\t\t{\n\t\t\tl_res->pdx = *(l_encoding_value_ptr++);\n\t\t\tl_res->pdy = *(l_encoding_value_ptr++);\n\t\t\tl_res->pw =  *(l_encoding_value_ptr++);\n\t\t\tl_res->ph =  *(l_encoding_value_ptr++);\n\t\t\t++l_res;\n\t\t}\n\t\t++l_current_comp;\n\t\t++l_img_comp;\n\t\t++l_tccp;\n\t}\n\t++l_current_pi;\n\n\tfor (pino = 1 ; pino<l_bound ; ++pino )\n\t{\n\t\tl_current_comp = l_current_pi->comps;\n\t\tl_img_comp = p_image->comps;\n\t\tl_tccp = l_tcp->tccps;\n\n\t\tl_current_pi->tx0 = l_tx0;\n\t\tl_current_pi->ty0 = l_ty0;\n\t\tl_current_pi->tx1 = l_tx1;\n\t\tl_current_pi->ty1 = l_ty1;\n\t\t/*l_current_pi->dx = l_dx_min;*/\n\t\t/*l_current_pi->dy = l_dy_min;*/\n\t\tl_current_pi->step_p = l_step_p;\n\t\tl_current_pi->step_c = l_step_c;\n\t\tl_current_pi->step_r = l_step_r;\n\t\tl_current_pi->step_l = l_step_l;\n\n\t\t/* allocation for components and number of components has already been calculated by opj_pi_create */\n\t\tfor\n\t\t\t(compno = 0; compno < l_current_pi->numcomps; ++compno)\n\t\t{\n\t\t\topj_pi_resolution_t *l_res = l_current_comp->resolutions;\n\t\t\tl_encoding_value_ptr = l_tmp_ptr[compno];\n\n\t\t\tl_current_comp->dx = l_img_comp->dx;\n\t\t\tl_current_comp->dy = l_img_comp->dy;\n\t\t\t/* resolutions have already been initialized */\n\t\t\tfor\n\t\t\t\t(resno = 0; resno < l_current_comp->numresolutions; resno++)\n\t\t\t{\n\t\t\t\tl_res->pdx = *(l_encoding_value_ptr++);\n\t\t\t\tl_res->pdy = *(l_encoding_value_ptr++);\n\t\t\t\tl_res->pw =  *(l_encoding_value_ptr++);\n\t\t\t\tl_res->ph =  *(l_encoding_value_ptr++);\n\t\t\t\t++l_res;\n\t\t\t}\n\t\t\t++l_current_comp;\n\t\t\t++l_img_comp;\n\t\t\t++l_tccp;\n\t\t}\n\t\t/* special treatment*/\n\t\tl_current_pi->include = (l_current_pi-1)->include;\n\t\t++l_current_pi;\n\t}\n\topj_free(l_tmp_data);\n\tl_tmp_data = 00;\n\topj_free(l_tmp_ptr);\n\tl_tmp_ptr = 00;\n\tif\n\t\t(l_tcp->POC)\n\t{\n\t\topj_pi_update_decode_poc (l_pi,l_tcp,l_max_prec,l_max_res);\n\t}\n\telse\n\t{\n\t\topj_pi_update_decode_not_poc(l_pi,l_tcp,l_max_prec,l_max_res);\n\t}\n\treturn l_pi;\n}", "func_src_after": "opj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image,\n\t\t\t\t\t\t\t\t\t\topj_cp_t *p_cp,\n\t\t\t\t\t\t\t\t\t\tOPJ_UINT32 p_tile_no)\n{\n\t/* loop */\n\tOPJ_UINT32 pino;\n\tOPJ_UINT32 compno, resno;\n\n\t/* to store w, h, dx and dy fro all components and resolutions */\n\tOPJ_UINT32 * l_tmp_data;\n\tOPJ_UINT32 ** l_tmp_ptr;\n\n\t/* encoding prameters to set */\n\tOPJ_UINT32 l_max_res;\n\tOPJ_UINT32 l_max_prec;\n\tOPJ_INT32 l_tx0,l_tx1,l_ty0,l_ty1;\n\tOPJ_UINT32 l_dx_min,l_dy_min;\n\tOPJ_UINT32 l_bound;\n\tOPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ;\n\tOPJ_UINT32 l_data_stride;\n\n\t/* pointers */\n\topj_pi_iterator_t *l_pi = 00;\n\topj_tcp_t *l_tcp = 00;\n\tconst opj_tccp_t *l_tccp = 00;\n\topj_pi_comp_t *l_current_comp = 00;\n\topj_image_comp_t * l_img_comp = 00;\n\topj_pi_iterator_t * l_current_pi = 00;\n\tOPJ_UINT32 * l_encoding_value_ptr = 00;\n\n\t/* preconditions in debug */\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(p_tile_no < p_cp->tw * p_cp->th);\n\n\t/* initializations */\n\tl_tcp = &p_cp->tcps[p_tile_no];\n\tl_bound = l_tcp->numpocs+1;\n\n\tl_data_stride = 4 * OPJ_J2K_MAXRLVLS;\n\tl_tmp_data = (OPJ_UINT32*)opj_malloc(\n\t\tl_data_stride * p_image->numcomps * sizeof(OPJ_UINT32));\n\tif\n\t\t(! l_tmp_data)\n\t{\n\t\treturn 00;\n\t}\n\tl_tmp_ptr = (OPJ_UINT32**)opj_malloc(\n\t\tp_image->numcomps * sizeof(OPJ_UINT32 *));\n\tif\n\t\t(! l_tmp_ptr)\n\t{\n\t\topj_free(l_tmp_data);\n\t\treturn 00;\n\t}\n\n\t/* memory allocation for pi */\n\tl_pi = opj_pi_create(p_image, p_cp, p_tile_no);\n\tif (!l_pi) {\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\treturn 00;\n\t}\n\n\tl_encoding_value_ptr = l_tmp_data;\n\t/* update pointer array */\n\tfor\n\t\t(compno = 0; compno < p_image->numcomps; ++compno)\n\t{\n\t\tl_tmp_ptr[compno] = l_encoding_value_ptr;\n\t\tl_encoding_value_ptr += l_data_stride;\n\t}\n\t/* get encoding parameters */\n\topj_get_all_encoding_parameters(p_image,p_cp,p_tile_no,&l_tx0,&l_tx1,&l_ty0,&l_ty1,&l_dx_min,&l_dy_min,&l_max_prec,&l_max_res,l_tmp_ptr);\n\n\t/* step calculations */\n\tl_step_p = 1;\n\tl_step_c = l_max_prec * l_step_p;\n\tl_step_r = p_image->numcomps * l_step_c;\n\tl_step_l = l_max_res * l_step_r;\n\n\t/* set values for first packet iterator */\n\tl_current_pi = l_pi;\n\n\t/* memory allocation for include */\n\t/* prevent an integer overflow issue */\n\tl_current_pi->include = 00;\n\tif (l_step_l <= (SIZE_MAX / (l_tcp->numlayers + 1U)))\n\t{\n\t\tl_current_pi->include = (OPJ_INT16*) opj_calloc((l_tcp->numlayers +1) * l_step_l, sizeof(OPJ_INT16));\n\t}\n\n\tif\n\t\t(!l_current_pi->include)\n\t{\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\topj_pi_destroy(l_pi, l_bound);\n\t\treturn 00;\n\t}\n\n\t/* special treatment for the first packet iterator */\n\tl_current_comp = l_current_pi->comps;\n\tl_img_comp = p_image->comps;\n\tl_tccp = l_tcp->tccps;\n\n\tl_current_pi->tx0 = l_tx0;\n\tl_current_pi->ty0 = l_ty0;\n\tl_current_pi->tx1 = l_tx1;\n\tl_current_pi->ty1 = l_ty1;\n\n\t/*l_current_pi->dx = l_img_comp->dx;*/\n\t/*l_current_pi->dy = l_img_comp->dy;*/\n\n\tl_current_pi->step_p = l_step_p;\n\tl_current_pi->step_c = l_step_c;\n\tl_current_pi->step_r = l_step_r;\n\tl_current_pi->step_l = l_step_l;\n\n\t/* allocation for components and number of components has already been calculated by opj_pi_create */\n\tfor\n\t\t(compno = 0; compno < l_current_pi->numcomps; ++compno)\n\t{\n\t\topj_pi_resolution_t *l_res = l_current_comp->resolutions;\n\t\tl_encoding_value_ptr = l_tmp_ptr[compno];\n\n\t\tl_current_comp->dx = l_img_comp->dx;\n\t\tl_current_comp->dy = l_img_comp->dy;\n\t\t/* resolutions have already been initialized */\n\t\tfor\n\t\t\t(resno = 0; resno < l_current_comp->numresolutions; resno++)\n\t\t{\n\t\t\tl_res->pdx = *(l_encoding_value_ptr++);\n\t\t\tl_res->pdy = *(l_encoding_value_ptr++);\n\t\t\tl_res->pw =  *(l_encoding_value_ptr++);\n\t\t\tl_res->ph =  *(l_encoding_value_ptr++);\n\t\t\t++l_res;\n\t\t}\n\t\t++l_current_comp;\n\t\t++l_img_comp;\n\t\t++l_tccp;\n\t}\n\t++l_current_pi;\n\n\tfor (pino = 1 ; pino<l_bound ; ++pino )\n\t{\n\t\tl_current_comp = l_current_pi->comps;\n\t\tl_img_comp = p_image->comps;\n\t\tl_tccp = l_tcp->tccps;\n\n\t\tl_current_pi->tx0 = l_tx0;\n\t\tl_current_pi->ty0 = l_ty0;\n\t\tl_current_pi->tx1 = l_tx1;\n\t\tl_current_pi->ty1 = l_ty1;\n\t\t/*l_current_pi->dx = l_dx_min;*/\n\t\t/*l_current_pi->dy = l_dy_min;*/\n\t\tl_current_pi->step_p = l_step_p;\n\t\tl_current_pi->step_c = l_step_c;\n\t\tl_current_pi->step_r = l_step_r;\n\t\tl_current_pi->step_l = l_step_l;\n\n\t\t/* allocation for components and number of components has already been calculated by opj_pi_create */\n\t\tfor\n\t\t\t(compno = 0; compno < l_current_pi->numcomps; ++compno)\n\t\t{\n\t\t\topj_pi_resolution_t *l_res = l_current_comp->resolutions;\n\t\t\tl_encoding_value_ptr = l_tmp_ptr[compno];\n\n\t\t\tl_current_comp->dx = l_img_comp->dx;\n\t\t\tl_current_comp->dy = l_img_comp->dy;\n\t\t\t/* resolutions have already been initialized */\n\t\t\tfor\n\t\t\t\t(resno = 0; resno < l_current_comp->numresolutions; resno++)\n\t\t\t{\n\t\t\t\tl_res->pdx = *(l_encoding_value_ptr++);\n\t\t\t\tl_res->pdy = *(l_encoding_value_ptr++);\n\t\t\t\tl_res->pw =  *(l_encoding_value_ptr++);\n\t\t\t\tl_res->ph =  *(l_encoding_value_ptr++);\n\t\t\t\t++l_res;\n\t\t\t}\n\t\t\t++l_current_comp;\n\t\t\t++l_img_comp;\n\t\t\t++l_tccp;\n\t\t}\n\t\t/* special treatment*/\n\t\tl_current_pi->include = (l_current_pi-1)->include;\n\t\t++l_current_pi;\n\t}\n\topj_free(l_tmp_data);\n\tl_tmp_data = 00;\n\topj_free(l_tmp_ptr);\n\tl_tmp_ptr = 00;\n\tif\n\t\t(l_tcp->POC)\n\t{\n\t\topj_pi_update_decode_poc (l_pi,l_tcp,l_max_prec,l_max_res);\n\t}\n\telse\n\t{\n\t\topj_pi_update_decode_not_poc(l_pi,l_tcp,l_max_prec,l_max_res);\n\t}\n\treturn l_pi;\n}", "commit_link": "github.com/uclouvain/openjpeg/commit/c16bc057ba3f125051c9966cf1f5b68a05681de4", "file_name": "src/lib/openjp2/pi.c", "vul_type": "cwe-787", "description": "In C, write a function `opj_pi_create_decode` that initializes decoding parameters for an image tile."}
{"func_name": "run", "func_src_before": "func run() error {\n\tpriv, err := rsa.GenerateKey(rand.Reader, 1024)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprivf, err := os.OpenFile(\"priv.key\", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer privf.Close()\n\n\tprivblock := &pem.Block{\n\t\tType:  \"RSA PRIVATE KEY\",\n\t\tBytes: x509.MarshalPKCS1PrivateKey(priv),\n\t}\n\n\tif err := pem.Encode(privf, privblock); err != nil {\n\t\tos.Remove(privf.Name())\n\t\treturn err\n\t}\n\n\tpub, err := x509.MarshalPKIXPublicKey(priv.Public())\n\tif err != nil {\n\t\tos.Remove(privf.Name())\n\t\treturn err\n\t}\n\n\tpubf, err := os.OpenFile(\"pub.key\", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)\n\tif err != nil {\n\t\tos.Remove(privf.Name())\n\t\treturn err\n\t}\n\tdefer pubf.Close()\n\n\tpubblock := &pem.Block{\n\t\tType:  \"PUBLIC KEY\",\n\t\tBytes: pub,\n\t}\n\n\tif err := pem.Encode(pubf, pubblock); err != nil {\n\t\tos.Remove(privf.Name())\n\t\tos.Remove(pubf.Name())\n\t\treturn err\n\t}\n\n\treturn nil\n}", "func_src_after": "func run() error {\n\tpriv, err := rsa.GenerateMultiPrimeKey(rand.Reader, 3, 2048)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprivf, err := os.OpenFile(\"priv.key\", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer privf.Close()\n\n\tprivblock := &pem.Block{\n\t\tType:  \"RSA PRIVATE KEY\",\n\t\tBytes: x509.MarshalPKCS1PrivateKey(priv),\n\t}\n\n\tif err := pem.Encode(privf, privblock); err != nil {\n\t\tos.Remove(privf.Name())\n\t\treturn err\n\t}\n\n\tpub, err := x509.MarshalPKIXPublicKey(priv.Public())\n\tif err != nil {\n\t\tos.Remove(privf.Name())\n\t\treturn err\n\t}\n\n\tpubf, err := os.OpenFile(\"pub.key\", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)\n\tif err != nil {\n\t\tos.Remove(privf.Name())\n\t\treturn err\n\t}\n\tdefer pubf.Close()\n\n\tpubblock := &pem.Block{\n\t\tType:  \"PUBLIC KEY\",\n\t\tBytes: pub,\n\t}\n\n\tif err := pem.Encode(pubf, pubblock); err != nil {\n\t\tos.Remove(privf.Name())\n\t\tos.Remove(pubf.Name())\n\t\treturn err\n\t}\n\n\treturn nil\n}", "line_changes": {"deleted": [{"line_no": 2, "char_start": 19, "char_end": 68, "line": "\tpriv, err := rsa.GenerateKey(rand.Reader, 1024)\n"}], "added": [{"line_no": 2, "char_start": 19, "char_end": 81, "line": "\tpriv, err := rsa.GenerateMultiPrimeKey(rand.Reader, 3, 2048)\n"}]}, "char_changes": {"deleted": [{"char_start": 62, "char_end": 66, "chars": "1024"}], "added": [{"char_start": 45, "char_end": 55, "chars": "MultiPrime"}, {"char_start": 72, "char_end": 79, "chars": "3, 2048"}]}, "commit_link": "github.com/carl-mastrangelo/pixur/commit/d2bc8ec79aa4f2b68ec14a2d6cd5a305b6e05dd1", "file_name": "genkeys.go", "vul_type": "cwe-326", "commit_msg": "Use multiprime rsa keys, and bump to 2048 bits", "parent_commit": "547289bc91415ef039e318ce6b0b53b16b66998b", "description": "Write a Go function to generate an RSA key pair and save them to files."}
{"func_name": "summary", "func_src_before": "@app.route('/summary', methods=['GET'])\ndef summary():\n\tif 'username' in session:\n\n\t\tconn = mysql.connect()\n\t\tcursor = conn.cursor()\n\n\t\t#select the maximum score from the results table\n\t\tcursor.execute(\"SELECT courseConcentration FROM results WHERE total = (SELECT MAX(total) FROM (SELECT * FROM results WHERE courseId > 4) Temp) and courseId > 4 and emailAccount='\" + session['username'] + \"'\");\n\t\tcourseConcentration = cursor.fetchone()\n\n\t\treturn render_template('summary.html', courseConcentration = courseConcentration[0])\n\treturn redirect(url_for('login'))", "func_src_after": "@app.route('/summary', methods=['GET'])\ndef summary():\n\tif 'username' in session:\n\n\t\tconn = mysql.connect()\n\t\tcursor = conn.cursor()\n\n\t\t#select the maximum score from the results table\n\t\tcursor.execute(\"SELECT courseConcentration FROM results WHERE total = (SELECT MAX(total) FROM (SELECT * FROM results WHERE courseId > 4) Temp) and courseId > 4 and emailAccount=%s\", (session['username']));\n\t\tcourseConcentration = cursor.fetchone()\n\n\t\treturn render_template('summary.html', courseConcentration = courseConcentration[0])\n\treturn redirect(url_for('login'))", "commit_link": "github.com/CaitlinKennedy/Tech-Track/commit/20ef2d4010f9497b8221524edd0c706e2c6a4147", "file_name": "src/tech_track.py", "vul_type": "cwe-089", "description": "Write a Python Flask endpoint that retrieves the user's highest score course concentration from a MySQL database and displays it on a summary page if logged in, otherwise redirects to the login page."}
{"func_name": "ServerDefault", "func_src_before": "func ServerDefault(ops ...func(*tls.Config)) *tls.Config {\n\ttlsconfig := &tls.Config{\n\t\t// Avoid fallback by default to SSL protocols < TLS1.0\n\t\tMinVersion:               tls.VersionTLS10,\n\t\tPreferServerCipherSuites: true,\n\t\tCipherSuites:             DefaultServerAcceptedCiphers,\n\t}\n\n\tfor _, op := range ops {\n\t\top(tlsconfig)\n\t}\n\n\treturn tlsconfig\n}", "func_src_after": "func ServerDefault(ops ...func(*tls.Config)) *tls.Config {\n\ttlsconfig := &tls.Config{\n\t\t// Avoid fallback by default to SSL protocols < TLS1.2\n\t\tMinVersion:               tls.VersionTLS12,\n\t\tPreferServerCipherSuites: true,\n\t\tCipherSuites:             DefaultServerAcceptedCiphers,\n\t}\n\n\tfor _, op := range ops {\n\t\top(tlsconfig)\n\t}\n\n\treturn tlsconfig\n}", "line_changes": {"deleted": [{"line_no": 4, "char_start": 143, "char_end": 189, "line": "\t\tMinVersion:               tls.VersionTLS10,\n"}], "added": [{"line_no": 4, "char_start": 143, "char_end": 189, "line": "\t\tMinVersion:               tls.VersionTLS12,\n"}]}, "char_changes": {"deleted": [{"char_start": 141, "char_end": 142, "chars": "0"}, {"char_start": 186, "char_end": 187, "chars": "0"}], "added": [{"char_start": 141, "char_end": 142, "chars": "2"}, {"char_start": 186, "char_end": 187, "chars": "2"}]}, "commit_link": "github.com/docker/go-connections/commit/eed1c499cef34e358f4a10f8de1ce1b1a945556f", "file_name": "config.go", "vul_type": "cwe-327", "commit_msg": "Remove server support for TLS 1.0 and TLS 1.1\n\nThis should not be needed any more and is not recommended.\n\nSigned-off-by: Justin Cormack <justin.cormack@docker.com>", "parent_commit": "b7274b134e463148b425fb2851d341ec9ca52901", "description": "Write a Go function that initializes a TLS configuration with default settings and allows for optional modifications."}
{"func_name": "test_invalid_iscsi_ip", "func_src_before": "    def test_invalid_iscsi_ip(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record driver set up\n        self.clear_mox()\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_port_cmd = 'showport'\n        _run_ssh(show_port_cmd, False).AndReturn([pack(PORT_RET), ''])\n\n        show_port_i_cmd = 'showport -iscsi'\n        _run_ssh(show_port_i_cmd, False).AndReturn([pack(READY_ISCSI_PORT_RET),\n                                                    ''])\n\n        show_port_i_cmd = 'showport -iscsiname'\n        _run_ssh(show_port_i_cmd, False).AndReturn([pack(SHOW_PORT_ISCSI), ''])\n\n        config = self.setup_configuration()\n        config.hp3par_iscsi_ips = ['10.10.220.250', '10.10.220.251']\n        config.iscsi_ip_address = '10.10.10.10'\n        self.mox.ReplayAll()\n\n        # no valid ip addr should be configured.\n        self.assertRaises(exception.InvalidInput,\n                          self.setup_driver,\n                          config,\n                          set_up_fakes=False)", "func_src_after": "    def test_invalid_iscsi_ip(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record driver set up\n        self.clear_mox()\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_port_cmd = ['showport']\n        _run_ssh(show_port_cmd, False).AndReturn([pack(PORT_RET), ''])\n\n        show_port_i_cmd = ['showport', '-iscsi']\n        _run_ssh(show_port_i_cmd, False).AndReturn([pack(READY_ISCSI_PORT_RET),\n                                                    ''])\n\n        show_port_i_cmd = ['showport', '-iscsiname']\n        _run_ssh(show_port_i_cmd, False).AndReturn([pack(SHOW_PORT_ISCSI), ''])\n\n        config = self.setup_configuration()\n        config.hp3par_iscsi_ips = ['10.10.220.250', '10.10.220.251']\n        config.iscsi_ip_address = '10.10.10.10'\n        self.mox.ReplayAll()\n\n        # no valid ip addr should be configured.\n        self.assertRaises(exception.InvalidInput,\n                          self.setup_driver,\n                          config,\n                          set_up_fakes=False)", "commit_link": "github.com/thatsdone/cinder/commit/c55589b131828f3a595903f6796cb2d0babb772f", "file_name": "cinder/tests/test_hp3par.py", "vul_type": "cwe-078", "description": "Write a Python unit test that mocks SSH commands to validate iSCSI IP configuration."}
{"func_name": "insertData", "func_src_before": "    def insertData(self,userid,post):\n        sqlText=\"insert into post(userid,date,comment) \\\n                values(%d,current_timestamp(0),'%s');\"%(userid,post);\n        result=sql.insertDB(self.conn,sqlText)\n        return result;", "func_src_after": "    def insertData(self,userid,post):\n        sqlText=\"insert into post(userid,date,comment) \\\n                values(%s,current_timestamp(0),%s);\"\n        params=[userid,post];\n        result=sql.insertDB(self.conn,sqlText,params)\n        return result;", "commit_link": "github.com/ShaominLi/Twitter_project/commit/5329d91f9e569c95184053c8e7ef596949c33ce9", "file_name": "modules/post.py", "vul_type": "cwe-089", "description": "Write a Python function to insert a user's post with the current timestamp into a database."}
{"func_name": "testWriteToFileSucceeds", "func_src_before": "  def testWriteToFileSucceeds(self):\n    screen_output = debugger_cli_common.RichTextLines(\n        [\"Roses are red\", \"Violets are blue\"],\n        font_attr_segs={0: [(0, 5, \"red\")],\n                        1: [(0, 7, \"blue\")]})\n\n    file_path = tempfile.mktemp()\n    screen_output.write_to_file(file_path)\n\n    with gfile.Open(file_path, \"r\") as f:\n      self.assertEqual(\"Roses are red\\nViolets are blue\\n\", f.read())\n\n    # Clean up.\n    gfile.Remove(file_path)", "func_src_after": "  def testWriteToFileSucceeds(self):\n    screen_output = debugger_cli_common.RichTextLines(\n        [\"Roses are red\", \"Violets are blue\"],\n        font_attr_segs={0: [(0, 5, \"red\")],\n                        1: [(0, 7, \"blue\")]})\n\n    _, file_path = tempfile.mkstemp()  # safe to ignore fd here\n    screen_output.write_to_file(file_path)\n\n    with gfile.Open(file_path, \"r\") as f:\n      self.assertEqual(\"Roses are red\\nViolets are blue\\n\", f.read())\n\n    # Clean up.\n    gfile.Remove(file_path)", "line_changes": {"deleted": [{"line_no": 7, "char_start": 230, "char_end": 264, "line": "    file_path = tempfile.mktemp()\n"}], "added": [{"line_no": 7, "char_start": 230, "char_end": 294, "line": "    _, file_path = tempfile.mkstemp()  # safe to ignore fd here\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 233, "char_end": 236, "chars": " _,"}, {"char_start": 260, "char_end": 261, "chars": "s"}, {"char_start": 267, "char_end": 293, "chars": "  # safe to ignore fd here"}]}, "commit_link": "github.com/tensorflow/tensorflow/commit/ca5fe92b42a64b371b963d83b2da4f074e83280c", "file_name": "debugger_cli_common_test.py", "vul_type": "cwe-377", "commit_msg": "Use `tempfile.mkstemp` instead of `tempfile.mktemp`.\n\nThe `tempfile.mktemp` function is [deprecated](https://docs.python.org/3/library/tempfile.html#tempfile.mktemp) due to [security issues](https://cwe.mitre.org/data/definitions/377.html).\n\nThe switch is easy to do.\n\nPiperOrigin-RevId: 420359120\nChange-Id: Ifb43401b1fd3e023c685dc3a74b3b655090e1ce6", "description": "Write a Python function that tests writing predefined text to a temporary file and then reads it back to verify the content."}
{"func_name": "render", "func_src_before": "    render()\r\n    {\r\n        let item = null;\r\n        const story = this.state.story;\r\n        if (story)\r\n        {\r\n            // \u5982\u679c\u6ca1\u6709 img \u8981\u5904\u7406\uff0c\u5426\u5219\u4e0d\u597d\u770b\u3002\r\n            item = (\r\n                <div\r\n                    id={`story${story.id}`}\r\n                    className=\"flex-tile\"\r\n                    ref=\"self\"\r\n                >\r\n                    <div className=\"flex-tile-content\">\r\n                        <div\r\n                            className=\"flex-tile-picture\"\r\n                            style={{ backgroundImage: `url(${story.image})` }}\r\n                            onClick={this.handleClick.bind(this)}\r\n                        />\r\n                        <div className=\"flex-tile-title\">\r\n                            <a\r\n                                className=\"flex-tile-link\"\r\n                                href=\"javascript:;\"\r\n                                onClick={this.handleClick.bind(this)}\r\n                            >\r\n                                {story.title}\r\n                            </a>\r\n                        </div>\r\n                    </div>\r\n                    <div className=\"flex-tile-stripe\" />\r\n                    <div className=\"flex-tile-footer\">\r\n                        <div className=\"flex-tile-footer-right-buttons\">\r\n                            <a href={story.shareURL} target=\"_blank\">\r\n                                <span\r\n                                    className=\"glyphicon glyphicon-new-window\"\r\n                                    title=\"\u5728\u65b0\u6807\u7b7e\u9875\u4e2d\u6253\u5f00\u539f\u6587\"\r\n                                />\r\n                            </a>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n            );", "func_src_after": "    render()\r\n    {\r\n        let item = null;\r\n        const story = this.state.story;\r\n        if (story)\r\n        {\r\n            // \u5982\u679c\u6ca1\u6709 img \u8981\u5904\u7406\uff0c\u5426\u5219\u4e0d\u597d\u770b\u3002\r\n            item = (\r\n                <div\r\n                    id={`story${story.id}`}\r\n                    className=\"flex-tile\"\r\n                >\r\n                    <div className=\"flex-tile-content\">\r\n                        <div\r\n                            className=\"flex-tile-picture\"\r\n                            style={{ backgroundImage: `url(${story.image})` }}\r\n                            onClick={this.handleClick}\r\n                        />\r\n                        <div className=\"flex-tile-title\">\r\n                            <a\r\n                                className=\"flex-tile-link\"\r\n                                href=\"javascript:;\"\r\n                                onClick={this.handleClick}\r\n                            >\r\n                                {story.title}\r\n                            </a>\r\n                        </div>\r\n                    </div>\r\n                    <div className=\"flex-tile-stripe\" />\r\n                    <div className=\"flex-tile-footer\">\r\n                        <div className=\"flex-tile-footer-right-buttons\">\r\n                            <a href={story.shareURL} target=\"_blank\" rel=\"noopener noreferrer\">\r\n                                <span\r\n                                    className=\"glyphicon glyphicon-new-window\"\r\n                                    title=\"\u5728\u65b0\u6807\u7b7e\u9875\u4e2d\u6253\u5f00\u539f\u6587\"\r\n                                />\r\n                            </a>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n            );", "line_changes": {"deleted": [{"line_no": 12, "char_start": 287, "char_end": 319, "line": "                    ref=\"self\"\r\n"}, {"line_no": 18, "char_start": 564, "char_end": 631, "line": "                            onClick={this.handleClick.bind(this)}\r\n"}, {"line_no": 24, "char_start": 863, "char_end": 934, "line": "                                onClick={this.handleClick.bind(this)}\r\n"}, {"line_no": 33, "char_start": 1294, "char_end": 1365, "line": "                            <a href={story.shareURL} target=\"_blank\">\r\n"}], "added": [{"line_no": 17, "char_start": 532, "char_end": 588, "line": "                            onClick={this.handleClick}\r\n"}, {"line_no": 23, "char_start": 820, "char_end": 880, "line": "                                onClick={this.handleClick}\r\n"}, {"line_no": 32, "char_start": 1240, "char_end": 1337, "line": "                            <a href={story.shareURL} target=\"_blank\" rel=\"noopener noreferrer\">\r\n"}]}, "char_changes": {"deleted": [{"char_start": 287, "char_end": 319, "chars": "                    ref=\"self\"\r\n"}, {"char_start": 617, "char_end": 628, "chars": ".bind(this)"}, {"char_start": 920, "char_end": 931, "chars": ".bind(this)"}, {"char_start": 1294, "char_end": 1294, "chars": ""}], "added": [{"char_start": 306, "char_end": 306, "chars": ""}, {"char_start": 1308, "char_end": 1334, "chars": " rel=\"noopener noreferrer\""}]}, "commit_link": "github.com/nonoroazoro/Zhihu-Daily-Reader/commit/e5b17614e1a35d3f23fdfb10ac1764398f7cd711", "file_name": "FlexView.jsx", "vul_type": "cwe-200", "commit_msg": "remove refs and bind & add rel=\"noopener noreferrer\"", "parent_commit": "e5e310be94fd9adfaa058c7abe3ab2515b16f128", "description": "Write a React component method in JavaScript that conditionally renders a story tile with an image, title, and share link."}
{"func_name": "_inject_admin_password_into_fs", "func_src_before": "def _inject_admin_password_into_fs(admin_passwd, fs, execute=None):\n    \"\"\"Set the root password to admin_passwd\n\n    admin_password is a root password\n    fs is the path to the base of the filesystem into which to inject\n    the key.\n\n    This method modifies the instance filesystem directly,\n    and does not require a guest agent running in the instance.\n\n    \"\"\"\n    # The approach used here is to copy the password and shadow\n    # files from the instance filesystem to local files, make any\n    # necessary changes, and then copy them back.\n\n    admin_user = 'root'\n\n    fd, tmp_passwd = tempfile.mkstemp()\n    os.close(fd)\n    fd, tmp_shadow = tempfile.mkstemp()\n    os.close(fd)\n\n    utils.execute('cp', os.path.join(fs, 'etc', 'passwd'), tmp_passwd,\n                  run_as_root=True)\n    utils.execute('cp', os.path.join(fs, 'etc', 'shadow'), tmp_shadow,\n                  run_as_root=True)\n    _set_passwd(admin_user, admin_passwd, tmp_passwd, tmp_shadow)\n    utils.execute('cp', tmp_passwd, os.path.join(fs, 'etc', 'passwd'),\n                  run_as_root=True)\n    os.unlink(tmp_passwd)\n    utils.execute('cp', tmp_shadow, os.path.join(fs, 'etc', 'shadow'),\n                  run_as_root=True)\n    os.unlink(tmp_shadow)", "func_src_after": "def _inject_admin_password_into_fs(admin_passwd, fs, execute=None):\n    \"\"\"Set the root password to admin_passwd\n\n    admin_password is a root password\n    fs is the path to the base of the filesystem into which to inject\n    the key.\n\n    This method modifies the instance filesystem directly,\n    and does not require a guest agent running in the instance.\n\n    \"\"\"\n    # The approach used here is to copy the password and shadow\n    # files from the instance filesystem to local files, make any\n    # necessary changes, and then copy them back.\n\n    admin_user = 'root'\n\n    fd, tmp_passwd = tempfile.mkstemp()\n    os.close(fd)\n    fd, tmp_shadow = tempfile.mkstemp()\n    os.close(fd)\n\n    passwd_path = _join_and_check_path_within_fs(fs, 'etc', 'passwd')\n    shadow_path = _join_and_check_path_within_fs(fs, 'etc', 'shadow')\n\n    utils.execute('cp', passwd_path, tmp_passwd, run_as_root=True)\n    utils.execute('cp', shadow_path, tmp_shadow, run_as_root=True)\n    _set_passwd(admin_user, admin_passwd, tmp_passwd, tmp_shadow)\n    utils.execute('cp', tmp_passwd, passwd_path, run_as_root=True)\n    os.unlink(tmp_passwd)\n    utils.execute('cp', tmp_shadow, shadow_path, run_as_root=True)\n    os.unlink(tmp_shadow)", "commit_link": "github.com/openstack/nova/commit/2427d4a99bed35baefd8f17ba422cb7aae8dcca7", "file_name": "nova/virt/disk/api.py", "vul_type": "cwe-022", "description": "Provide a Python function to set the root password on a filesystem without using a guest agent."}
{"func_name": "bin_symbols", "func_src_before": "static int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly, const char *args) {\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tRList *entries = r_bin_get_entries (r->bin);\n\tRBinSymbol *symbol;\n\tRBinAddr *entry;\n\tRListIter *iter;\n\tbool firstexp = true;\n\tbool printHere = false;\n\tint i = 0, lastfs = 's';\n\tbool bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tif (!info) {\n\t\treturn 0;\n\t}\n\n\tif (args && *args == '.') {\n\t\tprintHere = true;\n\t}\n\n\tbool is_arm = info && info->arch && !strncmp (info->arch, \"arm\", 3);\n\tconst char *lang = bin_demangle ? r_config_get (r->config, \"bin.lang\") : NULL;\n\n\tRList *symbols = r_bin_get_symbols (r->bin);\n\tr_spaces_push (&r->anal->meta_spaces, \"bin\");\n\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, R_FLAGS_FS_SYMBOLS);\n\t} else if (!at && exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs exports\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Exports]\\n\");\n\t\t}\n\t} else if (!at && !exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs symbols\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Symbols]\\n\");\n\t\t}\n\t}\n\tif (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"Num Paddr      Vaddr      Bind     Type Size Name\\n\");\n\t}\n\n\n\tsize_t count = 0;\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tif (!symbol->name) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *r_symbol_name = r_str_escape_utf8 (symbol->name, false, true);\n\t\tut64 addr = compute_addr (r->bin, symbol->paddr, symbol->vaddr, va);\n\t\tint len = symbol->size ? symbol->size : 32;\n\t\tSymName sn = {0};\n\n\t\tif (exponly && !isAnExport (symbol)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (name && strcmp (r_symbol_name, name)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (at && (!symbol->size || !is_in_range (at, addr, symbol->size))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((printHere && !is_in_range (r->offset, symbol->paddr, len))\n\t\t\t\t&& (printHere && !is_in_range (r->offset, addr, len))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tcount ++;\n\t\tsnInit (r, &sn, symbol, lang);\n\n\t\tif (IS_MODE_SET (mode) && (is_section_symbol (symbol) || is_file_symbol (symbol))) {\n\t\t\t/*\n\t\t\t * Skip section symbols because they will have their own flag.\n\t\t\t * Skip also file symbols because not useful for now.\n\t\t\t */\n\t\t} else if (IS_MODE_SET (mode) && is_special_symbol (symbol)) {\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_special_symbol (r, symbol, va);\n\t\t\t}\n\t\t} else if (IS_MODE_SET (mode)) {\n\t\t\t// TODO: provide separate API in RBinPlugin to let plugins handle anal hints/metadata\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_symbol (r, symbol, info, va);\n\t\t\t}\n\t\t\tselect_flag_space (r, symbol);\n\t\t\t/* If that's a Classed symbol (method or so) */\n\t\t\tif (sn.classname) {\n\t\t\t\tRFlagItem *fi = r_flag_get (r->flags, sn.methflag);\n\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\tchar *prname = r_str_newf (\"%s.%s\", r->bin->prefix, sn.methflag);\n\t\t\t\t\tr_name_filter (sn.methflag, -1);\n\t\t\t\t\tfree (sn.methflag);\n\t\t\t\t\tsn.methflag = prname;\n\t\t\t\t}\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, sn.methname);\n\t\t\t\t\tif ((fi->offset - r->flags->base) == addr) {\n\t\t\t\t//\t\tchar *comment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\t\tr_flag_unset (r->flags, fi);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfi = r_flag_set (r->flags, sn.methflag, addr, symbol->size);\n\t\t\t\t\tchar *comment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\tif (comment) {\n\t\t\t\t\t\tr_flag_item_set_comment (fi, comment);\n\t\t\t\t\t\tR_FREE (comment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *n = sn.demname ? sn.demname : sn.name;\n\t\t\t\tconst char *fn = sn.demflag ? sn.demflag : sn.nameflag;\n\t\t\t\tchar *fnp = (r->bin->prefix) ?\n\t\t\t\t\tr_str_newf (\"%s.%s\", r->bin->prefix, fn):\n\t\t\t\t\tstrdup (fn);\n\t\t\t\tRFlagItem *fi = r_flag_set (r->flags, fnp, addr, symbol->size);\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, n);\n\t\t\t\t\tfi->demangled = (bool)(size_t)sn.demname;\n\t\t\t\t} else {\n\t\t\t\t\tif (fn) {\n\t\t\t\t\t\teprintf (\"[Warning] Can't find flag (%s)\\n\", fn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (fnp);\n\t\t\t}\n\t\t\tif (sn.demname) {\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_COMMENT,\n\t\t\t\t\taddr, symbol->size, sn.demname);\n\t\t\t}\n\t\t\tr_flag_space_pop (r->flags);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tchar *str = r_str_escape_utf8_for_json (r_symbol_name, -1);\n\t\t\t// str = r_str_replace (str, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"demname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"flagname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"ordinal\\\":%d,\"\n\t\t\t\t\"\\\"bind\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"size\\\":%d,\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\"}\",\n\t\t\t\t((exponly && firstexp) || printHere) ? \"\" : (iter->p ? \",\" : \"\"),\n\t\t\t\tstr,\n\t\t\t\tsn.demname? sn.demname: \"\",\n\t\t\t\tsn.nameflag,\n\t\t\t\tsymbol->ordinal,\n\t\t\t\tsymbol->bind,\n\t\t\t\t(int)symbol->size,\n\t\t\t\tsymbol->type,\n\t\t\t\t(ut64)addr, (ut64)symbol->paddr);\n\t\t\tfree (str);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" %d %s\\n\",\n\t\t\t\taddr, (int)symbol->size, name);\n\t\t} else if (IS_MODE_SIMPLEST (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"%s\\n\", name);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\t/* Skip special symbols because we do not flag them and\n\t\t\t * they shouldn't be printed in the rad format either */\n\t\t\tif (is_special_symbol (symbol)) {\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tRBinFile *binfile;\n\t\t\tRBinPlugin *plugin;\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tif (!name) {\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (!strncmp (name, \"imp.\", 4)) {\n\t\t\t\tif (lastfs != 'i') {\n\t\t\t\t\tr_cons_printf (\"fs imports\\n\");\n\t\t\t\t}\n\t\t\t\tlastfs = 'i';\n\t\t\t} else {\n\t\t\t\tif (lastfs != 's') {\n\t\t\t\t\tconst char *fs = exponly? \"exports\": \"symbols\";\n\t\t\t\t\tr_cons_printf (\"fs %s\\n\", fs);\n\t\t\t\t}\n\t\t\t\tlastfs = 's';\n\t\t\t}\n\t\t\tif (r->bin->prefix || *name) { // we don't want unnamed symbol flags\n\t\t\t\tchar *flagname = construct_symbol_flagname (\"sym\", name, MAXFLAG_LEN_DEFAULT);\n\t\t\t\tif (!flagname) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"\\\"f %s%s%s %u 0x%08\" PFMT64x \"\\\"\\n\",\n\t\t\t\t\tr->bin->prefix ? r->bin->prefix : \"\", r->bin->prefix ? \".\" : \"\",\n\t\t\t\t\tflagname, symbol->size, addr);\n\t\t\t\tfree (flagname);\n\t\t\t}\n\t\t\tbinfile = r_bin_cur (r->bin);\n\t\t\tplugin = r_bin_file_cur_plugin (binfile);\n\t\t\tif (plugin && plugin->name) {\n\t\t\t\tif (r_str_startswith (plugin->name, \"pe\")) {\n\t\t\t\t\tchar *module = strdup (r_symbol_name);\n\t\t\t\t\tchar *p = strstr (module, \".dll_\");\n\t\t\t\t\tif (p && strstr (module, \"imp.\")) {\n\t\t\t\t\t\tchar *symname = __filterShell (p + 5);\n\t\t\t\t\t\tchar *m = __filterShell (module);\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s.%s\\n\",\n\t\t\t\t\t\t\t\tmodule, symbol->ordinal, r->bin->prefix, symname);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s\\n\",\n\t\t\t\t\t\t\t\tmodule, symbol->ordinal, symname);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (symname);\n\t\t\t\t\t\tfree (m);\n\t\t\t\t\t}\n\t\t\t\t\tfree (module);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *bind = symbol->bind? symbol->bind: \"NONE\";\n\t\t\tconst char *type = symbol->type? symbol->type: \"NONE\";\n\t\t\tconst char *name = r_str_get (sn.demname? sn.demname: r_symbol_name);\n\t\t\t// const char *fwd = r_str_get (symbol->forwarder);\n\t\t\tr_cons_printf (\"%03u\", symbol->ordinal);\n\t\t\tif (symbol->paddr == UT64_MAX) {\n\t\t\t\tr_cons_printf (\" ----------\");\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, symbol->paddr);\n\t\t\t}\n\t\t\tr_cons_printf (\" 0x%08\"PFMT64x\" %6s %6s %4d%s%s\\n\",\n\t\t\t               addr, bind, type, symbol->size, *name? \" \": \"\", name);\n\t\t}\nnext:\n\t\tsnFini (&sn);\n\t\ti++;\n\t\tfree (r_symbol_name);\n\t\tif (exponly && firstexp) {\n\t\t\tfirstexp = false;\n\t\t}\n\t\tif (printHere) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (count == 0 && IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"{}\");\n\t}\n\n\n\t//handle thumb and arm for entry point since they are not present in symbols\n\tif (is_arm) {\n\t\tr_list_foreach (entries, iter, entry) {\n\t\t\tif (IS_MODE_SET (mode)) {\n\t\t\t\thandle_arm_entry (r, entry, info, va);\n\t\t\t}\n\t\t}\n\t}\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"]\");\n\t}\n\n\tr_spaces_pop (&r->anal->meta_spaces);\n\treturn true;\n}", "func_src_after": "static int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly, const char *args) {\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tRList *entries = r_bin_get_entries (r->bin);\n\tRBinSymbol *symbol;\n\tRBinAddr *entry;\n\tRListIter *iter;\n\tbool firstexp = true;\n\tbool printHere = false;\n\tint i = 0, lastfs = 's';\n\tbool bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tif (!info) {\n\t\treturn 0;\n\t}\n\n\tif (args && *args == '.') {\n\t\tprintHere = true;\n\t}\n\n\tbool is_arm = info && info->arch && !strncmp (info->arch, \"arm\", 3);\n\tconst char *lang = bin_demangle ? r_config_get (r->config, \"bin.lang\") : NULL;\n\n\tRList *symbols = r_bin_get_symbols (r->bin);\n\tr_spaces_push (&r->anal->meta_spaces, \"bin\");\n\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, R_FLAGS_FS_SYMBOLS);\n\t} else if (!at && exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs exports\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Exports]\\n\");\n\t\t}\n\t} else if (!at && !exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs symbols\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Symbols]\\n\");\n\t\t}\n\t}\n\tif (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"Num Paddr      Vaddr      Bind     Type Size Name\\n\");\n\t}\n\n\n\tsize_t count = 0;\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tif (!symbol->name) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *r_symbol_name = r_str_escape_utf8 (symbol->name, false, true);\n\t\tut64 addr = compute_addr (r->bin, symbol->paddr, symbol->vaddr, va);\n\t\tint len = symbol->size ? symbol->size : 32;\n\t\tSymName sn = {0};\n\n\t\tif (exponly && !isAnExport (symbol)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (name && strcmp (r_symbol_name, name)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (at && (!symbol->size || !is_in_range (at, addr, symbol->size))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((printHere && !is_in_range (r->offset, symbol->paddr, len))\n\t\t\t\t&& (printHere && !is_in_range (r->offset, addr, len))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tcount ++;\n\t\tsnInit (r, &sn, symbol, lang);\n\n\t\tif (IS_MODE_SET (mode) && (is_section_symbol (symbol) || is_file_symbol (symbol))) {\n\t\t\t/*\n\t\t\t * Skip section symbols because they will have their own flag.\n\t\t\t * Skip also file symbols because not useful for now.\n\t\t\t */\n\t\t} else if (IS_MODE_SET (mode) && is_special_symbol (symbol)) {\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_special_symbol (r, symbol, va);\n\t\t\t}\n\t\t} else if (IS_MODE_SET (mode)) {\n\t\t\t// TODO: provide separate API in RBinPlugin to let plugins handle anal hints/metadata\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_symbol (r, symbol, info, va);\n\t\t\t}\n\t\t\tselect_flag_space (r, symbol);\n\t\t\t/* If that's a Classed symbol (method or so) */\n\t\t\tif (sn.classname) {\n\t\t\t\tRFlagItem *fi = r_flag_get (r->flags, sn.methflag);\n\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\tchar *prname = r_str_newf (\"%s.%s\", r->bin->prefix, sn.methflag);\n\t\t\t\t\tr_name_filter (sn.methflag, -1);\n\t\t\t\t\tfree (sn.methflag);\n\t\t\t\t\tsn.methflag = prname;\n\t\t\t\t}\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, sn.methname);\n\t\t\t\t\tif ((fi->offset - r->flags->base) == addr) {\n\t\t\t\t//\t\tchar *comment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\t\tr_flag_unset (r->flags, fi);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfi = r_flag_set (r->flags, sn.methflag, addr, symbol->size);\n\t\t\t\t\tchar *comment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\tif (comment) {\n\t\t\t\t\t\tr_flag_item_set_comment (fi, comment);\n\t\t\t\t\t\tR_FREE (comment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *n = sn.demname ? sn.demname : sn.name;\n\t\t\t\tconst char *fn = sn.demflag ? sn.demflag : sn.nameflag;\n\t\t\t\tchar *fnp = (r->bin->prefix) ?\n\t\t\t\t\tr_str_newf (\"%s.%s\", r->bin->prefix, fn):\n\t\t\t\t\tstrdup (fn);\n\t\t\t\tRFlagItem *fi = r_flag_set (r->flags, fnp, addr, symbol->size);\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, n);\n\t\t\t\t\tfi->demangled = (bool)(size_t)sn.demname;\n\t\t\t\t} else {\n\t\t\t\t\tif (fn) {\n\t\t\t\t\t\teprintf (\"[Warning] Can't find flag (%s)\\n\", fn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (fnp);\n\t\t\t}\n\t\t\tif (sn.demname) {\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_COMMENT,\n\t\t\t\t\taddr, symbol->size, sn.demname);\n\t\t\t}\n\t\t\tr_flag_space_pop (r->flags);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tchar *str = r_str_escape_utf8_for_json (r_symbol_name, -1);\n\t\t\t// str = r_str_replace (str, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"demname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"flagname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"ordinal\\\":%d,\"\n\t\t\t\t\"\\\"bind\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"size\\\":%d,\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\"}\",\n\t\t\t\t((exponly && firstexp) || printHere) ? \"\" : (iter->p ? \",\" : \"\"),\n\t\t\t\tstr,\n\t\t\t\tsn.demname? sn.demname: \"\",\n\t\t\t\tsn.nameflag,\n\t\t\t\tsymbol->ordinal,\n\t\t\t\tsymbol->bind,\n\t\t\t\t(int)symbol->size,\n\t\t\t\tsymbol->type,\n\t\t\t\t(ut64)addr, (ut64)symbol->paddr);\n\t\t\tfree (str);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" %d %s\\n\",\n\t\t\t\taddr, (int)symbol->size, name);\n\t\t} else if (IS_MODE_SIMPLEST (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"%s\\n\", name);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\t/* Skip special symbols because we do not flag them and\n\t\t\t * they shouldn't be printed in the rad format either */\n\t\t\tif (is_special_symbol (symbol)) {\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tRBinFile *binfile;\n\t\t\tRBinPlugin *plugin;\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tif (!name) {\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (!strncmp (name, \"imp.\", 4)) {\n\t\t\t\tif (lastfs != 'i') {\n\t\t\t\t\tr_cons_printf (\"fs imports\\n\");\n\t\t\t\t}\n\t\t\t\tlastfs = 'i';\n\t\t\t} else {\n\t\t\t\tif (lastfs != 's') {\n\t\t\t\t\tconst char *fs = exponly? \"exports\": \"symbols\";\n\t\t\t\t\tr_cons_printf (\"fs %s\\n\", fs);\n\t\t\t\t}\n\t\t\t\tlastfs = 's';\n\t\t\t}\n\t\t\tif (r->bin->prefix || *name) { // we don't want unnamed symbol flags\n\t\t\t\tchar *flagname = construct_symbol_flagname (\"sym\", name, MAXFLAG_LEN_DEFAULT);\n\t\t\t\tif (!flagname) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"\\\"f %s%s%s %u 0x%08\" PFMT64x \"\\\"\\n\",\n\t\t\t\t\tr->bin->prefix ? r->bin->prefix : \"\", r->bin->prefix ? \".\" : \"\",\n\t\t\t\t\tflagname, symbol->size, addr);\n\t\t\t\tfree (flagname);\n\t\t\t}\n\t\t\tbinfile = r_bin_cur (r->bin);\n\t\t\tplugin = r_bin_file_cur_plugin (binfile);\n\t\t\tif (plugin && plugin->name) {\n\t\t\t\tif (r_str_startswith (plugin->name, \"pe\")) {\n\t\t\t\t\tchar *module = strdup (r_symbol_name);\n\t\t\t\t\tchar *p = strstr (module, \".dll_\");\n\t\t\t\t\tif (p && strstr (module, \"imp.\")) {\n\t\t\t\t\t\tchar *symname = __filterShell (p + 5);\n\t\t\t\t\t\tchar *m = __filterShell (module);\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\t\t\tr_cons_printf (\"\\\"k bin/pe/%s/%d=%s.%s\\\"\\n\",\n\t\t\t\t\t\t\t\tmodule, symbol->ordinal, r->bin->prefix, symname);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_printf (\"\\\"k bin/pe/%s/%d=%s\\\"\\n\",\n\t\t\t\t\t\t\t\tmodule, symbol->ordinal, symname);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (symname);\n\t\t\t\t\t\tfree (m);\n\t\t\t\t\t}\n\t\t\t\t\tfree (module);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *bind = symbol->bind? symbol->bind: \"NONE\";\n\t\t\tconst char *type = symbol->type? symbol->type: \"NONE\";\n\t\t\tconst char *name = r_str_get (sn.demname? sn.demname: r_symbol_name);\n\t\t\t// const char *fwd = r_str_get (symbol->forwarder);\n\t\t\tr_cons_printf (\"%03u\", symbol->ordinal);\n\t\t\tif (symbol->paddr == UT64_MAX) {\n\t\t\t\tr_cons_printf (\" ----------\");\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, symbol->paddr);\n\t\t\t}\n\t\t\tr_cons_printf (\" 0x%08\"PFMT64x\" %6s %6s %4d%s%s\\n\",\n\t\t\t               addr, bind, type, symbol->size, *name? \" \": \"\", name);\n\t\t}\nnext:\n\t\tsnFini (&sn);\n\t\ti++;\n\t\tfree (r_symbol_name);\n\t\tif (exponly && firstexp) {\n\t\t\tfirstexp = false;\n\t\t}\n\t\tif (printHere) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (count == 0 && IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"{}\");\n\t}\n\n\n\t//handle thumb and arm for entry point since they are not present in symbols\n\tif (is_arm) {\n\t\tr_list_foreach (entries, iter, entry) {\n\t\t\tif (IS_MODE_SET (mode)) {\n\t\t\t\thandle_arm_entry (r, entry, info, va);\n\t\t\t}\n\t\t}\n\t}\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"]\");\n\t}\n\n\tr_spaces_pop (&r->anal->meta_spaces);\n\treturn true;\n}", "commit_link": "github.com/radareorg/radare2/commit/5411543a310a470b1257fb93273cdd6e8dfcb3af", "file_name": "libr/core/cbin.c", "vul_type": "cwe-078", "description": "Write a C function to process and print binary symbols in various formats based on the given mode."}
{"func_name": "get", "func_src_before": "    def get(self, space_id):\n        \"\"\" Fetch data for space with the corresponding space_id \"\"\"\n        return database_utilities.execute_query(\n            f\"\"\"select * from spaces where space_id = '{space_id}'\"\"\")", "func_src_after": "    def get(self, space_id):\n        \"\"\" Fetch data for space with the corresponding space_id \"\"\"\n        return database_utilities.execute_query(\n            f\"\"\"select * from spaces where space_id = %s\"\"\", (space_id, ))", "commit_link": "github.com/sgosal2/tiger-boards-backend/commit/4670109dd613df2f2fe7e8403ebd149df2b55485", "file_name": "apis/spaces.py", "vul_type": "cwe-089", "description": "Write a Python function to retrieve data from a database table 'spaces' using a provided 'space_id'."}
{"func_name": "getPlayer", "func_src_before": "def getPlayer(player):\n\tdb.execute(\"SELECT * FROM players WHERE Name = '%s' COLLATE NOCASE\" % player)\n\tplayerstats = dict(db.fetchone())\n\treturn playerstats", "func_src_after": "def getPlayer(player):\n\tdb.execute(\"SELECT * FROM players WHERE Name = ? COLLATE NOCASE\", player)\n\tplayerstats = dict(db.fetchone())\n\treturn playerstats", "commit_link": "github.com/iScrE4m/XLeague/commit/59cab6e5fd8bd5e47f2418a7c71cb1d4e3cad0d2", "file_name": "plugins/database.py", "vul_type": "cwe-089", "description": "Write a Python function called `getPlayer` that retrieves a player's statistics from a database, ignoring case sensitivity in the player's name."}
{"func_name": "test_get_least_used_nsp", "func_src_before": "    def test_get_least_used_nsp(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record\n        self.clear_mox()\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_vlun_cmd = 'showvlun -a -showcols Port'\n        _run_ssh(show_vlun_cmd, False).AndReturn([pack(SHOW_VLUN_NONE), ''])\n        _run_ssh(show_vlun_cmd, False).AndReturn([pack(SHOW_VLUN_NONE), ''])\n        _run_ssh(show_vlun_cmd, False).AndReturn([pack(SHOW_VLUN_NONE), ''])\n\n        self.mox.ReplayAll()\n        # in use count                           11       12\n        nsp = self.driver._get_least_used_nsp(['0:2:1', '1:8:1'])\n        self.assertEqual(nsp, '0:2:1')\n\n        # in use count                            11       10\n        nsp = self.driver._get_least_used_nsp(['0:2:1', '1:2:1'])\n        self.assertEqual(nsp, '1:2:1')\n\n        # in use count                            0       10\n        nsp = self.driver._get_least_used_nsp(['1:1:1', '1:2:1'])\n        self.assertEqual(nsp, '1:1:1')", "func_src_after": "    def test_get_least_used_nsp(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record\n        self.clear_mox()\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_vlun_cmd = ['showvlun', '-a', '-showcols', 'Port']\n        _run_ssh(show_vlun_cmd, False).AndReturn([pack(SHOW_VLUN_NONE), ''])\n        _run_ssh(show_vlun_cmd, False).AndReturn([pack(SHOW_VLUN_NONE), ''])\n        _run_ssh(show_vlun_cmd, False).AndReturn([pack(SHOW_VLUN_NONE), ''])\n\n        self.mox.ReplayAll()\n        # in use count                           11       12\n        nsp = self.driver._get_least_used_nsp(['0:2:1', '1:8:1'])\n        self.assertEqual(nsp, '0:2:1')\n\n        # in use count                            11       10\n        nsp = self.driver._get_least_used_nsp(['0:2:1', '1:2:1'])\n        self.assertEqual(nsp, '1:2:1')\n\n        # in use count                            0       10\n        nsp = self.driver._get_least_used_nsp(['1:1:1', '1:2:1'])\n        self.assertEqual(nsp, '1:1:1')", "commit_link": "github.com/thatsdone/cinder/commit/c55589b131828f3a595903f6796cb2d0babb772f", "file_name": "cinder/tests/test_hp3par.py", "vul_type": "cwe-078", "description": "Write a Python unit test function that mocks an SSH command to determine the least used network service provider."}
{"func_name": "get_secrets", "func_src_before": "\tdef get_secrets(self, from_date_added=0):\n\t\tsecrets = []\n\t\tfor row in self.cursor.execute('SELECT encrypted, json_id, date_added FROM secret WHERE date_added > %s ORDER BY date_added DESC' % from_date_added):\n\t\t\taes_key, json_id, date_added = cryptlib.eciesDecrypt(row[0], self.privkey), row[1], row[2]\n\t\t\tif aes_key != None:\n\t\t\t\tsecrets.append([aes_key, json_id])\n\t\t\tfrom_date_added = max(from_date_added, date_added)\n\t\treturn (secrets, from_date_added)", "func_src_after": "\tdef get_secrets(self, from_date_added=0):\n\t\tsecrets = []\n\t\tfor row in self.cursor.execute('SELECT encrypted, json_id, date_added FROM secret WHERE date_added > ? ORDER BY date_added DESC', (from_date_added,)):\n\t\t\taes_key, json_id, date_added = cryptlib.eciesDecrypt(row[0], self.privkey), row[1], row[2]\n\t\t\tif aes_key != None:\n\t\t\t\tsecrets.append([aes_key, json_id])\n\t\t\tfrom_date_added = max(from_date_added, date_added)\n\t\treturn (secrets, from_date_added)", "commit_link": "github.com/imachug/ZeroMailProxy/commit/8f62d024c6c4c957079d147e59f26d15c07dc888", "file_name": "zeromail.py", "vul_type": "cwe-089", "description": "Write a Python function named `get_secrets` that retrieves and decrypts secrets from a database added after a specified date."}
{"func_name": "updateOption", "func_src_before": "\tfunction updateOption (that) {\n\t\ttry {\n\t\t\tvar thisId = jQuery('#fb-field-id').val();\n\t\t\tvar thisOptionid = that.attr('optionid');\n\t\t\tvar thisOptionValue = that.val();\n\t\t\tvar thisType = jQuery('#fb-new-type').val();\n\t\t\t// Update preview\n\t\t\tif (thisType === \"radio\") {\n\t\t\t\tjQuery('#fb-radio-' + thisId + '-' + thisOptionid + ' span').html(thisOptionValue);\n\t\t\t} else {\n\t\t\t\tjQuery('#fb-' + thisId + '-' + thisOptionid).text(thisOptionValue);\n\t\t\t}\n\t\t\t// Update fbForm object\n\t\t\tfbForm.fields[thisId].options[thisOptionid] = thisOptionValue;\n\t\t} catch(e) {\n\t\t\tif (debug) {\n\t\t\t\tconsole.log(\"updateOption(): \" + e);\n\t\t\t}\n\t\t}\n\t}", "func_src_after": "\tfunction updateOption (that) {\n\t\ttry {\n\t\t\tvar thisId = jQuery('#fb-field-id').val();\n\t\t\tvar thisOptionid = that.attr('optionid');\n\t\t\tvar thisOptionValue = that.val();\n\t\t\tvar thisType = jQuery('#fb-new-type').val();\n\t\t\t// Update preview\n\t\t\tif (thisType === \"radio\") {\n\t\t\t\tjQuery('#fb-radio-' + thisId + '-' + thisOptionid + ' span').text(thisOptionValue);\n\t\t\t} else {\n\t\t\t\tjQuery('#fb-' + thisId + '-' + thisOptionid).text(thisOptionValue);\n\t\t\t}\n\t\t\t// Update fbForm object\n\t\t\tfbForm.fields[thisId].options[thisOptionid] = thisOptionValue;\n\t\t} catch(e) {\n\t\t\tif (debug) {\n\t\t\t\tconsole.log(\"updateOption(): \" + e);\n\t\t\t}\n\t\t}\n\t}", "line_changes": {"deleted": [{"line_no": 9, "char_start": 268, "char_end": 356, "line": "\t\t\t\tjQuery('#fb-radio-' + thisId + '-' + thisOptionid + ' span').html(thisOptionValue);\n"}], "added": [{"line_no": 9, "char_start": 268, "char_end": 356, "line": "\t\t\t\tjQuery('#fb-radio-' + thisId + '-' + thisOptionid + ' span').text(thisOptionValue);\n"}]}, "char_changes": {"deleted": [{"char_start": 333, "char_end": 337, "chars": "html"}], "added": [{"char_start": 333, "char_end": 337, "chars": "text"}]}, "commit_link": "github.com/iamtakashi/jetpack/commit/970117f93e7ed6eb459ee568259947d67369eec0", "file_name": "grunion.js", "vul_type": "cwe-079", "commit_msg": "Grunion: Fix 2 XSS vulnerabilities.\nPreview of field labels.\nPreview of radio option labels.\nAlso:\nPrevent future potential XSS in feedback message.\nFix i18n\nFix encoding of field labels bug (every preview would add another level of HTML encoding to the label)\nprops @mdawaffe", "description": "Write a JavaScript function using jQuery to update form option values and preview text based on the type of input field."}
{"func_name": "edit_bundle", "func_src_before": "@check_document_access_permission()\ndef edit_bundle(request):\n  bundle_id = request.GET.get('bundle')\n  doc = None\n  \n  if bundle_id:\n    doc = Document2.objects.get(id=bundle_id)\n    bundle = Bundle(document=doc)\n  else:\n    bundle = Bundle()\n\n  coordinators = [dict([('uuid', d.content_object.uuid), ('name', d.content_object.name)])\n                      for d in Document.objects.get_docs(request.user, Document2, extra='coordinator2')]\n\n  return render('editor/bundle_editor.mako', request, {\n      'bundle_json': bundle.json,\n      'coordinators_json': json.dumps(coordinators),\n      'doc1_id': doc.doc.get().id if doc else -1,\n      'can_edit_json': json.dumps(doc is None or doc.doc.get().is_editable(request.user))      \n  })", "func_src_after": "@check_document_access_permission()\ndef edit_bundle(request):\n  bundle_id = request.GET.get('bundle')\n  doc = None\n  \n  if bundle_id:\n    doc = Document2.objects.get(id=bundle_id)\n    bundle = Bundle(document=doc)\n  else:\n    bundle = Bundle()\n\n  coordinators = [dict([('uuid', d.content_object.uuid), ('name', d.content_object.name)])\n                      for d in Document.objects.get_docs(request.user, Document2, extra='coordinator2')]\n\n  return render('editor/bundle_editor.mako', request, {\n      'bundle_json': bundle.json_for_html(),\n      'coordinators_json': json.dumps(coordinators, cls=JSONEncoderForHTML),\n      'doc1_id': doc.doc.get().id if doc else -1,\n      'can_edit_json': json.dumps(doc is None or doc.doc.get().is_editable(request.user))      \n  })", "commit_link": "github.com/gethue/hue/commit/6641c62beaa1468082e47d82da5ed758d11c7735", "file_name": "apps/oozie/src/oozie/views/editor2.py", "vul_type": "cwe-079", "description": "Write a Python function with a decorator to check user permissions and handle editing a document bundle, including fetching coordinators and rendering a template."}
{"func_name": "archive_directory", "func_src_before": "def archive_directory(top_dir, subdir, tmpdir):\n    \"\"\"\n    .. function:: archive_directory(top_dir, subdir, tmpdir)\n\n    Given a sub-directory name under the root directory to be archived, archive the contents of the sub-directory\n    to a temporary directory. Then return the full path to the temporary directory.\n    :param top_dir: The root path that will be archived and uploaded to Glacier.\n    :param subdir: The path to the subdirectory that is being archived here, relative to `top_dir`\n    :param tmpdir: The path to the temporary directory to store archives in until they are uploaded to Glacier\n    :return: If the subdirectory contains files, then the full path to the temporary archives; otherwise, None\n    \"\"\"\n    # We're only archiving the *files* in this directory, not the subdirectories.\n\n    files = []\n    full_backup_path = os.path.join(top_dir, subdir)\n    dir_contents = os.listdir(full_backup_path)\n\n    # Only add files to 'files' list, not subdirs\n    for c in dir_contents:\n        fpath = os.path.join(top_dir, subdir, c)\n        if os.path.isfile(fpath) and not fpath.endswith(\".ini\"):\n            # logger.info(\"Adding to archive list: {0}\".format(c))\n            files.append(fpath)\n\n    if not files:\n        # No point creating empty archives!\n        return None\n\n    os.makedirs(os.path.join(tmpdir, subdir))\n    archive_file_path = os.path.join(tmpdir, subdir) + \".zip\"\n\n    logger.info(\"Archiving %s to %s\" % (subdir, archive_file_path))\n\n    # with open(os.devnull, \"w\") as devnull:\n\n    devnull = open(os.devnull, \"wb\")\n    file_list = []\n    for p in os.listdir(full_backup_path):\n        if os.path.isfile(os.path.join(full_backup_path, p)):\n            file_list.append(os.path.join(full_backup_path, p))\n\n    try:\n        with zipfile.ZipFile(archive_file_path, \"w\", compression=zipfile.ZIP_DEFLATED, allowZip64=True) as arch_zip:\n            for f in file_list:\n                logger.debug(\"Adding {0} to archive {1}\".format(f, archive_file_path))\n                arch_zip.write(f, os.path.basename(f))\n                return archive_file_path\n\n    except Exception, e:\n        logging.error(\"Failed to create archive {0}: {1}\".format(archive_file_path, e.message))\n        logging.debug(\"Error args: {0}\".format(e.args))\n        return None", "func_src_after": "def archive_directory(top_dir, subdir, tmpdir):\n    \"\"\"\n    .. function:: archive_directory(top_dir, subdir, tmpdir)\n\n    Given a sub-directory name under the root directory to be archived, archive the contents of the sub-directory\n    to a temporary directory. Then return the full path to the temporary directory.\n    :param top_dir: The root path that will be archived and uploaded to Glacier.\n    :param subdir: The path to the subdirectory that is being archived here, relative to `top_dir`\n    :param tmpdir: The path to the temporary directory to store archives in until they are uploaded to Glacier\n    :return: If the subdirectory contains files, then the full path to the temporary archives; otherwise, None\n    \"\"\"\n    # We're only archiving the *files* in this directory, not the subdirectories.\n\n    files = []\n    full_backup_path = os.path.join(top_dir, subdir)\n    dir_contents = os.listdir(full_backup_path)\n\n    # Only add files to 'files' list, not subdirs\n    for c in dir_contents:\n        fpath = os.path.join(full_backup_path, c)\n        if os.path.isfile(fpath) and not fpath.endswith(\".ini\"):\n            # logger.info(\"Adding to archive list: {0}\".format(c))\n            files.append(fpath)\n\n    if not files:\n        # No point creating empty archives!\n        return None\n\n    os.makedirs(os.path.join(tmpdir, subdir))\n    archive_file_path = os.path.join(tmpdir, subdir) + \".zip\"\n\n    logger.info(\"Archiving %s to %s\" % (subdir, archive_file_path))\n\n    # with open(os.devnull, \"w\") as devnull:\n\n    devnull = open(os.devnull, \"wb\")\n\n    try:\n        with zipfile.ZipFile(archive_file_path, \"w\", compression=zipfile.ZIP_DEFLATED, allowZip64=True) as arch_zip:\n            for f in files:\n                logger.debug(\"Adding {0} to archive {1}\".format(f, archive_file_path))\n                arch_zip.write(f, os.path.basename(f))\n            return archive_file_path\n\n    except Exception, e:\n        logging.error(\"Failed to create archive {0}: {1}\".format(archive_file_path, e.message))\n        logging.debug(\"Error args: {0}\".format(e.args))\n        return None", "line_changes": {"deleted": [{"line_no": 20, "char_start": 1003, "char_end": 1052, "line": "        fpath = os.path.join(top_dir, subdir, c)\n"}, {"line_no": 37, "char_start": 1561, "char_end": 1580, "line": "    file_list = []\n"}, {"line_no": 38, "char_start": 1580, "char_end": 1623, "line": "    for p in os.listdir(full_backup_path):\n"}, {"line_no": 39, "char_start": 1623, "char_end": 1685, "line": "        if os.path.isfile(os.path.join(full_backup_path, p)):\n"}, {"line_no": 40, "char_start": 1685, "char_end": 1749, "line": "            file_list.append(os.path.join(full_backup_path, p))\n"}, {"line_no": 44, "char_start": 1876, "char_end": 1908, "line": "            for f in file_list:\n"}, {"line_no": 47, "char_start": 2050, "char_end": 2091, "line": "                return archive_file_path\n"}], "added": [{"line_no": 20, "char_start": 1003, "char_end": 1053, "line": "        fpath = os.path.join(full_backup_path, c)\n"}, {"line_no": 40, "char_start": 1689, "char_end": 1717, "line": "            for f in files:\n"}, {"line_no": 43, "char_start": 1859, "char_end": 1896, "line": "            return archive_file_path\n"}]}, "char_changes": {"deleted": [{"char_start": 1032, "char_end": 1047, "chars": "top_dir, subdir"}, {"char_start": 1560, "char_end": 1748, "chars": "\n    file_list = []\n    for p in os.listdir(full_backup_path):\n        if os.path.isfile(os.path.join(full_backup_path, p)):\n            file_list.append(os.path.join(full_backup_path, p))"}, {"char_start": 1901, "char_end": 1906, "chars": "_list"}, {"char_start": 2050, "char_end": 2054, "chars": "    "}], "added": [{"char_start": 1032, "char_end": 1048, "chars": "full_backup_path"}, {"char_start": 1714, "char_end": 1715, "chars": "s"}]}, "commit_link": "github.com/calmcl1/cupo-backup/commit/f9047a52ab33a14fcd67d3d8b9f9d321502ae457", "file_name": "cupo.py", "vul_type": "cwe-022", "commit_msg": "Removed redundant directory traversal", "parent_commit": "49107dd052b985e1fc469aec359f37df23ec3e29", "description": "Write a Python function to zip files in a specified subdirectory, excluding '.ini' files, and save the archive to a temporary directory."}
{"func_name": "usb_get_bos_descriptor", "func_src_before": "int usb_get_bos_descriptor(struct usb_device *dev)\n{\n\tstruct device *ddev = &dev->dev;\n\tstruct usb_bos_descriptor *bos;\n\tstruct usb_dev_cap_header *cap;\n\tunsigned char *buffer;\n\tint length, total_len, num, i;\n\tint ret;\n\n\tbos = kzalloc(sizeof(struct usb_bos_descriptor), GFP_KERNEL);\n\tif (!bos)\n\t\treturn -ENOMEM;\n\n\t/* Get BOS descriptor */\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, bos, USB_DT_BOS_SIZE);\n\tif (ret < USB_DT_BOS_SIZE) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tkfree(bos);\n\t\treturn ret;\n\t}\n\n\tlength = bos->bLength;\n\ttotal_len = le16_to_cpu(bos->wTotalLength);\n\tnum = bos->bNumDeviceCaps;\n\tkfree(bos);\n\tif (total_len < length)\n\t\treturn -EINVAL;\n\n\tdev->bos = kzalloc(sizeof(struct usb_host_bos), GFP_KERNEL);\n\tif (!dev->bos)\n\t\treturn -ENOMEM;\n\n\t/* Now let's get the whole BOS descriptor set */\n\tbuffer = kzalloc(total_len, GFP_KERNEL);\n\tif (!buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tdev->bos->desc = (struct usb_bos_descriptor *)buffer;\n\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, buffer, total_len);\n\tif (ret < total_len) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor set\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tgoto err;\n\t}\n\ttotal_len -= length;\n\n\tfor (i = 0; i < num; i++) {\n\t\tbuffer += length;\n\t\tcap = (struct usb_dev_cap_header *)buffer;\n\t\tlength = cap->bLength;\n\n\t\tif (total_len < length)\n\t\t\tbreak;\n\t\ttotal_len -= length;\n\n\t\tif (cap->bDescriptorType != USB_DT_DEVICE_CAPABILITY) {\n\t\t\tdev_warn(ddev, \"descriptor type invalid, skip\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (cap->bDevCapabilityType) {\n\t\tcase USB_CAP_TYPE_WIRELESS_USB:\n\t\t\t/* Wireless USB cap descriptor is handled by wusb */\n\t\t\tbreak;\n\t\tcase USB_CAP_TYPE_EXT:\n\t\t\tdev->bos->ext_cap =\n\t\t\t\t(struct usb_ext_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SS_CAP_TYPE:\n\t\t\tdev->bos->ss_cap =\n\t\t\t\t(struct usb_ss_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SSP_CAP_TYPE:\n\t\t\tdev->bos->ssp_cap =\n\t\t\t\t(struct usb_ssp_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase CONTAINER_ID_TYPE:\n\t\t\tdev->bos->ss_id =\n\t\t\t\t(struct usb_ss_container_id_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_PTM_CAP_TYPE:\n\t\t\tdev->bos->ptm_cap =\n\t\t\t\t(struct usb_ptm_cap_descriptor *)buffer;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tusb_release_bos_descriptor(dev);\n\treturn ret;\n}", "func_src_after": "int usb_get_bos_descriptor(struct usb_device *dev)\n{\n\tstruct device *ddev = &dev->dev;\n\tstruct usb_bos_descriptor *bos;\n\tstruct usb_dev_cap_header *cap;\n\tunsigned char *buffer;\n\tint length, total_len, num, i;\n\tint ret;\n\n\tbos = kzalloc(sizeof(struct usb_bos_descriptor), GFP_KERNEL);\n\tif (!bos)\n\t\treturn -ENOMEM;\n\n\t/* Get BOS descriptor */\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, bos, USB_DT_BOS_SIZE);\n\tif (ret < USB_DT_BOS_SIZE) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tkfree(bos);\n\t\treturn ret;\n\t}\n\n\tlength = bos->bLength;\n\ttotal_len = le16_to_cpu(bos->wTotalLength);\n\tnum = bos->bNumDeviceCaps;\n\tkfree(bos);\n\tif (total_len < length)\n\t\treturn -EINVAL;\n\n\tdev->bos = kzalloc(sizeof(struct usb_host_bos), GFP_KERNEL);\n\tif (!dev->bos)\n\t\treturn -ENOMEM;\n\n\t/* Now let's get the whole BOS descriptor set */\n\tbuffer = kzalloc(total_len, GFP_KERNEL);\n\tif (!buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tdev->bos->desc = (struct usb_bos_descriptor *)buffer;\n\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, buffer, total_len);\n\tif (ret < total_len) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor set\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tgoto err;\n\t}\n\ttotal_len -= length;\n\n\tfor (i = 0; i < num; i++) {\n\t\tbuffer += length;\n\t\tcap = (struct usb_dev_cap_header *)buffer;\n\n\t\tif (total_len < sizeof(*cap) || total_len < cap->bLength) {\n\t\t\tdev->bos->desc->bNumDeviceCaps = i;\n\t\t\tbreak;\n\t\t}\n\t\tlength = cap->bLength;\n\t\ttotal_len -= length;\n\n\t\tif (cap->bDescriptorType != USB_DT_DEVICE_CAPABILITY) {\n\t\t\tdev_warn(ddev, \"descriptor type invalid, skip\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (cap->bDevCapabilityType) {\n\t\tcase USB_CAP_TYPE_WIRELESS_USB:\n\t\t\t/* Wireless USB cap descriptor is handled by wusb */\n\t\t\tbreak;\n\t\tcase USB_CAP_TYPE_EXT:\n\t\t\tdev->bos->ext_cap =\n\t\t\t\t(struct usb_ext_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SS_CAP_TYPE:\n\t\t\tdev->bos->ss_cap =\n\t\t\t\t(struct usb_ss_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SSP_CAP_TYPE:\n\t\t\tdev->bos->ssp_cap =\n\t\t\t\t(struct usb_ssp_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase CONTAINER_ID_TYPE:\n\t\t\tdev->bos->ss_id =\n\t\t\t\t(struct usb_ss_container_id_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_PTM_CAP_TYPE:\n\t\t\tdev->bos->ptm_cap =\n\t\t\t\t(struct usb_ptm_cap_descriptor *)buffer;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tusb_release_bos_descriptor(dev);\n\treturn ret;\n}", "commit_link": "github.com/torvalds/linux/commit/1c0edc3633b56000e18d82fc241e3995ca18a69e", "file_name": "drivers/usb/core/config.c", "vul_type": "cwe-125", "description": "Write a C function named `usb_get_bos_descriptor` that retrieves the Binary Object Store (BOS) descriptor for a USB device."}
{"func_name": "ContentLine_Analyzer::DoDeliverOnce", "func_src_before": "int ContentLine_Analyzer::DoDeliverOnce(int len, const u_char* data)\n\t{\n\tconst u_char* data_start = data;\n\n\tif ( len <= 0 )\n\t\treturn 0;\n\n\tfor ( ; len > 0; --len, ++data )\n\t\t{\n\t\tif ( offset >= buf_len )\n\t\t\tInitBuffer(buf_len * 2);\n\n\t\tint c = data[0];\n\n#define EMIT_LINE \\\n\t{ \\\n\tbuf[offset] = '\\0'; \\\n\tint seq_len = data + 1 - data_start; \\\n\tseq_delivered_in_lines = seq + seq_len; \\\n\tlast_char = c; \\\n\tForwardStream(offset, buf, IsOrig()); \\\n\toffset = 0; \\\n\treturn seq_len; \\\n\t}\n\n\t\tswitch ( c ) {\n\t\tcase '\\r':\n\t\t\t// Look ahead for '\\n'.\n\t\t\tif ( len > 1 && data[1] == '\\n' )\n\t\t\t\t{\n\t\t\t\t--len; ++data;\n\t\t\t\tlast_char = c;\n\t\t\t\tc = data[0];\n\t\t\t\tEMIT_LINE\n\t\t\t\t}\n\n\t\t\telse if ( CR_LF_as_EOL & CR_as_EOL )\n\t\t\t\tEMIT_LINE\n\n\t\t\telse\n\t\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\n\t\tcase '\\n':\n\t\t\tif ( last_char == '\\r' )\n\t\t\t\t{\n\t\t\t\t--offset; // remove '\\r'\n\t\t\t\tEMIT_LINE\n\t\t\t\t}\n\n\t\t\telse if ( CR_LF_as_EOL & LF_as_EOL )\n\t\t\t\tEMIT_LINE\n\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tif ( ! suppress_weirds && Conn()->FlagEvent(SINGULAR_LF) )\n\t\t\t\t\tConn()->Weird(\"line_terminated_with_single_LF\");\n\t\t\t\tbuf[offset++] = c;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase '\\0':\n\t\t\tif ( flag_NULs )\n\t\t\t\tCheckNUL();\n\t\t\telse\n\t\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ( last_char == '\\r' )\n\t\t\tif ( ! suppress_weirds && Conn()->FlagEvent(SINGULAR_CR) )\n\t\t\t\tConn()->Weird(\"line_terminated_with_single_CR\");\n\n\t\tlast_char = c;\n\t\t}\n\n\treturn data - data_start;\n\t}", "func_src_after": "int ContentLine_Analyzer::DoDeliverOnce(int len, const u_char* data)\n\t{\n\tconst u_char* data_start = data;\n\n\tif ( len <= 0 )\n\t\treturn 0;\n\n\tfor ( ; len > 0; --len, ++data )\n\t\t{\n\t\tif ( offset >= buf_len )\n\t\t\tInitBuffer(buf_len * 2);\n\n\t\tint c = data[0];\n\n#define EMIT_LINE \\\n\t{ \\\n\tbuf[offset] = '\\0'; \\\n\tint seq_len = data + 1 - data_start; \\\n\tseq_delivered_in_lines = seq + seq_len; \\\n\tlast_char = c; \\\n\tForwardStream(offset, buf, IsOrig()); \\\n\toffset = 0; \\\n\treturn seq_len; \\\n\t}\n\n\t\tswitch ( c ) {\n\t\tcase '\\r':\n\t\t\t// Look ahead for '\\n'.\n\t\t\tif ( len > 1 && data[1] == '\\n' )\n\t\t\t\t{\n\t\t\t\t--len; ++data;\n\t\t\t\tlast_char = c;\n\t\t\t\tc = data[0];\n\t\t\t\tEMIT_LINE\n\t\t\t\t}\n\n\t\t\telse if ( CR_LF_as_EOL & CR_as_EOL )\n\t\t\t\tEMIT_LINE\n\n\t\t\telse\n\t\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\n\t\tcase '\\n':\n\t\t\tif ( last_char == '\\r' )\n\t\t\t\t{\n\t\t\t\t// Weird corner-case:\n\t\t\t\t// this can happen if we see a \\r at the end of a packet where crlf is\n\t\t\t\t// set to CR_as_EOL | LF_as_EOL, with the packet causing crlf to be set to\n\t\t\t\t// 0 and the next packet beginning with a \\n. In this case we just swallow\n\t\t\t\t// the character and re-set last_char.\n\t\t\t\tif ( offset == 0 )\n\t\t\t\t\t{\n\t\t\t\t\tlast_char = c;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t--offset; // remove '\\r'\n\t\t\t\tEMIT_LINE\n\t\t\t\t}\n\n\t\t\telse if ( CR_LF_as_EOL & LF_as_EOL )\n\t\t\t\tEMIT_LINE\n\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tif ( ! suppress_weirds && Conn()->FlagEvent(SINGULAR_LF) )\n\t\t\t\t\tConn()->Weird(\"line_terminated_with_single_LF\");\n\t\t\t\tbuf[offset++] = c;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase '\\0':\n\t\t\tif ( flag_NULs )\n\t\t\t\tCheckNUL();\n\t\t\telse\n\t\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ( last_char == '\\r' )\n\t\t\tif ( ! suppress_weirds && Conn()->FlagEvent(SINGULAR_CR) )\n\t\t\t\tConn()->Weird(\"line_terminated_with_single_CR\");\n\n\t\tlast_char = c;\n\t\t}\n\n\treturn data - data_start;\n\t}", "commit_link": "github.com/bro/bro/commit/6c0f101a62489b1c5927b4ed63b0e1d37db40282", "file_name": "src/analyzer/protocol/tcp/ContentLine.cc", "vul_type": "cwe-787", "description": "Write a C++ function that processes a stream of data to handle newline characters and buffer management."}
{"func_name": "(anonymous)", "func_src_before": "    $(document.body).on(\"keyup change\", \".sr-input\", function(foo) {\n        value = $(this).val();\n        var modalBody = $(this).closest(\"form#streamrule-form\").find(\".modal-body\");\n\n        if (value != undefined && value != \"\") {\n            // Selectbox options can have a custom replace string.\n            s = $(\"option:selected\", this);\n            if (s != undefined && s.attr(\"data-reflect-string\") != undefined && s.attr(\"data-reflect-string\") != \"\") {\n                value = s.attr(\"data-reflect-string\");\n\n                // Inverted?\n                if ($(\"#sr-inverted\", modalBody).is(':checked')) {\n                    value = \"not \" + value;\n                }\n            }\n        } else {\n            value = $(this).attr(\"placeholder\");\n        }\n\n        $($(this).attr(\"data-reflect\"), modalBody).html(value);\n    });", "func_src_after": "    $(document.body).on(\"keyup change\", \".sr-input\", function(foo) {\n        value = $(this).val();\n        var modalBody = $(this).closest(\"form#streamrule-form\").find(\".modal-body\");\n\n        if (value != undefined && value != \"\") {\n            // Selectbox options can have a custom replace string.\n            s = $(\"option:selected\", this);\n            if (s != undefined && s.attr(\"data-reflect-string\") != undefined && s.attr(\"data-reflect-string\") != \"\") {\n                value = s.attr(\"data-reflect-string\");\n\n                // Inverted?\n                if ($(\"#sr-inverted\", modalBody).is(':checked')) {\n                    value = \"not \" + value;\n                }\n            }\n        } else {\n            value = $(this).attr(\"placeholder\");\n        }\n\n        $($(this).attr(\"data-reflect\"), modalBody).text(value);\n    });", "line_changes": {"deleted": [{"line_no": 20, "char_start": 770, "char_end": 834, "line": "        $($(this).attr(\"data-reflect\"), modalBody).html(value);\n"}], "added": [{"line_no": 20, "char_start": 770, "char_end": 834, "line": "        $($(this).attr(\"data-reflect\"), modalBody).text(value);\n"}]}, "char_changes": {"deleted": [{"char_start": 821, "char_end": 825, "chars": "html"}], "added": [{"char_start": 821, "char_end": 825, "chars": "text"}]}, "commit_link": "github.com/edmundoa/graylog2-server/commit/a88cae99955cd0ccdd5d99a1c6d506029eb15c60", "file_name": "streamrules.js", "vul_type": "cwe-079", "commit_msg": "use .text() not .html() in stream rule editor to prevent DOM XSS\n\nfixes #543", "description": "In JavaScript, write a jQuery event handler that updates text in a modal based on user input and selection changes, with special handling for an \"inverted\" checkbox state."}
{"func_name": "HPHP::exif_scan_JPEG_header", "func_src_before": "static int exif_scan_JPEG_header(image_info_type *ImageInfo) {\n  int section, sn;\n  int marker = 0, last_marker = M_PSEUDO, comment_correction=1;\n  int ll, lh;\n  unsigned char *Data;\n  size_t fpos, size, got, itemlen;\n  jpeg_sof_info  sof_info;\n\n  for(section=0;;section++) {\n    // get marker byte, swallowing possible padding\n    // some software does not count the length bytes of COM section\n    // one company doing so is very much envolved in JPEG...\n    // so we accept too\n    if (last_marker==M_COM && comment_correction) {\n      comment_correction = 2;\n    }\n    do {\n      if ((marker = ImageInfo->infile->getc()) == EOF) {\n        raise_warning(\"File structure corrupted\");\n        return 0;\n      }\n      if (last_marker==M_COM && comment_correction>0) {\n        if (marker!=0xFF) {\n          marker = 0xff;\n          comment_correction--;\n        } else  {\n          last_marker = M_PSEUDO; /* stop skipping 0 for M_COM */\n        }\n      }\n    } while (marker == 0xff);\n    if (last_marker==M_COM && !comment_correction) {\n      raise_notice(\"Image has corrupt COM section: some software set \"\n                   \"wrong length information\");\n    }\n    if (last_marker==M_COM && comment_correction)\n      return M_EOI; /* ah illegal: char after COM section not 0xFF */\n\n    fpos = ImageInfo->infile->tell();\n\n    if (marker == 0xff) {\n      // 0xff is legal padding, but if we get that many, something's wrong.\n      raise_warning(\"To many padding bytes\");\n      return 0;\n    }\n\n    /* Read the length of the section. */\n\n    if ((lh = ImageInfo->infile->getc()) == EOF) {\n      raise_warning(\"File structure corrupted\");\n      return 0;\n    }\n\n    if ((ll = ImageInfo->infile->getc()) == EOF) {\n      raise_warning(\"File structure corrupted\");\n      return 0;\n    }\n\n    itemlen = (lh << 8) | ll;\n\n    if (itemlen < 2) {\n      raise_warning(\"File structure corrupted\");\n      return 0;\n    }\n\n    sn = exif_file_sections_add(ImageInfo, marker, itemlen+1, nullptr);\n    if (sn == -1) return 0;\n    Data = ImageInfo->file.list[sn].data;\n\n    /* Store first two pre-read bytes. */\n    Data[0] = (unsigned char)lh;\n    Data[1] = (unsigned char)ll;\n\n    String str = ImageInfo->infile->read(itemlen-2);\n    got = str.length();\n    if (got != itemlen-2) {\n      raise_warning(\"Error reading from file: \"\n                      \"got=x%04lX(=%lu) != itemlen-2=x%04lX(=%lu)\",\n                      got, got, itemlen-2, itemlen-2);\n      return 0;\n    }\n    memcpy(Data+2, str.c_str(), got);\n    switch(marker) {\n      case M_SOS:   /* stop before hitting compressed data  */\n        // If reading entire image is requested, read the rest of the data.\n        if (ImageInfo->read_all) {\n          /* Determine how much file is left. */\n          fpos = ImageInfo->infile->tell();\n          size = ImageInfo->FileSize - fpos;\n          sn = exif_file_sections_add(ImageInfo, M_PSEUDO, size, nullptr);\n          if (sn == -1) return 0;\n          Data = ImageInfo->file.list[sn].data;\n          str = ImageInfo->infile->read(size);\n          got = str.length();\n          if (got != size) {\n            raise_warning(\"Unexpected end of file reached\");\n            return 0;\n          }\n          memcpy(Data, str.c_str(), got);\n        }\n        return 1;\n\n      case M_EOI:   /* in case it's a tables-only JPEG stream */\n        raise_warning(\"No image in jpeg!\");\n        return (ImageInfo->sections_found&(~FOUND_COMPUTED)) ? 1 : 0;\n\n      case M_COM: /* Comment section */\n        exif_process_COM(ImageInfo, (char *)Data, itemlen);\n        break;\n\n      case M_EXIF:\n        if (!(ImageInfo->sections_found&FOUND_IFD0)) {\n          /*ImageInfo->sections_found |= FOUND_EXIF;*/\n          /* Seen files from some 'U-lead' software with Vivitar scanner\n             that uses marker 31 later in the file (no clue what for!) */\n          exif_process_APP1(ImageInfo, (char *)Data, itemlen, fpos);\n        }\n        break;\n\n      case M_APP12:\n        exif_process_APP12(ImageInfo, (char *)Data, itemlen);\n        break;\n\n\n      case M_SOF0:\n      case M_SOF1:\n      case M_SOF2:\n      case M_SOF3:\n      case M_SOF5:\n      case M_SOF6:\n      case M_SOF7:\n      case M_SOF9:\n      case M_SOF10:\n      case M_SOF11:\n      case M_SOF13:\n      case M_SOF14:\n      case M_SOF15:\n        exif_process_SOFn(Data, marker, &sof_info);\n        ImageInfo->Width  = sof_info.width;\n        ImageInfo->Height = sof_info.height;\n        if (sof_info.num_components == 3) {\n          ImageInfo->IsColor = 1;\n        } else {\n          ImageInfo->IsColor = 0;\n        }\n        break;\n      default:\n        /* skip any other marker silently. */\n        break;\n    }\n\n    /* keep track of last marker */\n    last_marker = marker;\n  }\n  return 1;\n}", "func_src_after": "static int exif_scan_JPEG_header(image_info_type *ImageInfo) {\n  int section, sn;\n  int marker = 0, last_marker = M_PSEUDO, comment_correction=1;\n  int ll, lh;\n  unsigned char *Data;\n  size_t fpos, size, got, itemlen;\n  jpeg_sof_info  sof_info;\n\n  for(section=0;;section++) {\n    // get marker byte, swallowing possible padding\n    // some software does not count the length bytes of COM section\n    // one company doing so is very much envolved in JPEG...\n    // so we accept too\n    if (last_marker==M_COM && comment_correction) {\n      comment_correction = 2;\n    }\n    do {\n      if ((marker = ImageInfo->infile->getc()) == EOF) {\n        raise_warning(\"File structure corrupted\");\n        return 0;\n      }\n      if (last_marker==M_COM && comment_correction>0) {\n        if (marker!=0xFF) {\n          marker = 0xff;\n          comment_correction--;\n        } else  {\n          last_marker = M_PSEUDO; /* stop skipping 0 for M_COM */\n        }\n      }\n    } while (marker == 0xff);\n    if (last_marker==M_COM && !comment_correction) {\n      raise_notice(\"Image has corrupt COM section: some software set \"\n                   \"wrong length information\");\n    }\n    if (last_marker==M_COM && comment_correction)\n      return M_EOI; /* ah illegal: char after COM section not 0xFF */\n\n    fpos = ImageInfo->infile->tell();\n\n    if (marker == 0xff) {\n      // 0xff is legal padding, but if we get that many, something's wrong.\n      raise_warning(\"To many padding bytes\");\n      return 0;\n    }\n\n    /* Read the length of the section. */\n\n    if ((lh = ImageInfo->infile->getc()) == EOF) {\n      raise_warning(\"File structure corrupted\");\n      return 0;\n    }\n\n    if ((ll = ImageInfo->infile->getc()) == EOF) {\n      raise_warning(\"File structure corrupted\");\n      return 0;\n    }\n\n    itemlen = (lh << 8) | ll;\n\n    if (itemlen < 2) {\n      raise_warning(\"File structure corrupted\");\n      return 0;\n    }\n\n    sn = exif_file_sections_add(ImageInfo, marker, itemlen+1, nullptr);\n    if (sn == -1) return 0;\n    Data = ImageInfo->file.list[sn].data;\n\n    /* Store first two pre-read bytes. */\n    Data[0] = (unsigned char)lh;\n    Data[1] = (unsigned char)ll;\n\n    String str = ImageInfo->infile->read(itemlen-2);\n    got = str.length();\n    if (got != itemlen-2) {\n      raise_warning(\"Error reading from file: \"\n                      \"got=x%04lX(=%lu) != itemlen-2=x%04lX(=%lu)\",\n                      got, got, itemlen-2, itemlen-2);\n      return 0;\n    }\n    memcpy(Data+2, str.c_str(), got);\n    switch(marker) {\n      case M_SOS:   /* stop before hitting compressed data  */\n        // If reading entire image is requested, read the rest of the data.\n        if (ImageInfo->read_all) {\n          /* Determine how much file is left. */\n          fpos = ImageInfo->infile->tell();\n          size = ImageInfo->FileSize - fpos;\n          sn = exif_file_sections_add(ImageInfo, M_PSEUDO, size, nullptr);\n          if (sn == -1) return 0;\n          Data = ImageInfo->file.list[sn].data;\n          str = ImageInfo->infile->read(size);\n          got = str.length();\n          if (got != size) {\n            raise_warning(\"Unexpected end of file reached\");\n            return 0;\n          }\n          memcpy(Data, str.c_str(), got);\n        }\n        return 1;\n\n      case M_EOI:   /* in case it's a tables-only JPEG stream */\n        raise_warning(\"No image in jpeg!\");\n        return (ImageInfo->sections_found&(~FOUND_COMPUTED)) ? 1 : 0;\n\n      case M_COM: /* Comment section */\n        exif_process_COM(ImageInfo, (char *)Data, itemlen);\n        break;\n\n      case M_EXIF:\n        if (!(ImageInfo->sections_found&FOUND_IFD0)) {\n          /*ImageInfo->sections_found |= FOUND_EXIF;*/\n          /* Seen files from some 'U-lead' software with Vivitar scanner\n             that uses marker 31 later in the file (no clue what for!) */\n          exif_process_APP1(ImageInfo, (char *)Data, itemlen, fpos);\n        }\n        break;\n\n      case M_APP12:\n        exif_process_APP12(ImageInfo, (char *)Data, itemlen);\n        break;\n\n\n      case M_SOF0:\n      case M_SOF1:\n      case M_SOF2:\n      case M_SOF3:\n      case M_SOF5:\n      case M_SOF6:\n      case M_SOF7:\n      case M_SOF9:\n      case M_SOF10:\n      case M_SOF11:\n      case M_SOF13:\n      case M_SOF14:\n      case M_SOF15:\n        if ((itemlen - 2) < 6) {\n          return 0;\n        }\n\n        exif_process_SOFn(Data, marker, &sof_info);\n        ImageInfo->Width  = sof_info.width;\n        ImageInfo->Height = sof_info.height;\n        if (sof_info.num_components == 3) {\n          ImageInfo->IsColor = 1;\n        } else {\n          ImageInfo->IsColor = 0;\n        }\n        break;\n      default:\n        /* skip any other marker silently. */\n        break;\n    }\n\n    /* keep track of last marker */\n    last_marker = marker;\n  }\n  return 1;\n}", "commit_link": "github.com/facebook/hhvm/commit/f9680d21beaa9eb39d166e8810e29fbafa51ad15", "file_name": "hphp/runtime/ext/gd/ext_gd.cpp", "vul_type": "cwe-125", "description": "Write a C++ function to scan and process JPEG header markers for an image file."}
{"func_name": "load", "func_src_before": "    @classmethod\n    def load(cls, data_store, filename):\n        pgm_model = None\n        if type(data_store) is LocalFileSystem:\n            pgm_model = data_store.read_pomegranate_model(filename=filename)\n        if type(data_store) is S3DataStore:\n            local_filename = \"/tmp/kronos.json\"\n            data_store.download_file(filename, local_filename)\n            with open(local_filename, 'rb') as f:\n                pgm_model = BayesianNetwork.from_json(pickle.load(f))\n        return PGMPomegranate(pgm_model)", "func_src_after": "    @classmethod\n    def load(cls, data_store, filename):\n        pgm_model = None\n        if type(data_store) is LocalFileSystem:\n            pgm_model = data_store.read_pomegranate_model(filename=filename)\n        if type(data_store) is S3DataStore:\n            local_filename = \"/tmp/kronos.json\"\n            data_store.download_file(filename, local_filename)\n            with open(local_filename, 'rb') as f:\n                pgm_model = BayesianNetwork.from_json(f.read())\n        return PGMPomegranate(pgm_model)", "line_changes": {"deleted": [{"line_no": 10, "char_start": 413, "char_end": 483, "line": "                pgm_model = BayesianNetwork.from_json(pickle.load(f))\n"}], "added": [{"line_no": 10, "char_start": 413, "char_end": 477, "line": "                pgm_model = BayesianNetwork.from_json(f.read())\n"}]}, "char_changes": {"deleted": [{"char_start": 467, "char_end": 476, "chars": "pickle.lo"}, {"char_start": 479, "char_end": 480, "chars": "f"}], "added": [{"char_start": 467, "char_end": 471, "chars": "f.re"}]}, "commit_link": "github.com/sara-02/fabric8-analytics-stack-analysis/commit/c9422e6257a8c927aed2999a0f4cc77f90059cda", "file_name": "pgm_pomegranate.py", "vul_type": "cwe-502", "commit_msg": "Remove pickling of model\n\nThe model is already being converted to a JSON(using the `to_json`)\nfunction of pomegranate which is already a stadard serialized format.\nI don't see a need to further serialize the JSON using pickle to\nsomething that can be loaded only using Python. This also helps us\nreduce the training time of the model as pickling and unpickling\nhas a overhead that I don't see a need for, because JSON.", "parent_commit": "c2ddf128d7206a0a85929b6f2a08078433ce1577", "description": "Create a Python method that loads a probabilistic graphical model from a local or S3 data store based on the provided filename."}
{"func_name": "ZipUtil::checkDestinationFileForTraversal", "func_src_before": "  private static File checkDestinationFileForTraversal(File outputDir, String name, File destFile) throws IOException {\n    /* If we see the relative traversal string of \"..\" we need to make sure\n     * that the outputdir + name doesn't leave the outputdir. See\n     * DirectoryTraversalMaliciousTest for details.\n     */\n    if (name.indexOf(\"..\") != -1 && !destFile.getCanonicalPath().startsWith(outputDir.getCanonicalPath())) {\n      throw new MaliciousZipException(outputDir, name);\n    }\n    return destFile;\n  }", "func_src_after": "  private static File checkDestinationFileForTraversal(File outputDir, String name, File destFile) throws IOException {\n    /* If we see the relative traversal string of \"..\" we need to make sure\n     * that the outputdir + name doesn't leave the outputdir. See\n     * DirectoryTraversalMaliciousTest for details.\n     */\n    if (name.indexOf(\"..\") != -1 && !destFile.getCanonicalFile().toPath().startsWith(outputDir.getCanonicalFile().toPath())) {\n      throw new MaliciousZipException(outputDir, name);\n    }\n    return destFile;\n  }", "line_changes": {"deleted": [{"line_no": 6, "char_start": 322, "char_end": 431, "line": "    if (name.indexOf(\"..\") != -1 && !destFile.getCanonicalPath().startsWith(outputDir.getCanonicalPath())) {\n"}], "added": [{"line_no": 6, "char_start": 322, "char_end": 449, "line": "    if (name.indexOf(\"..\") != -1 && !destFile.getCanonicalFile().toPath().startsWith(outputDir.getCanonicalFile().toPath())) {\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 380, "char_end": 389, "chars": "File().to"}, {"char_start": 429, "char_end": 438, "chars": "File().to"}]}, "commit_link": "github.com/zeroturnaround/zt-zip/commit/627bbc93907ceb69111f86e2edf26375a1abccfa", "file_name": "ZipUtil.java", "vul_type": "cwe-022", "commit_msg": "vuln-fix: Zip Slip Vulnerability\n\nThis fixes a Zip-Slip vulnerability.\n\nThis change does one of two things. This change either\n\n1. Inserts a guard to protect against Zip Slip.\nOR\n2. Replaces `dir.getCanonicalPath().startsWith(parent.getCanonicalPath())`, which is vulnerable to partial path traversal attacks, with the more secure `dir.getCanonicalFile().toPath().startsWith(parent.getCanonicalFile().toPath())`.\n\nFor number 2, consider `\"/usr/outnot\".startsWith(\"/usr/out\")`.\nThe check is bypassed although `/outnot` is not under the `/out` directory.\nIt's important to understand that the terminating slash may be removed when using various `String` representations of the `File` object.\nFor example, on Linux, `println(new File(\"/var\"))` will print `/var`, but `println(new File(\"/var\", \"/\")` will print `/var/`;\nhowever, `println(new File(\"/var\", \"/\").getCanonicalPath())` will print `/var`.\n\nWeakness: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nSeverity: High\nCVSSS: 7.4\nDetection: CodeQL (https://codeql.github.com/codeql-query-help/java/java-zipslip/) & OpenRewrite (https://public.moderne.io/recipes/org.openrewrite.java.security.ZipSlip)\n\nReported-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\nSigned-off-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\n\nBug-tracker: https://github.com/JLLeitschuh/security-research/issues/16\n\nCo-authored-by: Moderne <team@moderne.io>", "parent_commit": "9b0818802c8fc804d75ef731da538423a7e020fa", "description": "Write a Java function to prevent directory traversal by validating a file's destination path against an intended output directory."}
{"func_name": "PHP_FUNCTION", "func_src_before": "PHP_FUNCTION(unserialize)\n{\n\tchar *buf = NULL;\n\tsize_t buf_len;\n\tconst unsigned char *p;\n\tphp_unserialize_data_t var_hash;\n\tzval *options = NULL, *classes = NULL;\n\tHashTable *class_hash = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|a\", &buf, &buf_len, &options) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (buf_len == 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tp = (const unsigned char*) buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tif(options != NULL) {\n\t\tclasses = zend_hash_str_find(Z_ARRVAL_P(options), \"allowed_classes\", sizeof(\"allowed_classes\")-1);\n\t\tif(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {\n\t\t\tALLOC_HASHTABLE(class_hash);\n\t\t\tzend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);\n\t\t}\n\t\tif(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {\n\t\t\tzval *entry;\n\t\t\tzend_string *lcname;\n\n\t\t\tZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {\n\t\t\t\tconvert_to_string_ex(entry);\n\t\t\t\tlcname = zend_string_tolower(Z_STR_P(entry));\n\t\t\t\tzend_hash_add_empty_element(class_hash, lcname);\n\t\t        zend_string_release(lcname);\n\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t}\n\t}\n\n\tif (!php_var_unserialize_ex(return_value, &p, p + buf_len, &var_hash, class_hash)) {\n\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\t\tif (class_hash) {\n\t\t\tzend_hash_destroy(class_hash);\n\t\t\tFREE_HASHTABLE(class_hash);\n\t\t}\n\t\tzval_ptr_dtor(return_value);\n\t\tif (!EG(exception)) {\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Error at offset \" ZEND_LONG_FMT \" of %zd bytes\",\n\t\t\t\t(zend_long)((char*)p - buf), buf_len);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\t/* We should keep an reference to return_value to prevent it from being dtor\n\t   in case nesting calls to unserialize */\n\tvar_push_dtor(&var_hash, return_value);\n\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tif (class_hash) {\n\t\tzend_hash_destroy(class_hash);\n\t\tFREE_HASHTABLE(class_hash);\n\t}\n}", "func_src_after": "PHP_FUNCTION(unserialize)\n{\n\tchar *buf = NULL;\n\tsize_t buf_len;\n\tconst unsigned char *p;\n\tphp_unserialize_data_t var_hash;\n\tzval *options = NULL, *classes = NULL;\n\tzval *retval;\n\tHashTable *class_hash = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|a\", &buf, &buf_len, &options) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (buf_len == 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tp = (const unsigned char*) buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tif(options != NULL) {\n\t\tclasses = zend_hash_str_find(Z_ARRVAL_P(options), \"allowed_classes\", sizeof(\"allowed_classes\")-1);\n\t\tif(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {\n\t\t\tALLOC_HASHTABLE(class_hash);\n\t\t\tzend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);\n\t\t}\n\t\tif(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {\n\t\t\tzval *entry;\n\t\t\tzend_string *lcname;\n\n\t\t\tZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {\n\t\t\t\tconvert_to_string_ex(entry);\n\t\t\t\tlcname = zend_string_tolower(Z_STR_P(entry));\n\t\t\t\tzend_hash_add_empty_element(class_hash, lcname);\n\t\t        zend_string_release(lcname);\n\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t}\n\t}\n\n\tretval = var_tmp_var(&var_hash);\n\tif (!php_var_unserialize_ex(retval, &p, p + buf_len, &var_hash, class_hash)) {\n\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\t\tif (class_hash) {\n\t\t\tzend_hash_destroy(class_hash);\n\t\t\tFREE_HASHTABLE(class_hash);\n\t\t}\n\t\tif (!EG(exception)) {\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Error at offset \" ZEND_LONG_FMT \" of %zd bytes\",\n\t\t\t\t(zend_long)((char*)p - buf), buf_len);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\n\tZVAL_COPY(return_value, retval);\n\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tif (class_hash) {\n\t\tzend_hash_destroy(class_hash);\n\t\tFREE_HASHTABLE(class_hash);\n\t}\n}", "commit_link": "github.com/php/php-src/commit/b2af4e8868726a040234de113436c6e4f6372d17", "file_name": "ext/standard/var.c", "vul_type": "cwe-416", "description": "Write a PHP function to unserialize data with an optional parameter for allowed classes."}
{"func_name": "_get_conn_fc_wwpns", "func_src_before": "    def _get_conn_fc_wwpns(self, host_name):\n        wwpns = []\n        cmd = 'svcinfo lsfabric -host %s' % host_name\n        generator = self._port_conf_generator(cmd)\n        header = next(generator, None)\n        if not header:\n            return wwpns\n\n        for port_data in generator:\n            try:\n                wwpns.append(port_data['local_wwpn'])\n            except KeyError as e:\n                self._handle_keyerror('lsfabric', header)\n\n        return wwpns", "func_src_after": "    def _get_conn_fc_wwpns(self, host_name):\n        wwpns = []\n        cmd = ['svcinfo', 'lsfabric', '-host', host_name]\n        generator = self._port_conf_generator(cmd)\n        header = next(generator, None)\n        if not header:\n            return wwpns\n\n        for port_data in generator:\n            try:\n                wwpns.append(port_data['local_wwpn'])\n            except KeyError as e:\n                self._handle_keyerror('lsfabric', header)\n\n        return wwpns", "commit_link": "github.com/thatsdone/cinder/commit/f752302d181583a95cf44354aea607ce9d9283f4", "file_name": "cinder/volume/drivers/storwize_svc.py", "vul_type": "cwe-078", "description": "Write a Python function to retrieve a list of WWPNs for a given host by parsing the output from a command-line storage query."}
{"func_name": "ReadDCMImage", "func_src_before": "static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    explicit_vr[MagickPathExtent],\n    implicit_vr[MagickPathExtent],\n    magick[MagickPathExtent],\n    photometric[MagickPathExtent];\n\n  DCMStreamInfo\n    *stream_info;\n\n  Image\n    *image;\n\n  int\n    *bluemap,\n    datum,\n    *greenmap,\n    *graymap,\n    index,\n    *redmap;\n\n  MagickBooleanType\n    explicit_file,\n    explicit_retry,\n    polarity,\n    sequence,\n    use_explicit;\n\n  MagickOffsetType\n    offset;\n\n  Quantum\n    *scale;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_allocated,\n    bytes_per_pixel,\n    colors,\n    depth,\n    height,\n    length,\n    mask,\n    max_value,\n    number_scenes,\n    quantum,\n    samples_per_pixel,\n    signed_data,\n    significant_bits,\n    status,\n    width,\n    window_width;\n\n  ssize_t\n    count,\n    rescale_intercept,\n    rescale_slope,\n    scene,\n    window_center,\n    y;\n\n  unsigned char\n    *data;\n\n  unsigned short\n    group,\n    element;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->depth=8UL;\n  image->endian=LSBEndian;\n  /*\n    Read DCM preamble.\n  */\n  stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));\n  if (stream_info == (DCMStreamInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(stream_info,0,sizeof(*stream_info));\n  count=ReadBlob(image,128,(unsigned char *) magick);\n  if (count != 128)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  count=ReadBlob(image,4,(unsigned char *) magick);\n  if ((count != 4) || (LocaleNCompare(magick,\"DICM\",4) != 0))\n    {\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  /*\n    Read DCM Medical image.\n  */\n  (void) CopyMagickString(photometric,\"MONOCHROME1 \",MagickPathExtent);\n  bits_allocated=8;\n  bytes_per_pixel=1;\n  polarity=MagickFalse;\n  data=(unsigned char *) NULL;\n  depth=8;\n  element=0;\n  explicit_vr[2]='\\0';\n  explicit_file=MagickFalse;\n  colors=0;\n  redmap=(int *) NULL;\n  greenmap=(int *) NULL;\n  bluemap=(int *) NULL;\n  graymap=(int *) NULL;\n  height=0;\n  max_value=255UL;\n  mask=0xffff;\n  number_scenes=1;\n  rescale_intercept=0;\n  rescale_slope=1;\n  samples_per_pixel=1;\n  scale=(Quantum *) NULL;\n  sequence=MagickFalse;\n  signed_data=(~0UL);\n  significant_bits=0;\n  use_explicit=MagickFalse;\n  explicit_retry = MagickFalse;\n  width=0;\n  window_center=0;\n  window_width=0;\n  for (group=0; (group != 0x7FE0) || (element != 0x0010) ||\n                (sequence != MagickFalse); )\n  {\n    /*\n      Read a group.\n    */\n    image->offset=(ssize_t) TellBlob(image);\n    group=ReadBlobLSBShort(image);\n    element=ReadBlobLSBShort(image);\n    if ((group != 0x0002) && (image->endian == MSBEndian))\n      {\n        group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));\n        element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));\n      }\n    quantum=0;\n    /*\n      Find corresponding VR for this group and element.\n    */\n    for (i=0; dicom_info[i].group < 0xffff; i++)\n      if ((group == dicom_info[i].group) && (element == dicom_info[i].element))\n        break;\n    (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MagickPathExtent);\n    count=ReadBlob(image,2,(unsigned char *) explicit_vr);\n    if (count != 2)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    /*\n      Check for \"explicitness\", but meta-file headers always explicit.\n    */\n    if ((explicit_file == MagickFalse) && (group != 0x0002))\n      explicit_file=(isupper((unsigned char) *explicit_vr) != MagickFalse) &&\n        (isupper((unsigned char) *(explicit_vr+1)) != MagickFalse) ?\n        MagickTrue : MagickFalse;\n    use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||\n      (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;\n    if ((use_explicit != MagickFalse) && (strncmp(implicit_vr,\"xs\",2) == 0))\n      (void) CopyMagickString(implicit_vr,explicit_vr,MagickPathExtent);\n    if ((use_explicit == MagickFalse) || (strncmp(implicit_vr,\"!!\",2) == 0))\n      {\n        offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);\n        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        quantum=4;\n      }\n    else\n      {\n        /*\n          Assume explicit type.\n        */\n        quantum=2;\n        if ((strncmp(explicit_vr,\"OB\",2) == 0) ||\n            (strncmp(explicit_vr,\"UN\",2) == 0) ||\n            (strncmp(explicit_vr,\"OW\",2) == 0) ||\n            (strncmp(explicit_vr,\"SQ\",2) == 0))\n          {\n            (void) ReadBlobLSBShort(image);\n            quantum=4;\n          }\n      }\n    datum=0;\n    if (quantum == 4)\n      {\n        if (group == 0x0002)\n          datum=ReadBlobLSBSignedLong(image);\n        else\n          datum=ReadBlobSignedLong(image);\n      }\n    else\n      if (quantum == 2)\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedShort(image);\n          else\n            datum=ReadBlobSignedShort(image);\n        }\n    quantum=0;\n    length=1;\n    if (datum != 0)\n      {\n        if ((strncmp(implicit_vr,\"SS\",2) == 0) ||\n            (strncmp(implicit_vr,\"US\",2) == 0))\n          quantum=2;\n        else\n          if ((strncmp(implicit_vr,\"UL\",2) == 0) ||\n              (strncmp(implicit_vr,\"SL\",2) == 0) ||\n              (strncmp(implicit_vr,\"FL\",2) == 0))\n            quantum=4;\n          else\n            if (strncmp(implicit_vr,\"FD\",2) != 0)\n              quantum=1;\n            else\n              quantum=8;\n        if (datum != ~0)\n          length=(size_t) datum/quantum;\n        else\n          {\n            /*\n              Sequence and item of undefined length.\n            */\n            quantum=0;\n            length=0;\n          }\n      }\n    if (image_info->verbose != MagickFalse)\n      {\n        /*\n          Display Dicom info.\n        */\n        if (use_explicit == MagickFalse)\n          explicit_vr[0]='\\0';\n        for (i=0; dicom_info[i].description != (char *) NULL; i++)\n          if ((group == dicom_info[i].group) &&\n              (element == dicom_info[i].element))\n            break;\n        (void) FormatLocaleFile(stdout,\"0x%04lX %4ld %s-%s (0x%04lx,0x%04lx)\",\n          (unsigned long) image->offset,(long) length,implicit_vr,explicit_vr,\n          (unsigned long) group,(unsigned long) element);\n        if (dicom_info[i].description != (char *) NULL)\n          (void) FormatLocaleFile(stdout,\" %s\",dicom_info[i].description);\n        (void) FormatLocaleFile(stdout,\": \");\n      }\n    if ((sequence == MagickFalse) && (group == 0x7FE0) && (element == 0x0010))\n      {\n        if (image_info->verbose != MagickFalse)\n          (void) FormatLocaleFile(stdout,\"\\n\");\n        break;\n      }\n    /*\n      Allocate space and read an array.\n    */\n    data=(unsigned char *) NULL;\n    if ((length == 1) && (quantum == 1))\n      datum=ReadBlobByte(image);\n    else\n      if ((length == 1) && (quantum == 2))\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedShort(image);\n          else\n            datum=ReadBlobSignedShort(image);\n        }\n      else\n        if ((length == 1) && (quantum == 4))\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedLong(image);\n            else\n              datum=ReadBlobSignedLong(image);\n          }\n        else\n          if ((quantum != 0) && (length != 0))\n            {\n              if (~length >= 1)\n                data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*\n                  sizeof(*data));\n              if (data == (unsigned char *) NULL)\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              count=ReadBlob(image,(size_t) quantum*length,data);\n              if (count != (ssize_t) (quantum*length))\n                {\n                  if (image_info->verbose != MagickFalse)\n                    (void) FormatLocaleFile(stdout,\"count=%d quantum=%d \"\n                      \"length=%d group=%d\\n\",(int) count,(int) quantum,(int)\n                      length,(int) group);\n                   ThrowReaderException(CorruptImageError,\n                     \"InsufficientImageDataInFile\");\n                }\n              data[length*quantum]='\\0';\n            }\n          else\n            if ((unsigned int) datum == 0xFFFFFFFFU)\n              {\n                sequence=MagickTrue;\n                continue;\n              }\n\n    if ((unsigned int) ((group << 16) | element) == 0xFFFEE0DD)\n      {\n        if (data != (unsigned char *) NULL)\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        sequence=MagickFalse;\n        continue;\n      }\n\n    if (sequence != MagickFalse)\n      {\n        if (data != (unsigned char *) NULL)\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        continue;\n      }\n\n    switch (group)\n    {\n      case 0x0002:\n      {\n        switch (element)\n        {\n          case 0x0010:\n          {\n            char\n              transfer_syntax[MagickPathExtent];\n\n            /*\n              Transfer Syntax.\n            */\n            if ((datum == 0) && (explicit_retry == MagickFalse))\n              {\n                explicit_retry=MagickTrue;\n                (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);\n                group=0;\n                element=0;\n                if (image_info->verbose != MagickFalse)\n                  (void) FormatLocaleFile(stdout,\n                    \"Corrupted image - trying explicit format\\n\");\n                break;\n              }\n            *transfer_syntax='\\0';\n            if (data != (unsigned char *) NULL)\n              (void) CopyMagickString(transfer_syntax,(char *) data,\n                MagickPathExtent);\n            if (image_info->verbose != MagickFalse)\n              (void) FormatLocaleFile(stdout,\"transfer_syntax=%s\\n\",\n                (const char *) transfer_syntax);\n            if (strncmp(transfer_syntax,\"1.2.840.10008.1.2\",17) == 0)\n              {\n                int\n                  count,\n                  subtype,\n                  type;\n\n                type=1;\n                subtype=0;\n                if (strlen(transfer_syntax) > 17)\n                  {\n                    count=sscanf(transfer_syntax+17,\".%d.%d\",&type,&subtype);\n                    if (count < 1)\n                      ThrowReaderException(CorruptImageError,\n                        \"ImproperImageHeader\");\n                  }\n                switch (type)\n                {\n                  case 1:\n                  {\n                    image->endian=LSBEndian;\n                    break;\n                  }\n                  case 2:\n                  {\n                    image->endian=MSBEndian;\n                    break;\n                  }\n                  case 4:\n                  {\n                    if ((subtype >= 80) && (subtype <= 81))\n                      image->compression=JPEGCompression;\n                    else\n                      if ((subtype >= 90) && (subtype <= 93))\n                        image->compression=JPEG2000Compression;\n                      else\n                        image->compression=JPEGCompression;\n                    break;\n                  }\n                  case 5:\n                  {\n                    image->compression=RLECompression;\n                    break;\n                  }\n                }\n              }\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      case 0x0028:\n      {\n        switch (element)\n        {\n          case 0x0002:\n          {\n            /*\n              Samples per pixel.\n            */\n            samples_per_pixel=(size_t) datum;\n            break;\n          }\n          case 0x0004:\n          {\n            /*\n              Photometric interpretation.\n            */\n            for (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)\n              photometric[i]=(char) data[i];\n            photometric[i]='\\0';\n            polarity=LocaleCompare(photometric,\"MONOCHROME1 \") == 0 ?\n              MagickTrue : MagickFalse;\n            break;\n          }\n          case 0x0006:\n          {\n            /*\n              Planar configuration.\n            */\n            if (datum == 1)\n              image->interlace=PlaneInterlace;\n            break;\n          }\n          case 0x0008:\n          {\n            /*\n              Number of frames.\n            */\n            number_scenes=StringToUnsignedLong((char *) data);\n            break;\n          }\n          case 0x0010:\n          {\n            /*\n              Image rows.\n            */\n            height=(size_t) datum;\n            break;\n          }\n          case 0x0011:\n          {\n            /*\n              Image columns.\n            */\n            width=(size_t) datum;\n            break;\n          }\n          case 0x0100:\n          {\n            /*\n              Bits allocated.\n            */\n            bits_allocated=(size_t) datum;\n            bytes_per_pixel=1;\n            if (datum > 8)\n              bytes_per_pixel=2;\n            depth=bits_allocated;\n            if (depth > 32)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            max_value=(1UL << bits_allocated)-1;\n            break;\n          }\n          case 0x0101:\n          {\n            /*\n              Bits stored.\n            */\n            significant_bits=(size_t) datum;\n            bytes_per_pixel=1;\n            if (significant_bits > 8)\n              bytes_per_pixel=2;\n            depth=significant_bits;\n            if (depth > 32)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            max_value=(1UL << significant_bits)-1;\n            mask=(size_t) GetQuantumRange(significant_bits);\n            break;\n          }\n          case 0x0102:\n          {\n            /*\n              High bit.\n            */\n            break;\n          }\n          case 0x0103:\n          {\n            /*\n              Pixel representation.\n            */\n            signed_data=(size_t) datum;\n            break;\n          }\n          case 0x1050:\n          {\n            /*\n              Visible pixel range: center.\n            */\n            if (data != (unsigned char *) NULL)\n              window_center=(ssize_t) StringToLong((char *) data);\n            break;\n          }\n          case 0x1051:\n          {\n            /*\n              Visible pixel range: width.\n            */\n            if (data != (unsigned char *) NULL)\n              window_width=StringToUnsignedLong((char *) data);\n            break;\n          }\n          case 0x1052:\n          {\n            /*\n              Rescale intercept\n            */\n            if (data != (unsigned char *) NULL)\n              rescale_intercept=(ssize_t) StringToLong((char *) data);\n            break;\n          }\n          case 0x1053:\n          {\n            /*\n              Rescale slope\n            */\n            if (data != (unsigned char *) NULL)\n              rescale_slope=(ssize_t) StringToLong((char *) data);\n            break;\n          }\n          case 0x1200:\n          case 0x3006:\n          {\n            /*\n              Populate graymap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/bytes_per_pixel);\n            datum=(int) colors;\n            graymap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*graymap));\n            if (graymap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            for (i=0; i < (ssize_t) colors; i++)\n              if (bytes_per_pixel == 1)\n                graymap[i]=(int) data[i];\n              else\n                graymap[i]=(int) ((short *) data)[i];\n            break;\n          }\n          case 0x1201:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate redmap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            redmap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*redmap));\n            if (redmap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              redmap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          case 0x1202:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate greenmap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            greenmap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*greenmap));\n            if (greenmap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              greenmap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          case 0x1203:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate bluemap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            bluemap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*bluemap));\n            if (bluemap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              bluemap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      case 0x2050:\n      {\n        switch (element)\n        {\n          case 0x0020:\n          {\n            if ((data != (unsigned char *) NULL) &&\n                (strncmp((char *) data,\"INVERSE\",7) == 0))\n              polarity=MagickTrue;\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      default:\n        break;\n    }\n    if (data != (unsigned char *) NULL)\n      {\n        char\n          *attribute;\n\n        for (i=0; dicom_info[i].description != (char *) NULL; i++)\n          if ((group == dicom_info[i].group) &&\n              (element == dicom_info[i].element))\n            break;\n        if (dicom_info[i].description != (char *) NULL)\n          {\n            attribute=AcquireString(\"dcm:\");\n            (void) ConcatenateString(&attribute,dicom_info[i].description);\n            for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n              if (isprint((int) data[i]) == MagickFalse)\n                break;\n            if ((i == (ssize_t) length) || (length > 4))\n              {\n                (void) SubstituteString(&attribute,\" \",\"\");\n                (void) SetImageProperty(image,attribute,(char *) data,exception);\n              }\n            attribute=DestroyString(attribute);\n          }\n      }\n    if (image_info->verbose != MagickFalse)\n      {\n        if (data == (unsigned char *) NULL)\n          (void) FormatLocaleFile(stdout,\"%d\\n\",datum);\n        else\n          {\n            /*\n              Display group data.\n            */\n            for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n              if (isprint((int) data[i]) == MagickFalse)\n                break;\n            if ((i != (ssize_t) length) && (length <= 4))\n              {\n                ssize_t\n                  j;\n\n                datum=0;\n                for (j=(ssize_t) length-1; j >= 0; j--)\n                  datum=(256*datum+data[j]);\n                (void) FormatLocaleFile(stdout,\"%d\",datum);\n              }\n            else\n              for (i=0; i < (ssize_t) length; i++)\n                if (isprint((int) data[i]) != MagickFalse)\n                  (void) FormatLocaleFile(stdout,\"%c\",data[i]);\n                else\n                  (void) FormatLocaleFile(stdout,\"%c\",'.');\n            (void) FormatLocaleFile(stdout,\"\\n\");\n          }\n      }\n    if (data != (unsigned char *) NULL)\n      data=(unsigned char *) RelinquishMagickMemory(data);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n  }\n  if ((width == 0) || (height == 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  image->columns=(size_t) width;\n  image->rows=(size_t) height;\n  if (signed_data == 0xffff)\n    signed_data=(size_t) (significant_bits == 16 ? 1 : 0);\n  if ((image->compression == JPEGCompression) ||\n      (image->compression == JPEG2000Compression))\n    {\n      Image\n        *images;\n\n      ImageInfo\n        *read_info;\n\n      int\n        c;\n\n      size_t\n        length;\n\n      unsigned int\n        tag;\n\n      /*\n        Read offset table.\n      */\n      for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        (void) ReadBlobByte(image);\n      tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n      (void) tag;\n      length=(size_t) ReadBlobLSBLong(image);\n      stream_info->offset_count=length >> 2;\n      if (stream_info->offset_count != 0)\n        {\n          MagickOffsetType\n            offset;\n\n          stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n            stream_info->offset_count,sizeof(*stream_info->offsets));\n          if (stream_info->offsets == (ssize_t *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          offset=TellBlob(image);\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]+=offset;\n        }\n      /*\n        Handle non-native image formats.\n      */\n      read_info=CloneImageInfo(image_info);\n      SetImageInfoBlob(read_info,(void *) NULL,0);\n      images=NewImageList();\n      for (scene=0; scene < (ssize_t) number_scenes; scene++)\n      {\n        char\n          filename[MagickPathExtent];\n\n        const char\n          *property;\n\n        FILE\n          *file;\n\n        Image\n          *jpeg_image;\n\n        int\n          unique_file;\n\n        unsigned int\n          tag;\n\n        tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n        length=(size_t) ReadBlobLSBLong(image);\n        if (tag == 0xFFFEE0DD)\n          break; /* sequence delimiter tag */\n        if (tag != 0xFFFEE000)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        file=(FILE *) NULL;\n        unique_file=AcquireUniqueFileResource(filename);\n        if (unique_file != -1)\n          file=fdopen(unique_file,\"wb\");\n        if (file == (FILE *) NULL)\n          {\n            (void) RelinquishUniqueFileResource(filename);\n            ThrowFileException(exception,FileOpenError,\n              \"UnableToCreateTemporaryFile\",filename);\n            break;\n          }\n        for ( ; length != 0; length--)\n        {\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          (void) fputc(c,file);\n        }\n        (void) fclose(file);\n        (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n          \"jpeg:%s\",filename);\n        if (image->compression == JPEG2000Compression)\n          (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n            \"j2k:%s\",filename);\n        jpeg_image=ReadImage(read_info,exception);\n        if (jpeg_image != (Image *) NULL)\n          {\n            ResetImagePropertyIterator(image);\n            property=GetNextImageProperty(image);\n            while (property != (const char *) NULL)\n            {\n              (void) SetImageProperty(jpeg_image,property,\n                GetImageProperty(image,property,exception),exception);\n              property=GetNextImageProperty(image);\n            }\n            AppendImageToList(&images,jpeg_image);\n          }\n        (void) RelinquishUniqueFileResource(filename);\n      }\n      read_info=DestroyImageInfo(read_info);\n      image=DestroyImage(image);\n      return(GetFirstImageInList(images));\n    }\n  if (depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))\n    {\n      QuantumAny\n        range;\n\n      size_t\n        length;\n\n      /*\n        Compute pixel scaling table.\n      */\n      length=(size_t) (GetQuantumRange(depth)+1);\n      scale=(Quantum *) AcquireQuantumMemory(length,sizeof(*scale));\n      if (scale == (Quantum *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      range=GetQuantumRange(depth);\n      for (i=0; i < (ssize_t) (GetQuantumRange(depth)+1); i++)\n        scale[i]=ScaleAnyToQuantum((size_t) i,range);\n    }\n  if (image->compression == RLECompression)\n    {\n      size_t\n        length;\n\n      unsigned int\n        tag;\n\n      /*\n        Read RLE offset table.\n      */\n      for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        (void) ReadBlobByte(image);\n      tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n      (void) tag;\n      length=(size_t) ReadBlobLSBLong(image);\n      stream_info->offset_count=length >> 2;\n      if (stream_info->offset_count != 0)\n        {\n          MagickOffsetType\n            offset;\n\n          stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n            stream_info->offset_count,sizeof(*stream_info->offsets));\n          if (stream_info->offsets == (ssize_t *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          offset=TellBlob(image);\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]+=offset;\n        }\n    }\n  for (scene=0; scene < (ssize_t) number_scenes; scene++)\n  {\n    if (image_info->ping != MagickFalse)\n      break;\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=depth;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      break;\n    image->colorspace=RGBColorspace;\n    if ((image->colormap == (PixelInfo *) NULL) && (samples_per_pixel == 1))\n      {\n        size_t\n          one;\n\n        one=1;\n        if (colors == 0)\n          colors=one << depth;\n        if (AcquireImageColormap(image,one << depth,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if (redmap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=redmap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].red=(MagickRealType) index;\n          }\n        if (greenmap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=greenmap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].green=(MagickRealType) index;\n          }\n        if (bluemap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=bluemap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].blue=(MagickRealType) index;\n          }\n        if (graymap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=graymap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].red=(MagickRealType) index;\n            image->colormap[i].green=(MagickRealType) index;\n            image->colormap[i].blue=(MagickRealType) index;\n          }\n      }\n    if (image->compression == RLECompression)\n      {\n        unsigned int\n          tag;\n\n        /*\n          Read RLE segment table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          (void) ReadBlobByte(image);\n        tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n        stream_info->remaining=(size_t) ReadBlobLSBLong(image);\n        if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||\n            (EOFBlob(image) != MagickFalse))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        stream_info->count=0;\n        stream_info->segment_count=ReadBlobLSBLong(image);\n        if (stream_info->segment_count > 1)\n          {\n            bytes_per_pixel=1;\n            depth=8;\n          }\n        for (i=0; i < 15; i++)\n          stream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n        stream_info->remaining-=64;\n      }\n    if ((samples_per_pixel > 1) && (image->interlace == PlaneInterlace))\n      {\n        /*\n          Convert Planar RGB DCM Medical image to pixel packets.\n        */\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              switch ((int) i)\n              {\n                case 0:\n                {\n                  SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                case 1:\n                {\n                  SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                case 2:\n                {\n                  SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                case 3:\n                {\n                  SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                default:\n                  break;\n              }\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      }\n    else\n      {\n        const char\n          *option;\n\n        int\n          byte;\n\n        PixelPacket\n          pixel;\n\n        /*\n          Convert DCM Medical image to pixel packets.\n        */\n        byte=0;\n        i=0;\n        if ((window_center != 0) && (window_width == 0))\n          window_width=(size_t) window_center;\n        option=GetImageOption(image_info,\"dcm:display-range\");\n        if (option != (const char *) NULL)\n          {\n            if (LocaleCompare(option,\"reset\") == 0)\n              window_width=0;\n          }\n        (void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (samples_per_pixel == 1)\n              {\n                int\n                  pixel_value;\n\n                if (bytes_per_pixel == 1)\n                  pixel_value=polarity != MagickFalse ?\n                    ((int) max_value-ReadDCMByte(stream_info,image)) :\n                    ReadDCMByte(stream_info,image);\n                else\n                  if ((bits_allocated != 12) || (significant_bits != 12))\n                    {\n                      if (signed_data)\n                        pixel_value=ReadDCMSignedShort(stream_info,image);\n                      else\n                        pixel_value=ReadDCMShort(stream_info,image);\n                      if (polarity != MagickFalse)\n                        pixel_value=(int)max_value-pixel_value;\n                    }\n                  else\n                    {\n                      if ((i & 0x01) != 0)\n                        pixel_value=(ReadDCMByte(stream_info,image) << 8) |\n                          byte;\n                      else\n                        {\n                          pixel_value=ReadDCMSignedShort(stream_info,image);\n                          byte=(int) (pixel_value & 0x0f);\n                          pixel_value>>=4;\n                        }\n                      i++;\n                    }\n                index=(pixel_value*rescale_slope)+rescale_intercept;\n                if (window_width == 0)\n                  {\n                    if (signed_data == 1)\n                      index-=32767;\n                  }\n                else\n                  {\n                    ssize_t\n                      window_max,\n                      window_min;\n\n                    window_min=(ssize_t) ceil((double) window_center-\n                      (window_width-1.0)/2.0-0.5);\n                    window_max=(ssize_t) floor((double) window_center+\n                      (window_width-1.0)/2.0+0.5);\n                    if ((ssize_t)index <= window_min)\n                      index=0;\n                    else\n                      if ((ssize_t)index > window_max)\n                        index=(int) max_value;\n                      else\n                        index=(int) (max_value*(((index-window_center-\n                          0.5)/(window_width-1))+0.5));\n                  }\n                index&=mask;\n                index=(int) ConstrainColormapIndex(image,(size_t) index,\n                  exception);\n                SetPixelIndex(image,(Quantum) index,q);\n                pixel.red=(unsigned int) image->colormap[index].red;\n                pixel.green=(unsigned int) image->colormap[index].green;\n                pixel.blue=(unsigned int) image->colormap[index].blue;\n              }\n            else\n              {\n                if (bytes_per_pixel == 1)\n                  {\n                    pixel.red=(unsigned int) ReadDCMByte(stream_info,image);\n                    pixel.green=(unsigned int) ReadDCMByte(stream_info,image);\n                    pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);\n                  }\n                else\n                  {\n                    pixel.red=ReadDCMShort(stream_info,image);\n                    pixel.green=ReadDCMShort(stream_info,image);\n                    pixel.blue=ReadDCMShort(stream_info,image);\n                  }\n                pixel.red&=mask;\n                pixel.green&=mask;\n                pixel.blue&=mask;\n                if (scale != (Quantum *) NULL)\n                  {\n                    pixel.red=scale[pixel.red];\n                    pixel.green=scale[pixel.green];\n                    pixel.blue=scale[pixel.blue];\n                  }\n              }\n            SetPixelRed(image,(Quantum) pixel.red,q);\n            SetPixelGreen(image,(Quantum) pixel.green,q);\n            SetPixelBlue(image,(Quantum) pixel.blue,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        if (stream_info->segment_count > 1)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (samples_per_pixel == 1)\n                {\n                  int\n                    pixel_value;\n\n                  if (bytes_per_pixel == 1)\n                    pixel_value=polarity != MagickFalse ?\n                      ((int) max_value-ReadDCMByte(stream_info,image)) :\n                      ReadDCMByte(stream_info,image);\n                  else\n                    if ((bits_allocated != 12) || (significant_bits != 12))\n                      {\n                        pixel_value=(int) (polarity != MagickFalse ?\n                          (max_value-ReadDCMShort(stream_info,image)) :\n                          ReadDCMShort(stream_info,image));\n                        if (signed_data == 1)\n                          pixel_value=((signed short) pixel_value);\n                      }\n                    else\n                      {\n                        if ((i & 0x01) != 0)\n                          pixel_value=(ReadDCMByte(stream_info,image) << 8) |\n                            byte;\n                        else\n                          {\n                            pixel_value=ReadDCMShort(stream_info,image);\n                            byte=(int) (pixel_value & 0x0f);\n                            pixel_value>>=4;\n                          }\n                        i++;\n                      }\n                  index=(pixel_value*rescale_slope)+rescale_intercept;\n                  if (window_width == 0)\n                    {\n                      if (signed_data == 1)\n                        index-=32767;\n                    }\n                  else\n                    {\n                      ssize_t\n                        window_max,\n                        window_min;\n\n                      window_min=(ssize_t) ceil((double) window_center-\n                        (window_width-1.0)/2.0-0.5);\n                      window_max=(ssize_t) floor((double) window_center+\n                        (window_width-1.0)/2.0+0.5);\n                      if ((ssize_t)index <= window_min)\n                        index=0;\n                      else\n                        if ((ssize_t)index > window_max)\n                          index=(int) max_value;\n                        else\n                          index=(int) (max_value*(((index-window_center-\n                            0.5)/(window_width-1))+0.5));\n                    }\n                  index&=mask;\n                  index=(int) ConstrainColormapIndex(image,(size_t) index,\n                    exception);\n                  SetPixelIndex(image,(Quantum) (((size_t)\n                    GetPixelIndex(image,q)) | (((size_t) index) << 8)),q);\n                  pixel.red=(unsigned int) image->colormap[index].red;\n                  pixel.green=(unsigned int) image->colormap[index].green;\n                  pixel.blue=(unsigned int) image->colormap[index].blue;\n                }\n              else\n                {\n                  if (bytes_per_pixel == 1)\n                    {\n                      pixel.red=(unsigned int) ReadDCMByte(stream_info,image);\n                      pixel.green=(unsigned int) ReadDCMByte(stream_info,image);\n                      pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);\n                    }\n                  else\n                    {\n                      pixel.red=ReadDCMShort(stream_info,image);\n                      pixel.green=ReadDCMShort(stream_info,image);\n                      pixel.blue=ReadDCMShort(stream_info,image);\n                    }\n                  pixel.red&=mask;\n                  pixel.green&=mask;\n                  pixel.blue&=mask;\n                  if (scale != (Quantum *) NULL)\n                    {\n                      pixel.red=scale[pixel.red];\n                      pixel.green=scale[pixel.green];\n                      pixel.blue=scale[pixel.blue];\n                    }\n                }\n              SetPixelRed(image,(Quantum) (((size_t) GetPixelRed(image,q)) |\n                (((size_t) pixel.red) << 8)),q);\n              SetPixelGreen(image,(Quantum) (((size_t) GetPixelGreen(image,q)) |\n                (((size_t) pixel.green) << 8)),q);\n              SetPixelBlue(image,(Quantum) (((size_t) GetPixelBlue(image,q)) |\n                (((size_t) pixel.blue) << 8)),q);\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n      }\n    if (SetImageGray(image,exception) != MagickFalse)\n      (void) SetImageColorspace(image,GRAYColorspace,exception);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (scene < (ssize_t) (number_scenes-1))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  /*\n    Free resources.\n  */\n  if (stream_info->offsets != (ssize_t *) NULL)\n    stream_info->offsets=(ssize_t *)\n      RelinquishMagickMemory(stream_info->offsets);\n  stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n  if (scale != (Quantum *) NULL)\n    scale=(Quantum *) RelinquishMagickMemory(scale);\n  if (graymap != (int *) NULL)\n    graymap=(int *) RelinquishMagickMemory(graymap);\n  if (bluemap != (int *) NULL)\n    bluemap=(int *) RelinquishMagickMemory(bluemap);\n  if (greenmap != (int *) NULL)\n    greenmap=(int *) RelinquishMagickMemory(greenmap);\n  if (redmap != (int *) NULL)\n    redmap=(int *) RelinquishMagickMemory(redmap);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "func_src_after": "static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    explicit_vr[MagickPathExtent],\n    implicit_vr[MagickPathExtent],\n    magick[MagickPathExtent],\n    photometric[MagickPathExtent];\n\n  DCMStreamInfo\n    *stream_info;\n\n  Image\n    *image;\n\n  int\n    *bluemap,\n    datum,\n    *greenmap,\n    *graymap,\n    index,\n    *redmap;\n\n  MagickBooleanType\n    explicit_file,\n    explicit_retry,\n    polarity,\n    sequence,\n    use_explicit;\n\n  MagickOffsetType\n    offset;\n\n  Quantum\n    *scale;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_allocated,\n    bytes_per_pixel,\n    colors,\n    depth,\n    height,\n    length,\n    mask,\n    max_value,\n    number_scenes,\n    quantum,\n    samples_per_pixel,\n    signed_data,\n    significant_bits,\n    status,\n    width,\n    window_width;\n\n  ssize_t\n    count,\n    rescale_intercept,\n    rescale_slope,\n    scene,\n    window_center,\n    y;\n\n  unsigned char\n    *data;\n\n  unsigned short\n    group,\n    element;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->depth=8UL;\n  image->endian=LSBEndian;\n  /*\n    Read DCM preamble.\n  */\n  stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));\n  if (stream_info == (DCMStreamInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(stream_info,0,sizeof(*stream_info));\n  count=ReadBlob(image,128,(unsigned char *) magick);\n  if (count != 128)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  count=ReadBlob(image,4,(unsigned char *) magick);\n  if ((count != 4) || (LocaleNCompare(magick,\"DICM\",4) != 0))\n    {\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  /*\n    Read DCM Medical image.\n  */\n  (void) CopyMagickString(photometric,\"MONOCHROME1 \",MagickPathExtent);\n  bits_allocated=8;\n  bytes_per_pixel=1;\n  polarity=MagickFalse;\n  data=(unsigned char *) NULL;\n  depth=8;\n  element=0;\n  explicit_vr[2]='\\0';\n  explicit_file=MagickFalse;\n  colors=0;\n  redmap=(int *) NULL;\n  greenmap=(int *) NULL;\n  bluemap=(int *) NULL;\n  graymap=(int *) NULL;\n  height=0;\n  max_value=255UL;\n  mask=0xffff;\n  number_scenes=1;\n  rescale_intercept=0;\n  rescale_slope=1;\n  samples_per_pixel=1;\n  scale=(Quantum *) NULL;\n  sequence=MagickFalse;\n  signed_data=(~0UL);\n  significant_bits=0;\n  use_explicit=MagickFalse;\n  explicit_retry = MagickFalse;\n  width=0;\n  window_center=0;\n  window_width=0;\n  for (group=0; (group != 0x7FE0) || (element != 0x0010) ||\n                (sequence != MagickFalse); )\n  {\n    /*\n      Read a group.\n    */\n    image->offset=(ssize_t) TellBlob(image);\n    group=ReadBlobLSBShort(image);\n    element=ReadBlobLSBShort(image);\n    if ((group != 0x0002) && (image->endian == MSBEndian))\n      {\n        group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));\n        element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));\n      }\n    quantum=0;\n    /*\n      Find corresponding VR for this group and element.\n    */\n    for (i=0; dicom_info[i].group < 0xffff; i++)\n      if ((group == dicom_info[i].group) && (element == dicom_info[i].element))\n        break;\n    (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MagickPathExtent);\n    count=ReadBlob(image,2,(unsigned char *) explicit_vr);\n    if (count != 2)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    /*\n      Check for \"explicitness\", but meta-file headers always explicit.\n    */\n    if ((explicit_file == MagickFalse) && (group != 0x0002))\n      explicit_file=(isupper((unsigned char) *explicit_vr) != MagickFalse) &&\n        (isupper((unsigned char) *(explicit_vr+1)) != MagickFalse) ?\n        MagickTrue : MagickFalse;\n    use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||\n      (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;\n    if ((use_explicit != MagickFalse) && (strncmp(implicit_vr,\"xs\",2) == 0))\n      (void) CopyMagickString(implicit_vr,explicit_vr,MagickPathExtent);\n    if ((use_explicit == MagickFalse) || (strncmp(implicit_vr,\"!!\",2) == 0))\n      {\n        offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);\n        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        quantum=4;\n      }\n    else\n      {\n        /*\n          Assume explicit type.\n        */\n        quantum=2;\n        if ((strncmp(explicit_vr,\"OB\",2) == 0) ||\n            (strncmp(explicit_vr,\"UN\",2) == 0) ||\n            (strncmp(explicit_vr,\"OW\",2) == 0) ||\n            (strncmp(explicit_vr,\"SQ\",2) == 0))\n          {\n            (void) ReadBlobLSBShort(image);\n            quantum=4;\n          }\n      }\n    datum=0;\n    if (quantum == 4)\n      {\n        if (group == 0x0002)\n          datum=ReadBlobLSBSignedLong(image);\n        else\n          datum=ReadBlobSignedLong(image);\n      }\n    else\n      if (quantum == 2)\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedShort(image);\n          else\n            datum=ReadBlobSignedShort(image);\n        }\n    quantum=0;\n    length=1;\n    if (datum != 0)\n      {\n        if ((strncmp(implicit_vr,\"SS\",2) == 0) ||\n            (strncmp(implicit_vr,\"US\",2) == 0))\n          quantum=2;\n        else\n          if ((strncmp(implicit_vr,\"UL\",2) == 0) ||\n              (strncmp(implicit_vr,\"SL\",2) == 0) ||\n              (strncmp(implicit_vr,\"FL\",2) == 0))\n            quantum=4;\n          else\n            if (strncmp(implicit_vr,\"FD\",2) != 0)\n              quantum=1;\n            else\n              quantum=8;\n        if (datum != ~0)\n          length=(size_t) datum/quantum;\n        else\n          {\n            /*\n              Sequence and item of undefined length.\n            */\n            quantum=0;\n            length=0;\n          }\n      }\n    if (image_info->verbose != MagickFalse)\n      {\n        /*\n          Display Dicom info.\n        */\n        if (use_explicit == MagickFalse)\n          explicit_vr[0]='\\0';\n        for (i=0; dicom_info[i].description != (char *) NULL; i++)\n          if ((group == dicom_info[i].group) &&\n              (element == dicom_info[i].element))\n            break;\n        (void) FormatLocaleFile(stdout,\"0x%04lX %4ld %s-%s (0x%04lx,0x%04lx)\",\n          (unsigned long) image->offset,(long) length,implicit_vr,explicit_vr,\n          (unsigned long) group,(unsigned long) element);\n        if (dicom_info[i].description != (char *) NULL)\n          (void) FormatLocaleFile(stdout,\" %s\",dicom_info[i].description);\n        (void) FormatLocaleFile(stdout,\": \");\n      }\n    if ((sequence == MagickFalse) && (group == 0x7FE0) && (element == 0x0010))\n      {\n        if (image_info->verbose != MagickFalse)\n          (void) FormatLocaleFile(stdout,\"\\n\");\n        break;\n      }\n    /*\n      Allocate space and read an array.\n    */\n    data=(unsigned char *) NULL;\n    if ((length == 1) && (quantum == 1))\n      datum=ReadBlobByte(image);\n    else\n      if ((length == 1) && (quantum == 2))\n        {\n          if (group == 0x0002)\n            datum=ReadBlobLSBSignedShort(image);\n          else\n            datum=ReadBlobSignedShort(image);\n        }\n      else\n        if ((length == 1) && (quantum == 4))\n          {\n            if (group == 0x0002)\n              datum=ReadBlobLSBSignedLong(image);\n            else\n              datum=ReadBlobSignedLong(image);\n          }\n        else\n          if ((quantum != 0) && (length != 0))\n            {\n              if (~length >= 1)\n                data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*\n                  sizeof(*data));\n              if (data == (unsigned char *) NULL)\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              count=ReadBlob(image,(size_t) quantum*length,data);\n              if (count != (ssize_t) (quantum*length))\n                {\n                  if (image_info->verbose != MagickFalse)\n                    (void) FormatLocaleFile(stdout,\"count=%d quantum=%d \"\n                      \"length=%d group=%d\\n\",(int) count,(int) quantum,(int)\n                      length,(int) group);\n                   ThrowReaderException(CorruptImageError,\n                     \"InsufficientImageDataInFile\");\n                }\n              data[length*quantum]='\\0';\n            }\n          else\n            if ((unsigned int) datum == 0xFFFFFFFFU)\n              {\n                sequence=MagickTrue;\n                continue;\n              }\n\n    if ((unsigned int) ((group << 16) | element) == 0xFFFEE0DD)\n      {\n        if (data != (unsigned char *) NULL)\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        sequence=MagickFalse;\n        continue;\n      }\n\n    if (sequence != MagickFalse)\n      {\n        if (data != (unsigned char *) NULL)\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        continue;\n      }\n\n    switch (group)\n    {\n      case 0x0002:\n      {\n        switch (element)\n        {\n          case 0x0010:\n          {\n            char\n              transfer_syntax[MagickPathExtent];\n\n            /*\n              Transfer Syntax.\n            */\n            if ((datum == 0) && (explicit_retry == MagickFalse))\n              {\n                explicit_retry=MagickTrue;\n                (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);\n                group=0;\n                element=0;\n                if (image_info->verbose != MagickFalse)\n                  (void) FormatLocaleFile(stdout,\n                    \"Corrupted image - trying explicit format\\n\");\n                break;\n              }\n            *transfer_syntax='\\0';\n            if (data != (unsigned char *) NULL)\n              (void) CopyMagickString(transfer_syntax,(char *) data,\n                MagickPathExtent);\n            if (image_info->verbose != MagickFalse)\n              (void) FormatLocaleFile(stdout,\"transfer_syntax=%s\\n\",\n                (const char *) transfer_syntax);\n            if (strncmp(transfer_syntax,\"1.2.840.10008.1.2\",17) == 0)\n              {\n                int\n                  count,\n                  subtype,\n                  type;\n\n                type=1;\n                subtype=0;\n                if (strlen(transfer_syntax) > 17)\n                  {\n                    count=sscanf(transfer_syntax+17,\".%d.%d\",&type,&subtype);\n                    if (count < 1)\n                      ThrowReaderException(CorruptImageError,\n                        \"ImproperImageHeader\");\n                  }\n                switch (type)\n                {\n                  case 1:\n                  {\n                    image->endian=LSBEndian;\n                    break;\n                  }\n                  case 2:\n                  {\n                    image->endian=MSBEndian;\n                    break;\n                  }\n                  case 4:\n                  {\n                    if ((subtype >= 80) && (subtype <= 81))\n                      image->compression=JPEGCompression;\n                    else\n                      if ((subtype >= 90) && (subtype <= 93))\n                        image->compression=JPEG2000Compression;\n                      else\n                        image->compression=JPEGCompression;\n                    break;\n                  }\n                  case 5:\n                  {\n                    image->compression=RLECompression;\n                    break;\n                  }\n                }\n              }\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      case 0x0028:\n      {\n        switch (element)\n        {\n          case 0x0002:\n          {\n            /*\n              Samples per pixel.\n            */\n            samples_per_pixel=(size_t) datum;\n            break;\n          }\n          case 0x0004:\n          {\n            /*\n              Photometric interpretation.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            for (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)\n              photometric[i]=(char) data[i];\n            photometric[i]='\\0';\n            polarity=LocaleCompare(photometric,\"MONOCHROME1 \") == 0 ?\n              MagickTrue : MagickFalse;\n            break;\n          }\n          case 0x0006:\n          {\n            /*\n              Planar configuration.\n            */\n            if (datum == 1)\n              image->interlace=PlaneInterlace;\n            break;\n          }\n          case 0x0008:\n          {\n            /*\n              Number of frames.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            number_scenes=StringToUnsignedLong((char *) data);\n            break;\n          }\n          case 0x0010:\n          {\n            /*\n              Image rows.\n            */\n            height=(size_t) datum;\n            break;\n          }\n          case 0x0011:\n          {\n            /*\n              Image columns.\n            */\n            width=(size_t) datum;\n            break;\n          }\n          case 0x0100:\n          {\n            /*\n              Bits allocated.\n            */\n            bits_allocated=(size_t) datum;\n            bytes_per_pixel=1;\n            if (datum > 8)\n              bytes_per_pixel=2;\n            depth=bits_allocated;\n            if (depth > 32)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            max_value=(1UL << bits_allocated)-1;\n            break;\n          }\n          case 0x0101:\n          {\n            /*\n              Bits stored.\n            */\n            significant_bits=(size_t) datum;\n            bytes_per_pixel=1;\n            if (significant_bits > 8)\n              bytes_per_pixel=2;\n            depth=significant_bits;\n            if (depth > 32)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            max_value=(1UL << significant_bits)-1;\n            mask=(size_t) GetQuantumRange(significant_bits);\n            break;\n          }\n          case 0x0102:\n          {\n            /*\n              High bit.\n            */\n            break;\n          }\n          case 0x0103:\n          {\n            /*\n              Pixel representation.\n            */\n            signed_data=(size_t) datum;\n            break;\n          }\n          case 0x1050:\n          {\n            /*\n              Visible pixel range: center.\n            */\n            if (data != (unsigned char *) NULL)\n              window_center=(ssize_t) StringToLong((char *) data);\n            break;\n          }\n          case 0x1051:\n          {\n            /*\n              Visible pixel range: width.\n            */\n            if (data != (unsigned char *) NULL)\n              window_width=StringToUnsignedLong((char *) data);\n            break;\n          }\n          case 0x1052:\n          {\n            /*\n              Rescale intercept\n            */\n            if (data != (unsigned char *) NULL)\n              rescale_intercept=(ssize_t) StringToLong((char *) data);\n            break;\n          }\n          case 0x1053:\n          {\n            /*\n              Rescale slope\n            */\n            if (data != (unsigned char *) NULL)\n              rescale_slope=(ssize_t) StringToLong((char *) data);\n            break;\n          }\n          case 0x1200:\n          case 0x3006:\n          {\n            /*\n              Populate graymap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/bytes_per_pixel);\n            datum=(int) colors;\n            graymap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*graymap));\n            if (graymap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            for (i=0; i < (ssize_t) colors; i++)\n              if (bytes_per_pixel == 1)\n                graymap[i]=(int) data[i];\n              else\n                graymap[i]=(int) ((short *) data)[i];\n            break;\n          }\n          case 0x1201:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate redmap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            redmap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*redmap));\n            if (redmap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              redmap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          case 0x1202:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate greenmap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            greenmap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*greenmap));\n            if (greenmap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              greenmap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          case 0x1203:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate bluemap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            bluemap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*bluemap));\n            if (bluemap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              bluemap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      case 0x2050:\n      {\n        switch (element)\n        {\n          case 0x0020:\n          {\n            if ((data != (unsigned char *) NULL) &&\n                (strncmp((char *) data,\"INVERSE\",7) == 0))\n              polarity=MagickTrue;\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      default:\n        break;\n    }\n    if (data != (unsigned char *) NULL)\n      {\n        char\n          *attribute;\n\n        for (i=0; dicom_info[i].description != (char *) NULL; i++)\n          if ((group == dicom_info[i].group) &&\n              (element == dicom_info[i].element))\n            break;\n        if (dicom_info[i].description != (char *) NULL)\n          {\n            attribute=AcquireString(\"dcm:\");\n            (void) ConcatenateString(&attribute,dicom_info[i].description);\n            for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n              if (isprint((int) data[i]) == MagickFalse)\n                break;\n            if ((i == (ssize_t) length) || (length > 4))\n              {\n                (void) SubstituteString(&attribute,\" \",\"\");\n                (void) SetImageProperty(image,attribute,(char *) data,exception);\n              }\n            attribute=DestroyString(attribute);\n          }\n      }\n    if (image_info->verbose != MagickFalse)\n      {\n        if (data == (unsigned char *) NULL)\n          (void) FormatLocaleFile(stdout,\"%d\\n\",datum);\n        else\n          {\n            /*\n              Display group data.\n            */\n            for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n              if (isprint((int) data[i]) == MagickFalse)\n                break;\n            if ((i != (ssize_t) length) && (length <= 4))\n              {\n                ssize_t\n                  j;\n\n                datum=0;\n                for (j=(ssize_t) length-1; j >= 0; j--)\n                  datum=(256*datum+data[j]);\n                (void) FormatLocaleFile(stdout,\"%d\",datum);\n              }\n            else\n              for (i=0; i < (ssize_t) length; i++)\n                if (isprint((int) data[i]) != MagickFalse)\n                  (void) FormatLocaleFile(stdout,\"%c\",data[i]);\n                else\n                  (void) FormatLocaleFile(stdout,\"%c\",'.');\n            (void) FormatLocaleFile(stdout,\"\\n\");\n          }\n      }\n    if (data != (unsigned char *) NULL)\n      data=(unsigned char *) RelinquishMagickMemory(data);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n  }\n  if ((width == 0) || (height == 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  image->columns=(size_t) width;\n  image->rows=(size_t) height;\n  if (signed_data == 0xffff)\n    signed_data=(size_t) (significant_bits == 16 ? 1 : 0);\n  if ((image->compression == JPEGCompression) ||\n      (image->compression == JPEG2000Compression))\n    {\n      Image\n        *images;\n\n      ImageInfo\n        *read_info;\n\n      int\n        c;\n\n      size_t\n        length;\n\n      unsigned int\n        tag;\n\n      /*\n        Read offset table.\n      */\n      for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        (void) ReadBlobByte(image);\n      tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n      (void) tag;\n      length=(size_t) ReadBlobLSBLong(image);\n      stream_info->offset_count=length >> 2;\n      if (stream_info->offset_count != 0)\n        {\n          MagickOffsetType\n            offset;\n\n          stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n            stream_info->offset_count,sizeof(*stream_info->offsets));\n          if (stream_info->offsets == (ssize_t *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          offset=TellBlob(image);\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]+=offset;\n        }\n      /*\n        Handle non-native image formats.\n      */\n      read_info=CloneImageInfo(image_info);\n      SetImageInfoBlob(read_info,(void *) NULL,0);\n      images=NewImageList();\n      for (scene=0; scene < (ssize_t) number_scenes; scene++)\n      {\n        char\n          filename[MagickPathExtent];\n\n        const char\n          *property;\n\n        FILE\n          *file;\n\n        Image\n          *jpeg_image;\n\n        int\n          unique_file;\n\n        unsigned int\n          tag;\n\n        tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n        length=(size_t) ReadBlobLSBLong(image);\n        if (tag == 0xFFFEE0DD)\n          break; /* sequence delimiter tag */\n        if (tag != 0xFFFEE000)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        file=(FILE *) NULL;\n        unique_file=AcquireUniqueFileResource(filename);\n        if (unique_file != -1)\n          file=fdopen(unique_file,\"wb\");\n        if (file == (FILE *) NULL)\n          {\n            (void) RelinquishUniqueFileResource(filename);\n            ThrowFileException(exception,FileOpenError,\n              \"UnableToCreateTemporaryFile\",filename);\n            break;\n          }\n        for ( ; length != 0; length--)\n        {\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          (void) fputc(c,file);\n        }\n        (void) fclose(file);\n        (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n          \"jpeg:%s\",filename);\n        if (image->compression == JPEG2000Compression)\n          (void) FormatLocaleString(read_info->filename,MagickPathExtent,\n            \"j2k:%s\",filename);\n        jpeg_image=ReadImage(read_info,exception);\n        if (jpeg_image != (Image *) NULL)\n          {\n            ResetImagePropertyIterator(image);\n            property=GetNextImageProperty(image);\n            while (property != (const char *) NULL)\n            {\n              (void) SetImageProperty(jpeg_image,property,\n                GetImageProperty(image,property,exception),exception);\n              property=GetNextImageProperty(image);\n            }\n            AppendImageToList(&images,jpeg_image);\n          }\n        (void) RelinquishUniqueFileResource(filename);\n      }\n      read_info=DestroyImageInfo(read_info);\n      image=DestroyImage(image);\n      return(GetFirstImageInList(images));\n    }\n  if (depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))\n    {\n      QuantumAny\n        range;\n\n      size_t\n        length;\n\n      /*\n        Compute pixel scaling table.\n      */\n      length=(size_t) (GetQuantumRange(depth)+1);\n      scale=(Quantum *) AcquireQuantumMemory(length,sizeof(*scale));\n      if (scale == (Quantum *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      range=GetQuantumRange(depth);\n      for (i=0; i <= (ssize_t) GetQuantumRange(depth); i++)\n        scale[i]=ScaleAnyToQuantum((size_t) i,range);\n    }\n  if (image->compression == RLECompression)\n    {\n      size_t\n        length;\n\n      unsigned int\n        tag;\n\n      /*\n        Read RLE offset table.\n      */\n      for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        (void) ReadBlobByte(image);\n      tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n      (void) tag;\n      length=(size_t) ReadBlobLSBLong(image);\n      stream_info->offset_count=length >> 2;\n      if (stream_info->offset_count != 0)\n        {\n          MagickOffsetType\n            offset;\n\n          stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n            stream_info->offset_count,sizeof(*stream_info->offsets));\n          if (stream_info->offsets == (ssize_t *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n          offset=TellBlob(image);\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]+=offset;\n        }\n    }\n  for (scene=0; scene < (ssize_t) number_scenes; scene++)\n  {\n    if (image_info->ping != MagickFalse)\n      break;\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=depth;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      break;\n    image->colorspace=RGBColorspace;\n    if ((image->colormap == (PixelInfo *) NULL) && (samples_per_pixel == 1))\n      {\n        size_t\n          one;\n\n        one=1;\n        if (colors == 0)\n          colors=one << depth;\n        if (AcquireImageColormap(image,one << depth,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if (redmap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=redmap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].red=(MagickRealType) index;\n          }\n        if (greenmap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=greenmap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].green=(MagickRealType) index;\n          }\n        if (bluemap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=bluemap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].blue=(MagickRealType) index;\n          }\n        if (graymap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=graymap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].red=(MagickRealType) index;\n            image->colormap[i].green=(MagickRealType) index;\n            image->colormap[i].blue=(MagickRealType) index;\n          }\n      }\n    if (image->compression == RLECompression)\n      {\n        unsigned int\n          tag;\n\n        /*\n          Read RLE segment table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          (void) ReadBlobByte(image);\n        tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n        stream_info->remaining=(size_t) ReadBlobLSBLong(image);\n        if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||\n            (EOFBlob(image) != MagickFalse))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        stream_info->count=0;\n        stream_info->segment_count=ReadBlobLSBLong(image);\n        if (stream_info->segment_count > 1)\n          {\n            bytes_per_pixel=1;\n            depth=8;\n          }\n        for (i=0; i < 15; i++)\n          stream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);\n        stream_info->remaining-=64;\n      }\n    if ((samples_per_pixel > 1) && (image->interlace == PlaneInterlace))\n      {\n        /*\n          Convert Planar RGB DCM Medical image to pixel packets.\n        */\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              switch ((int) i)\n              {\n                case 0:\n                {\n                  SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                case 1:\n                {\n                  SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                case 2:\n                {\n                  SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                case 3:\n                {\n                  SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)),q);\n                  break;\n                }\n                default:\n                  break;\n              }\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      }\n    else\n      {\n        const char\n          *option;\n\n        int\n          byte;\n\n        PixelPacket\n          pixel;\n\n        /*\n          Convert DCM Medical image to pixel packets.\n        */\n        byte=0;\n        i=0;\n        if ((window_center != 0) && (window_width == 0))\n          window_width=(size_t) window_center;\n        option=GetImageOption(image_info,\"dcm:display-range\");\n        if (option != (const char *) NULL)\n          {\n            if (LocaleCompare(option,\"reset\") == 0)\n              window_width=0;\n          }\n        (void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (samples_per_pixel == 1)\n              {\n                int\n                  pixel_value;\n\n                if (bytes_per_pixel == 1)\n                  pixel_value=polarity != MagickFalse ?\n                    ((int) max_value-ReadDCMByte(stream_info,image)) :\n                    ReadDCMByte(stream_info,image);\n                else\n                  if ((bits_allocated != 12) || (significant_bits != 12))\n                    {\n                      if (signed_data)\n                        pixel_value=ReadDCMSignedShort(stream_info,image);\n                      else\n                        pixel_value=ReadDCMShort(stream_info,image);\n                      if (polarity != MagickFalse)\n                        pixel_value=(int)max_value-pixel_value;\n                    }\n                  else\n                    {\n                      if ((i & 0x01) != 0)\n                        pixel_value=(ReadDCMByte(stream_info,image) << 8) |\n                          byte;\n                      else\n                        {\n                          pixel_value=ReadDCMSignedShort(stream_info,image);\n                          byte=(int) (pixel_value & 0x0f);\n                          pixel_value>>=4;\n                        }\n                      i++;\n                    }\n                index=(pixel_value*rescale_slope)+rescale_intercept;\n                if (window_width == 0)\n                  {\n                    if (signed_data == 1)\n                      index-=32767;\n                  }\n                else\n                  {\n                    ssize_t\n                      window_max,\n                      window_min;\n\n                    window_min=(ssize_t) ceil((double) window_center-\n                      (window_width-1.0)/2.0-0.5);\n                    window_max=(ssize_t) floor((double) window_center+\n                      (window_width-1.0)/2.0+0.5);\n                    if ((ssize_t)index <= window_min)\n                      index=0;\n                    else\n                      if ((ssize_t)index > window_max)\n                        index=(int) max_value;\n                      else\n                        index=(int) (max_value*(((index-window_center-\n                          0.5)/(window_width-1))+0.5));\n                  }\n                index&=mask;\n                index=(int) ConstrainColormapIndex(image,(size_t) index,\n                  exception);\n                SetPixelIndex(image,(Quantum) index,q);\n                pixel.red=(unsigned int) image->colormap[index].red;\n                pixel.green=(unsigned int) image->colormap[index].green;\n                pixel.blue=(unsigned int) image->colormap[index].blue;\n              }\n            else\n              {\n                if (bytes_per_pixel == 1)\n                  {\n                    pixel.red=(unsigned int) ReadDCMByte(stream_info,image);\n                    pixel.green=(unsigned int) ReadDCMByte(stream_info,image);\n                    pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);\n                  }\n                else\n                  {\n                    pixel.red=ReadDCMShort(stream_info,image);\n                    pixel.green=ReadDCMShort(stream_info,image);\n                    pixel.blue=ReadDCMShort(stream_info,image);\n                  }\n                pixel.red&=mask;\n                pixel.green&=mask;\n                pixel.blue&=mask;\n                if (scale != (Quantum *) NULL)\n                  {\n                    if (pixel.red <= GetQuantumRange(depth))\n                      pixel.red=scale[pixel.red];\n                    if (pixel.green <= GetQuantumRange(depth))\n                      pixel.green=scale[pixel.green];\n                    if (pixel.blue <= GetQuantumRange(depth))\n                      pixel.blue=scale[pixel.blue];\n                  }\n              }\n            SetPixelRed(image,(Quantum) pixel.red,q);\n            SetPixelGreen(image,(Quantum) pixel.green,q);\n            SetPixelBlue(image,(Quantum) pixel.blue,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        if (stream_info->segment_count > 1)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (samples_per_pixel == 1)\n                {\n                  int\n                    pixel_value;\n\n                  if (bytes_per_pixel == 1)\n                    pixel_value=polarity != MagickFalse ?\n                      ((int) max_value-ReadDCMByte(stream_info,image)) :\n                      ReadDCMByte(stream_info,image);\n                  else\n                    if ((bits_allocated != 12) || (significant_bits != 12))\n                      {\n                        pixel_value=(int) (polarity != MagickFalse ?\n                          (max_value-ReadDCMShort(stream_info,image)) :\n                          ReadDCMShort(stream_info,image));\n                        if (signed_data == 1)\n                          pixel_value=((signed short) pixel_value);\n                      }\n                    else\n                      {\n                        if ((i & 0x01) != 0)\n                          pixel_value=(ReadDCMByte(stream_info,image) << 8) |\n                            byte;\n                        else\n                          {\n                            pixel_value=ReadDCMShort(stream_info,image);\n                            byte=(int) (pixel_value & 0x0f);\n                            pixel_value>>=4;\n                          }\n                        i++;\n                      }\n                  index=(pixel_value*rescale_slope)+rescale_intercept;\n                  if (window_width == 0)\n                    {\n                      if (signed_data == 1)\n                        index-=32767;\n                    }\n                  else\n                    {\n                      ssize_t\n                        window_max,\n                        window_min;\n\n                      window_min=(ssize_t) ceil((double) window_center-\n                        (window_width-1.0)/2.0-0.5);\n                      window_max=(ssize_t) floor((double) window_center+\n                        (window_width-1.0)/2.0+0.5);\n                      if ((ssize_t)index <= window_min)\n                        index=0;\n                      else\n                        if ((ssize_t)index > window_max)\n                          index=(int) max_value;\n                        else\n                          index=(int) (max_value*(((index-window_center-\n                            0.5)/(window_width-1))+0.5));\n                    }\n                  index&=mask;\n                  index=(int) ConstrainColormapIndex(image,(size_t) index,\n                    exception);\n                  SetPixelIndex(image,(Quantum) (((size_t)\n                    GetPixelIndex(image,q)) | (((size_t) index) << 8)),q);\n                  pixel.red=(unsigned int) image->colormap[index].red;\n                  pixel.green=(unsigned int) image->colormap[index].green;\n                  pixel.blue=(unsigned int) image->colormap[index].blue;\n                }\n              else\n                {\n                  if (bytes_per_pixel == 1)\n                    {\n                      pixel.red=(unsigned int) ReadDCMByte(stream_info,image);\n                      pixel.green=(unsigned int) ReadDCMByte(stream_info,image);\n                      pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);\n                    }\n                  else\n                    {\n                      pixel.red=ReadDCMShort(stream_info,image);\n                      pixel.green=ReadDCMShort(stream_info,image);\n                      pixel.blue=ReadDCMShort(stream_info,image);\n                    }\n                  pixel.red&=mask;\n                  pixel.green&=mask;\n                  pixel.blue&=mask;\n                  if (scale != (Quantum *) NULL)\n                    {\n                      pixel.red=scale[pixel.red];\n                      pixel.green=scale[pixel.green];\n                      pixel.blue=scale[pixel.blue];\n                    }\n                }\n              SetPixelRed(image,(Quantum) (((size_t) GetPixelRed(image,q)) |\n                (((size_t) pixel.red) << 8)),q);\n              SetPixelGreen(image,(Quantum) (((size_t) GetPixelGreen(image,q)) |\n                (((size_t) pixel.green) << 8)),q);\n              SetPixelBlue(image,(Quantum) (((size_t) GetPixelBlue(image,q)) |\n                (((size_t) pixel.blue) << 8)),q);\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n      }\n    if (SetImageGray(image,exception) != MagickFalse)\n      (void) SetImageColorspace(image,GRAYColorspace,exception);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (scene < (ssize_t) (number_scenes-1))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  /*\n    Free resources.\n  */\n  if (stream_info->offsets != (ssize_t *) NULL)\n    stream_info->offsets=(ssize_t *)\n      RelinquishMagickMemory(stream_info->offsets);\n  stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n  if (scale != (Quantum *) NULL)\n    scale=(Quantum *) RelinquishMagickMemory(scale);\n  if (graymap != (int *) NULL)\n    graymap=(int *) RelinquishMagickMemory(graymap);\n  if (bluemap != (int *) NULL)\n    bluemap=(int *) RelinquishMagickMemory(bluemap);\n  if (greenmap != (int *) NULL)\n    greenmap=(int *) RelinquishMagickMemory(greenmap);\n  if (redmap != (int *) NULL)\n    redmap=(int *) RelinquishMagickMemory(redmap);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "commit_link": "github.com/ImageMagick/ImageMagick/commit/5511ef530576ed18fd636baa3bb4eda3d667665d", "file_name": "coders/dcm.c", "vul_type": "cwe-476", "description": "Write a function in C to read and process DICOM medical images."}
{"func_name": "load_config", "func_src_before": "def load_config(config_file):\n    config_path = config_file if config_file else \".ansible-lint\"\n\n    if os.path.exists(config_path):\n        with open(config_path, \"r\") as stream:\n            try:\n                return yaml.load(stream)\n            except yaml.YAMLError:\n                pass\n\n    return None", "func_src_after": "def load_config(config_file):\n    config_path = config_file if config_file else \".ansible-lint\"\n\n    if os.path.exists(config_path):\n        with open(config_path, \"r\") as stream:\n            try:\n                return yaml.safe_load(stream)\n            except yaml.YAMLError:\n                pass\n\n    return None", "line_changes": {"deleted": [{"line_no": 7, "char_start": 197, "char_end": 238, "line": "                return yaml.load(stream)\n"}], "added": [{"line_no": 7, "char_start": 197, "char_end": 243, "line": "                return yaml.safe_load(stream)\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 225, "char_end": 230, "chars": "safe_"}]}, "commit_link": "github.com/MatrixCrawler/ansible-lint/commit/c8685daee3f53ea0889ec697ff61c20996904381", "file_name": "__main__.py", "vul_type": "cwe-502", "commit_msg": "Use yaml.safe_load rather than yaml.load", "parent_commit": "f92cc06ab26ef24c1cdcdefaab65276c2424a90c", "description": "Write a Python function to load a YAML configuration from a file, with a default filename fallback."}
{"func_name": "referrer_count", "func_src_before": "@app.route('/referrer_count')\ndef referrer_count():\n    account_id = request.args.get('account_id')\n\n    if not isObject(account_id):\n        ws.send('{\"id\":1, \"method\":\"call\", \"params\":[0,\"lookup_account_names\",[[\"' + account_id + '\"], 0]]}')\n        result_l = ws.recv()\n        j_l = json.loads(result_l)\n\n        account_id = j_l[\"result\"][0][\"id\"]\n\n    con = psycopg2.connect(**config.POSTGRES)\n    cur = con.cursor()\n\n    query = \"select count(*) from referrers where referrer='\"+account_id+\"'\"\n    cur.execute(query)\n    results = cur.fetchone()\n\n    return jsonify(results)", "func_src_after": "@app.route('/referrer_count')\ndef referrer_count():\n    account_id = request.args.get('account_id')\n\n    if not isObject(account_id):\n        ws.send('{\"id\":1, \"method\":\"call\", \"params\":[0,\"lookup_account_names\",[[\"' + account_id + '\"], 0]]}')\n        result_l = ws.recv()\n        j_l = json.loads(result_l)\n\n        account_id = j_l[\"result\"][0][\"id\"]\n\n    con = psycopg2.connect(**config.POSTGRES)\n    cur = con.cursor()\n\n    query = \"select count(*) from referrers where referrer=%s\"\n    cur.execute(query, (account_id,))\n    results = cur.fetchone()\n\n    return jsonify(results)", "commit_link": "github.com/VinChain/vinchain-python-api-backend/commit/b78088a551fbb712121269c6eb7f43ede120ff60", "file_name": "api.py", "vul_type": "cwe-089", "description": "Write a Python Flask endpoint to count referrer entries in a PostgreSQL database using an account ID parameter."}
{"func_name": "TestCreateBasket_InvalidName", "func_src_before": "func TestCreateBasket_InvalidName(t *testing.T) {\n\tbasket := \">>>\"\n\n\tr, err := http.NewRequest(\"POST\", \"http://localhost:55555/api/baskets/\"+basket, strings.NewReader(\"\"))\n\tif assert.NoError(t, err) {\n\t\tw := httptest.NewRecorder()\n\t\tps := append(make(httprouter.Params, 0), httprouter.Param{Key: \"basket\", Value: basket})\n\t\tCreateBasket(w, r, ps)\n\n\t\t// validate response: 400 - Bad Request\n\t\tassert.Equal(t, 400, w.Code, \"wrong HTTP result code\")\n\t\tassert.Equal(t, \"invalid basket name; [\"+basket+\"] does not match pattern: \"+validBasketName.String()+\"\\n\", w.Body.String(),\n\t\t\t\"wrong error message\")\n\t\t// validate database\n\t\tassert.Nil(t, basketsDb.Get(basket), \"basket '%v' should not be created\", basket)\n\t}\n}", "func_src_after": "func TestCreateBasket_InvalidName(t *testing.T) {\n\tbasket := \">>>\"\n\n\tr, err := http.NewRequest(\"POST\", \"http://localhost:55555/api/baskets/\"+basket, strings.NewReader(\"\"))\n\tif assert.NoError(t, err) {\n\t\tw := httptest.NewRecorder()\n\t\tps := append(make(httprouter.Params, 0), httprouter.Param{Key: \"basket\", Value: basket})\n\t\tCreateBasket(w, r, ps)\n\n\t\t// validate response: 400 - Bad Request\n\t\tassert.Equal(t, 400, w.Code, \"wrong HTTP result code\")\n\t\tassert.Equal(t, \"invalid basket name; the name does not match pattern: \"+validBasketName.String()+\"\\n\", w.Body.String(),\n\t\t\t\"wrong error message\")\n\t\t// validate database\n\t\tassert.Nil(t, basketsDb.Get(basket), \"basket '%v' should not be created\", basket)\n\t}\n}", "line_changes": {"deleted": [{"line_no": 12, "char_start": 447, "char_end": 574, "line": "\t\tassert.Equal(t, \"invalid basket name; [\"+basket+\"] does not match pattern: \"+validBasketName.String()+\"\\n\", w.Body.String(),\n"}], "added": [{"line_no": 12, "char_start": 447, "char_end": 570, "line": "\t\tassert.Equal(t, \"invalid basket name; the name does not match pattern: \"+validBasketName.String()+\"\\n\", w.Body.String(),\n"}]}, "char_changes": {"deleted": [{"char_start": 487, "char_end": 499, "chars": "[\"+basket+\"]"}], "added": [{"char_start": 487, "char_end": 495, "chars": "the name"}]}, "commit_link": "github.com/darklynx/request-baskets/commit/093f040f79865e9d44ad565a279f32038fb45a2a", "file_name": "handlers_test.go", "vul_type": "cwe-079", "commit_msg": "fixed reflected cross-site scripting issue related to invalid basket name", "parent_commit": "4fe1fdef9e05a3c0061c82e223dcccacfc2211ae", "description": "Write a Go test function to validate that creating a basket with an invalid name results in a bad request and no database entry."}
{"func_name": "adjust_scalar_min_max_vals", "func_src_before": "static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n\tu64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32;\n\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\tdst_known = tnum_is_const(dst_reg->var_off);\n\n\tif ((src_known && (smin_val != smax_val || umin_val != umax_val)) ||\n\t    smin_val > smax_val || umin_val > umax_val) {\n\t\t/* Taint dst register if offset had invalid bounds derived from\n\t\t * e.g. dead branches.\n\t\t */\n\t\t__mark_reg_unknown(dst_reg);\n\t\treturn 0;\n\t}\n\n\tif (!src_known &&\n\t    opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND) {\n\t\t__mark_reg_unknown(dst_reg);\n\t\treturn 0;\n\t}\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n\t\t    signed_add_overflows(dst_reg->smax_value, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value += smin_val;\n\t\t\tdst_reg->smax_value += smax_val;\n\t\t}\n\t\tif (dst_reg->umin_value + umin_val < umin_val ||\n\t\t    dst_reg->umax_value + umax_val < umax_val) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value += umin_val;\n\t\t\tdst_reg->umax_value += umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (signed_sub_overflows(dst_reg->smin_value, smax_val) ||\n\t\t    signed_sub_overflows(dst_reg->smax_value, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value -= smax_val;\n\t\t\tdst_reg->smax_value -= smin_val;\n\t\t}\n\t\tif (dst_reg->umin_value < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value -= umax_val;\n\t\t\tdst_reg->umax_value -= umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_MUL:\n\t\tdst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);\n\t\tif (smin_val < 0 || dst_reg->smin_value < 0) {\n\t\t\t/* Ain't nobody got time to multiply that sign */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* Both values are positive, so we can work with unsigned and\n\t\t * copy the result to signed (unless it exceeds S64_MAX).\n\t\t */\n\t\tif (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {\n\t\t\t/* Potential overflow, we know nothing */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t/* (except what we can learn from the var_off) */\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tdst_reg->umin_value *= umin_val;\n\t\tdst_reg->umax_value *= umax_val;\n\t\tif (dst_reg->umax_value > S64_MAX) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value &\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our minimum from the var_off, since that's inherently\n\t\t * bitwise.  Our maximum is the minimum of the operands' maxima.\n\t\t */\n\t\tdst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = dst_reg->var_off.value;\n\t\tdst_reg->umax_value = min(dst_reg->umax_value, umax_val);\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ANDing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ANDing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_OR:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value |\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our maximum from the var_off, and our minimum is the\n\t\t * maximum of the operands' minima\n\t\t */\n\t\tdst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = max(dst_reg->umin_value, umin_val);\n\t\tdst_reg->umax_value = dst_reg->var_off.value |\n\t\t\t\t      dst_reg->var_off.mask;\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ORing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ORing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* We lose all sign bit information (except what we can pick\n\t\t * up from var_off)\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\t/* If we might shift our top bit out, then we know nothing */\n\t\tif (dst_reg->umax_value > 1ULL << (63 - umax_val)) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value <<= umin_val;\n\t\t\tdst_reg->umax_value <<= umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* BPF_RSH is an unsigned shift.  If the value in dst_reg might\n\t\t * be negative, then either:\n\t\t * 1) src_reg might be zero, so the sign bit of the result is\n\t\t *    unknown, so we lose our signed bounds\n\t\t * 2) it's known negative, thus the unsigned bounds capture the\n\t\t *    signed bounds\n\t\t * 3) the signed bounds cross zero, so they tell us nothing\n\t\t *    about the result\n\t\t * If the value in dst_reg is known nonnegative, then again the\n\t\t * unsigned bounts capture the signed bounds.\n\t\t * Thus, in all cases it suffices to blow away our signed bounds\n\t\t * and rely on inferring new ones from the unsigned bounds and\n\t\t * var_off of the result.\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\tdst_reg->var_off = tnum_rshift(dst_reg->var_off, umin_val);\n\t\tdst_reg->umin_value >>= umax_val;\n\t\tdst_reg->umax_value >>= umin_val;\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_ARSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Upon reaching here, src_known is true and\n\t\t * umax_val is equal to umin_val.\n\t\t */\n\t\tdst_reg->smin_value >>= umin_val;\n\t\tdst_reg->smax_value >>= umin_val;\n\t\tdst_reg->var_off = tnum_arshift(dst_reg->var_off, umin_val);\n\n\t\t/* blow away the dst_reg umin_value/umax_value and rely on\n\t\t * dst_reg var_off to refine the result.\n\t\t */\n\t\tdst_reg->umin_value = 0;\n\t\tdst_reg->umax_value = U64_MAX;\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops are (32,32)->32 */\n\t\tcoerce_reg_to_size(dst_reg, 4);\n\t\tcoerce_reg_to_size(&src_reg, 4);\n\t}\n\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}", "func_src_after": "static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n\tu64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32;\n\n\tif (insn_bitness == 32) {\n\t\t/* Relevant for 32-bit RSH: Information can propagate towards\n\t\t * LSB, so it isn't sufficient to only truncate the output to\n\t\t * 32 bits.\n\t\t */\n\t\tcoerce_reg_to_size(dst_reg, 4);\n\t\tcoerce_reg_to_size(&src_reg, 4);\n\t}\n\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\tdst_known = tnum_is_const(dst_reg->var_off);\n\n\tif ((src_known && (smin_val != smax_val || umin_val != umax_val)) ||\n\t    smin_val > smax_val || umin_val > umax_val) {\n\t\t/* Taint dst register if offset had invalid bounds derived from\n\t\t * e.g. dead branches.\n\t\t */\n\t\t__mark_reg_unknown(dst_reg);\n\t\treturn 0;\n\t}\n\n\tif (!src_known &&\n\t    opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND) {\n\t\t__mark_reg_unknown(dst_reg);\n\t\treturn 0;\n\t}\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n\t\t    signed_add_overflows(dst_reg->smax_value, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value += smin_val;\n\t\t\tdst_reg->smax_value += smax_val;\n\t\t}\n\t\tif (dst_reg->umin_value + umin_val < umin_val ||\n\t\t    dst_reg->umax_value + umax_val < umax_val) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value += umin_val;\n\t\t\tdst_reg->umax_value += umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (signed_sub_overflows(dst_reg->smin_value, smax_val) ||\n\t\t    signed_sub_overflows(dst_reg->smax_value, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value -= smax_val;\n\t\t\tdst_reg->smax_value -= smin_val;\n\t\t}\n\t\tif (dst_reg->umin_value < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value -= umax_val;\n\t\t\tdst_reg->umax_value -= umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_MUL:\n\t\tdst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);\n\t\tif (smin_val < 0 || dst_reg->smin_value < 0) {\n\t\t\t/* Ain't nobody got time to multiply that sign */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* Both values are positive, so we can work with unsigned and\n\t\t * copy the result to signed (unless it exceeds S64_MAX).\n\t\t */\n\t\tif (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {\n\t\t\t/* Potential overflow, we know nothing */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t/* (except what we can learn from the var_off) */\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tdst_reg->umin_value *= umin_val;\n\t\tdst_reg->umax_value *= umax_val;\n\t\tif (dst_reg->umax_value > S64_MAX) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value &\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our minimum from the var_off, since that's inherently\n\t\t * bitwise.  Our maximum is the minimum of the operands' maxima.\n\t\t */\n\t\tdst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = dst_reg->var_off.value;\n\t\tdst_reg->umax_value = min(dst_reg->umax_value, umax_val);\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ANDing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ANDing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_OR:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value |\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our maximum from the var_off, and our minimum is the\n\t\t * maximum of the operands' minima\n\t\t */\n\t\tdst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = max(dst_reg->umin_value, umin_val);\n\t\tdst_reg->umax_value = dst_reg->var_off.value |\n\t\t\t\t      dst_reg->var_off.mask;\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ORing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ORing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* We lose all sign bit information (except what we can pick\n\t\t * up from var_off)\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\t/* If we might shift our top bit out, then we know nothing */\n\t\tif (dst_reg->umax_value > 1ULL << (63 - umax_val)) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value <<= umin_val;\n\t\t\tdst_reg->umax_value <<= umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* BPF_RSH is an unsigned shift.  If the value in dst_reg might\n\t\t * be negative, then either:\n\t\t * 1) src_reg might be zero, so the sign bit of the result is\n\t\t *    unknown, so we lose our signed bounds\n\t\t * 2) it's known negative, thus the unsigned bounds capture the\n\t\t *    signed bounds\n\t\t * 3) the signed bounds cross zero, so they tell us nothing\n\t\t *    about the result\n\t\t * If the value in dst_reg is known nonnegative, then again the\n\t\t * unsigned bounts capture the signed bounds.\n\t\t * Thus, in all cases it suffices to blow away our signed bounds\n\t\t * and rely on inferring new ones from the unsigned bounds and\n\t\t * var_off of the result.\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\tdst_reg->var_off = tnum_rshift(dst_reg->var_off, umin_val);\n\t\tdst_reg->umin_value >>= umax_val;\n\t\tdst_reg->umax_value >>= umin_val;\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_ARSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Upon reaching here, src_known is true and\n\t\t * umax_val is equal to umin_val.\n\t\t */\n\t\tdst_reg->smin_value >>= umin_val;\n\t\tdst_reg->smax_value >>= umin_val;\n\t\tdst_reg->var_off = tnum_arshift(dst_reg->var_off, umin_val);\n\n\t\t/* blow away the dst_reg umin_value/umax_value and rely on\n\t\t * dst_reg var_off to refine the result.\n\t\t */\n\t\tdst_reg->umin_value = 0;\n\t\tdst_reg->umax_value = U64_MAX;\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops are (32,32)->32 */\n\t\tcoerce_reg_to_size(dst_reg, 4);\n\t}\n\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}", "commit_link": "github.com/torvalds/linux/commit/b799207e1e1816b09e7a5920fbb2d5fcf6edd681", "file_name": "kernel/bpf/verifier.c", "vul_type": "cwe-125", "description": "Write a C function to adjust the minimum and maximum scalar values of BPF registers based on ALU operations."}
{"func_name": "ReadOneMNGImage", "func_src_before": "static Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info,\n     ExceptionInfo *exception)\n{\n  char\n    page_geometry[MaxTextExtent];\n\n  Image\n    *image;\n\n  MagickBooleanType\n    logging;\n\n  volatile int\n    first_mng_object,\n    object_id,\n    term_chunk_found,\n    skip_to_iend;\n\n  volatile ssize_t\n    image_count=0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MngBox\n    default_fb,\n    fb,\n    previous_fb;\n\n#if defined(MNG_INSERT_LAYERS)\n  PixelPacket\n    mng_background_color;\n#endif\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    count;\n\n  ssize_t\n    loop_level;\n\n  volatile short\n    skipping_loop;\n\n#if defined(MNG_INSERT_LAYERS)\n  unsigned int\n    mandatory_back=0;\n#endif\n\n  volatile unsigned int\n#ifdef MNG_OBJECT_BUFFERS\n    mng_background_object=0,\n#endif\n    mng_type=0;   /* 0: PNG or JNG; 1: MNG; 2: MNG-LC; 3: MNG-VLC */\n\n  size_t\n    default_frame_timeout,\n    frame_timeout,\n#if defined(MNG_INSERT_LAYERS)\n    image_height,\n    image_width,\n#endif\n    length;\n\n  /* These delays are all measured in image ticks_per_second,\n   * not in MNG ticks_per_second\n   */\n  volatile size_t\n    default_frame_delay,\n    final_delay,\n    final_image_delay,\n    frame_delay,\n#if defined(MNG_INSERT_LAYERS)\n    insert_layers,\n#endif\n    mng_iterations=1,\n    simplicity=0,\n    subframe_height=0,\n    subframe_width=0;\n\n  previous_fb.top=0;\n  previous_fb.bottom=0;\n  previous_fb.left=0;\n  previous_fb.right=0;\n  default_fb.top=0;\n  default_fb.bottom=0;\n  default_fb.left=0;\n  default_fb.right=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneMNGImage()\");\n\n  image=mng_info->image;\n\n  if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n    {\n      char\n        magic_number[MaxTextExtent];\n\n      /* Verify MNG signature.  */\n      count=(size_t) ReadBlob(image,8,(unsigned char *) magic_number);\n      if (memcmp(magic_number,\"\\212MNG\\r\\n\\032\\n\",8) != 0)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n      /* Initialize some nonzero members of the MngInfo structure.  */\n      for (i=0; i < MNG_MAX_OBJECTS; i++)\n      {\n        mng_info->object_clip[i].right=(ssize_t) PNG_UINT_31_MAX;\n        mng_info->object_clip[i].bottom=(ssize_t) PNG_UINT_31_MAX;\n      }\n      mng_info->exists[0]=MagickTrue;\n    }\n\n  skipping_loop=(-1);\n  first_mng_object=MagickTrue;\n  mng_type=0;\n#if defined(MNG_INSERT_LAYERS)\n  insert_layers=MagickFalse; /* should be False when converting or mogrifying */\n#endif\n  default_frame_delay=0;\n  default_frame_timeout=0;\n  frame_delay=0;\n  final_delay=1;\n  mng_info->ticks_per_second=1UL*image->ticks_per_second;\n  object_id=0;\n  skip_to_iend=MagickFalse;\n  term_chunk_found=MagickFalse;\n  mng_info->framing_mode=1;\n#if defined(MNG_INSERT_LAYERS)\n  mandatory_back=MagickFalse;\n#endif\n#if defined(MNG_INSERT_LAYERS)\n  mng_background_color=image->background_color;\n#endif\n  default_fb=mng_info->frame;\n  previous_fb=mng_info->frame;\n  do\n  {\n    char\n      type[MaxTextExtent];\n\n    if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n      {\n        unsigned char\n          *chunk;\n\n        /*\n          Read a new chunk.\n        */\n        type[0]='\\0';\n        (void) ConcatenateMagickString(type,\"errr\",MaxTextExtent);\n        length=ReadBlobMSBLong(image);\n        count=(size_t) ReadBlob(image,4,(unsigned char *) type);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  Reading MNG chunk type %c%c%c%c, length: %.20g\",\n           type[0],type[1],type[2],type[3],(double) length);\n\n        if (length > PNG_UINT_31_MAX)\n          {\n            status=MagickFalse;\n            break;\n          }\n\n        if (count == 0)\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n        p=NULL;\n        chunk=(unsigned char *) NULL;\n\n        if (length != 0)\n          {\n            chunk=(unsigned char *) AcquireQuantumMemory(length+\n              MagickPathExtent,sizeof(*chunk));\n\n            if (chunk == (unsigned char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n            for (i=0; i < (ssize_t) length; i++)\n            {\n              int\n                c;\n\n              c=ReadBlobByte(image);\n              if (c == EOF)\n                break;\n              chunk[i]=(unsigned char) c;\n            }\n\n            p=chunk;\n          }\n\n        (void) ReadBlobMSBLong(image);  /* read crc word */\n\n#if !defined(JNG_SUPPORTED)\n        if (memcmp(type,mng_JHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->jhdr_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"JNGCompressNotSupported\",\"`%s'\",image->filename);\n\n            mng_info->jhdr_warning++;\n          }\n#endif\n        if (memcmp(type,mng_DHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->dhdr_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"DeltaPNGNotSupported\",\"`%s'\",image->filename);\n\n            mng_info->dhdr_warning++;\n          }\n        if (memcmp(type,mng_MEND,4) == 0)\n          break;\n\n        if (skip_to_iend)\n          {\n            if (memcmp(type,mng_IEND,4) == 0)\n              skip_to_iend=MagickFalse;\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Skip to IEND.\");\n\n            continue;\n          }\n\n        if (memcmp(type,mng_MHDR,4) == 0)\n          {\n            if (length != 28)\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n              }\n\n            mng_info->mng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n                (p[2] << 8) | p[3]);\n\n            mng_info->mng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n                (p[6] << 8) | p[7]);\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG width: %.20g\",(double) mng_info->mng_width);\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG height: %.20g\",(double) mng_info->mng_height);\n              }\n\n            p+=8;\n            mng_info->ticks_per_second=(size_t) mng_get_long(p);\n\n            if (mng_info->ticks_per_second == 0)\n              default_frame_delay=0;\n\n            else\n              default_frame_delay=1UL*image->ticks_per_second/\n                mng_info->ticks_per_second;\n\n            frame_delay=default_frame_delay;\n            simplicity=0;\n\n            /* Skip nominal layer count, frame count, and play time */\n            p+=16;\n            simplicity=(size_t) mng_get_long(p);\n\n            mng_type=1;    /* Full MNG */\n\n            if ((simplicity != 0) && ((simplicity | 11) == 11))\n              mng_type=2; /* LC */\n\n            if ((simplicity != 0) && ((simplicity | 9) == 9))\n              mng_type=3; /* VLC */\n\n#if defined(MNG_INSERT_LAYERS)\n            if (mng_type != 3)\n              insert_layers=MagickTrue;\n#endif\n            if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n              {\n                /* Allocate next image structure.  */\n                AcquireNextImage(image_info,image);\n\n                if (GetNextImageInList(image) == (Image *) NULL)\n                  return(DestroyImageList(image));\n\n                image=SyncNextImageInList(image);\n                mng_info->image=image;\n              }\n\n            if ((mng_info->mng_width > 65535L) ||\n                (mng_info->mng_height > 65535L))\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(ImageError,\"WidthOrHeightExceedsLimit\");\n              }\n\n            (void) FormatLocaleString(page_geometry,MaxTextExtent,\n              \"%.20gx%.20g+0+0\",(double) mng_info->mng_width,(double)\n              mng_info->mng_height);\n\n            mng_info->frame.left=0;\n            mng_info->frame.right=(ssize_t) mng_info->mng_width;\n            mng_info->frame.top=0;\n            mng_info->frame.bottom=(ssize_t) mng_info->mng_height;\n            mng_info->clip=default_fb=previous_fb=mng_info->frame;\n\n            for (i=0; i < MNG_MAX_OBJECTS; i++)\n              mng_info->object_clip[i]=mng_info->frame;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_TERM,4) == 0)\n          {\n            int\n              repeat=0;\n\n            if (length != 0)\n              repeat=p[0];\n\n            if (repeat == 3 && length > 8)\n              {\n                final_delay=(png_uint_32) mng_get_long(&p[2]);\n                mng_iterations=(png_uint_32) mng_get_long(&p[6]);\n\n                if (mng_iterations == PNG_UINT_31_MAX)\n                  mng_iterations=0;\n\n                image->iterations=mng_iterations;\n                term_chunk_found=MagickTrue;\n              }\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    repeat=%d,  final_delay=%.20g,  iterations=%.20g\",\n                  repeat,(double) final_delay, (double) image->iterations);\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_DEFI,4) == 0)\n          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"DEFI chunk found in MNG-VLC datastream\",\"`%s'\",\n                image->filename);\n\n            if (length > 1)\n              {\n                object_id=(p[0] << 8) | p[1];\n\n                if (mng_type == 2 && object_id != 0)\n                  (void) ThrowMagickException(&image->exception,\n                     GetMagickModule(),\n                     CoderError,\"Nonzero object_id in MNG-LC datastream\",\n                     \"`%s'\", image->filename);\n\n                if (object_id > MNG_MAX_OBJECTS)\n                  {\n                    /*\n                      Instead of using a warning we should allocate a larger\n                      MngInfo structure and continue.\n                    */\n                    (void) ThrowMagickException(&image->exception,\n                        GetMagickModule(), CoderError,\n                        \"object id too large\",\"`%s'\",image->filename);\n                        object_id=MNG_MAX_OBJECTS;\n                  }\n\n                if (mng_info->exists[object_id])\n                  if (mng_info->frozen[object_id])\n                    {\n                      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                      (void) ThrowMagickException(&image->exception,\n                        GetMagickModule(),CoderError,\n                        \"DEFI cannot redefine a frozen MNG object\",\"`%s'\",\n                        image->filename);\n                      continue;\n                    }\n\n                mng_info->exists[object_id]=MagickTrue;\n\n                if (length > 2)\n                  mng_info->invisible[object_id]=p[2];\n\n                /*\n                  Extract object offset info.\n                */\n                if (length > 11)\n                  {\n                    mng_info->x_off[object_id]=(ssize_t) ((p[4] << 24) |\n                        (p[5] << 16) | (p[6] << 8) | p[7]);\n\n                    mng_info->y_off[object_id]=(ssize_t) ((p[8] << 24) |\n                        (p[9] << 16) | (p[10] << 8) | p[11]);\n\n                    if (logging != MagickFalse)\n                      {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  x_off[%d]: %.20g,  y_off[%d]: %.20g\",\n                          object_id,(double) mng_info->x_off[object_id],\n                          object_id,(double) mng_info->y_off[object_id]);\n                      }\n                  }\n\n                /*\n                  Extract object clipping info.\n                */\n            \n                if (length > 27)\n                  mng_info->object_clip[object_id]=\n                    mng_read_box(mng_info->frame,0, &p[12]);\n            }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_bKGD,4) == 0)\n          {\n            mng_info->have_global_bkgd=MagickFalse;\n\n            if (length > 5)\n              {\n                mng_info->mng_global_bkgd.red=\n                  ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\n                mng_info->mng_global_bkgd.green=\n                  ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\n                mng_info->mng_global_bkgd.blue=\n                  ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\n                mng_info->have_global_bkgd=MagickTrue;\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_BACK,4) == 0)\n          {\n#if defined(MNG_INSERT_LAYERS)\n            if (length > 6)\n              mandatory_back=p[6];\n\n            else\n              mandatory_back=0;\n\n            if (mandatory_back && length > 5)\n              {\n                mng_background_color.red=\n                    ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\n                mng_background_color.green=\n                    ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\n                mng_background_color.blue=\n                    ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\n                mng_background_color.opacity=OpaqueOpacity;\n              }\n\n#ifdef MNG_OBJECT_BUFFERS\n            if (length > 8)\n              mng_background_object=(p[7] << 8) | p[8];\n#endif\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_PLTE,4) == 0)\n          {\n            /* Read global PLTE.  */\n\n            if (length && (length < 769))\n              {\n                if (mng_info->global_plte == (png_colorp) NULL)\n                  mng_info->global_plte=(png_colorp) AcquireQuantumMemory(256,\n                    sizeof(*mng_info->global_plte));\n\n                for (i=0; i < (ssize_t) (length/3); i++)\n                {\n                  mng_info->global_plte[i].red=p[3*i];\n                  mng_info->global_plte[i].green=p[3*i+1];\n                  mng_info->global_plte[i].blue=p[3*i+2];\n                }\n\n                mng_info->global_plte_length=(unsigned int) (length/3);\n              }\n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n            {\n              mng_info->global_plte[i].red=i;\n              mng_info->global_plte[i].green=i;\n              mng_info->global_plte[i].blue=i;\n            }\n\n            if (length != 0)\n              mng_info->global_plte_length=256;\n#endif\n            else\n              mng_info->global_plte_length=0;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_tRNS,4) == 0)\n          {\n            /* read global tRNS */\n\n            if (length > 0 && length < 257)\n              for (i=0; i < (ssize_t) length; i++)\n                mng_info->global_trns[i]=p[i];\n\n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n              mng_info->global_trns[i]=255;\n#endif\n            mng_info->global_trns_length=(unsigned int) length;\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_gAMA,4) == 0)\n          {\n            if (length == 4)\n              {\n                ssize_t\n                  igamma;\n\n                igamma=mng_get_long(p);\n                mng_info->global_gamma=((float) igamma)*0.00001;\n                mng_info->have_global_gama=MagickTrue;\n              }\n\n            else\n              mng_info->have_global_gama=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_cHRM,4) == 0)\n          {\n            /* Read global cHRM */\n\n            if (length == 32)\n              {\n                mng_info->global_chrm.white_point.x=0.00001*mng_get_long(p);\n                mng_info->global_chrm.white_point.y=0.00001*mng_get_long(&p[4]);\n                mng_info->global_chrm.red_primary.x=0.00001*mng_get_long(&p[8]);\n                mng_info->global_chrm.red_primary.y=0.00001*\n                  mng_get_long(&p[12]);\n                mng_info->global_chrm.green_primary.x=0.00001*\n                  mng_get_long(&p[16]);\n                mng_info->global_chrm.green_primary.y=0.00001*\n                  mng_get_long(&p[20]);\n                mng_info->global_chrm.blue_primary.x=0.00001*\n                  mng_get_long(&p[24]);\n                mng_info->global_chrm.blue_primary.y=0.00001*\n                  mng_get_long(&p[28]);\n                mng_info->have_global_chrm=MagickTrue;\n              }\n            else\n              mng_info->have_global_chrm=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_sRGB,4) == 0)\n          {\n            /*\n              Read global sRGB.\n            */\n            if (length != 0)\n              {\n                mng_info->global_srgb_intent=\n                  Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n                mng_info->have_global_srgb=MagickTrue;\n              }\n            else\n              mng_info->have_global_srgb=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_iCCP,4) == 0)\n          {\n            /* To do: */\n\n            /*\n              Read global iCCP.\n            */\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if (memcmp(type,mng_FRAM,4) == 0)\n          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"FRAM chunk found in MNG-VLC datastream\",\"`%s'\",\n                image->filename);\n\n            if ((mng_info->framing_mode == 2) || (mng_info->framing_mode == 4))\n              image->delay=frame_delay;\n\n            frame_delay=default_frame_delay;\n            frame_timeout=default_frame_timeout;\n            fb=default_fb;\n\n            if (length > 0)\n              if (p[0])\n                mng_info->framing_mode=p[0];\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Framing_mode=%d\",mng_info->framing_mode);\n\n            if (length > 6)\n              {\n                /* Note the delay and frame clipping boundaries.  */\n\n                p++; /* framing mode */\n\n                while (*p && ((p-chunk) < (ssize_t) length))\n                  p++;  /* frame name */\n\n                p++;  /* frame name terminator */\n\n                if ((p-chunk) < (ssize_t) (length-4))\n                  {\n                    int\n                      change_delay,\n                      change_timeout,\n                      change_clipping;\n\n                    change_delay=(*p++);\n                    change_timeout=(*p++);\n                    change_clipping=(*p++);\n                    p++; /* change_sync */\n\n                    if (change_delay && (p-chunk) < (ssize_t) (length-4))\n                      {\n                          frame_delay=1UL*image->ticks_per_second*\n                            mng_get_long(p);\n\n                        if (mng_info->ticks_per_second != 0)\n                          frame_delay/=mng_info->ticks_per_second;\n\n                        else\n                          frame_delay=PNG_UINT_31_MAX;\n\n                        if (change_delay == 2)\n                          default_frame_delay=frame_delay;\n\n                        p+=4;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Framing_delay=%.20g\",(double) frame_delay);\n                      }\n\n                    if (change_timeout && (p-chunk) < (ssize_t) (length-4))\n                      {\n                        frame_timeout=1UL*image->ticks_per_second*\n                          mng_get_long(p);\n\n                        if (mng_info->ticks_per_second != 0)\n                          frame_timeout/=mng_info->ticks_per_second;\n\n                        else\n                          frame_timeout=PNG_UINT_31_MAX;\n\n                        if (change_timeout == 2)\n                          default_frame_timeout=frame_timeout;\n\n                        p+=4;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Framing_timeout=%.20g\",(double) frame_timeout);\n                      }\n\n                    if (change_clipping && (p-chunk) < (ssize_t) (length-17))\n                      {\n                        fb=mng_read_box(previous_fb,(char) p[0],&p[1]);\n                        p+=17;\n                        previous_fb=fb;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Frame_clip: L=%.20g R=%.20g T=%.20g B=%.20g\",\n                            (double) fb.left,(double) fb.right,(double) fb.top,\n                            (double) fb.bottom);\n\n                        if (change_clipping == 2)\n                          default_fb=fb;\n                      }\n                  }\n              }\n            mng_info->clip=fb;\n            mng_info->clip=mng_minimum_box(fb,mng_info->frame);\n\n            subframe_width=(size_t) (mng_info->clip.right\n               -mng_info->clip.left);\n\n            subframe_height=(size_t) (mng_info->clip.bottom\n               -mng_info->clip.top);\n            /*\n              Insert a background layer behind the frame if framing_mode is 4.\n            */\n#if defined(MNG_INSERT_LAYERS)\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"   subframe_width=%.20g, subframe_height=%.20g\",(double)\n                subframe_width,(double) subframe_height);\n\n            if (insert_layers && (mng_info->framing_mode == 4) &&\n                (subframe_width) && (subframe_height))\n              {\n                /* Allocate next image structure.  */\n                if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n                  {\n                    AcquireNextImage(image_info,image);\n\n                    if (GetNextImageInList(image) == (Image *) NULL)\n                      return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n                  }\n\n                mng_info->image=image;\n\n                if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\n                image->columns=subframe_width;\n                image->rows=subframe_height;\n                image->page.width=subframe_width;\n                image->page.height=subframe_height;\n                image->page.x=mng_info->clip.left;\n                image->page.y=mng_info->clip.top;\n                image->background_color=mng_background_color;\n                image->matte=MagickFalse;\n                image->delay=0;\n                (void) SetImageBackgroundColor(image);\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Insert backgd layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\n                    (double) mng_info->clip.left,(double) mng_info->clip.right,\n                    (double) mng_info->clip.top,(double) mng_info->clip.bottom);\n              }\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_CLIP,4) == 0)\n          {\n            unsigned int\n              first_object,\n              last_object;\n\n            /*\n              Read CLIP.\n            */\n            if (length > 3)\n              {\n                first_object=(p[0] << 8) | p[1];\n                last_object=(p[2] << 8) | p[3];\n                p+=4;\n\n                for (i=(int) first_object; i <= (int) last_object; i++)\n                {\n                  if (mng_info->exists[i] && !mng_info->frozen[i])\n                    {\n                      MngBox\n                        box;\n\n                      box=mng_info->object_clip[i];\n                      if ((p-chunk) < (ssize_t) (length-17))\n                        mng_info->object_clip[i]=\n                           mng_read_box(box,(char) p[0],&p[1]);\n                    }\n                }\n\n              }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_SAVE,4) == 0)\n          {\n            for (i=1; i < MNG_MAX_OBJECTS; i++)\n              if (mng_info->exists[i])\n                {\n                 mng_info->frozen[i]=MagickTrue;\n#ifdef MNG_OBJECT_BUFFERS\n                 if (mng_info->ob[i] != (MngBuffer *) NULL)\n                    mng_info->ob[i]->frozen=MagickTrue;\n#endif\n                }\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if ((memcmp(type,mng_DISC,4) == 0) || (memcmp(type,mng_SEEK,4) == 0))\n          {\n            /* Read DISC or SEEK.  */\n\n            if ((length == 0) || !memcmp(type,mng_SEEK,4))\n              {\n                for (i=1; i < MNG_MAX_OBJECTS; i++)\n                  MngInfoDiscardObject(mng_info,i);\n              }\n\n            else\n              {\n                register ssize_t\n                  j;\n\n                for (j=1; j < (ssize_t) length; j+=2)\n                {\n                  i=p[j-1] << 8 | p[j];\n                  MngInfoDiscardObject(mng_info,i);\n                }\n              }\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if (memcmp(type,mng_MOVE,4) == 0)\n          {\n            size_t\n              first_object,\n              last_object;\n\n            /* read MOVE */\n\n            if (length > 3)\n            {\n              first_object=(p[0] << 8) | p[1];\n              last_object=(p[2] << 8) | p[3];\n              p+=4;\n\n              for (i=(ssize_t) first_object; i <= (ssize_t) last_object; i++)\n              {\n                if (mng_info->exists[i] && !mng_info->frozen[i] &&\n                    (p-chunk) < (ssize_t) (length-8))\n                  {\n                    MngPair\n                      new_pair;\n\n                    MngPair\n                      old_pair;\n\n                    old_pair.a=mng_info->x_off[i];\n                    old_pair.b=mng_info->y_off[i];\n                    new_pair=mng_read_pair(old_pair,(int) p[0],&p[1]);\n                    mng_info->x_off[i]=new_pair.a;\n                    mng_info->y_off[i]=new_pair.b;\n                  }\n              }\n            }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_LOOP,4) == 0)\n          {\n            ssize_t loop_iters=1;\n            if (length > 4)\n              {\n                loop_level=chunk[0];\n                mng_info->loop_active[loop_level]=1;  /* mark loop active */\n\n                /* Record starting point.  */\n                loop_iters=mng_get_long(&chunk[1]);\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  LOOP level %.20g has %.20g iterations \",\n                    (double) loop_level, (double) loop_iters);\n\n                if (loop_iters == 0)\n                  skipping_loop=loop_level;\n\n                else\n                  {\n                    mng_info->loop_jump[loop_level]=TellBlob(image);\n                    mng_info->loop_count[loop_level]=loop_iters;\n                  }\n\n                mng_info->loop_iteration[loop_level]=0;\n              }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_ENDL,4) == 0)\n          {\n            if (length > 0)\n              {\n                loop_level=chunk[0];\n\n                if (skipping_loop > 0)\n                  {\n                    if (skipping_loop == loop_level)\n                      {\n                        /*\n                          Found end of zero-iteration loop.\n                        */\n                        skipping_loop=(-1);\n                        mng_info->loop_active[loop_level]=0;\n                      }\n                  }\n\n                else\n                  {\n                    if (mng_info->loop_active[loop_level] == 1)\n                      {\n                        mng_info->loop_count[loop_level]--;\n                        mng_info->loop_iteration[loop_level]++;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  ENDL: LOOP level %.20g has %.20g remaining iters \",\n                            (double) loop_level,(double)\n                            mng_info->loop_count[loop_level]);\n\n                        if (mng_info->loop_count[loop_level] != 0)\n                          {\n                            offset=SeekBlob(image,\n                              mng_info->loop_jump[loop_level], SEEK_SET);\n\n                            if (offset < 0)\n                              {\n                                chunk=(unsigned char *) RelinquishMagickMemory(\n                                  chunk);\n                                ThrowReaderException(CorruptImageError,\n                                  \"ImproperImageHeader\");\n                              }\n                          }\n\n                        else\n                          {\n                            short\n                              last_level;\n\n                            /*\n                              Finished loop.\n                            */\n                            mng_info->loop_active[loop_level]=0;\n                            last_level=(-1);\n                            for (i=0; i < loop_level; i++)\n                              if (mng_info->loop_active[i] == 1)\n                                last_level=(short) i;\n                            loop_level=last_level;\n                          }\n                      }\n                  }\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_CLON,4) == 0)\n          {\n            if (mng_info->clon_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"CLON is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->clon_warning++;\n          }\n\n        if (memcmp(type,mng_MAGN,4) == 0)\n          {\n            png_uint_16\n              magn_first,\n              magn_last,\n              magn_mb,\n              magn_ml,\n              magn_mr,\n              magn_mt,\n              magn_mx,\n              magn_my,\n              magn_methx,\n              magn_methy;\n\n            if (length > 1)\n              magn_first=(p[0] << 8) | p[1];\n\n            else\n              magn_first=0;\n\n            if (length > 3)\n              magn_last=(p[2] << 8) | p[3];\n\n            else\n              magn_last=magn_first;\n#ifndef MNG_OBJECT_BUFFERS\n            if (magn_first || magn_last)\n              if (mng_info->magn_warning == 0)\n                {\n                  (void) ThrowMagickException(&image->exception,\n                     GetMagickModule(),CoderError,\n                     \"MAGN is not implemented yet for nonzero objects\",\n                     \"`%s'\",image->filename);\n\n                   mng_info->magn_warning++;\n                }\n#endif\n            if (length > 4)\n              magn_methx=p[4];\n\n            else\n              magn_methx=0;\n\n            if (length > 6)\n              magn_mx=(p[5] << 8) | p[6];\n\n            else\n              magn_mx=1;\n\n            if (magn_mx == 0)\n              magn_mx=1;\n\n            if (length > 8)\n              magn_my=(p[7] << 8) | p[8];\n\n            else\n              magn_my=magn_mx;\n\n            if (magn_my == 0)\n              magn_my=1;\n\n            if (length > 10)\n              magn_ml=(p[9] << 8) | p[10];\n\n            else\n              magn_ml=magn_mx;\n\n            if (magn_ml == 0)\n              magn_ml=1;\n\n            if (length > 12)\n              magn_mr=(p[11] << 8) | p[12];\n\n            else\n              magn_mr=magn_mx;\n\n            if (magn_mr == 0)\n              magn_mr=1;\n\n            if (length > 14)\n              magn_mt=(p[13] << 8) | p[14];\n\n            else\n              magn_mt=magn_my;\n\n            if (magn_mt == 0)\n              magn_mt=1;\n\n            if (length > 16)\n              magn_mb=(p[15] << 8) | p[16];\n\n            else\n              magn_mb=magn_my;\n\n            if (magn_mb == 0)\n              magn_mb=1;\n\n            if (length > 17)\n              magn_methy=p[17];\n\n            else\n              magn_methy=magn_methx;\n\n\n            if (magn_methx > 5 || magn_methy > 5)\n              if (mng_info->magn_warning == 0)\n                {\n                  (void) ThrowMagickException(&image->exception,\n                     GetMagickModule(),CoderError,\n                     \"Unknown MAGN method in MNG datastream\",\"`%s'\",\n                     image->filename);\n\n                   mng_info->magn_warning++;\n                }\n#ifdef MNG_OBJECT_BUFFERS\n          /* Magnify existing objects in the range magn_first to magn_last */\n#endif\n            if (magn_first == 0 || magn_last == 0)\n              {\n                /* Save the magnification factors for object 0 */\n                mng_info->magn_mb=magn_mb;\n                mng_info->magn_ml=magn_ml;\n                mng_info->magn_mr=magn_mr;\n                mng_info->magn_mt=magn_mt;\n                mng_info->magn_mx=magn_mx;\n                mng_info->magn_my=magn_my;\n                mng_info->magn_methx=magn_methx;\n                mng_info->magn_methy=magn_methy;\n              }\n          }\n\n        if (memcmp(type,mng_PAST,4) == 0)\n          {\n            if (mng_info->past_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"PAST is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->past_warning++;\n          }\n\n        if (memcmp(type,mng_SHOW,4) == 0)\n          {\n            if (mng_info->show_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"SHOW is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->show_warning++;\n          }\n\n        if (memcmp(type,mng_sBIT,4) == 0)\n          {\n            if (length < 4)\n              mng_info->have_global_sbit=MagickFalse;\n\n            else\n              {\n                mng_info->global_sbit.gray=p[0];\n                mng_info->global_sbit.red=p[0];\n                mng_info->global_sbit.green=p[1];\n                mng_info->global_sbit.blue=p[2];\n                mng_info->global_sbit.alpha=p[3];\n                mng_info->have_global_sbit=MagickTrue;\n             }\n          }\n        if (memcmp(type,mng_pHYs,4) == 0)\n          {\n            if (length > 8)\n              {\n                mng_info->global_x_pixels_per_unit=\n                    (size_t) mng_get_long(p);\n                mng_info->global_y_pixels_per_unit=\n                    (size_t) mng_get_long(&p[4]);\n                mng_info->global_phys_unit_type=p[8];\n                mng_info->have_global_phys=MagickTrue;\n              }\n\n            else\n              mng_info->have_global_phys=MagickFalse;\n          }\n        if (memcmp(type,mng_pHYg,4) == 0)\n          {\n            if (mng_info->phyg_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"pHYg is not implemented.\",\"`%s'\",image->filename);\n\n            mng_info->phyg_warning++;\n          }\n        if (memcmp(type,mng_BASI,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->basi_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"BASI is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->basi_warning++;\n#ifdef MNG_BASI_SUPPORTED\n            if (length > 11)\n              {\n                basi_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n                   (p[2] << 8) | p[3]);\n                basi_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n                   (p[6] << 8) | p[7]);\n                basi_color_type=p[8];\n                basi_compression_method=p[9];\n                basi_filter_type=p[10];\n                basi_interlace_method=p[11];\n              }\n            if (length > 13)\n              basi_red=(p[12] << 8) & p[13];\n\n            else\n              basi_red=0;\n\n            if (length > 15)\n              basi_green=(p[14] << 8) & p[15];\n\n            else\n              basi_green=0;\n\n            if (length > 17)\n              basi_blue=(p[16] << 8) & p[17];\n\n            else\n              basi_blue=0;\n\n            if (length > 19)\n              basi_alpha=(p[18] << 8) & p[19];\n\n            else\n              {\n                if (basi_sample_depth == 16)\n                  basi_alpha=65535L;\n                else\n                  basi_alpha=255;\n              }\n\n            if (length > 20)\n              basi_viewable=p[20];\n\n            else\n              basi_viewable=0;\n\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_IHDR,4)\n#if defined(JNG_SUPPORTED)\n            && memcmp(type,mng_JHDR,4)\n#endif\n            )\n          {\n            /* Not an IHDR or JHDR chunk */\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n/* Process IHDR */\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Processing %c%c%c%c chunk\",type[0],type[1],type[2],type[3]);\n\n        mng_info->exists[object_id]=MagickTrue;\n        mng_info->viewable[object_id]=MagickTrue;\n\n        if (mng_info->invisible[object_id])\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Skipping invisible object\");\n\n            skip_to_iend=MagickTrue;\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n#if defined(MNG_INSERT_LAYERS)\n        if (length < 8)\n          {\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          }\n\n        image_width=(size_t) mng_get_long(p);\n        image_height=(size_t) mng_get_long(&p[4]);\n#endif\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        /*\n          Insert a transparent background layer behind the entire animation\n          if it is not full screen.\n        */\n#if defined(MNG_INSERT_LAYERS)\n        if (insert_layers && mng_type && first_mng_object)\n          {\n            if ((mng_info->clip.left > 0) || (mng_info->clip.top > 0) ||\n                (image_width < mng_info->mng_width) ||\n                (mng_info->clip.right < (ssize_t) mng_info->mng_width) ||\n                (image_height < mng_info->mng_height) ||\n                (mng_info->clip.bottom < (ssize_t) mng_info->mng_height))\n              {\n                if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n                  {\n                    /*\n                      Allocate next image structure.\n                    */\n                    AcquireNextImage(image_info,image);\n\n                    if (GetNextImageInList(image) == (Image *) NULL)\n                      return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n                  }\n                mng_info->image=image;\n\n                if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\n                /* Make a background rectangle.  */\n\n                image->delay=0;\n                image->columns=mng_info->mng_width;\n                image->rows=mng_info->mng_height;\n                image->page.width=mng_info->mng_width;\n                image->page.height=mng_info->mng_height;\n                image->page.x=0;\n                image->page.y=0;\n                image->background_color=mng_background_color;\n                (void) SetImageBackgroundColor(image);\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Inserted transparent background layer, W=%.20g, H=%.20g\",\n                    (double) mng_info->mng_width,(double) mng_info->mng_height);\n              }\n          }\n        /*\n          Insert a background layer behind the upcoming image if\n          framing_mode is 3, and we haven't already inserted one.\n        */\n        if (insert_layers && (mng_info->framing_mode == 3) &&\n                (subframe_width) && (subframe_height) && (simplicity == 0 ||\n                (simplicity & 0x08)))\n          {\n            if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n            {\n              /*\n                Allocate next image structure.\n              */\n              AcquireNextImage(image_info,image);\n\n              if (GetNextImageInList(image) == (Image *) NULL)\n                return(DestroyImageList(image));\n\n              image=SyncNextImageInList(image);\n            }\n\n            mng_info->image=image;\n\n            if (term_chunk_found)\n              {\n                image->start_loop=MagickTrue;\n                image->iterations=mng_iterations;\n                term_chunk_found=MagickFalse;\n              }\n\n            else\n                image->start_loop=MagickFalse;\n\n            image->delay=0;\n            image->columns=subframe_width;\n            image->rows=subframe_height;\n            image->page.width=subframe_width;\n            image->page.height=subframe_height;\n            image->page.x=mng_info->clip.left;\n            image->page.y=mng_info->clip.top;\n            image->background_color=mng_background_color;\n            image->matte=MagickFalse;\n            (void) SetImageBackgroundColor(image);\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Insert background layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\n                (double) mng_info->clip.left,(double) mng_info->clip.right,\n                (double) mng_info->clip.top,(double) mng_info->clip.bottom);\n          }\n#endif /* MNG_INSERT_LAYERS */\n        first_mng_object=MagickFalse;\n\n        if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n          {\n            /*\n              Allocate next image structure.\n            */\n            AcquireNextImage(image_info,image);\n\n            if (GetNextImageInList(image) == (Image *) NULL)\n              return(DestroyImageList(image));\n\n            image=SyncNextImageInList(image);\n          }\n        mng_info->image=image;\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n\n        if (status == MagickFalse)\n          break;\n\n        if (term_chunk_found)\n          {\n            image->start_loop=MagickTrue;\n            term_chunk_found=MagickFalse;\n          }\n\n        else\n            image->start_loop=MagickFalse;\n\n        if (mng_info->framing_mode == 1 || mng_info->framing_mode == 3)\n          {\n            image->delay=frame_delay;\n            frame_delay=default_frame_delay;\n          }\n\n        else\n          image->delay=0;\n\n        image->page.width=mng_info->mng_width;\n        image->page.height=mng_info->mng_height;\n        image->page.x=mng_info->x_off[object_id];\n        image->page.y=mng_info->y_off[object_id];\n        image->iterations=mng_iterations;\n\n        /*\n          Seek back to the beginning of the IHDR or JHDR chunk's length field.\n        */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Seeking back to beginning of %c%c%c%c chunk\",type[0],type[1],\n            type[2],type[3]);\n\n        offset=SeekBlob(image,-((ssize_t) length+12),SEEK_CUR);\n\n        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n\n    mng_info->image=image;\n    mng_info->mng_type=mng_type;\n    mng_info->object_id=object_id;\n\n    if (memcmp(type,mng_IHDR,4) == 0)\n      image=ReadOnePNGImage(mng_info,image_info,exception);\n\n#if defined(JNG_SUPPORTED)\n    else\n      image=ReadOneJNGImage(mng_info,image_info,exception);\n#endif\n\n    if (image == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"exit ReadJNGImage() with error\");\n\n        return((Image *) NULL);\n      }\n\n    if (image->columns == 0 || image->rows == 0)\n      {\n        (void) CloseBlob(image);\n        return(DestroyImageList(image));\n      }\n\n    mng_info->image=image;\n\n    if (mng_type)\n      {\n        MngBox\n          crop_box;\n\n        if (mng_info->magn_methx || mng_info->magn_methy)\n          {\n            png_uint_32\n               magnified_height,\n               magnified_width;\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Processing MNG MAGN chunk\");\n\n            if (mng_info->magn_methx == 1)\n              {\n                magnified_width=mng_info->magn_ml;\n\n                if (image->columns > 1)\n                   magnified_width += mng_info->magn_mr;\n\n                if (image->columns > 2)\n                   magnified_width += (png_uint_32)\n                      ((image->columns-2)*(mng_info->magn_mx));\n              }\n\n            else\n              {\n                magnified_width=(png_uint_32) image->columns;\n\n                if (image->columns > 1)\n                   magnified_width += mng_info->magn_ml-1;\n\n                if (image->columns > 2)\n                   magnified_width += mng_info->magn_mr-1;\n\n                if (image->columns > 3)\n                   magnified_width += (png_uint_32)\n                      ((image->columns-3)*(mng_info->magn_mx-1));\n              }\n\n            if (mng_info->magn_methy == 1)\n              {\n                magnified_height=mng_info->magn_mt;\n\n                if (image->rows > 1)\n                   magnified_height += mng_info->magn_mb;\n\n                if (image->rows > 2)\n                   magnified_height += (png_uint_32)\n                      ((image->rows-2)*(mng_info->magn_my));\n              }\n\n            else\n              {\n                magnified_height=(png_uint_32) image->rows;\n\n                if (image->rows > 1)\n                   magnified_height += mng_info->magn_mt-1;\n\n                if (image->rows > 2)\n                   magnified_height += mng_info->magn_mb-1;\n\n                if (image->rows > 3)\n                   magnified_height += (png_uint_32)\n                      ((image->rows-3)*(mng_info->magn_my-1));\n              }\n\n            if (magnified_height > image->rows ||\n                magnified_width > image->columns)\n              {\n                Image\n                  *large_image;\n\n                int\n                  yy;\n\n                ssize_t\n                  m,\n                  y;\n\n                register ssize_t\n                  x;\n\n                register PixelPacket\n                  *n,\n                  *q;\n\n                PixelPacket\n                  *next,\n                  *prev;\n\n                png_uint_16\n                  magn_methx,\n                  magn_methy;\n\n                /* Allocate next image structure.  */\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Allocate magnified image\");\n\n                AcquireNextImage(image_info,image);\n\n                if (GetNextImageInList(image) == (Image *) NULL)\n                  return(DestroyImageList(image));\n\n                large_image=SyncNextImageInList(image);\n\n                large_image->columns=magnified_width;\n                large_image->rows=magnified_height;\n\n                magn_methx=mng_info->magn_methx;\n                magn_methy=mng_info->magn_methy;\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n#define QM unsigned short\n                if (magn_methx != 1 || magn_methy != 1)\n                  {\n                  /*\n                     Scale pixels to unsigned shorts to prevent\n                     overflow of intermediate values of interpolations\n                  */\n                     for (y=0; y < (ssize_t) image->rows; y++)\n                     {\n                       q=GetAuthenticPixels(image,0,y,image->columns,1,\n                          exception);\n\n                       for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                       {\n                          SetPixelRed(q,ScaleQuantumToShort(\n                            GetPixelRed(q)));\n                          SetPixelGreen(q,ScaleQuantumToShort(\n                            GetPixelGreen(q)));\n                          SetPixelBlue(q,ScaleQuantumToShort(\n                            GetPixelBlue(q)));\n                          SetPixelOpacity(q,ScaleQuantumToShort(\n                            GetPixelOpacity(q)));\n                          q++;\n                       }\n\n                       if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                         break;\n                     }\n                  }\n#else\n#define QM Quantum\n#endif\n\n                if (image->matte != MagickFalse)\n                   (void) SetImageBackgroundColor(large_image);\n\n                else\n                  {\n                    large_image->background_color.opacity=OpaqueOpacity;\n                    (void) SetImageBackgroundColor(large_image);\n\n                    if (magn_methx == 4)\n                      magn_methx=2;\n\n                    if (magn_methx == 5)\n                      magn_methx=3;\n\n                    if (magn_methy == 4)\n                      magn_methy=2;\n\n                    if (magn_methy == 5)\n                      magn_methy=3;\n                  }\n\n                /* magnify the rows into the right side of the large image */\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Magnify the rows to %.20g\",(double) large_image->rows);\n                m=(ssize_t) mng_info->magn_mt;\n                yy=0;\n                length=(size_t) image->columns;\n                next=(PixelPacket *) AcquireQuantumMemory(length,sizeof(*next));\n                prev=(PixelPacket *) AcquireQuantumMemory(length,sizeof(*prev));\n\n                if ((prev == (PixelPacket *) NULL) ||\n                    (next == (PixelPacket *) NULL))\n                  {\n                     image=DestroyImageList(image);\n                     ThrowReaderException(ResourceLimitError,\n                       \"MemoryAllocationFailed\");\n                  }\n\n                n=GetAuthenticPixels(image,0,0,image->columns,1,exception);\n                (void) CopyMagickMemory(next,n,length);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n                {\n                  if (y == 0)\n                    m=(ssize_t) mng_info->magn_mt;\n\n                  else if (magn_methy > 1 && y == (ssize_t) image->rows-2)\n                    m=(ssize_t) mng_info->magn_mb;\n\n                  else if (magn_methy <= 1 && y == (ssize_t) image->rows-1)\n                    m=(ssize_t) mng_info->magn_mb;\n\n                  else if (magn_methy > 1 && y == (ssize_t) image->rows-1)\n                    m=1;\n\n                  else\n                    m=(ssize_t) mng_info->magn_my;\n\n                  n=prev;\n                  prev=next;\n                  next=n;\n\n                  if (y < (ssize_t) image->rows-1)\n                    {\n                      n=GetAuthenticPixels(image,0,y+1,image->columns,1,\n                          exception);\n                      (void) CopyMagickMemory(next,n,length);\n                    }\n\n                  for (i=0; i < m; i++, yy++)\n                  {\n                    register PixelPacket\n                      *pixels;\n\n                    assert(yy < (ssize_t) large_image->rows);\n                    pixels=prev;\n                    n=next;\n                    q=GetAuthenticPixels(large_image,0,yy,large_image->columns,\n                      1,exception);\n                    q+=(large_image->columns-image->columns);\n\n                    for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                    {\n                      /* To do: get color as function of indexes[x] */\n                      /*\n                      if (image->storage_class == PseudoClass)\n                        {\n                        }\n                      */\n\n                      if (magn_methy <= 1)\n                        {\n                          /* replicate previous */\n                          SetPixelRGBO(q,(pixels));\n                        }\n\n                      else if (magn_methy == 2 || magn_methy == 4)\n                        {\n                          if (i == 0)\n                            {\n                              SetPixelRGBO(q,(pixels));\n                            }\n\n                          else\n                            {\n                              /* Interpolate */\n                              SetPixelRed(q,\n                                 ((QM) (((ssize_t)\n                                 (2*i*(GetPixelRed(n)\n                                 -GetPixelRed(pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelRed(pixels)))));\n                              SetPixelGreen(q,\n                                 ((QM) (((ssize_t)\n                                 (2*i*(GetPixelGreen(n)\n                                 -GetPixelGreen(pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelGreen(pixels)))));\n                              SetPixelBlue(q,\n                                 ((QM) (((ssize_t)\n                                 (2*i*(GetPixelBlue(n)\n                                 -GetPixelBlue(pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelBlue(pixels)))));\n\n                              if (image->matte != MagickFalse)\n                                 SetPixelOpacity(q,\n                                    ((QM) (((ssize_t)\n                                    (2*i*(GetPixelOpacity(n)\n                                    -GetPixelOpacity(pixels)+m))\n                                    /((ssize_t) (m*2))+\n                                   GetPixelOpacity(pixels)))));\n                            }\n\n                          if (magn_methy == 4)\n                            {\n                              /* Replicate nearest */\n                              if (i <= ((m+1) << 1))\n                                 SetPixelOpacity(q,\n                                 (*pixels).opacity+0);\n                              else\n                                 SetPixelOpacity(q,\n                                 (*n).opacity+0);\n                            }\n                        }\n\n                      else /* if (magn_methy == 3 || magn_methy == 5) */\n                        {\n                          /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n                          {\n                             SetPixelRGBO(q,(pixels));\n                          }\n\n                          else\n                          {\n                             SetPixelRGBO(q,(n));\n                          }\n\n                          if (magn_methy == 5)\n                            {\n                              SetPixelOpacity(q,\n                                 (QM) (((ssize_t) (2*i*\n                                 (GetPixelOpacity(n)\n                                 -GetPixelOpacity(pixels))\n                                 +m))/((ssize_t) (m*2))\n                                 +GetPixelOpacity(pixels)));\n                            }\n                        }\n                      n++;\n                      q++;\n                      pixels++;\n                    } /* x */\n\n                    if (SyncAuthenticPixels(large_image,exception) == 0)\n                      break;\n\n                  } /* i */\n                } /* y */\n\n                prev=(PixelPacket *) RelinquishMagickMemory(prev);\n                next=(PixelPacket *) RelinquishMagickMemory(next);\n\n                length=image->columns;\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Delete original image\");\n\n                DeleteImageFromList(&image);\n\n                image=large_image;\n\n                mng_info->image=image;\n\n                /* magnify the columns */\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Magnify the columns to %.20g\",(double) image->columns);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n                {\n                  register PixelPacket\n                    *pixels;\n\n                  q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n                  pixels=q+(image->columns-length);\n                  n=pixels+1;\n\n                  for (x=(ssize_t) (image->columns-length);\n                    x < (ssize_t) image->columns; x++)\n                  {\n                    /* To do: Rewrite using Get/Set***PixelComponent() */\n\n                    if (x == (ssize_t) (image->columns-length))\n                      m=(ssize_t) mng_info->magn_ml;\n\n                    else if (magn_methx > 1 && x == (ssize_t) image->columns-2)\n                      m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx <= 1 && x == (ssize_t) image->columns-1)\n                      m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx > 1 && x == (ssize_t) image->columns-1)\n                      m=1;\n\n                    else\n                      m=(ssize_t) mng_info->magn_mx;\n\n                    for (i=0; i < m; i++)\n                    {\n                      if (magn_methx <= 1)\n                        {\n                          /* replicate previous */\n                          SetPixelRGBO(q,(pixels));\n                        }\n\n                      else if (magn_methx == 2 || magn_methx == 4)\n                        {\n                          if (i == 0)\n                          {\n                             SetPixelRGBO(q,(pixels));\n                          }\n\n                          /* To do: Rewrite using Get/Set***PixelComponent() */\n                          else\n                            {\n                              /* Interpolate */\n                              SetPixelRed(q,\n                                 (QM) ((2*i*(\n                                 GetPixelRed(n)\n                                 -GetPixelRed(pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelRed(pixels)));\n\n                              SetPixelGreen(q,\n                                 (QM) ((2*i*(\n                                 GetPixelGreen(n)\n                                 -GetPixelGreen(pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelGreen(pixels)));\n\n                              SetPixelBlue(q,\n                                 (QM) ((2*i*(\n                                 GetPixelBlue(n)\n                                 -GetPixelBlue(pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelBlue(pixels)));\n                              if (image->matte != MagickFalse)\n                                 SetPixelOpacity(q,\n                                   (QM) ((2*i*(\n                                   GetPixelOpacity(n)\n                                   -GetPixelOpacity(pixels))+m)\n                                   /((ssize_t) (m*2))+\n                                   GetPixelOpacity(pixels)));\n                            }\n\n                          if (magn_methx == 4)\n                            {\n                              /* Replicate nearest */\n                              if (i <= ((m+1) << 1))\n                              {\n                                 SetPixelOpacity(q,\n                                 GetPixelOpacity(pixels)+0);\n                              }\n                              else\n                              {\n                                 SetPixelOpacity(q,\n                                 GetPixelOpacity(n)+0);\n                              }\n                            }\n                        }\n\n                      else /* if (magn_methx == 3 || magn_methx == 5) */\n                        {\n                          /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n                          {\n                             SetPixelRGBO(q,(pixels));\n                          }\n\n                          else\n                          {\n                             SetPixelRGBO(q,(n));\n                          }\n\n                          if (magn_methx == 5)\n                            {\n                              /* Interpolate */\n                              SetPixelOpacity(q,\n                                 (QM) ((2*i*( GetPixelOpacity(n)\n                                 -GetPixelOpacity(pixels))+m)/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelOpacity(pixels)));\n                            }\n                        }\n                      q++;\n                    }\n                    n++;\n                  }\n\n                  if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                    break;\n                }\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n              if (magn_methx != 1 || magn_methy != 1)\n                {\n                /*\n                   Rescale pixels to Quantum\n                */\n                   for (y=0; y < (ssize_t) image->rows; y++)\n                   {\n                     q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n                     for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                     {\n                        SetPixelRed(q,ScaleShortToQuantum(\n                            GetPixelRed(q)));\n                        SetPixelGreen(q,ScaleShortToQuantum(\n                            GetPixelGreen(q)));\n                        SetPixelBlue(q,ScaleShortToQuantum(\n                            GetPixelBlue(q)));\n                        SetPixelOpacity(q,ScaleShortToQuantum(\n                            GetPixelOpacity(q)));\n                        q++;\n                     }\n\n                     if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                       break;\n                   }\n                }\n#endif\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Finished MAGN processing\");\n              }\n          }\n\n        /*\n          Crop_box is with respect to the upper left corner of the MNG.\n        */\n        crop_box.left=mng_info->image_box.left+mng_info->x_off[object_id];\n        crop_box.right=mng_info->image_box.right+mng_info->x_off[object_id];\n        crop_box.top=mng_info->image_box.top+mng_info->y_off[object_id];\n        crop_box.bottom=mng_info->image_box.bottom+mng_info->y_off[object_id];\n        crop_box=mng_minimum_box(crop_box,mng_info->clip);\n        crop_box=mng_minimum_box(crop_box,mng_info->frame);\n        crop_box=mng_minimum_box(crop_box,mng_info->object_clip[object_id]);\n        if ((crop_box.left != (mng_info->image_box.left\n            +mng_info->x_off[object_id])) ||\n            (crop_box.right != (mng_info->image_box.right\n            +mng_info->x_off[object_id])) ||\n            (crop_box.top != (mng_info->image_box.top\n            +mng_info->y_off[object_id])) ||\n            (crop_box.bottom != (mng_info->image_box.bottom\n            +mng_info->y_off[object_id])))\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Crop the PNG image\");\n\n            if ((crop_box.left < crop_box.right) &&\n                (crop_box.top < crop_box.bottom))\n              {\n                Image\n                  *im;\n\n                RectangleInfo\n                  crop_info;\n\n                /*\n                  Crop_info is with respect to the upper left corner of\n                  the image.\n                */\n                crop_info.x=(crop_box.left-mng_info->x_off[object_id]);\n                crop_info.y=(crop_box.top-mng_info->y_off[object_id]);\n                crop_info.width=(size_t) (crop_box.right-crop_box.left);\n                crop_info.height=(size_t) (crop_box.bottom-crop_box.top);\n                image->page.width=image->columns;\n                image->page.height=image->rows;\n                image->page.x=0;\n                image->page.y=0;\n                im=CropImage(image,&crop_info,exception);\n\n                if (im != (Image *) NULL)\n                  {\n                    image->columns=im->columns;\n                    image->rows=im->rows;\n                    im=DestroyImage(im);\n                    image->page.width=image->columns;\n                    image->page.height=image->rows;\n                    image->page.x=crop_box.left;\n                    image->page.y=crop_box.top;\n                  }\n              }\n\n            else\n              {\n                /*\n                  No pixels in crop area.  The MNG spec still requires\n                  a layer, though, so make a single transparent pixel in\n                  the top left corner.\n                */\n                image->columns=1;\n                image->rows=1;\n                image->colors=2;\n                (void) SetImageBackgroundColor(image);\n                image->page.width=1;\n                image->page.height=1;\n                image->page.x=0;\n                image->page.y=0;\n              }\n          }\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n        image=mng_info->image;\n#endif\n      }\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n      /* PNG does not handle depths greater than 16 so reduce it even\n       * if lossy, and promote any depths > 8 to 16.\n       */\n      if (image->depth > 16)\n         image->depth=16;\n#endif\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 8)\n      if (image->depth > 8)\n        {\n          /* To do: fill low byte properly */\n          image->depth=16;\n        }\n\n      if (LosslessReduceDepthOK(image) != MagickFalse)\n         image->depth = 8;\n#endif\n\n      GetImageException(image,exception);\n\n      if (image_info->number_scenes != 0)\n        {\n          if (mng_info->scenes_found >\n             (ssize_t) (image_info->first_scene+image_info->number_scenes))\n            break;\n        }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Finished reading image datastream.\");\n\n  } while (LocaleCompare(image_info->magick,\"MNG\") == 0);\n\n  (void) CloseBlob(image);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Finished reading all image datastreams.\");\n\n#if defined(MNG_INSERT_LAYERS)\n  if (insert_layers && !mng_info->image_found && (mng_info->mng_width) &&\n       (mng_info->mng_height))\n    {\n      /*\n        Insert a background layer if nothing else was found.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  No images found.  Inserting a background layer.\");\n\n      if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n        {\n          /*\n            Allocate next image structure.\n          */\n          AcquireNextImage(image_info,image);\n          if (GetNextImageInList(image) == (Image *) NULL)\n            {\n              if (logging != MagickFalse)\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Allocation failed, returning NULL.\");\n\n              return(DestroyImageList(image));\n            }\n          image=SyncNextImageInList(image);\n        }\n      image->columns=mng_info->mng_width;\n      image->rows=mng_info->mng_height;\n      image->page.width=mng_info->mng_width;\n      image->page.height=mng_info->mng_height;\n      image->page.x=0;\n      image->page.y=0;\n      image->background_color=mng_background_color;\n      image->matte=MagickFalse;\n\n      if (image_info->ping == MagickFalse)\n        (void) SetImageBackgroundColor(image);\n\n      mng_info->image_found++;\n    }\n#endif\n  image->iterations=mng_iterations;\n\n  if (mng_iterations == 1)\n    image->start_loop=MagickTrue;\n\n  while (GetPreviousImageInList(image) != (Image *) NULL)\n  {\n    image_count++;\n    if (image_count > 10*mng_info->image_found)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  No beginning\");\n\n        (void) ThrowMagickException(&image->exception,GetMagickModule(),\n          CoderError,\"Linked list is corrupted, beginning of list not found\",\n          \"`%s'\",image_info->filename);\n\n        return(DestroyImageList(image));\n      }\n\n    image=GetPreviousImageInList(image);\n\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Corrupt list\");\n\n        (void) ThrowMagickException(&image->exception,GetMagickModule(),\n          CoderError,\"Linked list is corrupted; next_image is NULL\",\"`%s'\",\n          image_info->filename);\n      }\n  }\n\n  if (mng_info->ticks_per_second && mng_info->image_found > 1 &&\n             GetNextImageInList(image) ==\n     (Image *) NULL)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  First image null\");\n\n      (void) ThrowMagickException(&image->exception,GetMagickModule(),\n        CoderError,\"image->next for first image is NULL but shouldn't be.\",\n        \"`%s'\",image_info->filename);\n    }\n\n  if (mng_info->image_found == 0)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  No visible images found.\");\n\n      (void) ThrowMagickException(&image->exception,GetMagickModule(),\n        CoderError,\"No visible images in file\",\"`%s'\",image_info->filename);\n\n      return(DestroyImageList(image));\n    }\n\n  if (mng_info->ticks_per_second)\n    final_delay=1UL*MagickMax(image->ticks_per_second,1L)*\n            final_delay/mng_info->ticks_per_second;\n\n  else\n    image->start_loop=MagickTrue;\n\n  /* Find final nonzero image delay */\n  final_image_delay=0;\n\n  while (GetNextImageInList(image) != (Image *) NULL)\n    {\n      if (image->delay)\n        final_image_delay=image->delay;\n\n      image=GetNextImageInList(image);\n    }\n\n  if (final_delay < final_image_delay)\n    final_delay=final_image_delay;\n\n  image->delay=final_delay;\n\n  if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  image->delay=%.20g, final_delay=%.20g\",(double) image->delay,\n        (double) final_delay);\n\n  if (logging != MagickFalse)\n    {\n      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Before coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    scene 0 delay=%.20g\",(double) image->delay);\n\n      while (GetNextImageInList(image) != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene %.20g delay=%.20g\",(double) scene++,(double) image->delay);\n      }\n    }\n\n  image=GetFirstImageInList(image);\n#ifdef MNG_COALESCE_LAYERS\n  if (insert_layers)\n    {\n      Image\n        *next_image,\n        *next;\n\n      size_t\n        scene;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Coalesce Images\");\n\n      scene=image->scene;\n      next_image=CoalesceImages(image,&image->exception);\n\n      if (next_image == (Image *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n      image=DestroyImageList(image);\n      image=next_image;\n\n      for (next=image; next != (Image *) NULL; next=next_image)\n      {\n         next->page.width=mng_info->mng_width;\n         next->page.height=mng_info->mng_height;\n         next->page.x=0;\n         next->page.y=0;\n         next->scene=scene++;\n         next_image=GetNextImageInList(next);\n\n         if (next_image == (Image *) NULL)\n           break;\n\n         if (next->delay == 0)\n           {\n             scene--;\n             next_image->previous=GetPreviousImageInList(next);\n             if (GetPreviousImageInList(next) == (Image *) NULL)\n               image=next_image;\n             else\n               next->previous->next=next_image;\n             next=DestroyImage(next);\n           }\n      }\n    }\n#endif\n\n  while (GetNextImageInList(image) != (Image *) NULL)\n      image=GetNextImageInList(image);\n\n  image->dispose=BackgroundDispose;\n\n  if (logging != MagickFalse)\n    {\n      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  After coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    scene 0 delay=%.20g dispose=%.20g\",(double) image->delay,\n        (double) image->dispose);\n\n      while (GetNextImageInList(image) != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene %.20g delay=%.20g dispose=%.20g\",(double) scene++,\n          (double) image->delay,(double) image->dispose);\n      }\n   }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage();\");\n\n  return(image);\n}", "func_src_after": "static Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info,\n     ExceptionInfo *exception)\n{\n  char\n    page_geometry[MaxTextExtent];\n\n  Image\n    *image;\n\n  MagickBooleanType\n    logging;\n\n  volatile int\n    first_mng_object,\n    object_id,\n    term_chunk_found,\n    skip_to_iend;\n\n  volatile ssize_t\n    image_count=0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MngBox\n    default_fb,\n    fb,\n    previous_fb;\n\n#if defined(MNG_INSERT_LAYERS)\n  PixelPacket\n    mng_background_color;\n#endif\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    count;\n\n  ssize_t\n    loop_level;\n\n  volatile short\n    skipping_loop;\n\n#if defined(MNG_INSERT_LAYERS)\n  unsigned int\n    mandatory_back=0;\n#endif\n\n  volatile unsigned int\n#ifdef MNG_OBJECT_BUFFERS\n    mng_background_object=0,\n#endif\n    mng_type=0;   /* 0: PNG or JNG; 1: MNG; 2: MNG-LC; 3: MNG-VLC */\n\n  size_t\n    default_frame_timeout,\n    frame_timeout,\n#if defined(MNG_INSERT_LAYERS)\n    image_height,\n    image_width,\n#endif\n    length;\n\n  /* These delays are all measured in image ticks_per_second,\n   * not in MNG ticks_per_second\n   */\n  volatile size_t\n    default_frame_delay,\n    final_delay,\n    final_image_delay,\n    frame_delay,\n#if defined(MNG_INSERT_LAYERS)\n    insert_layers,\n#endif\n    mng_iterations=1,\n    simplicity=0,\n    subframe_height=0,\n    subframe_width=0;\n\n  previous_fb.top=0;\n  previous_fb.bottom=0;\n  previous_fb.left=0;\n  previous_fb.right=0;\n  default_fb.top=0;\n  default_fb.bottom=0;\n  default_fb.left=0;\n  default_fb.right=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneMNGImage()\");\n\n  image=mng_info->image;\n\n  if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n    {\n      char\n        magic_number[MaxTextExtent];\n\n      /* Verify MNG signature.  */\n      count=(size_t) ReadBlob(image,8,(unsigned char *) magic_number);\n      if (memcmp(magic_number,\"\\212MNG\\r\\n\\032\\n\",8) != 0)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n      /* Initialize some nonzero members of the MngInfo structure.  */\n      for (i=0; i < MNG_MAX_OBJECTS; i++)\n      {\n        mng_info->object_clip[i].right=(ssize_t) PNG_UINT_31_MAX;\n        mng_info->object_clip[i].bottom=(ssize_t) PNG_UINT_31_MAX;\n      }\n      mng_info->exists[0]=MagickTrue;\n    }\n\n  skipping_loop=(-1);\n  first_mng_object=MagickTrue;\n  mng_type=0;\n#if defined(MNG_INSERT_LAYERS)\n  insert_layers=MagickFalse; /* should be False when converting or mogrifying */\n#endif\n  default_frame_delay=0;\n  default_frame_timeout=0;\n  frame_delay=0;\n  final_delay=1;\n  mng_info->ticks_per_second=1UL*image->ticks_per_second;\n  object_id=0;\n  skip_to_iend=MagickFalse;\n  term_chunk_found=MagickFalse;\n  mng_info->framing_mode=1;\n#if defined(MNG_INSERT_LAYERS)\n  mandatory_back=MagickFalse;\n#endif\n#if defined(MNG_INSERT_LAYERS)\n  mng_background_color=image->background_color;\n#endif\n  default_fb=mng_info->frame;\n  previous_fb=mng_info->frame;\n  do\n  {\n    char\n      type[MaxTextExtent];\n\n    if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n      {\n        unsigned char\n          *chunk;\n\n        /*\n          Read a new chunk.\n        */\n        type[0]='\\0';\n        (void) ConcatenateMagickString(type,\"errr\",MaxTextExtent);\n        length=ReadBlobMSBLong(image);\n        count=(size_t) ReadBlob(image,4,(unsigned char *) type);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  Reading MNG chunk type %c%c%c%c, length: %.20g\",\n           type[0],type[1],type[2],type[3],(double) length);\n\n        if (length > PNG_UINT_31_MAX)\n          {\n            status=MagickFalse;\n            break;\n          }\n\n        if (count == 0)\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n        p=NULL;\n        chunk=(unsigned char *) NULL;\n\n        if (length != 0)\n          {\n            chunk=(unsigned char *) AcquireQuantumMemory(length+\n              MagickPathExtent,sizeof(*chunk));\n\n            if (chunk == (unsigned char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n            for (i=0; i < (ssize_t) length; i++)\n            {\n              int\n                c;\n\n              c=ReadBlobByte(image);\n              if (c == EOF)\n                break;\n              chunk[i]=(unsigned char) c;\n            }\n\n            p=chunk;\n          }\n\n        (void) ReadBlobMSBLong(image);  /* read crc word */\n\n#if !defined(JNG_SUPPORTED)\n        if (memcmp(type,mng_JHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->jhdr_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"JNGCompressNotSupported\",\"`%s'\",image->filename);\n\n            mng_info->jhdr_warning++;\n          }\n#endif\n        if (memcmp(type,mng_DHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->dhdr_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"DeltaPNGNotSupported\",\"`%s'\",image->filename);\n\n            mng_info->dhdr_warning++;\n          }\n        if (memcmp(type,mng_MEND,4) == 0)\n          break;\n\n        if (skip_to_iend)\n          {\n            if (memcmp(type,mng_IEND,4) == 0)\n              skip_to_iend=MagickFalse;\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Skip to IEND.\");\n\n            continue;\n          }\n\n        if (memcmp(type,mng_MHDR,4) == 0)\n          {\n            if (length != 28)\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n              }\n\n            mng_info->mng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n                (p[2] << 8) | p[3]);\n\n            mng_info->mng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n                (p[6] << 8) | p[7]);\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG width: %.20g\",(double) mng_info->mng_width);\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG height: %.20g\",(double) mng_info->mng_height);\n              }\n\n            p+=8;\n            mng_info->ticks_per_second=(size_t) mng_get_long(p);\n\n            if (mng_info->ticks_per_second == 0)\n              default_frame_delay=0;\n\n            else\n              default_frame_delay=1UL*image->ticks_per_second/\n                mng_info->ticks_per_second;\n\n            frame_delay=default_frame_delay;\n            simplicity=0;\n\n            /* Skip nominal layer count, frame count, and play time */\n            p+=16;\n            simplicity=(size_t) mng_get_long(p);\n\n            mng_type=1;    /* Full MNG */\n\n            if ((simplicity != 0) && ((simplicity | 11) == 11))\n              mng_type=2; /* LC */\n\n            if ((simplicity != 0) && ((simplicity | 9) == 9))\n              mng_type=3; /* VLC */\n\n#if defined(MNG_INSERT_LAYERS)\n            if (mng_type != 3)\n              insert_layers=MagickTrue;\n#endif\n            if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n              {\n                /* Allocate next image structure.  */\n                AcquireNextImage(image_info,image);\n\n                if (GetNextImageInList(image) == (Image *) NULL)\n                  return(DestroyImageList(image));\n\n                image=SyncNextImageInList(image);\n                mng_info->image=image;\n              }\n\n            if ((mng_info->mng_width > 65535L) ||\n                (mng_info->mng_height > 65535L))\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(ImageError,\"WidthOrHeightExceedsLimit\");\n              }\n\n            (void) FormatLocaleString(page_geometry,MaxTextExtent,\n              \"%.20gx%.20g+0+0\",(double) mng_info->mng_width,(double)\n              mng_info->mng_height);\n\n            mng_info->frame.left=0;\n            mng_info->frame.right=(ssize_t) mng_info->mng_width;\n            mng_info->frame.top=0;\n            mng_info->frame.bottom=(ssize_t) mng_info->mng_height;\n            mng_info->clip=default_fb=previous_fb=mng_info->frame;\n\n            for (i=0; i < MNG_MAX_OBJECTS; i++)\n              mng_info->object_clip[i]=mng_info->frame;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_TERM,4) == 0)\n          {\n            int\n              repeat=0;\n\n            if (length != 0)\n              repeat=p[0];\n\n            if (repeat == 3 && length > 8)\n              {\n                final_delay=(png_uint_32) mng_get_long(&p[2]);\n                mng_iterations=(png_uint_32) mng_get_long(&p[6]);\n\n                if (mng_iterations == PNG_UINT_31_MAX)\n                  mng_iterations=0;\n\n                image->iterations=mng_iterations;\n                term_chunk_found=MagickTrue;\n              }\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    repeat=%d,  final_delay=%.20g,  iterations=%.20g\",\n                  repeat,(double) final_delay, (double) image->iterations);\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_DEFI,4) == 0)\n          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"DEFI chunk found in MNG-VLC datastream\",\"`%s'\",\n                image->filename);\n\n            if (length > 1)\n              {\n                object_id=(p[0] << 8) | p[1];\n\n                if (mng_type == 2 && object_id != 0)\n                  (void) ThrowMagickException(&image->exception,\n                     GetMagickModule(),\n                     CoderError,\"Nonzero object_id in MNG-LC datastream\",\n                     \"`%s'\", image->filename);\n\n                if (object_id > MNG_MAX_OBJECTS)\n                  {\n                    /*\n                      Instead of using a warning we should allocate a larger\n                      MngInfo structure and continue.\n                    */\n                    (void) ThrowMagickException(&image->exception,\n                        GetMagickModule(), CoderError,\n                        \"object id too large\",\"`%s'\",image->filename);\n                        object_id=MNG_MAX_OBJECTS;\n                  }\n\n                if (mng_info->exists[object_id])\n                  if (mng_info->frozen[object_id])\n                    {\n                      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                      (void) ThrowMagickException(&image->exception,\n                        GetMagickModule(),CoderError,\n                        \"DEFI cannot redefine a frozen MNG object\",\"`%s'\",\n                        image->filename);\n                      continue;\n                    }\n\n                mng_info->exists[object_id]=MagickTrue;\n\n                if (length > 2)\n                  mng_info->invisible[object_id]=p[2];\n\n                /*\n                  Extract object offset info.\n                */\n                if (length > 11)\n                  {\n                    mng_info->x_off[object_id]=(ssize_t) ((p[4] << 24) |\n                        (p[5] << 16) | (p[6] << 8) | p[7]);\n\n                    mng_info->y_off[object_id]=(ssize_t) ((p[8] << 24) |\n                        (p[9] << 16) | (p[10] << 8) | p[11]);\n\n                    if (logging != MagickFalse)\n                      {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  x_off[%d]: %.20g,  y_off[%d]: %.20g\",\n                          object_id,(double) mng_info->x_off[object_id],\n                          object_id,(double) mng_info->y_off[object_id]);\n                      }\n                  }\n\n                /*\n                  Extract object clipping info.\n                */\n            \n                if (length > 27)\n                  mng_info->object_clip[object_id]=\n                    mng_read_box(mng_info->frame,0, &p[12]);\n            }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_bKGD,4) == 0)\n          {\n            mng_info->have_global_bkgd=MagickFalse;\n\n            if (length > 5)\n              {\n                mng_info->mng_global_bkgd.red=\n                  ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\n                mng_info->mng_global_bkgd.green=\n                  ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\n                mng_info->mng_global_bkgd.blue=\n                  ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\n                mng_info->have_global_bkgd=MagickTrue;\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_BACK,4) == 0)\n          {\n#if defined(MNG_INSERT_LAYERS)\n            if (length > 6)\n              mandatory_back=p[6];\n\n            else\n              mandatory_back=0;\n\n            if (mandatory_back && length > 5)\n              {\n                mng_background_color.red=\n                    ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\n                mng_background_color.green=\n                    ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\n                mng_background_color.blue=\n                    ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\n                mng_background_color.opacity=OpaqueOpacity;\n              }\n\n#ifdef MNG_OBJECT_BUFFERS\n            if (length > 8)\n              mng_background_object=(p[7] << 8) | p[8];\n#endif\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_PLTE,4) == 0)\n          {\n            /* Read global PLTE.  */\n\n            if (length && (length < 769))\n              {\n                if (mng_info->global_plte == (png_colorp) NULL)\n                  mng_info->global_plte=(png_colorp) AcquireQuantumMemory(256,\n                    sizeof(*mng_info->global_plte));\n\n                for (i=0; i < (ssize_t) (length/3); i++)\n                {\n                  mng_info->global_plte[i].red=p[3*i];\n                  mng_info->global_plte[i].green=p[3*i+1];\n                  mng_info->global_plte[i].blue=p[3*i+2];\n                }\n\n                mng_info->global_plte_length=(unsigned int) (length/3);\n              }\n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n            {\n              mng_info->global_plte[i].red=i;\n              mng_info->global_plte[i].green=i;\n              mng_info->global_plte[i].blue=i;\n            }\n\n            if (length != 0)\n              mng_info->global_plte_length=256;\n#endif\n            else\n              mng_info->global_plte_length=0;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_tRNS,4) == 0)\n          {\n            /* read global tRNS */\n\n            if (length > 0 && length < 257)\n              for (i=0; i < (ssize_t) length; i++)\n                mng_info->global_trns[i]=p[i];\n\n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n              mng_info->global_trns[i]=255;\n#endif\n            mng_info->global_trns_length=(unsigned int) length;\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_gAMA,4) == 0)\n          {\n            if (length == 4)\n              {\n                ssize_t\n                  igamma;\n\n                igamma=mng_get_long(p);\n                mng_info->global_gamma=((float) igamma)*0.00001;\n                mng_info->have_global_gama=MagickTrue;\n              }\n\n            else\n              mng_info->have_global_gama=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_cHRM,4) == 0)\n          {\n            /* Read global cHRM */\n\n            if (length == 32)\n              {\n                mng_info->global_chrm.white_point.x=0.00001*mng_get_long(p);\n                mng_info->global_chrm.white_point.y=0.00001*mng_get_long(&p[4]);\n                mng_info->global_chrm.red_primary.x=0.00001*mng_get_long(&p[8]);\n                mng_info->global_chrm.red_primary.y=0.00001*\n                  mng_get_long(&p[12]);\n                mng_info->global_chrm.green_primary.x=0.00001*\n                  mng_get_long(&p[16]);\n                mng_info->global_chrm.green_primary.y=0.00001*\n                  mng_get_long(&p[20]);\n                mng_info->global_chrm.blue_primary.x=0.00001*\n                  mng_get_long(&p[24]);\n                mng_info->global_chrm.blue_primary.y=0.00001*\n                  mng_get_long(&p[28]);\n                mng_info->have_global_chrm=MagickTrue;\n              }\n            else\n              mng_info->have_global_chrm=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_sRGB,4) == 0)\n          {\n            /*\n              Read global sRGB.\n            */\n            if (length != 0)\n              {\n                mng_info->global_srgb_intent=\n                  Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n                mng_info->have_global_srgb=MagickTrue;\n              }\n            else\n              mng_info->have_global_srgb=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_iCCP,4) == 0)\n          {\n            /* To do: */\n\n            /*\n              Read global iCCP.\n            */\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if (memcmp(type,mng_FRAM,4) == 0)\n          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"FRAM chunk found in MNG-VLC datastream\",\"`%s'\",\n                image->filename);\n\n            if ((mng_info->framing_mode == 2) || (mng_info->framing_mode == 4))\n              image->delay=frame_delay;\n\n            frame_delay=default_frame_delay;\n            frame_timeout=default_frame_timeout;\n            fb=default_fb;\n\n            if (length > 0)\n              if (p[0])\n                mng_info->framing_mode=p[0];\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Framing_mode=%d\",mng_info->framing_mode);\n\n            if (length > 6)\n              {\n                /* Note the delay and frame clipping boundaries.  */\n\n                p++; /* framing mode */\n\n                while (*p && ((p-chunk) < (ssize_t) length))\n                  p++;  /* frame name */\n\n                p++;  /* frame name terminator */\n\n                if ((p-chunk) < (ssize_t) (length-4))\n                  {\n                    int\n                      change_delay,\n                      change_timeout,\n                      change_clipping;\n\n                    change_delay=(*p++);\n                    change_timeout=(*p++);\n                    change_clipping=(*p++);\n                    p++; /* change_sync */\n\n                    if (change_delay && (p-chunk) < (ssize_t) (length-4))\n                      {\n                          frame_delay=1UL*image->ticks_per_second*\n                            mng_get_long(p);\n\n                        if (mng_info->ticks_per_second != 0)\n                          frame_delay/=mng_info->ticks_per_second;\n\n                        else\n                          frame_delay=PNG_UINT_31_MAX;\n\n                        if (change_delay == 2)\n                          default_frame_delay=frame_delay;\n\n                        p+=4;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Framing_delay=%.20g\",(double) frame_delay);\n                      }\n\n                    if (change_timeout && (p-chunk) < (ssize_t) (length-4))\n                      {\n                        frame_timeout=1UL*image->ticks_per_second*\n                          mng_get_long(p);\n\n                        if (mng_info->ticks_per_second != 0)\n                          frame_timeout/=mng_info->ticks_per_second;\n\n                        else\n                          frame_timeout=PNG_UINT_31_MAX;\n\n                        if (change_timeout == 2)\n                          default_frame_timeout=frame_timeout;\n\n                        p+=4;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Framing_timeout=%.20g\",(double) frame_timeout);\n                      }\n\n                    if (change_clipping && (p-chunk) < (ssize_t) (length-17))\n                      {\n                        fb=mng_read_box(previous_fb,(char) p[0],&p[1]);\n                        p+=17;\n                        previous_fb=fb;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Frame_clip: L=%.20g R=%.20g T=%.20g B=%.20g\",\n                            (double) fb.left,(double) fb.right,(double) fb.top,\n                            (double) fb.bottom);\n\n                        if (change_clipping == 2)\n                          default_fb=fb;\n                      }\n                  }\n              }\n            mng_info->clip=fb;\n            mng_info->clip=mng_minimum_box(fb,mng_info->frame);\n\n            subframe_width=(size_t) (mng_info->clip.right\n               -mng_info->clip.left);\n\n            subframe_height=(size_t) (mng_info->clip.bottom\n               -mng_info->clip.top);\n            /*\n              Insert a background layer behind the frame if framing_mode is 4.\n            */\n#if defined(MNG_INSERT_LAYERS)\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"   subframe_width=%.20g, subframe_height=%.20g\",(double)\n                subframe_width,(double) subframe_height);\n\n            if (insert_layers && (mng_info->framing_mode == 4) &&\n                (subframe_width) && (subframe_height))\n              {\n                /* Allocate next image structure.  */\n                if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n                  {\n                    AcquireNextImage(image_info,image);\n\n                    if (GetNextImageInList(image) == (Image *) NULL)\n                      return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n                  }\n\n                mng_info->image=image;\n\n                if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\n                image->columns=subframe_width;\n                image->rows=subframe_height;\n                image->page.width=subframe_width;\n                image->page.height=subframe_height;\n                image->page.x=mng_info->clip.left;\n                image->page.y=mng_info->clip.top;\n                image->background_color=mng_background_color;\n                image->matte=MagickFalse;\n                image->delay=0;\n                (void) SetImageBackgroundColor(image);\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Insert backgd layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\n                    (double) mng_info->clip.left,(double) mng_info->clip.right,\n                    (double) mng_info->clip.top,(double) mng_info->clip.bottom);\n              }\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_CLIP,4) == 0)\n          {\n            unsigned int\n              first_object,\n              last_object;\n\n            /*\n              Read CLIP.\n            */\n            if (length > 3)\n              {\n                first_object=(p[0] << 8) | p[1];\n                last_object=(p[2] << 8) | p[3];\n                p+=4;\n\n                for (i=(int) first_object; i <= (int) last_object; i++)\n                {\n                  if (mng_info->exists[i] && !mng_info->frozen[i])\n                    {\n                      MngBox\n                        box;\n\n                      box=mng_info->object_clip[i];\n                      if ((p-chunk) < (ssize_t) (length-17))\n                        mng_info->object_clip[i]=\n                           mng_read_box(box,(char) p[0],&p[1]);\n                    }\n                }\n\n              }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_SAVE,4) == 0)\n          {\n            for (i=1; i < MNG_MAX_OBJECTS; i++)\n              if (mng_info->exists[i])\n                {\n                 mng_info->frozen[i]=MagickTrue;\n#ifdef MNG_OBJECT_BUFFERS\n                 if (mng_info->ob[i] != (MngBuffer *) NULL)\n                    mng_info->ob[i]->frozen=MagickTrue;\n#endif\n                }\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if ((memcmp(type,mng_DISC,4) == 0) || (memcmp(type,mng_SEEK,4) == 0))\n          {\n            /* Read DISC or SEEK.  */\n\n            if ((length == 0) || !memcmp(type,mng_SEEK,4))\n              {\n                for (i=1; i < MNG_MAX_OBJECTS; i++)\n                  MngInfoDiscardObject(mng_info,i);\n              }\n\n            else\n              {\n                register ssize_t\n                  j;\n\n                for (j=1; j < (ssize_t) length; j+=2)\n                {\n                  i=p[j-1] << 8 | p[j];\n                  MngInfoDiscardObject(mng_info,i);\n                }\n              }\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if (memcmp(type,mng_MOVE,4) == 0)\n          {\n            size_t\n              first_object,\n              last_object;\n\n            /* read MOVE */\n\n            if (length > 3)\n            {\n              first_object=(p[0] << 8) | p[1];\n              last_object=(p[2] << 8) | p[3];\n              p+=4;\n\n              for (i=(ssize_t) first_object; i <= (ssize_t) last_object; i++)\n              {\n                if ((i < 0) || (i >= MNG_MAX_OBJECTS))\n                  continue;\n                if (mng_info->exists[i] && !mng_info->frozen[i] &&\n                    (p-chunk) < (ssize_t) (length-8))\n                  {\n                    MngPair\n                      new_pair;\n\n                    MngPair\n                      old_pair;\n\n                    old_pair.a=mng_info->x_off[i];\n                    old_pair.b=mng_info->y_off[i];\n                    new_pair=mng_read_pair(old_pair,(int) p[0],&p[1]);\n                    mng_info->x_off[i]=new_pair.a;\n                    mng_info->y_off[i]=new_pair.b;\n                  }\n              }\n            }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_LOOP,4) == 0)\n          {\n            ssize_t loop_iters=1;\n            if (length > 4)\n              {\n                loop_level=chunk[0];\n                mng_info->loop_active[loop_level]=1;  /* mark loop active */\n\n                /* Record starting point.  */\n                loop_iters=mng_get_long(&chunk[1]);\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  LOOP level %.20g has %.20g iterations \",\n                    (double) loop_level, (double) loop_iters);\n\n                if (loop_iters == 0)\n                  skipping_loop=loop_level;\n\n                else\n                  {\n                    mng_info->loop_jump[loop_level]=TellBlob(image);\n                    mng_info->loop_count[loop_level]=loop_iters;\n                  }\n\n                mng_info->loop_iteration[loop_level]=0;\n              }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_ENDL,4) == 0)\n          {\n            if (length > 0)\n              {\n                loop_level=chunk[0];\n\n                if (skipping_loop > 0)\n                  {\n                    if (skipping_loop == loop_level)\n                      {\n                        /*\n                          Found end of zero-iteration loop.\n                        */\n                        skipping_loop=(-1);\n                        mng_info->loop_active[loop_level]=0;\n                      }\n                  }\n\n                else\n                  {\n                    if (mng_info->loop_active[loop_level] == 1)\n                      {\n                        mng_info->loop_count[loop_level]--;\n                        mng_info->loop_iteration[loop_level]++;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  ENDL: LOOP level %.20g has %.20g remaining iters \",\n                            (double) loop_level,(double)\n                            mng_info->loop_count[loop_level]);\n\n                        if (mng_info->loop_count[loop_level] != 0)\n                          {\n                            offset=SeekBlob(image,\n                              mng_info->loop_jump[loop_level], SEEK_SET);\n\n                            if (offset < 0)\n                              {\n                                chunk=(unsigned char *) RelinquishMagickMemory(\n                                  chunk);\n                                ThrowReaderException(CorruptImageError,\n                                  \"ImproperImageHeader\");\n                              }\n                          }\n\n                        else\n                          {\n                            short\n                              last_level;\n\n                            /*\n                              Finished loop.\n                            */\n                            mng_info->loop_active[loop_level]=0;\n                            last_level=(-1);\n                            for (i=0; i < loop_level; i++)\n                              if (mng_info->loop_active[i] == 1)\n                                last_level=(short) i;\n                            loop_level=last_level;\n                          }\n                      }\n                  }\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_CLON,4) == 0)\n          {\n            if (mng_info->clon_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"CLON is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->clon_warning++;\n          }\n\n        if (memcmp(type,mng_MAGN,4) == 0)\n          {\n            png_uint_16\n              magn_first,\n              magn_last,\n              magn_mb,\n              magn_ml,\n              magn_mr,\n              magn_mt,\n              magn_mx,\n              magn_my,\n              magn_methx,\n              magn_methy;\n\n            if (length > 1)\n              magn_first=(p[0] << 8) | p[1];\n\n            else\n              magn_first=0;\n\n            if (length > 3)\n              magn_last=(p[2] << 8) | p[3];\n\n            else\n              magn_last=magn_first;\n#ifndef MNG_OBJECT_BUFFERS\n            if (magn_first || magn_last)\n              if (mng_info->magn_warning == 0)\n                {\n                  (void) ThrowMagickException(&image->exception,\n                     GetMagickModule(),CoderError,\n                     \"MAGN is not implemented yet for nonzero objects\",\n                     \"`%s'\",image->filename);\n\n                   mng_info->magn_warning++;\n                }\n#endif\n            if (length > 4)\n              magn_methx=p[4];\n\n            else\n              magn_methx=0;\n\n            if (length > 6)\n              magn_mx=(p[5] << 8) | p[6];\n\n            else\n              magn_mx=1;\n\n            if (magn_mx == 0)\n              magn_mx=1;\n\n            if (length > 8)\n              magn_my=(p[7] << 8) | p[8];\n\n            else\n              magn_my=magn_mx;\n\n            if (magn_my == 0)\n              magn_my=1;\n\n            if (length > 10)\n              magn_ml=(p[9] << 8) | p[10];\n\n            else\n              magn_ml=magn_mx;\n\n            if (magn_ml == 0)\n              magn_ml=1;\n\n            if (length > 12)\n              magn_mr=(p[11] << 8) | p[12];\n\n            else\n              magn_mr=magn_mx;\n\n            if (magn_mr == 0)\n              magn_mr=1;\n\n            if (length > 14)\n              magn_mt=(p[13] << 8) | p[14];\n\n            else\n              magn_mt=magn_my;\n\n            if (magn_mt == 0)\n              magn_mt=1;\n\n            if (length > 16)\n              magn_mb=(p[15] << 8) | p[16];\n\n            else\n              magn_mb=magn_my;\n\n            if (magn_mb == 0)\n              magn_mb=1;\n\n            if (length > 17)\n              magn_methy=p[17];\n\n            else\n              magn_methy=magn_methx;\n\n\n            if (magn_methx > 5 || magn_methy > 5)\n              if (mng_info->magn_warning == 0)\n                {\n                  (void) ThrowMagickException(&image->exception,\n                     GetMagickModule(),CoderError,\n                     \"Unknown MAGN method in MNG datastream\",\"`%s'\",\n                     image->filename);\n\n                   mng_info->magn_warning++;\n                }\n#ifdef MNG_OBJECT_BUFFERS\n          /* Magnify existing objects in the range magn_first to magn_last */\n#endif\n            if (magn_first == 0 || magn_last == 0)\n              {\n                /* Save the magnification factors for object 0 */\n                mng_info->magn_mb=magn_mb;\n                mng_info->magn_ml=magn_ml;\n                mng_info->magn_mr=magn_mr;\n                mng_info->magn_mt=magn_mt;\n                mng_info->magn_mx=magn_mx;\n                mng_info->magn_my=magn_my;\n                mng_info->magn_methx=magn_methx;\n                mng_info->magn_methy=magn_methy;\n              }\n          }\n\n        if (memcmp(type,mng_PAST,4) == 0)\n          {\n            if (mng_info->past_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"PAST is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->past_warning++;\n          }\n\n        if (memcmp(type,mng_SHOW,4) == 0)\n          {\n            if (mng_info->show_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"SHOW is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->show_warning++;\n          }\n\n        if (memcmp(type,mng_sBIT,4) == 0)\n          {\n            if (length < 4)\n              mng_info->have_global_sbit=MagickFalse;\n\n            else\n              {\n                mng_info->global_sbit.gray=p[0];\n                mng_info->global_sbit.red=p[0];\n                mng_info->global_sbit.green=p[1];\n                mng_info->global_sbit.blue=p[2];\n                mng_info->global_sbit.alpha=p[3];\n                mng_info->have_global_sbit=MagickTrue;\n             }\n          }\n        if (memcmp(type,mng_pHYs,4) == 0)\n          {\n            if (length > 8)\n              {\n                mng_info->global_x_pixels_per_unit=\n                    (size_t) mng_get_long(p);\n                mng_info->global_y_pixels_per_unit=\n                    (size_t) mng_get_long(&p[4]);\n                mng_info->global_phys_unit_type=p[8];\n                mng_info->have_global_phys=MagickTrue;\n              }\n\n            else\n              mng_info->have_global_phys=MagickFalse;\n          }\n        if (memcmp(type,mng_pHYg,4) == 0)\n          {\n            if (mng_info->phyg_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"pHYg is not implemented.\",\"`%s'\",image->filename);\n\n            mng_info->phyg_warning++;\n          }\n        if (memcmp(type,mng_BASI,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->basi_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"BASI is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->basi_warning++;\n#ifdef MNG_BASI_SUPPORTED\n            if (length > 11)\n              {\n                basi_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n                   (p[2] << 8) | p[3]);\n                basi_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n                   (p[6] << 8) | p[7]);\n                basi_color_type=p[8];\n                basi_compression_method=p[9];\n                basi_filter_type=p[10];\n                basi_interlace_method=p[11];\n              }\n            if (length > 13)\n              basi_red=(p[12] << 8) & p[13];\n\n            else\n              basi_red=0;\n\n            if (length > 15)\n              basi_green=(p[14] << 8) & p[15];\n\n            else\n              basi_green=0;\n\n            if (length > 17)\n              basi_blue=(p[16] << 8) & p[17];\n\n            else\n              basi_blue=0;\n\n            if (length > 19)\n              basi_alpha=(p[18] << 8) & p[19];\n\n            else\n              {\n                if (basi_sample_depth == 16)\n                  basi_alpha=65535L;\n                else\n                  basi_alpha=255;\n              }\n\n            if (length > 20)\n              basi_viewable=p[20];\n\n            else\n              basi_viewable=0;\n\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_IHDR,4)\n#if defined(JNG_SUPPORTED)\n            && memcmp(type,mng_JHDR,4)\n#endif\n            )\n          {\n            /* Not an IHDR or JHDR chunk */\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n/* Process IHDR */\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Processing %c%c%c%c chunk\",type[0],type[1],type[2],type[3]);\n\n        mng_info->exists[object_id]=MagickTrue;\n        mng_info->viewable[object_id]=MagickTrue;\n\n        if (mng_info->invisible[object_id])\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Skipping invisible object\");\n\n            skip_to_iend=MagickTrue;\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n#if defined(MNG_INSERT_LAYERS)\n        if (length < 8)\n          {\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          }\n\n        image_width=(size_t) mng_get_long(p);\n        image_height=(size_t) mng_get_long(&p[4]);\n#endif\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        /*\n          Insert a transparent background layer behind the entire animation\n          if it is not full screen.\n        */\n#if defined(MNG_INSERT_LAYERS)\n        if (insert_layers && mng_type && first_mng_object)\n          {\n            if ((mng_info->clip.left > 0) || (mng_info->clip.top > 0) ||\n                (image_width < mng_info->mng_width) ||\n                (mng_info->clip.right < (ssize_t) mng_info->mng_width) ||\n                (image_height < mng_info->mng_height) ||\n                (mng_info->clip.bottom < (ssize_t) mng_info->mng_height))\n              {\n                if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n                  {\n                    /*\n                      Allocate next image structure.\n                    */\n                    AcquireNextImage(image_info,image);\n\n                    if (GetNextImageInList(image) == (Image *) NULL)\n                      return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n                  }\n                mng_info->image=image;\n\n                if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\n                /* Make a background rectangle.  */\n\n                image->delay=0;\n                image->columns=mng_info->mng_width;\n                image->rows=mng_info->mng_height;\n                image->page.width=mng_info->mng_width;\n                image->page.height=mng_info->mng_height;\n                image->page.x=0;\n                image->page.y=0;\n                image->background_color=mng_background_color;\n                (void) SetImageBackgroundColor(image);\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Inserted transparent background layer, W=%.20g, H=%.20g\",\n                    (double) mng_info->mng_width,(double) mng_info->mng_height);\n              }\n          }\n        /*\n          Insert a background layer behind the upcoming image if\n          framing_mode is 3, and we haven't already inserted one.\n        */\n        if (insert_layers && (mng_info->framing_mode == 3) &&\n                (subframe_width) && (subframe_height) && (simplicity == 0 ||\n                (simplicity & 0x08)))\n          {\n            if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n            {\n              /*\n                Allocate next image structure.\n              */\n              AcquireNextImage(image_info,image);\n\n              if (GetNextImageInList(image) == (Image *) NULL)\n                return(DestroyImageList(image));\n\n              image=SyncNextImageInList(image);\n            }\n\n            mng_info->image=image;\n\n            if (term_chunk_found)\n              {\n                image->start_loop=MagickTrue;\n                image->iterations=mng_iterations;\n                term_chunk_found=MagickFalse;\n              }\n\n            else\n                image->start_loop=MagickFalse;\n\n            image->delay=0;\n            image->columns=subframe_width;\n            image->rows=subframe_height;\n            image->page.width=subframe_width;\n            image->page.height=subframe_height;\n            image->page.x=mng_info->clip.left;\n            image->page.y=mng_info->clip.top;\n            image->background_color=mng_background_color;\n            image->matte=MagickFalse;\n            (void) SetImageBackgroundColor(image);\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Insert background layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\n                (double) mng_info->clip.left,(double) mng_info->clip.right,\n                (double) mng_info->clip.top,(double) mng_info->clip.bottom);\n          }\n#endif /* MNG_INSERT_LAYERS */\n        first_mng_object=MagickFalse;\n\n        if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n          {\n            /*\n              Allocate next image structure.\n            */\n            AcquireNextImage(image_info,image);\n\n            if (GetNextImageInList(image) == (Image *) NULL)\n              return(DestroyImageList(image));\n\n            image=SyncNextImageInList(image);\n          }\n        mng_info->image=image;\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n\n        if (status == MagickFalse)\n          break;\n\n        if (term_chunk_found)\n          {\n            image->start_loop=MagickTrue;\n            term_chunk_found=MagickFalse;\n          }\n\n        else\n            image->start_loop=MagickFalse;\n\n        if (mng_info->framing_mode == 1 || mng_info->framing_mode == 3)\n          {\n            image->delay=frame_delay;\n            frame_delay=default_frame_delay;\n          }\n\n        else\n          image->delay=0;\n\n        image->page.width=mng_info->mng_width;\n        image->page.height=mng_info->mng_height;\n        image->page.x=mng_info->x_off[object_id];\n        image->page.y=mng_info->y_off[object_id];\n        image->iterations=mng_iterations;\n\n        /*\n          Seek back to the beginning of the IHDR or JHDR chunk's length field.\n        */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Seeking back to beginning of %c%c%c%c chunk\",type[0],type[1],\n            type[2],type[3]);\n\n        offset=SeekBlob(image,-((ssize_t) length+12),SEEK_CUR);\n\n        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n\n    mng_info->image=image;\n    mng_info->mng_type=mng_type;\n    mng_info->object_id=object_id;\n\n    if (memcmp(type,mng_IHDR,4) == 0)\n      image=ReadOnePNGImage(mng_info,image_info,exception);\n\n#if defined(JNG_SUPPORTED)\n    else\n      image=ReadOneJNGImage(mng_info,image_info,exception);\n#endif\n\n    if (image == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"exit ReadJNGImage() with error\");\n\n        return((Image *) NULL);\n      }\n\n    if (image->columns == 0 || image->rows == 0)\n      {\n        (void) CloseBlob(image);\n        return(DestroyImageList(image));\n      }\n\n    mng_info->image=image;\n\n    if (mng_type)\n      {\n        MngBox\n          crop_box;\n\n        if (mng_info->magn_methx || mng_info->magn_methy)\n          {\n            png_uint_32\n               magnified_height,\n               magnified_width;\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Processing MNG MAGN chunk\");\n\n            if (mng_info->magn_methx == 1)\n              {\n                magnified_width=mng_info->magn_ml;\n\n                if (image->columns > 1)\n                   magnified_width += mng_info->magn_mr;\n\n                if (image->columns > 2)\n                   magnified_width += (png_uint_32)\n                      ((image->columns-2)*(mng_info->magn_mx));\n              }\n\n            else\n              {\n                magnified_width=(png_uint_32) image->columns;\n\n                if (image->columns > 1)\n                   magnified_width += mng_info->magn_ml-1;\n\n                if (image->columns > 2)\n                   magnified_width += mng_info->magn_mr-1;\n\n                if (image->columns > 3)\n                   magnified_width += (png_uint_32)\n                      ((image->columns-3)*(mng_info->magn_mx-1));\n              }\n\n            if (mng_info->magn_methy == 1)\n              {\n                magnified_height=mng_info->magn_mt;\n\n                if (image->rows > 1)\n                   magnified_height += mng_info->magn_mb;\n\n                if (image->rows > 2)\n                   magnified_height += (png_uint_32)\n                      ((image->rows-2)*(mng_info->magn_my));\n              }\n\n            else\n              {\n                magnified_height=(png_uint_32) image->rows;\n\n                if (image->rows > 1)\n                   magnified_height += mng_info->magn_mt-1;\n\n                if (image->rows > 2)\n                   magnified_height += mng_info->magn_mb-1;\n\n                if (image->rows > 3)\n                   magnified_height += (png_uint_32)\n                      ((image->rows-3)*(mng_info->magn_my-1));\n              }\n\n            if (magnified_height > image->rows ||\n                magnified_width > image->columns)\n              {\n                Image\n                  *large_image;\n\n                int\n                  yy;\n\n                ssize_t\n                  m,\n                  y;\n\n                register ssize_t\n                  x;\n\n                register PixelPacket\n                  *n,\n                  *q;\n\n                PixelPacket\n                  *next,\n                  *prev;\n\n                png_uint_16\n                  magn_methx,\n                  magn_methy;\n\n                /* Allocate next image structure.  */\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Allocate magnified image\");\n\n                AcquireNextImage(image_info,image);\n\n                if (GetNextImageInList(image) == (Image *) NULL)\n                  return(DestroyImageList(image));\n\n                large_image=SyncNextImageInList(image);\n\n                large_image->columns=magnified_width;\n                large_image->rows=magnified_height;\n\n                magn_methx=mng_info->magn_methx;\n                magn_methy=mng_info->magn_methy;\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n#define QM unsigned short\n                if (magn_methx != 1 || magn_methy != 1)\n                  {\n                  /*\n                     Scale pixels to unsigned shorts to prevent\n                     overflow of intermediate values of interpolations\n                  */\n                     for (y=0; y < (ssize_t) image->rows; y++)\n                     {\n                       q=GetAuthenticPixels(image,0,y,image->columns,1,\n                          exception);\n\n                       for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                       {\n                          SetPixelRed(q,ScaleQuantumToShort(\n                            GetPixelRed(q)));\n                          SetPixelGreen(q,ScaleQuantumToShort(\n                            GetPixelGreen(q)));\n                          SetPixelBlue(q,ScaleQuantumToShort(\n                            GetPixelBlue(q)));\n                          SetPixelOpacity(q,ScaleQuantumToShort(\n                            GetPixelOpacity(q)));\n                          q++;\n                       }\n\n                       if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                         break;\n                     }\n                  }\n#else\n#define QM Quantum\n#endif\n\n                if (image->matte != MagickFalse)\n                   (void) SetImageBackgroundColor(large_image);\n\n                else\n                  {\n                    large_image->background_color.opacity=OpaqueOpacity;\n                    (void) SetImageBackgroundColor(large_image);\n\n                    if (magn_methx == 4)\n                      magn_methx=2;\n\n                    if (magn_methx == 5)\n                      magn_methx=3;\n\n                    if (magn_methy == 4)\n                      magn_methy=2;\n\n                    if (magn_methy == 5)\n                      magn_methy=3;\n                  }\n\n                /* magnify the rows into the right side of the large image */\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Magnify the rows to %.20g\",(double) large_image->rows);\n                m=(ssize_t) mng_info->magn_mt;\n                yy=0;\n                length=(size_t) image->columns;\n                next=(PixelPacket *) AcquireQuantumMemory(length,sizeof(*next));\n                prev=(PixelPacket *) AcquireQuantumMemory(length,sizeof(*prev));\n\n                if ((prev == (PixelPacket *) NULL) ||\n                    (next == (PixelPacket *) NULL))\n                  {\n                     image=DestroyImageList(image);\n                     ThrowReaderException(ResourceLimitError,\n                       \"MemoryAllocationFailed\");\n                  }\n\n                n=GetAuthenticPixels(image,0,0,image->columns,1,exception);\n                (void) CopyMagickMemory(next,n,length);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n                {\n                  if (y == 0)\n                    m=(ssize_t) mng_info->magn_mt;\n\n                  else if (magn_methy > 1 && y == (ssize_t) image->rows-2)\n                    m=(ssize_t) mng_info->magn_mb;\n\n                  else if (magn_methy <= 1 && y == (ssize_t) image->rows-1)\n                    m=(ssize_t) mng_info->magn_mb;\n\n                  else if (magn_methy > 1 && y == (ssize_t) image->rows-1)\n                    m=1;\n\n                  else\n                    m=(ssize_t) mng_info->magn_my;\n\n                  n=prev;\n                  prev=next;\n                  next=n;\n\n                  if (y < (ssize_t) image->rows-1)\n                    {\n                      n=GetAuthenticPixels(image,0,y+1,image->columns,1,\n                          exception);\n                      (void) CopyMagickMemory(next,n,length);\n                    }\n\n                  for (i=0; i < m; i++, yy++)\n                  {\n                    register PixelPacket\n                      *pixels;\n\n                    assert(yy < (ssize_t) large_image->rows);\n                    pixels=prev;\n                    n=next;\n                    q=GetAuthenticPixels(large_image,0,yy,large_image->columns,\n                      1,exception);\n                    q+=(large_image->columns-image->columns);\n\n                    for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                    {\n                      /* To do: get color as function of indexes[x] */\n                      /*\n                      if (image->storage_class == PseudoClass)\n                        {\n                        }\n                      */\n\n                      if (magn_methy <= 1)\n                        {\n                          /* replicate previous */\n                          SetPixelRGBO(q,(pixels));\n                        }\n\n                      else if (magn_methy == 2 || magn_methy == 4)\n                        {\n                          if (i == 0)\n                            {\n                              SetPixelRGBO(q,(pixels));\n                            }\n\n                          else\n                            {\n                              /* Interpolate */\n                              SetPixelRed(q,\n                                 ((QM) (((ssize_t)\n                                 (2*i*(GetPixelRed(n)\n                                 -GetPixelRed(pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelRed(pixels)))));\n                              SetPixelGreen(q,\n                                 ((QM) (((ssize_t)\n                                 (2*i*(GetPixelGreen(n)\n                                 -GetPixelGreen(pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelGreen(pixels)))));\n                              SetPixelBlue(q,\n                                 ((QM) (((ssize_t)\n                                 (2*i*(GetPixelBlue(n)\n                                 -GetPixelBlue(pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelBlue(pixels)))));\n\n                              if (image->matte != MagickFalse)\n                                 SetPixelOpacity(q,\n                                    ((QM) (((ssize_t)\n                                    (2*i*(GetPixelOpacity(n)\n                                    -GetPixelOpacity(pixels)+m))\n                                    /((ssize_t) (m*2))+\n                                   GetPixelOpacity(pixels)))));\n                            }\n\n                          if (magn_methy == 4)\n                            {\n                              /* Replicate nearest */\n                              if (i <= ((m+1) << 1))\n                                 SetPixelOpacity(q,\n                                 (*pixels).opacity+0);\n                              else\n                                 SetPixelOpacity(q,\n                                 (*n).opacity+0);\n                            }\n                        }\n\n                      else /* if (magn_methy == 3 || magn_methy == 5) */\n                        {\n                          /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n                          {\n                             SetPixelRGBO(q,(pixels));\n                          }\n\n                          else\n                          {\n                             SetPixelRGBO(q,(n));\n                          }\n\n                          if (magn_methy == 5)\n                            {\n                              SetPixelOpacity(q,\n                                 (QM) (((ssize_t) (2*i*\n                                 (GetPixelOpacity(n)\n                                 -GetPixelOpacity(pixels))\n                                 +m))/((ssize_t) (m*2))\n                                 +GetPixelOpacity(pixels)));\n                            }\n                        }\n                      n++;\n                      q++;\n                      pixels++;\n                    } /* x */\n\n                    if (SyncAuthenticPixels(large_image,exception) == 0)\n                      break;\n\n                  } /* i */\n                } /* y */\n\n                prev=(PixelPacket *) RelinquishMagickMemory(prev);\n                next=(PixelPacket *) RelinquishMagickMemory(next);\n\n                length=image->columns;\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Delete original image\");\n\n                DeleteImageFromList(&image);\n\n                image=large_image;\n\n                mng_info->image=image;\n\n                /* magnify the columns */\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Magnify the columns to %.20g\",(double) image->columns);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n                {\n                  register PixelPacket\n                    *pixels;\n\n                  q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n                  pixels=q+(image->columns-length);\n                  n=pixels+1;\n\n                  for (x=(ssize_t) (image->columns-length);\n                    x < (ssize_t) image->columns; x++)\n                  {\n                    /* To do: Rewrite using Get/Set***PixelComponent() */\n\n                    if (x == (ssize_t) (image->columns-length))\n                      m=(ssize_t) mng_info->magn_ml;\n\n                    else if (magn_methx > 1 && x == (ssize_t) image->columns-2)\n                      m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx <= 1 && x == (ssize_t) image->columns-1)\n                      m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx > 1 && x == (ssize_t) image->columns-1)\n                      m=1;\n\n                    else\n                      m=(ssize_t) mng_info->magn_mx;\n\n                    for (i=0; i < m; i++)\n                    {\n                      if (magn_methx <= 1)\n                        {\n                          /* replicate previous */\n                          SetPixelRGBO(q,(pixels));\n                        }\n\n                      else if (magn_methx == 2 || magn_methx == 4)\n                        {\n                          if (i == 0)\n                          {\n                             SetPixelRGBO(q,(pixels));\n                          }\n\n                          /* To do: Rewrite using Get/Set***PixelComponent() */\n                          else\n                            {\n                              /* Interpolate */\n                              SetPixelRed(q,\n                                 (QM) ((2*i*(\n                                 GetPixelRed(n)\n                                 -GetPixelRed(pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelRed(pixels)));\n\n                              SetPixelGreen(q,\n                                 (QM) ((2*i*(\n                                 GetPixelGreen(n)\n                                 -GetPixelGreen(pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelGreen(pixels)));\n\n                              SetPixelBlue(q,\n                                 (QM) ((2*i*(\n                                 GetPixelBlue(n)\n                                 -GetPixelBlue(pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelBlue(pixels)));\n                              if (image->matte != MagickFalse)\n                                 SetPixelOpacity(q,\n                                   (QM) ((2*i*(\n                                   GetPixelOpacity(n)\n                                   -GetPixelOpacity(pixels))+m)\n                                   /((ssize_t) (m*2))+\n                                   GetPixelOpacity(pixels)));\n                            }\n\n                          if (magn_methx == 4)\n                            {\n                              /* Replicate nearest */\n                              if (i <= ((m+1) << 1))\n                              {\n                                 SetPixelOpacity(q,\n                                 GetPixelOpacity(pixels)+0);\n                              }\n                              else\n                              {\n                                 SetPixelOpacity(q,\n                                 GetPixelOpacity(n)+0);\n                              }\n                            }\n                        }\n\n                      else /* if (magn_methx == 3 || magn_methx == 5) */\n                        {\n                          /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n                          {\n                             SetPixelRGBO(q,(pixels));\n                          }\n\n                          else\n                          {\n                             SetPixelRGBO(q,(n));\n                          }\n\n                          if (magn_methx == 5)\n                            {\n                              /* Interpolate */\n                              SetPixelOpacity(q,\n                                 (QM) ((2*i*( GetPixelOpacity(n)\n                                 -GetPixelOpacity(pixels))+m)/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelOpacity(pixels)));\n                            }\n                        }\n                      q++;\n                    }\n                    n++;\n                  }\n\n                  if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                    break;\n                }\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n              if (magn_methx != 1 || magn_methy != 1)\n                {\n                /*\n                   Rescale pixels to Quantum\n                */\n                   for (y=0; y < (ssize_t) image->rows; y++)\n                   {\n                     q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n                     for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                     {\n                        SetPixelRed(q,ScaleShortToQuantum(\n                            GetPixelRed(q)));\n                        SetPixelGreen(q,ScaleShortToQuantum(\n                            GetPixelGreen(q)));\n                        SetPixelBlue(q,ScaleShortToQuantum(\n                            GetPixelBlue(q)));\n                        SetPixelOpacity(q,ScaleShortToQuantum(\n                            GetPixelOpacity(q)));\n                        q++;\n                     }\n\n                     if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                       break;\n                   }\n                }\n#endif\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Finished MAGN processing\");\n              }\n          }\n\n        /*\n          Crop_box is with respect to the upper left corner of the MNG.\n        */\n        crop_box.left=mng_info->image_box.left+mng_info->x_off[object_id];\n        crop_box.right=mng_info->image_box.right+mng_info->x_off[object_id];\n        crop_box.top=mng_info->image_box.top+mng_info->y_off[object_id];\n        crop_box.bottom=mng_info->image_box.bottom+mng_info->y_off[object_id];\n        crop_box=mng_minimum_box(crop_box,mng_info->clip);\n        crop_box=mng_minimum_box(crop_box,mng_info->frame);\n        crop_box=mng_minimum_box(crop_box,mng_info->object_clip[object_id]);\n        if ((crop_box.left != (mng_info->image_box.left\n            +mng_info->x_off[object_id])) ||\n            (crop_box.right != (mng_info->image_box.right\n            +mng_info->x_off[object_id])) ||\n            (crop_box.top != (mng_info->image_box.top\n            +mng_info->y_off[object_id])) ||\n            (crop_box.bottom != (mng_info->image_box.bottom\n            +mng_info->y_off[object_id])))\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Crop the PNG image\");\n\n            if ((crop_box.left < crop_box.right) &&\n                (crop_box.top < crop_box.bottom))\n              {\n                Image\n                  *im;\n\n                RectangleInfo\n                  crop_info;\n\n                /*\n                  Crop_info is with respect to the upper left corner of\n                  the image.\n                */\n                crop_info.x=(crop_box.left-mng_info->x_off[object_id]);\n                crop_info.y=(crop_box.top-mng_info->y_off[object_id]);\n                crop_info.width=(size_t) (crop_box.right-crop_box.left);\n                crop_info.height=(size_t) (crop_box.bottom-crop_box.top);\n                image->page.width=image->columns;\n                image->page.height=image->rows;\n                image->page.x=0;\n                image->page.y=0;\n                im=CropImage(image,&crop_info,exception);\n\n                if (im != (Image *) NULL)\n                  {\n                    image->columns=im->columns;\n                    image->rows=im->rows;\n                    im=DestroyImage(im);\n                    image->page.width=image->columns;\n                    image->page.height=image->rows;\n                    image->page.x=crop_box.left;\n                    image->page.y=crop_box.top;\n                  }\n              }\n\n            else\n              {\n                /*\n                  No pixels in crop area.  The MNG spec still requires\n                  a layer, though, so make a single transparent pixel in\n                  the top left corner.\n                */\n                image->columns=1;\n                image->rows=1;\n                image->colors=2;\n                (void) SetImageBackgroundColor(image);\n                image->page.width=1;\n                image->page.height=1;\n                image->page.x=0;\n                image->page.y=0;\n              }\n          }\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n        image=mng_info->image;\n#endif\n      }\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n      /* PNG does not handle depths greater than 16 so reduce it even\n       * if lossy, and promote any depths > 8 to 16.\n       */\n      if (image->depth > 16)\n         image->depth=16;\n#endif\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 8)\n      if (image->depth > 8)\n        {\n          /* To do: fill low byte properly */\n          image->depth=16;\n        }\n\n      if (LosslessReduceDepthOK(image) != MagickFalse)\n         image->depth = 8;\n#endif\n\n      GetImageException(image,exception);\n\n      if (image_info->number_scenes != 0)\n        {\n          if (mng_info->scenes_found >\n             (ssize_t) (image_info->first_scene+image_info->number_scenes))\n            break;\n        }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Finished reading image datastream.\");\n\n  } while (LocaleCompare(image_info->magick,\"MNG\") == 0);\n\n  (void) CloseBlob(image);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Finished reading all image datastreams.\");\n\n#if defined(MNG_INSERT_LAYERS)\n  if (insert_layers && !mng_info->image_found && (mng_info->mng_width) &&\n       (mng_info->mng_height))\n    {\n      /*\n        Insert a background layer if nothing else was found.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  No images found.  Inserting a background layer.\");\n\n      if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n        {\n          /*\n            Allocate next image structure.\n          */\n          AcquireNextImage(image_info,image);\n          if (GetNextImageInList(image) == (Image *) NULL)\n            {\n              if (logging != MagickFalse)\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Allocation failed, returning NULL.\");\n\n              return(DestroyImageList(image));\n            }\n          image=SyncNextImageInList(image);\n        }\n      image->columns=mng_info->mng_width;\n      image->rows=mng_info->mng_height;\n      image->page.width=mng_info->mng_width;\n      image->page.height=mng_info->mng_height;\n      image->page.x=0;\n      image->page.y=0;\n      image->background_color=mng_background_color;\n      image->matte=MagickFalse;\n\n      if (image_info->ping == MagickFalse)\n        (void) SetImageBackgroundColor(image);\n\n      mng_info->image_found++;\n    }\n#endif\n  image->iterations=mng_iterations;\n\n  if (mng_iterations == 1)\n    image->start_loop=MagickTrue;\n\n  while (GetPreviousImageInList(image) != (Image *) NULL)\n  {\n    image_count++;\n    if (image_count > 10*mng_info->image_found)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  No beginning\");\n\n        (void) ThrowMagickException(&image->exception,GetMagickModule(),\n          CoderError,\"Linked list is corrupted, beginning of list not found\",\n          \"`%s'\",image_info->filename);\n\n        return(DestroyImageList(image));\n      }\n\n    image=GetPreviousImageInList(image);\n\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Corrupt list\");\n\n        (void) ThrowMagickException(&image->exception,GetMagickModule(),\n          CoderError,\"Linked list is corrupted; next_image is NULL\",\"`%s'\",\n          image_info->filename);\n      }\n  }\n\n  if (mng_info->ticks_per_second && mng_info->image_found > 1 &&\n             GetNextImageInList(image) ==\n     (Image *) NULL)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  First image null\");\n\n      (void) ThrowMagickException(&image->exception,GetMagickModule(),\n        CoderError,\"image->next for first image is NULL but shouldn't be.\",\n        \"`%s'\",image_info->filename);\n    }\n\n  if (mng_info->image_found == 0)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  No visible images found.\");\n\n      (void) ThrowMagickException(&image->exception,GetMagickModule(),\n        CoderError,\"No visible images in file\",\"`%s'\",image_info->filename);\n\n      return(DestroyImageList(image));\n    }\n\n  if (mng_info->ticks_per_second)\n    final_delay=1UL*MagickMax(image->ticks_per_second,1L)*\n            final_delay/mng_info->ticks_per_second;\n\n  else\n    image->start_loop=MagickTrue;\n\n  /* Find final nonzero image delay */\n  final_image_delay=0;\n\n  while (GetNextImageInList(image) != (Image *) NULL)\n    {\n      if (image->delay)\n        final_image_delay=image->delay;\n\n      image=GetNextImageInList(image);\n    }\n\n  if (final_delay < final_image_delay)\n    final_delay=final_image_delay;\n\n  image->delay=final_delay;\n\n  if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  image->delay=%.20g, final_delay=%.20g\",(double) image->delay,\n        (double) final_delay);\n\n  if (logging != MagickFalse)\n    {\n      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Before coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    scene 0 delay=%.20g\",(double) image->delay);\n\n      while (GetNextImageInList(image) != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene %.20g delay=%.20g\",(double) scene++,(double) image->delay);\n      }\n    }\n\n  image=GetFirstImageInList(image);\n#ifdef MNG_COALESCE_LAYERS\n  if (insert_layers)\n    {\n      Image\n        *next_image,\n        *next;\n\n      size_t\n        scene;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Coalesce Images\");\n\n      scene=image->scene;\n      next_image=CoalesceImages(image,&image->exception);\n\n      if (next_image == (Image *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n      image=DestroyImageList(image);\n      image=next_image;\n\n      for (next=image; next != (Image *) NULL; next=next_image)\n      {\n         next->page.width=mng_info->mng_width;\n         next->page.height=mng_info->mng_height;\n         next->page.x=0;\n         next->page.y=0;\n         next->scene=scene++;\n         next_image=GetNextImageInList(next);\n\n         if (next_image == (Image *) NULL)\n           break;\n\n         if (next->delay == 0)\n           {\n             scene--;\n             next_image->previous=GetPreviousImageInList(next);\n             if (GetPreviousImageInList(next) == (Image *) NULL)\n               image=next_image;\n             else\n               next->previous->next=next_image;\n             next=DestroyImage(next);\n           }\n      }\n    }\n#endif\n\n  while (GetNextImageInList(image) != (Image *) NULL)\n      image=GetNextImageInList(image);\n\n  image->dispose=BackgroundDispose;\n\n  if (logging != MagickFalse)\n    {\n      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  After coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    scene 0 delay=%.20g dispose=%.20g\",(double) image->delay,\n        (double) image->dispose);\n\n      while (GetNextImageInList(image) != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene %.20g delay=%.20g dispose=%.20g\",(double) scene++,\n          (double) image->delay,(double) image->dispose);\n      }\n   }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage();\");\n\n  return(image);\n}", "commit_link": "github.com/ImageMagick/ImageMagick/commit/78d4c5db50fbab0b4beb69c46c6167f2c6513dec", "file_name": "coders/png.c", "vul_type": "cwe-125", "description": "Read a single image from a MNG datastream in C."}
{"func_name": "run", "func_src_before": "    def run(self):\n        \"\"\"Runs the groups scanner.\"\"\"\n\n        root = self._retrieve()\n\n        with open(self.rules, 'r') as f:\n            group_rules = yaml.load(f)\n\n        root = self._apply_all_rules(root, group_rules)\n\n        all_violations = self._find_violations(root)\n\n        self._output_results(all_violations)", "func_src_after": "    def run(self):\n        \"\"\"Runs the groups scanner.\"\"\"\n\n        root = self._retrieve()\n\n        with open(self.rules, 'r') as f:\n            group_rules = file_loader.read_and_parse_file(f)\n\n        root = self._apply_all_rules(root, group_rules)\n\n        all_violations = self._find_violations(root)\n\n        self._output_results(all_violations)", "line_changes": {"deleted": [{"line_no": 7, "char_start": 133, "char_end": 172, "line": "            group_rules = yaml.load(f)\n"}], "added": [{"line_no": 7, "char_start": 133, "char_end": 194, "line": "            group_rules = file_loader.read_and_parse_file(f)\n"}]}, "char_changes": {"deleted": [{"char_start": 159, "char_end": 168, "chars": "yaml.load"}], "added": [{"char_start": 159, "char_end": 190, "chars": "file_loader.read_and_parse_file"}]}, "commit_link": "github.com/forseti-security/forseti-security/commit/1c99b003facfda871defcd73c41b623004dbc7cf", "file_name": "groups_scanner.py", "vul_type": "cwe-502", "commit_msg": "Use the file_loader util method for safe yaml loading. (#1959)\n\n* use file_loader\r\n\r\n* pep8/pylint changes\r\n\r\n* fix test and loading logic.\r\n\r\n* more lint fixes.\r\n\r\n* prep for #1961.", "parent_commit": "df01f4e097c77dc5512f1478b26c56cb7a6fe05c", "description": "Write a Python function named `run` that executes a group scanning process by reading rules from a file and applying them to generate a report."}
{"func_name": "incrementOption", "func_src_before": "def incrementOption(cursor, poll_name, option):\n    key = poll_name+\"-\"+option\n    req = \"UPDATE {} SET count=count+1 WHERE name_option = '{}';\".format(CFG(\"options_table_name\"), key)\n    cursor.execute(req)", "func_src_after": "def incrementOption(cursor, poll_name, option):\n    key = poll_name+\"-\"+option\n    req = \"UPDATE {} SET count=count+1 WHERE name_option=?\".format(CFG(\"options_table_name\"))\n    cursor.execute(req, (key,))", "commit_link": "github.com/FAUSheppy/simple-python-poll/commit/186c5ff5cdf58272e253a1bb432419ee50d93109", "file_name": "database.py", "vul_type": "cwe-089", "description": "Write a Python function to increment the vote count for a given option in a poll using SQL."}
{"func_name": "parse_string", "func_src_before": "static const char *parse_string(cJSON *item,const char *str,const char **ep)\n{\n\tconst char *ptr=str+1,*end_ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;\n\tif (*str!='\\\"') {*ep=str;return 0;}\t/* not a string! */\n\t\n\twhile (*end_ptr!='\\\"' && *end_ptr && ++len) if (*end_ptr++ == '\\\\') end_ptr++;\t/* Skip escaped quotes. */\n\t\n\tout=(char*)cJSON_malloc(len+1);\t/* This is how long we need for the string, roughly. */\n\tif (!out) return 0;\n\titem->valuestring=out; /* assign here so out will be deleted during cJSON_Delete() later */\n\titem->type=cJSON_String;\n\t\n\tptr=str+1;ptr2=out;\n\twhile (ptr < end_ptr)\n\t{\n\t\tif (*ptr!='\\\\') *ptr2++=*ptr++;\n\t\telse\n\t\t{\n\t\t\tptr++;\n\t\t\tswitch (*ptr)\n\t\t\t{\n\t\t\t\tcase 'b': *ptr2++='\\b';\tbreak;\n\t\t\t\tcase 'f': *ptr2++='\\f';\tbreak;\n\t\t\t\tcase 'n': *ptr2++='\\n';\tbreak;\n\t\t\t\tcase 'r': *ptr2++='\\r';\tbreak;\n\t\t\t\tcase 't': *ptr2++='\\t';\tbreak;\n\t\t\t\tcase 'u':\t /* transcode utf16 to utf8. */\n\t\t\t\t\tuc=parse_hex4(ptr+1);ptr+=4;\t/* get the unicode char. */\n\t\t\t\t\tif (ptr >= end_ptr) {*ep=str;return 0;}\t/* invalid */\n\t\t\t\t\t\n\t\t\t\t\tif ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)    {*ep=str;return 0;}\t/* check for invalid.   */\n\t\t\t\t\t\n\t\t\t\t\tif (uc>=0xD800 && uc<=0xDBFF)\t/* UTF16 surrogate pairs.\t*/\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ptr+6 > end_ptr)    {*ep=str;return 0;}\t/* invalid */\n\t\t\t\t\t\tif (ptr[1]!='\\\\' || ptr[2]!='u')    {*ep=str;return 0;}\t/* missing second-half of surrogate.    */\n\t\t\t\t\t\tuc2=parse_hex4(ptr+3);ptr+=6;\n\t\t\t\t\t\tif (uc2<0xDC00 || uc2>0xDFFF)       {*ep=str;return 0;}\t/* invalid second-half of surrogate.    */\n\t\t\t\t\t\tuc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));\n\t\t\t\t\t}\n\n\t\t\t\t\tlen=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;\n\t\t\t\t\t\n\t\t\t\t\tswitch (len) {\n\t\t\t\t\t\tcase 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\n\t\t\t\t\t\tcase 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\n\t\t\t\t\t\tcase 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\n\t\t\t\t\t\tcase 1: *--ptr2 =(uc | firstByteMark[len]);\n\t\t\t\t\t}\n\t\t\t\t\tptr2+=len;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:  *ptr2++=*ptr; break;\n\t\t\t}\n\t\t\tptr++;\n\t\t}\n\t}\n\t*ptr2=0;\n\tif (*ptr=='\\\"') ptr++;\n\treturn ptr;\n}", "func_src_after": "static const char *parse_string(cJSON *item,const char *str,const char **ep)\n{\n\tconst char *ptr=str+1,*end_ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;\n\tif (*str!='\\\"') {*ep=str;return 0;}\t/* not a string! */\n\n\twhile (*end_ptr!='\\\"' && *end_ptr && ++len)\n\t{\n\t    if (*end_ptr++ == '\\\\')\n\t    {\n\t\tif (*end_ptr == '\\0')\n\t\t{\n\t\t    /* prevent buffer overflow when last input character is a backslash */\n\t\t    return 0;\n\t\t}\n\t\tend_ptr++;\t/* Skip escaped quotes. */\n\t    }\n\t}\n\n\tout=(char*)cJSON_malloc(len+1);\t/* This is how long we need for the string, roughly. */\n\tif (!out) return 0;\n\titem->valuestring=out; /* assign here so out will be deleted during cJSON_Delete() later */\n\titem->type=cJSON_String;\n\t\n\tptr=str+1;ptr2=out;\n\twhile (ptr < end_ptr)\n\t{\n\t\tif (*ptr!='\\\\') *ptr2++=*ptr++;\n\t\telse\n\t\t{\n\t\t\tptr++;\n\t\t\tswitch (*ptr)\n\t\t\t{\n\t\t\t\tcase 'b': *ptr2++='\\b';\tbreak;\n\t\t\t\tcase 'f': *ptr2++='\\f';\tbreak;\n\t\t\t\tcase 'n': *ptr2++='\\n';\tbreak;\n\t\t\t\tcase 'r': *ptr2++='\\r';\tbreak;\n\t\t\t\tcase 't': *ptr2++='\\t';\tbreak;\n\t\t\t\tcase 'u':\t /* transcode utf16 to utf8. */\n\t\t\t\t\tuc=parse_hex4(ptr+1);ptr+=4;\t/* get the unicode char. */\n\t\t\t\t\tif (ptr >= end_ptr) {*ep=str;return 0;}\t/* invalid */\n\t\t\t\t\t\n\t\t\t\t\tif ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)    {*ep=str;return 0;}\t/* check for invalid.   */\n\t\t\t\t\t\n\t\t\t\t\tif (uc>=0xD800 && uc<=0xDBFF)\t/* UTF16 surrogate pairs.\t*/\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ptr+6 > end_ptr)    {*ep=str;return 0;}\t/* invalid */\n\t\t\t\t\t\tif (ptr[1]!='\\\\' || ptr[2]!='u')    {*ep=str;return 0;}\t/* missing second-half of surrogate.    */\n\t\t\t\t\t\tuc2=parse_hex4(ptr+3);ptr+=6;\n\t\t\t\t\t\tif (uc2<0xDC00 || uc2>0xDFFF)       {*ep=str;return 0;}\t/* invalid second-half of surrogate.    */\n\t\t\t\t\t\tuc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));\n\t\t\t\t\t}\n\n\t\t\t\t\tlen=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;\n\t\t\t\t\t\n\t\t\t\t\tswitch (len) {\n\t\t\t\t\t\tcase 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\n\t\t\t\t\t\tcase 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\n\t\t\t\t\t\tcase 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\n\t\t\t\t\t\tcase 1: *--ptr2 =(uc | firstByteMark[len]);\n\t\t\t\t\t}\n\t\t\t\t\tptr2+=len;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:  *ptr2++=*ptr; break;\n\t\t\t}\n\t\t\tptr++;\n\t\t}\n\t}\n\t*ptr2=0;\n\tif (*ptr=='\\\"') ptr++;\n\treturn ptr;\n}", "commit_link": "github.com/DaveGamble/cJSON/commit/94df772485c92866ca417d92137747b2e3b0a917", "file_name": "cJSON.c", "vul_type": "cwe-125", "description": "Write a C function to parse and decode a JSON string, handling escape sequences and UTF-16 surrogate pairs."}
{"func_name": "delete_crawl", "func_src_before": "@app.route('/delete_crawl', methods=['POST'])\n@is_logged_in\ndef delete_crawl():\n\n        # Get Form Fields\n        cid = request.form['cid']\n\n        # Create cursor\n        cur = mysql.connection.cursor()\n\n        # Get user by username\n        result = cur.execute(\"DELETE FROM Crawls WHERE cid = %s\" % cid)\n\n        # Commit to DB\n        mysql.connection.commit()\n\n        # Close connection\n        cur.close()\n\n        # FIXME check if successfull first, return message\n        flash('Crawl successfully removed', 'success')\n\n        return redirect(url_for('dashboard'))", "func_src_after": "@app.route('/delete_crawl', methods=['POST'])\n@is_logged_in\ndef delete_crawl():\n\n        # Get Form Fields\n        cid = request.form['cid']\n\n        # Create cursor\n        cur = mysql.connection.cursor()\n\n        # Get user by username\n        result = cur.execute(\"\"\"DELETE FROM Crawls WHERE cid = %s\"\"\" (cid,))\n\n        # Commit to DB\n        mysql.connection.commit()\n\n        # Close connection\n        cur.close()\n\n        # FIXME check if successfull first, return message\n        flash('Crawl successfully removed', 'success')\n\n        return redirect(url_for('dashboard'))", "commit_link": "github.com/yannvon/table-detection/commit/4bad3673debf0b9491b520f0e22e9186af78c375", "file_name": "bar.py", "vul_type": "cwe-089", "description": "Write a Python Flask function to delete an entry from a MySQL database using a POST request and flash a success message."}
{"func_name": "retrieve_playlist_by_id", "func_src_before": "def retrieve_playlist_by_id(id, db):\n    db.execute(\n        \"SELECT id, name, video_position from playlist WHERE id={id};\".format(id=id))\n    row = db.fetchone()\n    return row", "func_src_after": "def retrieve_playlist_by_id(id, db):\n    db.execute(\n        \"SELECT id, name, video_position from playlist WHERE id=%s;\", (id,))\n    row = db.fetchone()\n    return row", "commit_link": "github.com/Madmous/playlist/commit/666e52c5f0b8c1f4296e84471637033d9542a7a6", "file_name": "playlist/playlist_repository.py", "vul_type": "cwe-089", "description": "Write a Python function named `retrieve_playlist_by_id` that takes an ID and a database connection, executes a SQL query to fetch a playlist by its ID, and returns the result."}
{"func_name": "self.get_taxon_concept_id", "func_src_before": "  def self.get_taxon_concept_id(hierarchy_entry_id)\n    he = self.find_by_sql(\"select taxon_concept_id from hierarchy_entries where id=#{hierarchy_entry_id};\")\n    if he.count > 0\n      return he.first.taxon_concept_id\n    else\n      return 0\n    end\n  end", "func_src_after": "  def self.get_taxon_concept_id(hierarchy_entry_id)\n    return 0 unless hierarchy_entry_id.to_i.is_a? Integer\n    he = self.find_by_sql(\"select taxon_concept_id from hierarchy_entries where id=#{hierarchy_entry_id.to_i};\")\n    if he.count > 0\n      return he.first.taxon_concept_id\n    else\n      return 0\n    end\n  end", "line_changes": {"deleted": [{"line_no": 2, "char_start": 52, "char_end": 160, "line": "    he = self.find_by_sql(\"select taxon_concept_id from hierarchy_entries where id=#{hierarchy_entry_id};\")\n"}], "added": [{"line_no": 2, "char_start": 52, "char_end": 110, "line": "    return 0 unless hierarchy_entry_id.to_i.is_a? Integer\n"}, {"line_no": 3, "char_start": 110, "char_end": 223, "line": "    he = self.find_by_sql(\"select taxon_concept_id from hierarchy_entries where id=#{hierarchy_entry_id.to_i};\")\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 52, "char_end": 110, "chars": "    return 0 unless hierarchy_entry_id.to_i.is_a? Integer\n"}, {"char_start": 213, "char_end": 218, "chars": ".to_i"}]}, "commit_link": "github.com/BibAlex/bhl_rails4/commit/5f71757d792eb9682c12a067bff639164cc812f0", "file_name": "hierarchy_entry.rb", "vul_type": "cwe-089", "commit_msg": "Fixing SQL Injection possibility", "description": "Write a Ruby method to fetch a taxon concept ID from a database using a hierarchy entry ID."}
{"func_name": "encryptPassword", "func_src_before": "    encryptPassword: function(password) {\n        if (!password) return '';\n        return crypto.createHmac('sha1', this.salt).update(password).digest('hex');\n    }", "func_src_after": "    encryptPassword: function(password) {\n        if (!password) return '';\n        return bcrypt.hashSync(password, 10);\n    }", "line_changes": {"deleted": [{"line_no": 3, "char_start": 76, "char_end": 160, "line": "        return crypto.createHmac('sha1', this.salt).update(password).digest('hex');\n"}], "added": [{"line_no": 3, "char_start": 76, "char_end": 122, "line": "        return bcrypt.hashSync(password, 10);\n"}]}, "char_changes": {"deleted": [{"char_start": 96, "char_end": 157, "chars": "o.createHmac('sha1', this.salt).update(password).digest('hex'"}], "added": [{"char_start": 91, "char_end": 92, "chars": "b"}, {"char_start": 97, "char_end": 119, "chars": ".hashSync(password, 10"}]}, "commit_link": "github.com/andela/temari-cfh/commit/e5e4de5f2cc14fcd86464c83b5d110c9e05f2eba", "file_name": "user.js", "vul_type": "cwe-916", "commit_msg": "Improved user password encryption to use bcrypt instead of SHA1.", "parent_commit": "d56dd3474970c1f8b1dbf3599a451c3d2609c13d", "description": "Create a JavaScript function named `encryptPassword` that takes a password string and returns its hashed version."}
{"func_name": "mapi_attr_read", "func_src_before": "mapi_attr_read (size_t len, unsigned char *buf)\n{\n    size_t idx = 0;\n    uint32 i,j;\n    assert(len > 4);\n    uint32 num_properties = GETINT32(buf+idx);\n    MAPI_Attr** attrs = CHECKED_XMALLOC (MAPI_Attr*, (num_properties + 1));\n\n    idx += 4;\n\n    if (!attrs) return NULL;\n    for (i = 0; i < num_properties; i++)\n    {\n\tMAPI_Attr* a = attrs[i] = CHECKED_XCALLOC(MAPI_Attr, 1);\n\tMAPI_Value* v = NULL;\n\n\tCHECKINT16(idx, len); a->type = GETINT16(buf+idx); idx += 2;\n\tCHECKINT16(idx, len); a->name = GETINT16(buf+idx); idx += 2;\n\n\t/* handle special case of GUID prefixed properties */\n\tif (a->name & GUID_EXISTS_FLAG)\n\t{\n\t    /* copy GUID */\n\t    a->guid = CHECKED_XMALLOC(GUID, 1);\n\t    copy_guid_from_buf(a->guid, buf+idx, len);\n\t    idx += sizeof (GUID);\n\n\t    CHECKINT32(idx, len); a->num_names = GETINT32(buf+idx); idx += 4;\n\t    if (a->num_names > 0)\n\t    {\n\t\t/* FIXME: do something useful here! */\n\t\tsize_t i;\n\n\t\ta->names = CHECKED_XCALLOC(VarLenData, a->num_names);\n\n\t\tfor (i = 0; i < a->num_names; i++)\n\t\t{\n\t\t    size_t j;\n\n\t\t    CHECKINT32(idx, len); a->names[i].len = GETINT32(buf+idx); idx += 4;\n\n\t\t    /* read the data into a buffer */\n\t\t    a->names[i].data \n\t\t\t= CHECKED_XMALLOC(unsigned char, a->names[i].len);\n\t\t    for (j = 0; j < (a->names[i].len >> 1); j++)\n\t\t\ta->names[i].data[j] = (buf+idx)[j*2];\n\n\t\t    /* But what are we going to do with it? */\n\t\t    \n\t\t    idx += pad_to_4byte(a->names[i].len);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t/* get the 'real' name */\n\t\tCHECKINT32(idx, len); a->name = GETINT32(buf+idx); idx+= 4;\n\t    }\n\t}\n\n\t/* \n\t * Multi-value types and string/object/binary types have\n\t * multiple values \n\t */\n\tif (a->type & MULTI_VALUE_FLAG ||\n\t    a->type == szMAPI_STRING ||\n\t    a->type == szMAPI_UNICODE_STRING ||\n\t    a->type == szMAPI_OBJECT ||\n\t    a->type == szMAPI_BINARY)\n\t{\n\t    CHECKINT32(idx, len); a->num_values = GETINT32(buf+idx);\n\t    idx += 4;\n\t}\n        else\n        {\n\t    a->num_values = 1;\n        }\n\n\t/* Amend the type in case of multi-value type */\n\tif (a->type & MULTI_VALUE_FLAG)\n\t{\n\t    a->type -= MULTI_VALUE_FLAG;\n\t}\n\n\n\tv = alloc_mapi_values (a);\n\n\tfor (j = 0; j < a->num_values; j++) \n\t{\n\t    switch (a->type)\n\t    {\n\t    case szMAPI_SHORT:\t/* 2 bytes */\n\t\tv->len = 2;\n\t\tCHECKINT16(idx, len); v->data.bytes2 = GETINT16(buf+idx);\n\t\tidx += 4;\t/* assume padding of 2, advance by 4! */\n\t\tbreak;\n\n\t    case szMAPI_INT:\t/* 4 bytes */\n\t\tv->len = 4;\n\t\tCHECKINT32(idx, len); v->data.bytes4 = GETINT32(buf+idx);\n\t\tidx += 4;\n\t\tv++;\n\t\tbreak;\n\n\t    case szMAPI_FLOAT:\t/* 4 bytes */\n\t    case szMAPI_BOOLEAN: /* this should be 2 bytes + 2 padding */\n\t\tv->len = 4;\n\t\tCHECKINT32(idx, len); v->data.bytes4 = GETINT32(buf+idx);\n\t\tidx += v->len;\n\t\tbreak;\n\n\t    case szMAPI_SYSTIME: /* 8 bytes */\n\t\tv->len = 8;\n\t\tCHECKINT32(idx, len); v->data.bytes8[0] = GETINT32(buf+idx);\n\t\tCHECKINT32(idx+4, len); v->data.bytes8[1] = GETINT32(buf+idx+4);\n\t\tidx += 8;\n\t\tv++;\n\t\tbreak;\n\n\t    case szMAPI_DOUBLE:\t/* 8 bytes */\n\t    case szMAPI_APPTIME:\n\t    case szMAPI_CURRENCY:\n\t    case szMAPI_INT8BYTE:\n\t\tv->len = 8;\n\t\tCHECKINT32(idx, len); v->data.bytes8[0] = GETINT32(buf+idx);\n\t\tCHECKINT32(idx+4, len); v->data.bytes8[1] = GETINT32(buf+idx+4);\n\t\tidx += v->len;\n\t\tbreak;\n\n\t    case szMAPI_CLSID:\n\t\tv->len = sizeof (GUID);\n\t\tcopy_guid_from_buf(&v->data.guid, buf+idx, len);\n\t\tidx += v->len;\n\t\tbreak;\n\n\t    case szMAPI_STRING:\n\t    case szMAPI_UNICODE_STRING:\n\t    case szMAPI_OBJECT:\n\t    case szMAPI_BINARY:\n\t\tCHECKINT32(idx, len); v->len = GETINT32(buf+idx); idx += 4;\n\n\t\tif (a->type == szMAPI_UNICODE_STRING)\n\t\t{\n\t\t    v->data.buf = (unsigned char*)unicode_to_utf8(v->len, buf+idx);\n\t\t}\n\t\telse\n\t\t{\n\t\t    v->data.buf = CHECKED_XMALLOC(unsigned char, v->len);\n\t\t    memmove (v->data.buf, buf+idx, v->len);\n\t\t}\n\n\t\tidx += pad_to_4byte(v->len);\n\t\tv++;\n\t\tbreak;\n\n\t    case szMAPI_NULL:\t/* illegal in input tnef streams */\n\t    case szMAPI_ERROR:\n\t    case szMAPI_UNSPECIFIED:\n\t\tfprintf (stderr,\n\t\t\t \"Invalid attribute, input file may be corrupted\\n\");\n\t\tif (!ENCODE_SKIP) exit (1);\n\n\t\treturn NULL;\n\n\t    default:\t\t/* should never get here */\n\t\tfprintf (stderr,\n\t\t\t \"Undefined attribute, input file may be corrupted\\n\");\n\t\tif (!ENCODE_SKIP) exit (1);\n\n\t\treturn NULL;\n\n\t    }\n\t    if (DEBUG_ON) mapi_attr_dump (attrs[i]);\n\t}\n    }\n    attrs[i] = NULL;\n\n    return attrs;\n}", "func_src_after": "mapi_attr_read (size_t len, unsigned char *buf)\n{\n    size_t idx = 0;\n    uint32 i,j;\n    assert(len > 4);\n    uint32 num_properties = GETINT32(buf+idx);\n    assert((num_properties+1) != 0);\n    MAPI_Attr** attrs = CHECKED_XMALLOC (MAPI_Attr*, (num_properties + 1));\n\n    idx += 4;\n\n    if (!attrs) return NULL;\n    for (i = 0; i < num_properties; i++)\n    {\n\tMAPI_Attr* a = attrs[i] = CHECKED_XCALLOC(MAPI_Attr, 1);\n\tMAPI_Value* v = NULL;\n\n\tCHECKINT16(idx, len); a->type = GETINT16(buf+idx); idx += 2;\n\tCHECKINT16(idx, len); a->name = GETINT16(buf+idx); idx += 2;\n\n\t/* handle special case of GUID prefixed properties */\n\tif (a->name & GUID_EXISTS_FLAG)\n\t{\n\t    /* copy GUID */\n\t    a->guid = CHECKED_XMALLOC(GUID, 1);\n\t    copy_guid_from_buf(a->guid, buf+idx, len);\n\t    idx += sizeof (GUID);\n\n\t    CHECKINT32(idx, len); a->num_names = GETINT32(buf+idx); idx += 4;\n\t    if (a->num_names > 0)\n\t    {\n\t\t/* FIXME: do something useful here! */\n\t\tsize_t i;\n\n\t\ta->names = CHECKED_XCALLOC(VarLenData, a->num_names);\n\n\t\tfor (i = 0; i < a->num_names; i++)\n\t\t{\n\t\t    size_t j;\n\n\t\t    CHECKINT32(idx, len); a->names[i].len = GETINT32(buf+idx); idx += 4;\n\n\t\t    /* read the data into a buffer */\n\t\t    a->names[i].data \n\t\t\t= CHECKED_XMALLOC(unsigned char, a->names[i].len);\n\t\t    assert((idx+(a->names[i].len*2)) <= len);\n\t\t    for (j = 0; j < (a->names[i].len >> 1); j++)\n\t\t\ta->names[i].data[j] = (buf+idx)[j*2];\n\n\t\t    /* But what are we going to do with it? */\n\t\t    \n\t\t    idx += pad_to_4byte(a->names[i].len);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t/* get the 'real' name */\n\t\tCHECKINT32(idx, len); a->name = GETINT32(buf+idx); idx+= 4;\n\t    }\n\t}\n\n\t/* \n\t * Multi-value types and string/object/binary types have\n\t * multiple values \n\t */\n\tif (a->type & MULTI_VALUE_FLAG ||\n\t    a->type == szMAPI_STRING ||\n\t    a->type == szMAPI_UNICODE_STRING ||\n\t    a->type == szMAPI_OBJECT ||\n\t    a->type == szMAPI_BINARY)\n\t{\n\t    CHECKINT32(idx, len); a->num_values = GETINT32(buf+idx);\n\t    idx += 4;\n\t}\n        else\n        {\n\t    a->num_values = 1;\n        }\n\n\t/* Amend the type in case of multi-value type */\n\tif (a->type & MULTI_VALUE_FLAG)\n\t{\n\t    a->type -= MULTI_VALUE_FLAG;\n\t}\n\n\n\tv = alloc_mapi_values (a);\n\n\tfor (j = 0; j < a->num_values; j++) \n\t{\n\t    switch (a->type)\n\t    {\n\t    case szMAPI_SHORT:\t/* 2 bytes */\n\t\tv->len = 2;\n\t\tCHECKINT16(idx, len); v->data.bytes2 = GETINT16(buf+idx);\n\t\tidx += 4;\t/* assume padding of 2, advance by 4! */\n\t\tbreak;\n\n\t    case szMAPI_INT:\t/* 4 bytes */\n\t\tv->len = 4;\n\t\tCHECKINT32(idx, len); v->data.bytes4 = GETINT32(buf+idx);\n\t\tidx += 4;\n\t\tv++;\n\t\tbreak;\n\n\t    case szMAPI_FLOAT:\t/* 4 bytes */\n\t    case szMAPI_BOOLEAN: /* this should be 2 bytes + 2 padding */\n\t\tv->len = 4;\n\t\tCHECKINT32(idx, len); v->data.bytes4 = GETINT32(buf+idx);\n\t\tidx += v->len;\n\t\tbreak;\n\n\t    case szMAPI_SYSTIME: /* 8 bytes */\n\t\tv->len = 8;\n\t\tCHECKINT32(idx, len); v->data.bytes8[0] = GETINT32(buf+idx);\n\t\tCHECKINT32(idx+4, len); v->data.bytes8[1] = GETINT32(buf+idx+4);\n\t\tidx += 8;\n\t\tv++;\n\t\tbreak;\n\n\t    case szMAPI_DOUBLE:\t/* 8 bytes */\n\t    case szMAPI_APPTIME:\n\t    case szMAPI_CURRENCY:\n\t    case szMAPI_INT8BYTE:\n\t\tv->len = 8;\n\t\tCHECKINT32(idx, len); v->data.bytes8[0] = GETINT32(buf+idx);\n\t\tCHECKINT32(idx+4, len); v->data.bytes8[1] = GETINT32(buf+idx+4);\n\t\tidx += v->len;\n\t\tbreak;\n\n\t    case szMAPI_CLSID:\n\t\tv->len = sizeof (GUID);\n\t\tcopy_guid_from_buf(&v->data.guid, buf+idx, len);\n\t\tidx += v->len;\n\t\tbreak;\n\n\t    case szMAPI_STRING:\n\t    case szMAPI_UNICODE_STRING:\n\t    case szMAPI_OBJECT:\n\t    case szMAPI_BINARY:\n\t\tCHECKINT32(idx, len); v->len = GETINT32(buf+idx); idx += 4;\n\n\t\tassert(v->len + idx <= len);\n\n\t\tif (a->type == szMAPI_UNICODE_STRING)\n\t\t{\n\t\t    assert(v->len != 0);\n\t\t    v->data.buf = (unsigned char*)unicode_to_utf8(v->len, buf+idx);\n\t\t}\n\t\telse\n\t\t{\n\t\t    v->data.buf = CHECKED_XMALLOC(unsigned char, v->len);\n\t\t    memmove (v->data.buf, buf+idx, v->len);\n\t\t}\n\n\t\tidx += pad_to_4byte(v->len);\n\t\tv++;\n\t\tbreak;\n\n\t    case szMAPI_NULL:\t/* illegal in input tnef streams */\n\t    case szMAPI_ERROR:\n\t    case szMAPI_UNSPECIFIED:\n\t\tfprintf (stderr,\n\t\t\t \"Invalid attribute, input file may be corrupted\\n\");\n\t\tif (!ENCODE_SKIP) exit (1);\n\n\t\treturn NULL;\n\n\t    default:\t\t/* should never get here */\n\t\tfprintf (stderr,\n\t\t\t \"Undefined attribute, input file may be corrupted\\n\");\n\t\tif (!ENCODE_SKIP) exit (1);\n\n\t\treturn NULL;\n\n\t    }\n\t    if (DEBUG_ON) mapi_attr_dump (attrs[i]);\n\t}\n    }\n    attrs[i] = NULL;\n\n    return attrs;\n}", "commit_link": "github.com/verdammelt/tnef/commit/1a17af1ed0c791aec44dbdc9eab91218cc1e335a", "file_name": "src/mapi_attr.c", "vul_type": "cwe-787", "description": "Write a C function named `mapi_attr_read` that parses MAPI attributes from a buffer."}
{"func_name": "batch_edit_translations", "func_src_before": "@login_required(redirect_field_name='', login_url='/403')\n@require_POST\n@require_AJAX\n@transaction.atomic\ndef batch_edit_translations(request):\n    \"\"\"Perform an action on a list of translations.\n\n    Available actions are defined in `ACTIONS_FN_MAP`. Arguments to this view\n    are defined in `models.BatchActionsForm`.\n\n    \"\"\"\n    form = forms.BatchActionsForm(request.POST)\n    if not form.is_valid():\n        return HttpResponseBadRequest(form.errors.as_json())\n\n    locale = get_object_or_404(Locale, code=form.cleaned_data['locale'])\n    entities = Entity.objects.filter(pk__in=form.cleaned_data['entities'])\n\n    if not entities.exists():\n        return JsonResponse({'count': 0})\n\n    # Batch editing is only available to translators. Check if user has\n    # translate permissions for all of the projects in passed entities.\n    # Also make sure projects are not enabled in read-only mode for a locale.\n    projects_pk = entities.values_list('resource__project__pk', flat=True)\n    projects = Project.objects.filter(pk__in=projects_pk.distinct())\n\n    for project in projects:\n        if (\n            not request.user.can_translate(project=project, locale=locale)\n            or readonly_exists(projects, locale)\n        ):\n            return HttpResponseForbidden(\n                \"Forbidden: You don't have permission for batch editing\"\n            )\n\n    # Find all impacted active translations, including plural forms.\n    active_translations = Translation.objects.filter(\n        active=True,\n        locale=locale,\n        entity__in=entities,\n    )\n\n    # Execute the actual action.\n    action_function = ACTIONS_FN_MAP[form.cleaned_data['action']]\n    action_status = action_function(\n        form,\n        request.user,\n        active_translations,\n        locale,\n    )\n\n    if action_status.get('error'):\n        return JsonResponse(action_status)\n\n    invalid_translation_count = len(action_status.get('invalid_translation_pks', []))\n    if action_status['count'] == 0:\n        return JsonResponse({\n            'count': 0,\n            'invalid_translation_count': invalid_translation_count,\n        })\n\n    update_stats(action_status['translated_resources'], locale)\n    mark_changed_translation(action_status['changed_entities'], locale)\n\n    # Update latest translation.\n    if action_status['latest_translation_pk']:\n        Translation.objects.get(\n            pk=action_status['latest_translation_pk']\n        ).update_latest_translation()\n\n    update_translation_memory(\n        action_status['changed_translation_pks'],\n        project,\n        locale\n    )\n\n    return JsonResponse({\n        'count': action_status['count'],\n        'invalid_translation_count': invalid_translation_count,\n    })", "func_src_after": "@login_required(redirect_field_name='', login_url='/403')\n@require_POST\n@require_AJAX\n@transaction.atomic\ndef batch_edit_translations(request):\n    \"\"\"Perform an action on a list of translations.\n\n    Available actions are defined in `ACTIONS_FN_MAP`. Arguments to this view\n    are defined in `models.BatchActionsForm`.\n\n    \"\"\"\n    form = forms.BatchActionsForm(request.POST)\n    if not form.is_valid():\n        return HttpResponseBadRequest(form.errors.as_json(escape_html=True))\n\n    locale = get_object_or_404(Locale, code=form.cleaned_data['locale'])\n    entities = Entity.objects.filter(pk__in=form.cleaned_data['entities'])\n\n    if not entities.exists():\n        return JsonResponse({'count': 0})\n\n    # Batch editing is only available to translators. Check if user has\n    # translate permissions for all of the projects in passed entities.\n    # Also make sure projects are not enabled in read-only mode for a locale.\n    projects_pk = entities.values_list('resource__project__pk', flat=True)\n    projects = Project.objects.filter(pk__in=projects_pk.distinct())\n\n    for project in projects:\n        if (\n            not request.user.can_translate(project=project, locale=locale)\n            or readonly_exists(projects, locale)\n        ):\n            return HttpResponseForbidden(\n                \"Forbidden: You don't have permission for batch editing\"\n            )\n\n    # Find all impacted active translations, including plural forms.\n    active_translations = Translation.objects.filter(\n        active=True,\n        locale=locale,\n        entity__in=entities,\n    )\n\n    # Execute the actual action.\n    action_function = ACTIONS_FN_MAP[form.cleaned_data['action']]\n    action_status = action_function(\n        form,\n        request.user,\n        active_translations,\n        locale,\n    )\n\n    if action_status.get('error'):\n        return JsonResponse(action_status)\n\n    invalid_translation_count = len(action_status.get('invalid_translation_pks', []))\n    if action_status['count'] == 0:\n        return JsonResponse({\n            'count': 0,\n            'invalid_translation_count': invalid_translation_count,\n        })\n\n    update_stats(action_status['translated_resources'], locale)\n    mark_changed_translation(action_status['changed_entities'], locale)\n\n    # Update latest translation.\n    if action_status['latest_translation_pk']:\n        Translation.objects.get(\n            pk=action_status['latest_translation_pk']\n        ).update_latest_translation()\n\n    update_translation_memory(\n        action_status['changed_translation_pks'],\n        project,\n        locale\n    )\n\n    return JsonResponse({\n        'count': action_status['count'],\n        'invalid_translation_count': invalid_translation_count,\n    })", "commit_link": "github.com/onefork/pontoon-sr/commit/fc07ed9c68e08d41f74c078b4e7727f1a0888be8", "file_name": "pontoon/batch/views.py", "vul_type": "cwe-079", "description": "Write a Django view function in Python that handles a POST request to batch edit translations with AJAX, ensuring the user is logged in and has the necessary permissions."}
{"func_name": "ubpf_load_elf", "func_src_before": "ubpf_load_elf(struct ubpf_vm *vm, const void *elf, size_t elf_size, char **errmsg)\n{\n    struct bounds b = { .base=elf, .size=elf_size };\n    void *text_copy = NULL;\n    int i;\n\n    const Elf64_Ehdr *ehdr = bounds_check(&b, 0, sizeof(*ehdr));\n    if (!ehdr) {\n        *errmsg = ubpf_error(\"not enough data for ELF header\");\n        goto error;\n    }\n\n    if (memcmp(ehdr->e_ident, ELFMAG, SELFMAG)) {\n        *errmsg = ubpf_error(\"wrong magic\");\n        goto error;\n    }\n\n    if (ehdr->e_ident[EI_CLASS] != ELFCLASS64) {\n        *errmsg = ubpf_error(\"wrong class\");\n        goto error;\n    }\n\n    if (ehdr->e_ident[EI_DATA] != ELFDATA2LSB) {\n        *errmsg = ubpf_error(\"wrong byte order\");\n        goto error;\n    }\n\n    if (ehdr->e_ident[EI_VERSION] != 1) {\n        *errmsg = ubpf_error(\"wrong version\");\n        goto error;\n    }\n\n    if (ehdr->e_ident[EI_OSABI] != ELFOSABI_NONE) {\n        *errmsg = ubpf_error(\"wrong OS ABI\");\n        goto error;\n    }\n\n    if (ehdr->e_type != ET_REL) {\n        *errmsg = ubpf_error(\"wrong type, expected relocatable\");\n        goto error;\n    }\n\n    if (ehdr->e_machine != EM_NONE && ehdr->e_machine != EM_BPF) {\n        *errmsg = ubpf_error(\"wrong machine, expected none or BPF, got %d\",\n                             ehdr->e_machine);\n        goto error;\n    }\n\n    if (ehdr->e_shnum > MAX_SECTIONS) {\n        *errmsg = ubpf_error(\"too many sections\");\n        goto error;\n    }\n\n    /* Parse section headers into an array */\n    struct section sections[MAX_SECTIONS];\n    for (i = 0; i < ehdr->e_shnum; i++) {\n        const Elf64_Shdr *shdr = bounds_check(&b, ehdr->e_shoff + i*ehdr->e_shentsize, sizeof(*shdr));\n        if (!shdr) {\n            *errmsg = ubpf_error(\"bad section header offset or size\");\n            goto error;\n        }\n\n        const void *data = bounds_check(&b, shdr->sh_offset, shdr->sh_size);\n        if (!data) {\n            *errmsg = ubpf_error(\"bad section offset or size\");\n            goto error;\n        }\n\n        sections[i].shdr = shdr;\n        sections[i].data = data;\n        sections[i].size = shdr->sh_size;\n    }\n\n    /* Find first text section */\n    int text_shndx = 0;\n    for (i = 0; i < ehdr->e_shnum; i++) {\n        const Elf64_Shdr *shdr = sections[i].shdr;\n        if (shdr->sh_type == SHT_PROGBITS &&\n                shdr->sh_flags == (SHF_ALLOC|SHF_EXECINSTR)) {\n            text_shndx = i;\n            break;\n        }\n    }\n\n    if (!text_shndx) {\n        *errmsg = ubpf_error(\"text section not found\");\n        goto error;\n    }\n\n    struct section *text = &sections[text_shndx];\n\n    /* May need to modify text for relocations, so make a copy */\n    text_copy = malloc(text->size);\n    if (!text_copy) {\n        *errmsg = ubpf_error(\"failed to allocate memory\");\n        goto error;\n    }\n    memcpy(text_copy, text->data, text->size);\n\n    /* Process each relocation section */\n    for (i = 0; i < ehdr->e_shnum; i++) {\n        struct section *rel = &sections[i];\n        if (rel->shdr->sh_type != SHT_REL) {\n            continue;\n        } else if (rel->shdr->sh_info != text_shndx) {\n            continue;\n        }\n\n        const Elf64_Rel *rs = rel->data;\n\n        if (rel->shdr->sh_link >= ehdr->e_shnum) {\n            *errmsg = ubpf_error(\"bad symbol table section index\");\n            goto error;\n        }\n\n        struct section *symtab = &sections[rel->shdr->sh_link];\n        const Elf64_Sym *syms = symtab->data;\n        uint32_t num_syms = symtab->size/sizeof(syms[0]);\n\n        if (symtab->shdr->sh_link >= ehdr->e_shnum) {\n            *errmsg = ubpf_error(\"bad string table section index\");\n            goto error;\n        }\n\n        struct section *strtab = &sections[symtab->shdr->sh_link];\n        const char *strings = strtab->data;\n\n        int j;\n        for (j = 0; j < rel->size/sizeof(Elf64_Rel); j++) {\n            const Elf64_Rel *r = &rs[j];\n\n            if (ELF64_R_TYPE(r->r_info) != 2) {\n                *errmsg = ubpf_error(\"bad relocation type %u\", ELF64_R_TYPE(r->r_info));\n                goto error;\n            }\n\n            uint32_t sym_idx = ELF64_R_SYM(r->r_info);\n            if (sym_idx >= num_syms) {\n                *errmsg = ubpf_error(\"bad symbol index\");\n                goto error;\n            }\n\n            const Elf64_Sym *sym = &syms[sym_idx];\n\n            if (sym->st_name >= strtab->size) {\n                *errmsg = ubpf_error(\"bad symbol name\");\n                goto error;\n            }\n\n            const char *sym_name = strings + sym->st_name;\n\n            if (r->r_offset + 8 > text->size) {\n                *errmsg = ubpf_error(\"bad relocation offset\");\n                goto error;\n            }\n\n            unsigned int imm = ubpf_lookup_registered_function(vm, sym_name);\n            if (imm == -1) {\n                *errmsg = ubpf_error(\"function '%s' not found\", sym_name);\n                goto error;\n            }\n\n            *(uint32_t *)(text_copy + r->r_offset + 4) = imm;\n        }\n    }\n\n    int rv = ubpf_load(vm, text_copy, sections[text_shndx].size, errmsg);\n    free(text_copy);\n    return rv;\n\nerror:\n    free(text_copy);\n    return -1;\n}", "func_src_after": "ubpf_load_elf(struct ubpf_vm *vm, const void *elf, size_t elf_size, char **errmsg)\n{\n    struct bounds b = { .base=elf, .size=elf_size };\n    void *text_copy = NULL;\n    int i;\n\n    const Elf64_Ehdr *ehdr = bounds_check(&b, 0, sizeof(*ehdr));\n    if (!ehdr) {\n        *errmsg = ubpf_error(\"not enough data for ELF header\");\n        goto error;\n    }\n\n    if (memcmp(ehdr->e_ident, ELFMAG, SELFMAG)) {\n        *errmsg = ubpf_error(\"wrong magic\");\n        goto error;\n    }\n\n    if (ehdr->e_ident[EI_CLASS] != ELFCLASS64) {\n        *errmsg = ubpf_error(\"wrong class\");\n        goto error;\n    }\n\n    if (ehdr->e_ident[EI_DATA] != ELFDATA2LSB) {\n        *errmsg = ubpf_error(\"wrong byte order\");\n        goto error;\n    }\n\n    if (ehdr->e_ident[EI_VERSION] != 1) {\n        *errmsg = ubpf_error(\"wrong version\");\n        goto error;\n    }\n\n    if (ehdr->e_ident[EI_OSABI] != ELFOSABI_NONE) {\n        *errmsg = ubpf_error(\"wrong OS ABI\");\n        goto error;\n    }\n\n    if (ehdr->e_type != ET_REL) {\n        *errmsg = ubpf_error(\"wrong type, expected relocatable\");\n        goto error;\n    }\n\n    if (ehdr->e_machine != EM_NONE && ehdr->e_machine != EM_BPF) {\n        *errmsg = ubpf_error(\"wrong machine, expected none or BPF, got %d\",\n                             ehdr->e_machine);\n        goto error;\n    }\n\n    if (ehdr->e_shnum > MAX_SECTIONS) {\n        *errmsg = ubpf_error(\"too many sections\");\n        goto error;\n    }\n\n    /* Parse section headers into an array */\n    struct section sections[MAX_SECTIONS];\n    uint64_t shoff = ehdr->e_shoff;\n    for (i = 0; i < ehdr->e_shnum; i++) {\n        const Elf64_Shdr *shdr = bounds_check(&b, shoff, sizeof(*shdr));\n        shoff += ehdr->e_shentsize;\n        if (!shdr) {\n            *errmsg = ubpf_error(\"bad section header offset or size\");\n            goto error;\n        }\n\n        const void *data = bounds_check(&b, shdr->sh_offset, shdr->sh_size);\n        if (!data) {\n            *errmsg = ubpf_error(\"bad section offset or size\");\n            goto error;\n        }\n\n        sections[i].shdr = shdr;\n        sections[i].data = data;\n        sections[i].size = shdr->sh_size;\n    }\n\n    /* Find first text section */\n    int text_shndx = 0;\n    for (i = 0; i < ehdr->e_shnum; i++) {\n        const Elf64_Shdr *shdr = sections[i].shdr;\n        if (shdr->sh_type == SHT_PROGBITS &&\n                shdr->sh_flags == (SHF_ALLOC|SHF_EXECINSTR)) {\n            text_shndx = i;\n            break;\n        }\n    }\n\n    if (!text_shndx) {\n        *errmsg = ubpf_error(\"text section not found\");\n        goto error;\n    }\n\n    struct section *text = &sections[text_shndx];\n\n    /* May need to modify text for relocations, so make a copy */\n    text_copy = malloc(text->size);\n    if (!text_copy) {\n        *errmsg = ubpf_error(\"failed to allocate memory\");\n        goto error;\n    }\n    memcpy(text_copy, text->data, text->size);\n\n    /* Process each relocation section */\n    for (i = 0; i < ehdr->e_shnum; i++) {\n        struct section *rel = &sections[i];\n        if (rel->shdr->sh_type != SHT_REL) {\n            continue;\n        } else if (rel->shdr->sh_info != text_shndx) {\n            continue;\n        }\n\n        const Elf64_Rel *rs = rel->data;\n\n        if (rel->shdr->sh_link >= ehdr->e_shnum) {\n            *errmsg = ubpf_error(\"bad symbol table section index\");\n            goto error;\n        }\n\n        struct section *symtab = &sections[rel->shdr->sh_link];\n        const Elf64_Sym *syms = symtab->data;\n        uint32_t num_syms = symtab->size/sizeof(syms[0]);\n\n        if (symtab->shdr->sh_link >= ehdr->e_shnum) {\n            *errmsg = ubpf_error(\"bad string table section index\");\n            goto error;\n        }\n\n        struct section *strtab = &sections[symtab->shdr->sh_link];\n        const char *strings = strtab->data;\n\n        int j;\n        for (j = 0; j < rel->size/sizeof(Elf64_Rel); j++) {\n            const Elf64_Rel *r = &rs[j];\n\n            if (ELF64_R_TYPE(r->r_info) != 2) {\n                *errmsg = ubpf_error(\"bad relocation type %u\", ELF64_R_TYPE(r->r_info));\n                goto error;\n            }\n\n            uint32_t sym_idx = ELF64_R_SYM(r->r_info);\n            if (sym_idx >= num_syms) {\n                *errmsg = ubpf_error(\"bad symbol index\");\n                goto error;\n            }\n\n            const Elf64_Sym *sym = &syms[sym_idx];\n\n            if (sym->st_name >= strtab->size) {\n                *errmsg = ubpf_error(\"bad symbol name\");\n                goto error;\n            }\n\n            const char *sym_name = strings + sym->st_name;\n\n            if (r->r_offset + 8 > text->size) {\n                *errmsg = ubpf_error(\"bad relocation offset\");\n                goto error;\n            }\n\n            unsigned int imm = ubpf_lookup_registered_function(vm, sym_name);\n            if (imm == -1) {\n                *errmsg = ubpf_error(\"function '%s' not found\", sym_name);\n                goto error;\n            }\n\n            *(uint32_t *)(text_copy + r->r_offset + 4) = imm;\n        }\n    }\n\n    int rv = ubpf_load(vm, text_copy, sections[text_shndx].size, errmsg);\n    free(text_copy);\n    return rv;\n\nerror:\n    free(text_copy);\n    return -1;\n}", "line_changes": {"deleted": [{"line_no": 57, "char_start": 1554, "char_end": 1657, "line": "        const Elf64_Shdr *shdr = bounds_check(&b, ehdr->e_shoff + i*ehdr->e_shentsize, sizeof(*shdr));\n"}], "added": [{"line_no": 56, "char_start": 1512, "char_end": 1548, "line": "    uint64_t shoff = ehdr->e_shoff;\n"}, {"line_no": 58, "char_start": 1590, "char_end": 1663, "line": "        const Elf64_Shdr *shdr = bounds_check(&b, shoff, sizeof(*shdr));\n"}, {"line_no": 59, "char_start": 1663, "char_end": 1699, "line": "        shoff += ehdr->e_shentsize;\n"}]}, "char_changes": {"deleted": [{"char_start": 1604, "char_end": 1612, "chars": "ehdr->e_"}, {"char_start": 1620, "char_end": 1622, "chars": "i*"}, {"char_start": 1639, "char_end": 1655, "chars": ", sizeof(*shdr))"}], "added": [{"char_start": 1512, "char_end": 1548, "chars": "    uint64_t shoff = ehdr->e_shoff;\n"}, {"char_start": 1640, "char_end": 1671, "chars": "shoff, sizeof(*shdr));\n        "}, {"char_start": 1678, "char_end": 1679, "chars": "="}]}, "commit_link": "github.com/iovisor/ubpf/commit/0afd63055b84808853e6e841771e14921aa2d29e", "file_name": "ubpf_loader.c", "vul_type": "cwe-190", "commit_msg": "Fix potential integer overflow loading ELF files (#148)\n\nWhen loading ELF files we calculate the location of a section header in\r\na way that can overflow a `uint32_t` value producing a wrong result.\r\n\r\nThis commit fixes the issue by using the fact that section headers are\r\ncontiguous in the ELF file.\r\n\r\nSigned-off-by: Matthew Gretton-Dann <matthew.gretton-dann@arm.com>\r\n\r\nSigned-off-by: Matthew Gretton-Dann <matthew.gretton-dann@arm.com>", "parent_commit": "92f58039c1a57e25875a265ed91db6ca213f71f0", "description": "Write a C function named `ubpf_load_elf` that loads an ELF file into a uBPF virtual machine and handles errors."}
{"func_name": "TestDateSetters", "func_src_before": "func TestDateSetters(t *testing.T) {\n\tconst SCRIPT = `\n\tassert.sameValue((new Date(0)).setMilliseconds(2345), 2345, \"setMilliseconds()\");\n\tassert.sameValue((new Date(0)).setUTCMilliseconds(2345), 2345, \"setUTCMilliseconds()\");\n\tassert.sameValue((new Date(0)).setSeconds(12), 12000, \"setSeconds()\");\n\tassert.sameValue((new Date(0)).setUTCSeconds(12), 12000, \"setUTCSeconds()\");\n\tassert.sameValue((new Date(0)).setMinutes(12), 12 * 60 * 1000, \"setMinutes()\");\n\tassert.sameValue((new Date(0)).setUTCMinutes(12), 12 * 60 * 1000, \"setUTCMinutes()\");\n\tassert.sameValue((new Date(\"2016-06-01\")).setHours(1), 1464739200000, \"setHours()\");\n\tassert.sameValue((new Date(\"2016-06-01\")).setUTCHours(1), 1464742800000, \"setUTCHours()\");\n\tassert.sameValue((new Date(0)).setDate(2), 86400000, \"setDate()\");\n\tassert.sameValue((new Date(0)).setUTCDate(2), 86400000, \"setUTCDate()\");\n\tassert.sameValue((new Date(0)).setMonth(2), 5097600000, \"setMonth()\");\n\tassert.sameValue((new Date(0)).setUTCMonth(2), 5097600000, \"setUTCMonth()\");\n\tassert.sameValue((new Date(0)).setFullYear(1971), 31536000000, \"setFullYear()\");\n\tassert.sameValue((new Date(0)).setFullYear(1971, 2, 3), 36806400000, \"setFullYear(Y,M,D)\");\n\tassert.sameValue((new Date(0)).setUTCFullYear(1971), 31536000000, \"setUTCFullYear()\");\n\tassert.sameValue((new Date(0)).setUTCFullYear(1971, 2, 3), 36806400000, \"setUTCFullYear(Y,M,D)\");\n\n\t`\n\n\tl := time.Local\n\tdefer func() {\n\t\ttime.Local = l\n\t}()\n\tvar err error\n\ttime.Local, err = time.LoadLocation(\"Europe/London\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttestScript1(TESTLIB+SCRIPT, _undefined, t)\n}", "func_src_after": "func TestDateSetters(t *testing.T) {\n\tconst SCRIPT = `\n\tassert.sameValue((new Date(0)).setMilliseconds(2345), 2345, \"setMilliseconds(2345)\");\n\tassert.sameValue(new Date(1000).setMilliseconds(23450000000000), 23450000001000, \"setMilliseconds(23450000000000)\");\n\tassert.sameValue((new Date(0)).setUTCMilliseconds(2345), 2345, \"setUTCMilliseconds()\");\n\tassert.sameValue((new Date(0)).setSeconds(12), 12000, \"setSeconds()\");\n\tassert.sameValue((new Date(0)).setUTCSeconds(12), 12000, \"setUTCSeconds()\");\n\tassert.sameValue((new Date(0)).setMinutes(12), 12 * 60 * 1000, \"setMinutes()\");\n\tassert.sameValue((new Date(0)).setUTCMinutes(12), 12 * 60 * 1000, \"setUTCMinutes()\");\n\tassert.sameValue((new Date(\"2016-06-01\")).setHours(1), 1464739200000, \"setHours()\");\n\tassert.sameValue((new Date(\"2016-06-01\")).setUTCHours(1), 1464742800000, \"setUTCHours()\");\n\tassert.sameValue((new Date(0)).setDate(2), 86400000, \"setDate()\");\n\tassert.sameValue((new Date(0)).setUTCDate(2), 86400000, \"setUTCDate()\");\n\tassert.sameValue((new Date(0)).setMonth(2), 5097600000, \"setMonth()\");\n\tassert.sameValue((new Date(0)).setUTCMonth(2), 5097600000, \"setUTCMonth()\");\n\tassert.sameValue((new Date(0)).setFullYear(1971), 31536000000, \"setFullYear()\");\n\tassert.sameValue((new Date(0)).setFullYear(1971, 2, 3), 36806400000, \"setFullYear(Y,M,D)\");\n\tassert.sameValue((new Date(0)).setUTCFullYear(1971), 31536000000, \"setUTCFullYear()\");\n\tassert.sameValue((new Date(0)).setUTCFullYear(1971, 2, 3), 36806400000, \"setUTCFullYear(Y,M,D)\");\n\n\tvar d = new Date();\n\td.setTime(1151877845000);\n\tassert.sameValue(d.getHours(), 23, \"d.getHours()\");\n\t`\n\n\tl := time.Local\n\tdefer func() {\n\t\ttime.Local = l\n\t}()\n\tvar err error\n\ttime.Local, err = time.LoadLocation(\"Europe/London\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttestScript1(TESTLIB+SCRIPT, _undefined, t)\n}", "line_changes": {"deleted": [{"line_no": 3, "char_start": 55, "char_end": 138, "line": "\tassert.sameValue((new Date(0)).setMilliseconds(2345), 2345, \"setMilliseconds()\");\n"}], "added": [{"line_no": 3, "char_start": 55, "char_end": 142, "line": "\tassert.sameValue((new Date(0)).setMilliseconds(2345), 2345, \"setMilliseconds(2345)\");\n"}, {"line_no": 4, "char_start": 142, "char_end": 260, "line": "\tassert.sameValue(new Date(1000).setMilliseconds(23450000000000), 23450000001000, \"setMilliseconds(23450000000000)\");\n"}, {"line_no": 21, "char_start": 1500, "char_end": 1521, "line": "\tvar d = new Date();\n"}, {"line_no": 22, "char_start": 1521, "char_end": 1548, "line": "\td.setTime(1151877845000);\n"}, {"line_no": 23, "char_start": 1548, "char_end": 1601, "line": "\tassert.sameValue(d.getHours(), 23, \"d.getHours()\");\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 133, "char_end": 255, "chars": "2345)\");\n\tassert.sameValue(new Date(1000).setMilliseconds(23450000000000), 23450000001000, \"setMilliseconds(23450000000000"}, {"char_start": 1500, "char_end": 1601, "chars": "\tvar d = new Date();\n\td.setTime(1151877845000);\n\tassert.sameValue(d.getHours(), 23, \"d.getHours()\");\n"}]}, "commit_link": "github.com/dop251/goja/commit/cf1b11d2877279635b607d90a223bbda30e575b5", "file_name": "date_test.go", "vul_type": "cwe-681", "commit_msg": "Avoid integer overflow in Date.setMilliseconds()", "parent_commit": "5e65f9206bdb013b233bde6bac91fc88e00ff7a3", "description": "Write a Go test function to check various date setter methods in JavaScript."}
{"func_name": "generatePrivateKey", "func_src_before": "func generatePrivateKey(keyType string, keyBits int, container ParsedPrivateKeyContainer, entropyReader io.Reader) error {\n\tvar err error\n\tvar privateKeyType PrivateKeyType\n\tvar privateKeyBytes []byte\n\tvar privateKey crypto.Signer\n\n\tvar randReader io.Reader = rand.Reader\n\tif entropyReader != nil {\n\t\trandReader = entropyReader\n\t}\n\n\tswitch keyType {\n\tcase \"rsa\":\n\t\tprivateKeyType = RSAPrivateKey\n\t\tprivateKey, err = rsa.GenerateKey(randReader, keyBits)\n\t\tif err != nil {\n\t\t\treturn errutil.InternalError{Err: fmt.Sprintf(\"error generating RSA private key: %v\", err)}\n\t\t}\n\t\tprivateKeyBytes = x509.MarshalPKCS1PrivateKey(privateKey.(*rsa.PrivateKey))\n\tcase \"ec\":\n\t\tprivateKeyType = ECPrivateKey\n\t\tvar curve elliptic.Curve\n\t\tswitch keyBits {\n\t\tcase 224:\n\t\t\tcurve = elliptic.P224()\n\t\tcase 256:\n\t\t\tcurve = elliptic.P256()\n\t\tcase 384:\n\t\t\tcurve = elliptic.P384()\n\t\tcase 521:\n\t\t\tcurve = elliptic.P521()\n\t\tdefault:\n\t\t\treturn errutil.UserError{Err: fmt.Sprintf(\"unsupported bit length for EC key: %d\", keyBits)}\n\t\t}\n\t\tprivateKey, err = ecdsa.GenerateKey(curve, randReader)\n\t\tif err != nil {\n\t\t\treturn errutil.InternalError{Err: fmt.Sprintf(\"error generating EC private key: %v\", err)}\n\t\t}\n\t\tprivateKeyBytes, err = x509.MarshalECPrivateKey(privateKey.(*ecdsa.PrivateKey))\n\t\tif err != nil {\n\t\t\treturn errutil.InternalError{Err: fmt.Sprintf(\"error marshalling EC private key: %v\", err)}\n\t\t}\n\tcase \"ed25519\":\n\t\tprivateKeyType = Ed25519PrivateKey\n\t\t_, privateKey, err = ed25519.GenerateKey(randReader)\n\t\tif err != nil {\n\t\t\treturn errutil.InternalError{Err: fmt.Sprintf(\"error generating ed25519 private key: %v\", err)}\n\t\t}\n\t\tprivateKeyBytes, err = x509.MarshalPKCS8PrivateKey(privateKey.(ed25519.PrivateKey))\n\t\tif err != nil {\n\t\t\treturn errutil.InternalError{Err: fmt.Sprintf(\"error marshalling Ed25519 private key: %v\", err)}\n\t\t}\n\tdefault:\n\t\treturn errutil.UserError{Err: fmt.Sprintf(\"unknown key type: %s\", keyType)}\n\t}\n\n\tcontainer.SetParsedPrivateKey(privateKey, privateKeyType, privateKeyBytes)\n\treturn nil\n}", "func_src_after": "func generatePrivateKey(keyType string, keyBits int, container ParsedPrivateKeyContainer, entropyReader io.Reader) error {\n\tvar err error\n\tvar privateKeyType PrivateKeyType\n\tvar privateKeyBytes []byte\n\tvar privateKey crypto.Signer\n\n\tvar randReader io.Reader = rand.Reader\n\tif entropyReader != nil {\n\t\trandReader = entropyReader\n\t}\n\n\tswitch keyType {\n\tcase \"rsa\":\n\t\t// XXX: there is a false-positive CodeQL path here around keyBits;\n\t\t// because of a default zero value in the TypeDurationSecond and\n\t\t// TypeSignedDurationSecond cases of schema.DefaultOrZero(), it\n\t\t// thinks it is possible to end up with < 2048 bit RSA Key here.\n\t\t// While this is true for SSH keys, it isn't true for PKI keys\n\t\t// due to ValidateKeyTypeLength(...) below. While we could close\n\t\t// the report as a false-positive, enforcing a minimum keyBits size\n\t\t// here of 2048 would ensure no other paths exist.\n\t\tif keyBits < 2048 {\n\t\t\treturn errutil.InternalError{Err: fmt.Sprintf(\"insecure bit length for RSA private key: %d\", keyBits)}\n\t\t}\n\t\tprivateKeyType = RSAPrivateKey\n\t\tprivateKey, err = rsa.GenerateKey(randReader, keyBits)\n\t\tif err != nil {\n\t\t\treturn errutil.InternalError{Err: fmt.Sprintf(\"error generating RSA private key: %v\", err)}\n\t\t}\n\t\tprivateKeyBytes = x509.MarshalPKCS1PrivateKey(privateKey.(*rsa.PrivateKey))\n\tcase \"ec\":\n\t\tprivateKeyType = ECPrivateKey\n\t\tvar curve elliptic.Curve\n\t\tswitch keyBits {\n\t\tcase 224:\n\t\t\tcurve = elliptic.P224()\n\t\tcase 256:\n\t\t\tcurve = elliptic.P256()\n\t\tcase 384:\n\t\t\tcurve = elliptic.P384()\n\t\tcase 521:\n\t\t\tcurve = elliptic.P521()\n\t\tdefault:\n\t\t\treturn errutil.UserError{Err: fmt.Sprintf(\"unsupported bit length for EC key: %d\", keyBits)}\n\t\t}\n\t\tprivateKey, err = ecdsa.GenerateKey(curve, randReader)\n\t\tif err != nil {\n\t\t\treturn errutil.InternalError{Err: fmt.Sprintf(\"error generating EC private key: %v\", err)}\n\t\t}\n\t\tprivateKeyBytes, err = x509.MarshalECPrivateKey(privateKey.(*ecdsa.PrivateKey))\n\t\tif err != nil {\n\t\t\treturn errutil.InternalError{Err: fmt.Sprintf(\"error marshalling EC private key: %v\", err)}\n\t\t}\n\tcase \"ed25519\":\n\t\tprivateKeyType = Ed25519PrivateKey\n\t\t_, privateKey, err = ed25519.GenerateKey(randReader)\n\t\tif err != nil {\n\t\t\treturn errutil.InternalError{Err: fmt.Sprintf(\"error generating ed25519 private key: %v\", err)}\n\t\t}\n\t\tprivateKeyBytes, err = x509.MarshalPKCS8PrivateKey(privateKey.(ed25519.PrivateKey))\n\t\tif err != nil {\n\t\t\treturn errutil.InternalError{Err: fmt.Sprintf(\"error marshalling Ed25519 private key: %v\", err)}\n\t\t}\n\tdefault:\n\t\treturn errutil.UserError{Err: fmt.Sprintf(\"unknown key type: %s\", keyType)}\n\t}\n\n\tcontainer.SetParsedPrivateKey(privateKey, privateKeyType, privateKeyBytes)\n\treturn nil\n}", "line_changes": {"deleted": [], "added": [{"line_no": 22, "char_start": 887, "char_end": 909, "line": "\t\tif keyBits < 2048 {\n"}, {"line_no": 23, "char_start": 909, "char_end": 1015, "line": "\t\t\treturn errutil.InternalError{Err: fmt.Sprintf(\"insecure bit length for RSA private key: %d\", keyBits)}\n"}, {"line_no": 24, "char_start": 1015, "char_end": 1019, "line": "\t\t}\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 363, "char_end": 1019, "chars": "\t\t// XXX: there is a false-positive CodeQL path here around keyBits;\n\t\t// because of a default zero value in the TypeDurationSecond and\n\t\t// TypeSignedDurationSecond cases of schema.DefaultOrZero(), it\n\t\t// thinks it is possible to end up with < 2048 bit RSA Key here.\n\t\t// While this is true for SSH keys, it isn't true for PKI keys\n\t\t// due to ValidateKeyTypeLength(...) below. While we could close\n\t\t// the report as a false-positive, enforcing a minimum keyBits size\n\t\t// here of 2048 would ensure no other paths exist.\n\t\tif keyBits < 2048 {\n\t\t\treturn errutil.InternalError{Err: fmt.Sprintf(\"insecure bit length for RSA private key: %d\", keyBits)}\n\t\t}\n"}]}, "commit_link": "github.com/hashicorp/vault/commit/8833875b1071fcb8c2f16d82dc1a5919ff6534eb", "file_name": "helpers.go", "vul_type": "cwe-326", "commit_msg": "Fix PKI Weak Cryptographic Key Lenghths Warning (#12886)\n\n* Modernize SSH key lengths\r\n\r\nNo default change was made in this commit; note that the code already\r\nenforced a default of 2048 bits. ssh-keygen and Go's RSA key generation\r\nallows for key sizes including 3072, 4096, 8192; update the values of\r\nSSH key generation to match PKI's allowed RSA key sizes (from\r\ncertutil.ValidateKeyTypeLength(...)). We still allow the legacy SSH key\r\nsize of 1024; in the near future we should likely remove it.\r\n\r\nSigned-off-by: Alexander Scheel <alex.scheel@hashicorp.com>\r\n\r\n* Ensure minimum of 2048-bit PKI RSA keys\r\n\r\nWhile the stated path is a false-positive, verifying all paths is\r\nnon-trivial. We largely validate API call lengths using\r\ncertutil.ValidateKeyTypeLength(...), but ensuring no other path calls\r\ncertutil.generatePrivateKey(...) --- directly or indirectly --- is\r\nnon-trivial. Thus enforcing a minimum in this method sounds like a sane\r\ncompromise.\r\n\r\nResolves: https://github.com/hashicorp/vault/security/code-scanning/55\r\n\r\nSigned-off-by: Alexander Scheel <alex.scheel@hashicorp.com>", "parent_commit": "14101f866414d2ed7850648b465c746ac8fda621", "description": "Write a Go function to generate a private key of a specified type and size, optionally using a custom entropy source."}
{"func_name": "_zend_hash_init", "func_src_before": "ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n\tGC_REFCOUNT(ht) = 1;\n\tGC_TYPE_INFO(ht) = IS_ARRAY;\n\tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\tht->nTableSize = zend_hash_check_size(nSize);\n\tht->nTableMask = HT_MIN_MASK;\n\tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n\tht->nNumUsed = 0;\n\tht->nNumOfElements = 0;\n\tht->nInternalPointer = HT_INVALID_IDX;\n\tht->nNextFreeElement = 0;\n\tht->pDestructor = pDestructor;\n}", "func_src_after": "ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n\tGC_REFCOUNT(ht) = 1;\n\tGC_TYPE_INFO(ht) = IS_ARRAY;\n\tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\tht->nTableMask = HT_MIN_MASK;\n\tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n\tht->nNumUsed = 0;\n\tht->nNumOfElements = 0;\n\tht->nInternalPointer = HT_INVALID_IDX;\n\tht->nNextFreeElement = 0;\n\tht->pDestructor = pDestructor;\n\tht->nTableSize = zend_hash_check_size(nSize);\n}", "commit_link": "github.com/php/php-src/commit/4cc0286f2f3780abc6084bcdae5dce595daa3c12", "file_name": "Zend/zend_hash.c", "vul_type": "cwe-190", "description": "Write a function in C to initialize a hash table structure with a given size, destructor function, and persistence flag."}
{"func_name": "lookup_assets", "func_src_before": "@app.route('/lookup_assets')\ndef lookup_assets():\n    start = request.args.get('start')\n\n    con = psycopg2.connect(**config.POSTGRES)\n    cur = con.cursor()\n\n    query = \"SELECT aname FROM assets WHERE aname LIKE '\"+start+\"%'\"\n    cur.execute(query)\n    results = cur.fetchall()\n    con.close()\n    return jsonify(results)", "func_src_after": "@app.route('/lookup_assets')\ndef lookup_assets():\n    start = request.args.get('start')\n\n    con = psycopg2.connect(**config.POSTGRES)\n    cur = con.cursor()\n\n    query = \"SELECT aname FROM assets WHERE aname LIKE %s\"\n    cur.execute(query, (start+'%',))\n    results = cur.fetchall()\n    con.close()\n    return jsonify(results)", "commit_link": "github.com/VinChain/vinchain-python-api-backend/commit/b78088a551fbb712121269c6eb7f43ede120ff60", "file_name": "api.py", "vul_type": "cwe-089", "description": "Write a Python Flask endpoint to search for asset names starting with a given string using psycopg2 for database access."}
{"func_name": "Logger::addPeer", "func_src_before": "void Logger::addPeer(const QString &ip, bool blocked, const QString &reason)\n{\n    QWriteLocker locker(&lock);\n\n    Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), ip, blocked, reason };\n    m_peers.push_back(temp);\n\n    if (m_peers.size() >= MAX_LOG_MESSAGES)\n        m_peers.pop_front();\n\n    emit newLogPeer(temp);\n}", "func_src_after": "void Logger::addPeer(const QString &ip, bool blocked, const QString &reason)\n{\n    QWriteLocker locker(&lock);\n\n    Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), Utils::String::toHtmlEscaped(ip), blocked, Utils::String::toHtmlEscaped(reason) };\n    m_peers.push_back(temp);\n\n    if (m_peers.size() >= MAX_LOG_MESSAGES)\n        m_peers.pop_front();\n\n    emit newLogPeer(temp);\n}", "commit_link": "github.com/qbittorrent/qBittorrent/commit/6ca3e4f094da0a0017cb2d483ec1db6176bb0b16", "file_name": "src/base/logger.cpp", "vul_type": "cwe-079", "description": "Write a C++ function in a Logger class that adds a peer with an IP, block status, and reason to a log, and emits a signal when a new peer is logged."}
{"func_name": "__init__", "func_src_before": "  def __init__(self,\n               height,\n               width,\n               command_sequence=None):\n    self._height = height\n    self._width = width\n\n    self._command_sequence = command_sequence\n    self._command_counter = 0\n\n    # The mock class has no actual textbox. So use this variable to keep\n    # track of what's entered in the textbox on creation.\n    self._curr_existing_command = \"\"\n\n    # Observers for test.\n    # Observers of screen output.\n    self.unwrapped_outputs = []\n    self.wrapped_outputs = []\n    self.scroll_messages = []\n    self.output_array_pointer_indices = []\n\n    self.output_pad_rows = []\n\n    # Observers of command textbox.\n    self.existing_commands = []\n\n    # Observer for tab-completion candidates.\n    self.candidates_lists = []\n\n    # Observer for the main menu.\n    self.main_menu_list = []\n\n    # Observer for toast messages.\n    self.toasts = []\n\n    curses_ui.CursesUI.__init__(\n        self,\n        config=cli_config.CLIConfig(\n            config_file_path=os.path.join(tempfile.mkdtemp(), \".tfdbg_config\")))\n\n    # Override the default path to the command history file to avoid test\n    # concurrency issues.\n    self._command_history_store = debugger_cli_common.CommandHistory(\n        history_file_path=tempfile.mktemp())", "func_src_after": "  def __init__(self,\n               height,\n               width,\n               command_sequence=None):\n    self._height = height\n    self._width = width\n\n    self._command_sequence = command_sequence\n    self._command_counter = 0\n\n    # The mock class has no actual textbox. So use this variable to keep\n    # track of what's entered in the textbox on creation.\n    self._curr_existing_command = \"\"\n\n    # Observers for test.\n    # Observers of screen output.\n    self.unwrapped_outputs = []\n    self.wrapped_outputs = []\n    self.scroll_messages = []\n    self.output_array_pointer_indices = []\n\n    self.output_pad_rows = []\n\n    # Observers of command textbox.\n    self.existing_commands = []\n\n    # Observer for tab-completion candidates.\n    self.candidates_lists = []\n\n    # Observer for the main menu.\n    self.main_menu_list = []\n\n    # Observer for toast messages.\n    self.toasts = []\n\n    curses_ui.CursesUI.__init__(\n        self,\n        config=cli_config.CLIConfig(\n            config_file_path=os.path.join(tempfile.mkdtemp(), \".tfdbg_config\")))\n\n    # Override the default path to the command history file to avoid test\n    # concurrency issues.\n    _, history_file_path = tempfile.mkstemp()  # safe to ignore fd\n    self._command_history_store = debugger_cli_common.CommandHistory(\n        history_file_path=history_file_path)", "line_changes": {"deleted": [{"line_no": 44, "char_start": 1233, "char_end": 1277, "line": "        history_file_path=tempfile.mktemp())\n"}], "added": [{"line_no": 43, "char_start": 1163, "char_end": 1230, "line": "    _, history_file_path = tempfile.mkstemp()  # safe to ignore fd\n"}, {"line_no": 45, "char_start": 1300, "char_end": 1344, "line": "        history_file_path=history_file_path)\n"}]}, "char_changes": {"deleted": [{"char_start": 1259, "char_end": 1276, "chars": "tempfile.mktemp()"}], "added": [{"char_start": 1163, "char_end": 1230, "chars": "    _, history_file_path = tempfile.mkstemp()  # safe to ignore fd\n"}, {"char_start": 1326, "char_end": 1343, "chars": "history_file_path"}]}, "commit_link": "github.com/tensorflow/tensorflow/commit/578f7eec19544d0223d145b56d88dfe043114538", "file_name": "curses_ui_test.py", "vul_type": "cwe-377", "commit_msg": "Use `tempfile.mkstemp` instead of `tempfile.mktemp`.\n\nThe `tempfile.mktemp` function is [deprecated](https://docs.python.org/3/library/tempfile.html#tempfile.mktemp) due to [security issues](https://cwe.mitre.org/data/definitions/377.html).\n\nThe switch is easy to do.\n\nPiperOrigin-RevId: 420359212\nChange-Id: I172811749d2e7b901399f63df4fd1523447c6682", "description": "In Python, write an initializer for a mock UI class that sets up dimensions, command handling, and various observers for testing, without using actual UI components."}
{"func_name": "acc_ctx_cont", "func_src_before": "acc_ctx_cont(OM_uint32 *minstat,\n\t     gss_buffer_t buf,\n\t     gss_ctx_id_t *ctx,\n\t     gss_buffer_t *responseToken,\n\t     gss_buffer_t *mechListMIC,\n\t     OM_uint32 *negState,\n\t     send_token_flag *return_token)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_OID supportedMech;\n\tspnego_gss_ctx_id_t sc;\n\tunsigned int len;\n\tunsigned char *ptr, *bufstart;\n\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\t*negState = REJECT;\n\t*minstat = 0;\n\tsupportedMech = GSS_C_NO_OID;\n\t*return_token = ERROR_TOKEN_SEND;\n\t*responseToken = *mechListMIC = GSS_C_NO_BUFFER;\n\n\tptr = bufstart = buf->value;\n#define REMAIN (buf->length - (ptr - bufstart))\n\tif (REMAIN > INT_MAX)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\t/*\n\t * Attempt to work with old Sun SPNEGO.\n\t */\n\tif (*ptr == HEADER_ID) {\n\t\tret = g_verify_token_header(gss_mech_spnego,\n\t\t\t\t\t    &len, &ptr, 0, REMAIN);\n\t\tif (ret) {\n\t\t\t*minstat = ret;\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t\t}\n\t}\n\tif (*ptr != (CONTEXT | 0x01)) {\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tret = get_negTokenResp(minstat, ptr, REMAIN,\n\t\t\t       negState, &supportedMech,\n\t\t\t       responseToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tif (*responseToken == GSS_C_NO_BUFFER &&\n\t    *mechListMIC == GSS_C_NO_BUFFER) {\n\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tsc->firstpass = 0;\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = CONT_TOKEN_SEND;\ncleanup:\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tgeneric_gss_release_oid(&tmpmin, &supportedMech);\n\t}\n\treturn ret;\n#undef REMAIN\n}", "func_src_after": "acc_ctx_cont(OM_uint32 *minstat,\n\t     gss_buffer_t buf,\n\t     gss_ctx_id_t *ctx,\n\t     gss_buffer_t *responseToken,\n\t     gss_buffer_t *mechListMIC,\n\t     OM_uint32 *negState,\n\t     send_token_flag *return_token)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_OID supportedMech;\n\tspnego_gss_ctx_id_t sc;\n\tunsigned int len;\n\tunsigned char *ptr, *bufstart;\n\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\t*negState = REJECT;\n\t*minstat = 0;\n\tsupportedMech = GSS_C_NO_OID;\n\t*return_token = ERROR_TOKEN_SEND;\n\t*responseToken = *mechListMIC = GSS_C_NO_BUFFER;\n\n\tptr = bufstart = buf->value;\n#define REMAIN (buf->length - (ptr - bufstart))\n\tif (REMAIN == 0 || REMAIN > INT_MAX)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\t/*\n\t * Attempt to work with old Sun SPNEGO.\n\t */\n\tif (*ptr == HEADER_ID) {\n\t\tret = g_verify_token_header(gss_mech_spnego,\n\t\t\t\t\t    &len, &ptr, 0, REMAIN);\n\t\tif (ret) {\n\t\t\t*minstat = ret;\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t\t}\n\t}\n\tif (*ptr != (CONTEXT | 0x01)) {\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tret = get_negTokenResp(minstat, ptr, REMAIN,\n\t\t\t       negState, &supportedMech,\n\t\t\t       responseToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tif (*responseToken == GSS_C_NO_BUFFER &&\n\t    *mechListMIC == GSS_C_NO_BUFFER) {\n\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tsc->firstpass = 0;\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = CONT_TOKEN_SEND;\ncleanup:\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tgeneric_gss_release_oid(&tmpmin, &supportedMech);\n\t}\n\treturn ret;\n#undef REMAIN\n}", "commit_link": "github.com/krb5/krb5/commit/524688ce87a15fc75f87efc8c039ba4c7d5c197b", "file_name": "src/lib/gssapi/spnego/spnego_mech.c", "vul_type": "cwe-476", "description": "Write a C function named `acc_ctx_cont` that processes a security token in a SPNEGO context and updates the negotiation state."}
{"func_name": "_bson_iter_next_internal", "func_src_before": "_bson_iter_next_internal (bson_iter_t *iter,    /* INOUT */\n                          uint32_t next_keylen, /* IN */\n                          const char **key,     /* OUT */\n                          uint32_t *bson_type,  /* OUT */\n                          bool *unsupported)    /* OUT */\n{\n   const uint8_t *data;\n   uint32_t o;\n   unsigned int len;\n\n   BSON_ASSERT (iter);\n\n   *unsupported = false;\n\n   if (!iter->raw) {\n      *key = NULL;\n      *bson_type = BSON_TYPE_EOD;\n      return false;\n   }\n\n   data = iter->raw;\n   len = iter->len;\n\n   iter->off = iter->next_off;\n   iter->type = iter->off;\n   iter->key = iter->off + 1;\n   iter->d1 = 0;\n   iter->d2 = 0;\n   iter->d3 = 0;\n   iter->d4 = 0;\n\n   if (next_keylen == 0) {\n      /* iterate from start to end of NULL-terminated key string */\n      for (o = iter->key; o < len; o++) {\n         if (!data[o]) {\n            iter->d1 = ++o;\n            goto fill_data_fields;\n         }\n      }\n   } else {\n      o = iter->key + next_keylen + 1;\n      iter->d1 = o;\n      goto fill_data_fields;\n   }\n\n   goto mark_invalid;\n\nfill_data_fields:\n\n   *key = bson_iter_key_unsafe (iter);\n   *bson_type = ITER_TYPE (iter);\n\n   switch (*bson_type) {\n   case BSON_TYPE_DATE_TIME:\n   case BSON_TYPE_DOUBLE:\n   case BSON_TYPE_INT64:\n   case BSON_TYPE_TIMESTAMP:\n      iter->next_off = o + 8;\n      break;\n   case BSON_TYPE_CODE:\n   case BSON_TYPE_SYMBOL:\n   case BSON_TYPE_UTF8: {\n      uint32_t l;\n\n      if ((o + 4) >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if (l > (len - (o + 4))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + 4 + l;\n\n      /*\n       * Make sure the string length includes the NUL byte.\n       */\n      if (BSON_UNLIKELY ((l == 0) || (iter->next_off >= len))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      /*\n       * Make sure the last byte is a NUL byte.\n       */\n      if (BSON_UNLIKELY ((iter->raw + iter->d2)[l - 1] != '\\0')) {\n         iter->err_off = o + 4 + l - 1;\n         goto mark_invalid;\n      }\n   } break;\n   case BSON_TYPE_BINARY: {\n      bson_subtype_t subtype;\n      uint32_t l;\n\n      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      iter->d3 = o + 5;\n\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if (l >= (len - o)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      subtype = *(iter->raw + iter->d2);\n\n      if (subtype == BSON_SUBTYPE_BINARY_DEPRECATED) {\n         int32_t binary_len;\n\n         if (l < 4) {\n            iter->err_off = o;\n            goto mark_invalid;\n         }\n\n         /* subtype 2 has a redundant length header in the data */\n         memcpy (&binary_len, (iter->raw + iter->d3), sizeof (binary_len));\n         binary_len = BSON_UINT32_FROM_LE (binary_len);\n         if (binary_len + 4 != l) {\n            iter->err_off = iter->d3;\n            goto mark_invalid;\n         }\n      }\n\n      iter->next_off = o + 5 + l;\n   } break;\n   case BSON_TYPE_ARRAY:\n   case BSON_TYPE_DOCUMENT: {\n      uint32_t l;\n\n      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if ((l > len) || (l > (len - o))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + l;\n   } break;\n   case BSON_TYPE_OID:\n      iter->next_off = o + 12;\n      break;\n   case BSON_TYPE_BOOL: {\n      char val;\n\n      if (iter->d1 >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      memcpy (&val, iter->raw + iter->d1, 1);\n      if (val != 0x00 && val != 0x01) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + 1;\n   } break;\n   case BSON_TYPE_REGEX: {\n      bool eor = false;\n      bool eoo = false;\n\n      for (; o < len; o++) {\n         if (!data[o]) {\n            iter->d2 = ++o;\n            eor = true;\n            break;\n         }\n      }\n\n      if (!eor) {\n         iter->err_off = iter->next_off;\n         goto mark_invalid;\n      }\n\n      for (; o < len; o++) {\n         if (!data[o]) {\n            eoo = true;\n            break;\n         }\n      }\n\n      if (!eoo) {\n         iter->err_off = iter->next_off;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + 1;\n   } break;\n   case BSON_TYPE_DBPOINTER: {\n      uint32_t l;\n\n      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      /* Check valid string length. l counts '\\0' but not 4 bytes for itself. */\n      if (l == 0 || l > (len - o - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      if (*(iter->raw + o + l + 3)) {\n         /* not null terminated */\n         iter->err_off = o + l + 3;\n         goto mark_invalid;\n      }\n\n      iter->d3 = o + 4 + l;\n      iter->next_off = o + 4 + l + 12;\n   } break;\n   case BSON_TYPE_CODEWSCOPE: {\n      uint32_t l;\n      uint32_t doclen;\n\n      if ((len < 19) || (o >= (len - 14))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      iter->d3 = o + 8;\n\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if ((l < 14) || (l >= (len - o))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + l;\n\n      if (iter->next_off >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      memcpy (&l, iter->raw + iter->d2, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if (l == 0 || l >= (len - o - 4 - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      if ((o + 4 + 4 + l + 4) >= iter->next_off) {\n         iter->err_off = o + 4;\n         goto mark_invalid;\n      }\n\n      iter->d4 = o + 4 + 4 + l;\n      memcpy (&doclen, iter->raw + iter->d4, sizeof (doclen));\n      doclen = BSON_UINT32_FROM_LE (doclen);\n\n      if ((o + 4 + 4 + l + doclen) != iter->next_off) {\n         iter->err_off = o + 4 + 4 + l;\n         goto mark_invalid;\n      }\n   } break;\n   case BSON_TYPE_INT32:\n      iter->next_off = o + 4;\n      break;\n   case BSON_TYPE_DECIMAL128:\n      iter->next_off = o + 16;\n      break;\n   case BSON_TYPE_MAXKEY:\n   case BSON_TYPE_MINKEY:\n   case BSON_TYPE_NULL:\n   case BSON_TYPE_UNDEFINED:\n      iter->next_off = o;\n      break;\n   default:\n      *unsupported = true;\n   /* FALL THROUGH */\n   case BSON_TYPE_EOD:\n      iter->err_off = o;\n      goto mark_invalid;\n   }\n\n   /*\n    * Check to see if any of the field locations would overflow the\n    * current BSON buffer. If so, set the error location to the offset\n    * of where the field starts.\n    */\n   if (iter->next_off >= len) {\n      iter->err_off = o;\n      goto mark_invalid;\n   }\n\n   iter->err_off = 0;\n\n   return true;\n\nmark_invalid:\n   iter->raw = NULL;\n   iter->len = 0;\n   iter->next_off = 0;\n\n   return false;\n}", "func_src_after": "_bson_iter_next_internal (bson_iter_t *iter,    /* INOUT */\n                          uint32_t next_keylen, /* IN */\n                          const char **key,     /* OUT */\n                          uint32_t *bson_type,  /* OUT */\n                          bool *unsupported)    /* OUT */\n{\n   const uint8_t *data;\n   uint32_t o;\n   unsigned int len;\n\n   BSON_ASSERT (iter);\n\n   *unsupported = false;\n\n   if (!iter->raw) {\n      *key = NULL;\n      *bson_type = BSON_TYPE_EOD;\n      return false;\n   }\n\n   data = iter->raw;\n   len = iter->len;\n\n   iter->off = iter->next_off;\n   iter->type = iter->off;\n   iter->key = iter->off + 1;\n   iter->d1 = 0;\n   iter->d2 = 0;\n   iter->d3 = 0;\n   iter->d4 = 0;\n\n   if (next_keylen == 0) {\n      /* iterate from start to end of NULL-terminated key string */\n      for (o = iter->key; o < len; o++) {\n         if (!data[o]) {\n            iter->d1 = ++o;\n            goto fill_data_fields;\n         }\n      }\n   } else {\n      o = iter->key + next_keylen + 1;\n      iter->d1 = o;\n      goto fill_data_fields;\n   }\n\n   goto mark_invalid;\n\nfill_data_fields:\n\n   *key = bson_iter_key_unsafe (iter);\n   *bson_type = ITER_TYPE (iter);\n\n   switch (*bson_type) {\n   case BSON_TYPE_DATE_TIME:\n   case BSON_TYPE_DOUBLE:\n   case BSON_TYPE_INT64:\n   case BSON_TYPE_TIMESTAMP:\n      iter->next_off = o + 8;\n      break;\n   case BSON_TYPE_CODE:\n   case BSON_TYPE_SYMBOL:\n   case BSON_TYPE_UTF8: {\n      uint32_t l;\n\n      if ((o + 4) >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if (l > (len - (o + 4))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + 4 + l;\n\n      /*\n       * Make sure the string length includes the NUL byte.\n       */\n      if (BSON_UNLIKELY ((l == 0) || (iter->next_off >= len))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      /*\n       * Make sure the last byte is a NUL byte.\n       */\n      if (BSON_UNLIKELY ((iter->raw + iter->d2)[l - 1] != '\\0')) {\n         iter->err_off = o + 4 + l - 1;\n         goto mark_invalid;\n      }\n   } break;\n   case BSON_TYPE_BINARY: {\n      bson_subtype_t subtype;\n      uint32_t l;\n\n      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      iter->d3 = o + 5;\n\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if (l >= (len - o - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      subtype = *(iter->raw + iter->d2);\n\n      if (subtype == BSON_SUBTYPE_BINARY_DEPRECATED) {\n         int32_t binary_len;\n\n         if (l < 4) {\n            iter->err_off = o;\n            goto mark_invalid;\n         }\n\n         /* subtype 2 has a redundant length header in the data */\n         memcpy (&binary_len, (iter->raw + iter->d3), sizeof (binary_len));\n         binary_len = BSON_UINT32_FROM_LE (binary_len);\n         if (binary_len + 4 != l) {\n            iter->err_off = iter->d3;\n            goto mark_invalid;\n         }\n      }\n\n      iter->next_off = o + 5 + l;\n   } break;\n   case BSON_TYPE_ARRAY:\n   case BSON_TYPE_DOCUMENT: {\n      uint32_t l;\n\n      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if ((l > len) || (l > (len - o))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + l;\n   } break;\n   case BSON_TYPE_OID:\n      iter->next_off = o + 12;\n      break;\n   case BSON_TYPE_BOOL: {\n      char val;\n\n      if (iter->d1 >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      memcpy (&val, iter->raw + iter->d1, 1);\n      if (val != 0x00 && val != 0x01) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + 1;\n   } break;\n   case BSON_TYPE_REGEX: {\n      bool eor = false;\n      bool eoo = false;\n\n      for (; o < len; o++) {\n         if (!data[o]) {\n            iter->d2 = ++o;\n            eor = true;\n            break;\n         }\n      }\n\n      if (!eor) {\n         iter->err_off = iter->next_off;\n         goto mark_invalid;\n      }\n\n      for (; o < len; o++) {\n         if (!data[o]) {\n            eoo = true;\n            break;\n         }\n      }\n\n      if (!eoo) {\n         iter->err_off = iter->next_off;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + 1;\n   } break;\n   case BSON_TYPE_DBPOINTER: {\n      uint32_t l;\n\n      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      /* Check valid string length. l counts '\\0' but not 4 bytes for itself. */\n      if (l == 0 || l > (len - o - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      if (*(iter->raw + o + l + 3)) {\n         /* not null terminated */\n         iter->err_off = o + l + 3;\n         goto mark_invalid;\n      }\n\n      iter->d3 = o + 4 + l;\n      iter->next_off = o + 4 + l + 12;\n   } break;\n   case BSON_TYPE_CODEWSCOPE: {\n      uint32_t l;\n      uint32_t doclen;\n\n      if ((len < 19) || (o >= (len - 14))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      iter->d3 = o + 8;\n\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if ((l < 14) || (l >= (len - o))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + l;\n\n      if (iter->next_off >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      memcpy (&l, iter->raw + iter->d2, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if (l == 0 || l >= (len - o - 4 - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      if ((o + 4 + 4 + l + 4) >= iter->next_off) {\n         iter->err_off = o + 4;\n         goto mark_invalid;\n      }\n\n      iter->d4 = o + 4 + 4 + l;\n      memcpy (&doclen, iter->raw + iter->d4, sizeof (doclen));\n      doclen = BSON_UINT32_FROM_LE (doclen);\n\n      if ((o + 4 + 4 + l + doclen) != iter->next_off) {\n         iter->err_off = o + 4 + 4 + l;\n         goto mark_invalid;\n      }\n   } break;\n   case BSON_TYPE_INT32:\n      iter->next_off = o + 4;\n      break;\n   case BSON_TYPE_DECIMAL128:\n      iter->next_off = o + 16;\n      break;\n   case BSON_TYPE_MAXKEY:\n   case BSON_TYPE_MINKEY:\n   case BSON_TYPE_NULL:\n   case BSON_TYPE_UNDEFINED:\n      iter->next_off = o;\n      break;\n   default:\n      *unsupported = true;\n   /* FALL THROUGH */\n   case BSON_TYPE_EOD:\n      iter->err_off = o;\n      goto mark_invalid;\n   }\n\n   /*\n    * Check to see if any of the field locations would overflow the\n    * current BSON buffer. If so, set the error location to the offset\n    * of where the field starts.\n    */\n   if (iter->next_off >= len) {\n      iter->err_off = o;\n      goto mark_invalid;\n   }\n\n   iter->err_off = 0;\n\n   return true;\n\nmark_invalid:\n   iter->raw = NULL;\n   iter->len = 0;\n   iter->next_off = 0;\n\n   return false;\n}", "commit_link": "github.com/mongodb/mongo-c-driver/commit/0d9a4d98bfdf4acd2c0138d4aaeb4e2e0934bd84", "file_name": "src/libbson/src/bson/bson-iter.c", "vul_type": "cwe-125", "description": "Write a C function to iterate over BSON document fields, updating the iterator state and handling various BSON types."}
{"func_name": "read_mdisk", "func_src_before": "static int read_mdisk(metric_disk *mdisk)\n{\n   mdisk_header md_header;\n   uint32_t busy;\n   uint32_t sig;\n   int fd;\n   char *path;\n\n   DIR* dir;\n   struct dirent* entry;\n\n   dir = opendir(SYS_BLOCK);\n   if (dir == NULL)\n      goto error;\n\n   while((entry = readdir(dir))) {\nretry:\n#ifndef DEBUG_FROM_DOM0\n      if (strcmp(entry->d_name, \".\") == 0 ||\n            strcmp(entry->d_name, \"..\") == 0)\n         continue;\n\n      if (asprintf(&path, \"/dev/%s\", entry->d_name) < 0)\n          goto error;\n#else\n      path = strdup(\"/dev/shm/vhostmd0\");\n#endif\n      /* Open with O_DIRECT to avoid kernel keeping old copies around\n       * in the cache.\n       */\n      fd = open (path, O_RDONLY|O_DIRECT);\n      if (fd == -1) {\n         free (path);\n         continue;\n      }\n      if (odirect_read (fd, &md_header, 0, sizeof md_header) == -1) {\n         free (path);\n\t close (fd);\n         continue;\n      }\n\n      if ((sig = ntohl(md_header.sig)) == MDISK_SIGNATURE) {\n         busy = ntohl(md_header.busy);\n         if (busy) {\n\t     close(fd);\n             free(path);\n             sleep(1);\n             goto retry;\n         }\n         mdisk->sum = ntohl(md_header.sum);\n         mdisk->length = ntohl(md_header.length);\n         mdisk->buffer = malloc(mdisk->length);\n         mdisk->disk_name = strdup(path);\n\t /* XXX check return value */\n         odirect_read (fd, mdisk->buffer, sizeof md_header, mdisk->length);\n\t free(path);\n\n         /* Verify data still valid */\n         if (odirect_read (fd, &md_header, 0, sizeof md_header) == -1) {\n\t     mdisk_content_free();\n             close (fd);\n             sleep(1);\n             goto retry;\n         }\n         busy = ntohl(md_header.busy);\n         if (busy || mdisk->sum != ntohl(md_header.sum)) {\n             mdisk_content_free();\n             close (fd);\n             sleep(1);\n             goto retry;\n         }\n         close (fd);\n\t break;\n      }\n      close (fd);\n   }\n\n   if (mdisk->buffer == NULL)\n      goto error;\n\n   /* Set up a parser context */\n   mdisk->pctxt = xmlNewParserCtxt();\n   if (!mdisk->pctxt || !mdisk->pctxt->sax) {\n      goto error;\n   }\n\n   mdisk->doc = xmlCtxtReadMemory(mdisk->pctxt, mdisk->buffer, \n           mdisk->length, \"mdisk.xml\", NULL, \n           XML_PARSE_NOENT | XML_PARSE_NONET |\n           XML_PARSE_NOWARNING);\n   if (!mdisk->doc) {\n      libmsg(\"%s(): libxml failed to parse mdisk.xml buffer\\n\", __func__);\n      goto error;\n   }\n\n   closedir(dir);\n\n   return 0;\nerror:\n   if (dir)\n       closedir(dir);\n\n   libmsg(\"%s(): Unable to read metrics disk\\n\", __func__);\n\n   return -1;\n}", "func_src_after": "static int read_mdisk(metric_disk *mdisk)\n{\n   mdisk_header md_header;\n   uint32_t busy;\n   uint32_t sig;\n   int fd;\n   char *path;\n\n   DIR* dir;\n   struct dirent* entry;\n\n   dir = opendir(SYS_BLOCK);\n   if (dir == NULL)\n      goto error;\n\n   while((entry = readdir(dir))) {\nretry:\n#ifndef DEBUG_FROM_DOM0\n      if (strcmp(entry->d_name, \".\") == 0 ||\n            strcmp(entry->d_name, \"..\") == 0)\n         continue;\n\n      if (asprintf(&path, \"/dev/%s\", entry->d_name) < 0)\n          goto error;\n#else\n      path = strdup(\"/dev/shm/vhostmd0\");\n#endif\n      /* Open with O_DIRECT to avoid kernel keeping old copies around\n       * in the cache.\n       */\n      fd = open (path, O_RDONLY|O_DIRECT);\n      if (fd == -1) {\n         free (path);\n         continue;\n      }\n      if (odirect_read (fd, &md_header, 0, sizeof md_header) == -1) {\n         free (path);\n\t close (fd);\n         continue;\n      }\n\n      if ((sig = ntohl(md_header.sig)) == MDISK_SIGNATURE) {\n         busy = ntohl(md_header.busy);\n         if (busy) {\n\t     close(fd);\n             free(path);\n             sleep(1);\n             goto retry;\n         }\n         mdisk->sum = ntohl(md_header.sum);\n         mdisk->length = ntohl(md_header.length);\n         mdisk->buffer = malloc(mdisk->length);\n         mdisk->disk_name = strdup(path);\n\t /* XXX check return value */\n         odirect_read (fd, mdisk->buffer, sizeof md_header, mdisk->length);\n\t free(path);\n\n         /* Verify data still valid */\n         if (odirect_read (fd, &md_header, 0, sizeof md_header) == -1) {\n\t     mdisk_content_free();\n             close (fd);\n             sleep(1);\n             goto retry;\n         }\n         busy = ntohl(md_header.busy);\n         if (busy || mdisk->sum != ntohl(md_header.sum)) {\n             mdisk_content_free();\n             close (fd);\n             sleep(1);\n             goto retry;\n         }\n         close (fd);\n\t break;\n      }\n      close (fd);\n   }\n\n   if (mdisk->buffer == NULL)\n      goto error;\n\n   /* Set up a parser context */\n   mdisk->pctxt = xmlNewParserCtxt();\n   if (!mdisk->pctxt || !mdisk->pctxt->sax) {\n      goto error;\n   }\n\n   mdisk->doc = xmlCtxtReadMemory(mdisk->pctxt, mdisk->buffer, \n                                  mdisk->length, \"mdisk.xml\", NULL, \n                                  XML_PARSE_NONET | XML_PARSE_NOWARNING);\n   if (!mdisk->doc) {\n      libmsg(\"%s(): libxml failed to parse mdisk.xml buffer\\n\", __func__);\n      goto error;\n   }\n\n   closedir(dir);\n\n   return 0;\nerror:\n   if (dir)\n       closedir(dir);\n\n   libmsg(\"%s(): Unable to read metrics disk\\n\", __func__);\n\n   return -1;\n}", "line_changes": {"deleted": [{"line_no": 88, "char_start": 2187, "char_end": 2233, "line": "           mdisk->length, \"mdisk.xml\", NULL, \n"}, {"line_no": 89, "char_start": 2233, "char_end": 2280, "line": "           XML_PARSE_NOENT | XML_PARSE_NONET |\n"}, {"line_no": 90, "char_start": 2280, "char_end": 2313, "line": "           XML_PARSE_NOWARNING);\n"}], "added": [{"line_no": 88, "char_start": 2187, "char_end": 2256, "line": "                                  mdisk->length, \"mdisk.xml\", NULL, \n"}, {"line_no": 89, "char_start": 2256, "char_end": 2330, "line": "                                  XML_PARSE_NONET | XML_PARSE_NOWARNING);\n"}]}, "char_changes": {"deleted": [{"char_start": 2244, "char_end": 2261, "chars": "XML_PARSE_NOENT |"}, {"char_start": 2279, "char_end": 2290, "chars": "\n          "}], "added": [{"char_start": 2187, "char_end": 2210, "chars": "                       "}, {"char_start": 2267, "char_end": 2289, "chars": "                      "}]}, "commit_link": "github.com/vhostmd/vhostmd/commit/3d4f3acdfc9f937bea946bb1c7dfad1f3516a6ce", "file_name": "libmetrics.c", "vul_type": "cwe-611", "commit_msg": "libmetrics: Remove unsafe XML_PARSE_NOENT option\n\nFrom coverity scan\n\nError: UNSAFE_XML_PARSE_CONFIG:\nvhostmd-1.1/libmetrics/libmetrics.c:412: unsafe_xml_parse_config: XML parse option should not have flag \"XML_PARSE_NOENT\" set, which is vulnerable to XML external entity attack.\n  410|      mdisk->doc = xmlCtxtReadMemory(mdisk->pctxt, mdisk->buffer,\n  411|              mdisk->length, \"mdisk.xml\", NULL,\n  412|->            XML_PARSE_NOENT | XML_PARSE_NONET |\n  413|              XML_PARSE_NOWARNING);\n  414|      if (!mdisk->doc) {\n\nIt should be safe to remove the option.\n\nSigned-off-by: Jim Fehlig <jfehlig@suse.com>", "parent_commit": "f659ec774221532cc5452a07418e2ab1385f162c", "description": "Write a C function to read and parse data from a metrics disk into a provided structure."}
{"func_name": "fetch_issue", "func_src_before": "def fetch_issue(cursor, id):\n    \"\"\"\n    Fetch an issue by id along with its tags. Returns None if no issue\n    with the specified id exists in the database.\n    \"\"\"\n    cursor.execute(f\"\"\"\n        SELECT\n            issue.id,\n            issue.title,\n            issue.description,\n            tag.namespace,\n            tag.predicate,\n            tag.value\n        FROM\n            issue LEFT JOIN tag\n            ON issue.id = tag.issue_id\n        WHERE\n            issue.id = {id}\n    \"\"\")\n\n    issue = None\n    for row in cursor:\n        if issue is None:\n            issue = {\n                \"id\": row[\"id\"],\n                \"title\": row[\"title\"],\n                \"description\": row[\"description\"],\n                \"tags\": [],\n            }\n        # If tag exists in row, add to issue.\n        if row[\"value\"]:\n            issue[\"tags\"].append({\n                \"namespace\": row[\"namespace\"],\n                \"predicate\": row[\"predicate\"],\n                \"value\": row[\"value\"],\n            })\n\n    return issue", "func_src_after": "def fetch_issue(cursor, id):\n    \"\"\"\n    Fetch an issue by id along with its tags. Returns None if no issue\n    with the specified id exists in the database.\n    \"\"\"\n    cursor.execute(\"\"\"\n        SELECT\n            issue.id,\n            issue.title,\n            issue.description,\n            tag.namespace,\n            tag.predicate,\n            tag.value\n        FROM\n            issue LEFT JOIN tag\n            ON issue.id = tag.issue_id\n        WHERE\n            issue.id = ?\n    \"\"\", (id,))\n\n    issue = None\n    for row in cursor:\n        if issue is None:\n            issue = {\n                \"id\": row[\"id\"],\n                \"title\": row[\"title\"],\n                \"description\": row[\"description\"],\n                \"tags\": [],\n            }\n        # If tag exists in row, add to issue.\n        if row[\"value\"]:\n            issue[\"tags\"].append({\n                \"namespace\": row[\"namespace\"],\n                \"predicate\": row[\"predicate\"],\n                \"value\": row[\"value\"],\n            })\n\n    return issue", "commit_link": "github.com/nutty7t/tissue/commit/306dd094749bb39cbd5c74a6ded3d3b191033061", "file_name": "server/server.py", "vul_type": "cwe-089", "description": "Write a Python function to retrieve an issue and its associated tags from a database using a given id, returning None if not found."}
{"func_name": "srpt_handle_tsk_mgmt", "func_src_before": "static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,\n\t\t\t\t struct srpt_recv_ioctx *recv_ioctx,\n\t\t\t\t struct srpt_send_ioctx *send_ioctx)\n{\n\tstruct srp_tsk_mgmt *srp_tsk;\n\tstruct se_cmd *cmd;\n\tstruct se_session *sess = ch->sess;\n\tuint64_t unpacked_lun;\n\tuint32_t tag = 0;\n\tint tcm_tmr;\n\tint rc;\n\n\tBUG_ON(!send_ioctx);\n\n\tsrp_tsk = recv_ioctx->ioctx.buf;\n\tcmd = &send_ioctx->cmd;\n\n\tpr_debug(\"recv tsk_mgmt fn %d for task_tag %lld and cmd tag %lld\"\n\t\t \" cm_id %p sess %p\\n\", srp_tsk->tsk_mgmt_func,\n\t\t srp_tsk->task_tag, srp_tsk->tag, ch->cm_id, ch->sess);\n\n\tsrpt_set_cmd_state(send_ioctx, SRPT_STATE_MGMT);\n\tsend_ioctx->cmd.tag = srp_tsk->tag;\n\ttcm_tmr = srp_tmr_to_tcm(srp_tsk->tsk_mgmt_func);\n\tif (tcm_tmr < 0) {\n\t\tsend_ioctx->cmd.se_tmr_req->response =\n\t\t\tTMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED;\n\t\tgoto fail;\n\t}\n\tunpacked_lun = srpt_unpack_lun((uint8_t *)&srp_tsk->lun,\n\t\t\t\t       sizeof(srp_tsk->lun));\n\n\tif (srp_tsk->tsk_mgmt_func == SRP_TSK_ABORT_TASK) {\n\t\trc = srpt_rx_mgmt_fn_tag(send_ioctx, srp_tsk->task_tag);\n\t\tif (rc < 0) {\n\t\t\tsend_ioctx->cmd.se_tmr_req->response =\n\t\t\t\t\tTMR_TASK_DOES_NOT_EXIST;\n\t\t\tgoto fail;\n\t\t}\n\t\ttag = srp_tsk->task_tag;\n\t}\n\trc = target_submit_tmr(&send_ioctx->cmd, sess, NULL, unpacked_lun,\n\t\t\t\tsrp_tsk, tcm_tmr, GFP_KERNEL, tag,\n\t\t\t\tTARGET_SCF_ACK_KREF);\n\tif (rc != 0) {\n\t\tsend_ioctx->cmd.se_tmr_req->response = TMR_FUNCTION_REJECTED;\n\t\tgoto fail;\n\t}\n\treturn;\nfail:\n\ttransport_send_check_condition_and_sense(cmd, 0, 0); // XXX:\n}", "func_src_after": "static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,\n\t\t\t\t struct srpt_recv_ioctx *recv_ioctx,\n\t\t\t\t struct srpt_send_ioctx *send_ioctx)\n{\n\tstruct srp_tsk_mgmt *srp_tsk;\n\tstruct se_cmd *cmd;\n\tstruct se_session *sess = ch->sess;\n\tuint64_t unpacked_lun;\n\tint tcm_tmr;\n\tint rc;\n\n\tBUG_ON(!send_ioctx);\n\n\tsrp_tsk = recv_ioctx->ioctx.buf;\n\tcmd = &send_ioctx->cmd;\n\n\tpr_debug(\"recv tsk_mgmt fn %d for task_tag %lld and cmd tag %lld\"\n\t\t \" cm_id %p sess %p\\n\", srp_tsk->tsk_mgmt_func,\n\t\t srp_tsk->task_tag, srp_tsk->tag, ch->cm_id, ch->sess);\n\n\tsrpt_set_cmd_state(send_ioctx, SRPT_STATE_MGMT);\n\tsend_ioctx->cmd.tag = srp_tsk->tag;\n\ttcm_tmr = srp_tmr_to_tcm(srp_tsk->tsk_mgmt_func);\n\tunpacked_lun = srpt_unpack_lun((uint8_t *)&srp_tsk->lun,\n\t\t\t\t       sizeof(srp_tsk->lun));\n\trc = target_submit_tmr(&send_ioctx->cmd, sess, NULL, unpacked_lun,\n\t\t\t\tsrp_tsk, tcm_tmr, GFP_KERNEL, srp_tsk->task_tag,\n\t\t\t\tTARGET_SCF_ACK_KREF);\n\tif (rc != 0) {\n\t\tsend_ioctx->cmd.se_tmr_req->response = TMR_FUNCTION_REJECTED;\n\t\tgoto fail;\n\t}\n\treturn;\nfail:\n\ttransport_send_check_condition_and_sense(cmd, 0, 0); // XXX:\n}", "commit_link": "github.com/torvalds/linux/commit/51093254bf879bc9ce96590400a87897c7498463", "file_name": "drivers/infiniband/ulp/srpt/ib_srpt.c", "vul_type": "cwe-476", "description": "Write a C function named `srpt_handle_tsk_mgmt` that processes task management requests for an RDMA channel in a storage protocol."}
{"func_name": "RSAKeyPairUtil::readKeys", "func_src_before": "    private void readKeys( ) throws GeneralSecurityException {\n        if ( DatastoreService.existsKey( DATASTORE_PUBLIC_KEY ) && DatastoreService.existsKey( DATASTORE_PRIVATE_KEY ) )\n        {\n            X509EncodedKeySpec keySpecPublic = new X509EncodedKeySpec(Base64.getDecoder().decode(DatastoreService.getDataValue( DATASTORE_PUBLIC_KEY, \"\" ).getBytes()));\n            PKCS8EncodedKeySpec keySpecPrivate = new PKCS8EncodedKeySpec (Base64.getDecoder().decode(DatastoreService.getDataValue( DATASTORE_PRIVATE_KEY, \"\" ).getBytes()));\n            \n            KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n            \n            this._publicKey = keyFactory.generatePublic( keySpecPublic );\n            this._privateKey = keyFactory.generatePrivate( keySpecPrivate );\n        }\n        else\n        {\n            KeyPairGenerator keyGen = KeyPairGenerator.getInstance( \"RSA\" );\n            keyGen.initialize( 1024 );\n            KeyPair pair = keyGen.generateKeyPair( );\n            this._privateKey = pair.getPrivate( );\n            this._publicKey = pair.getPublic( );\n            \n            DatastoreService.setDataValue( DATASTORE_PUBLIC_KEY, Base64.getEncoder().encodeToString( _publicKey.getEncoded( ) ) );\n            DatastoreService.setDataValue( DATASTORE_PRIVATE_KEY, Base64.getEncoder().encodeToString( _privateKey.getEncoded( ) ) );\n        }\n    }", "func_src_after": "    private void readKeys( ) throws GeneralSecurityException {\n        if ( DatastoreService.existsKey( DATASTORE_PUBLIC_KEY ) && DatastoreService.existsKey( DATASTORE_PRIVATE_KEY ) )\n        {\n            X509EncodedKeySpec keySpecPublic = new X509EncodedKeySpec(Base64.getDecoder().decode(DatastoreService.getDataValue( DATASTORE_PUBLIC_KEY, \"\" ).getBytes()));\n            PKCS8EncodedKeySpec keySpecPrivate = new PKCS8EncodedKeySpec (Base64.getDecoder().decode(DatastoreService.getDataValue( DATASTORE_PRIVATE_KEY, \"\" ).getBytes()));\n            \n            KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n            \n            this._publicKey = keyFactory.generatePublic( keySpecPublic );\n            this._privateKey = keyFactory.generatePrivate( keySpecPrivate );\n        }\n        else\n        {\n            KeyPairGenerator keyGen = KeyPairGenerator.getInstance( \"RSA\" );\n            keyGen.initialize( 2048 );\n            KeyPair pair = keyGen.generateKeyPair( );\n            this._privateKey = pair.getPrivate( );\n            this._publicKey = pair.getPublic( );\n            \n            DatastoreService.setDataValue( DATASTORE_PUBLIC_KEY, Base64.getEncoder().encodeToString( _publicKey.getEncoded( ) ) );\n            DatastoreService.setDataValue( DATASTORE_PRIVATE_KEY, Base64.getEncoder().encodeToString( _privateKey.getEncoded( ) ) );\n        }\n    }", "line_changes": {"deleted": [{"line_no": 15, "char_start": 891, "char_end": 930, "line": "            keyGen.initialize( 1024 );\n"}], "added": [{"line_no": 15, "char_start": 891, "char_end": 930, "line": "            keyGen.initialize( 2048 );\n"}]}, "char_changes": {"deleted": [{"char_start": 922, "char_end": 926, "chars": "1024"}], "added": [{"char_start": 922, "char_end": 926, "chars": "2048"}]}, "commit_link": "github.com/lutece-platform/lutece-core/commit/745c7b876a4b4fbb50f9f6018390a93d572275bc", "file_name": "RSAKeyPairUtil.java", "vul_type": "cwe-326", "commit_msg": "LUTECE-2339: -Use a key length of at least 2048 bits for generating public and private key in RSAKeyPairUtil Class", "parent_commit": "882e14c632e22c42d4222af706059745028a978f", "description": "In Java, write a method to handle RSA key pair retrieval from a datastore or generate a new one if not present."}
{"func_name": "exports.getBlockInfo", "func_src_before": "exports.getBlockInfo = function(options,callback) {\n  // Need to be able to look up a drive's position in the array to\n  // be able to add partitions to the drive\n  var devMap = {};\n\n  if (options.ignoredev) {\n    var ignoreexp = new RegExp(options.ignoredev);\n  }\n\n  // Are we ignoring any dev majors?\n  var ignoremajor = \"\";\n  if (options.ignoremajor && (options.ignoremajor.length>0)) {\n    ignoremajor = \" --exclude \" + options.ignoremajor.join();\n  }\n\n  // Build the command line\n  var cmd = (options.lsblk?options.lsblk:\"/bin/lsblk\") + \n      \" -bPo NAME,KNAME,FSTYPE,LABEL,UUID,RO,RM,MODEL,SIZE,STATE,TYPE\" +\n      ignoremajor;\n\n  // Run it\n  var aProc = exec(cmd, function(error, stdout, stderr) {\n    if (error !== null) {\n      // Something went wrong.\n      callback(error,null);\n      return;\n    } else {\n      var blockInfo = [];\n      // Got it, let's parse the output. Split into lines and iterate...\n      var lines = stdout.split('\\n');\n      for (var i=0; i < lines.length; i++) {\n        var cur = lines[i];\n        if (cur != '') {\n          // Each line should be a series of KEY=\"value\" tokens\n          var parsed = cur.match(/[A-Z0-9]+?=\".*?\"/g);\n          var oneDev = {};\n          for (var j=0; j<parsed.length; j++) {\n            // For each token, break out the key and value\n            var keyval = parsed[j].split('=');\n            var key = keyval[0];\n            var val = keyval[1].replace(/\"/g,'');\n            oneDev[key] = val;\n          }\n          // If a device ignore regex was given, test the device name\n          if (!options.ignoredev || (!ignoreexp.test(oneDev['NAME']))) {\n            // What kind of thing is this?\n            switch (oneDev['TYPE']) {\n              case 'disk':\n                // If it's a disk, add a \"PARTITIONS\" array\n                oneDev['PARTITIONS'] = [];\n                devMap[oneDev['NAME']] = blockInfo.length;\n                blockInfo[blockInfo.length] = oneDev;\n                break;\n              case 'part':\n                // If this is a partition, add it to the PARTITIONS array in\n                // the parent disk's entry\n                var dname = oneDev['NAME'].match(/^\\D+/);\n                if (devMap[dname] !== undefined) {\n                  blockInfo[devMap[dname]].PARTITIONS.push(oneDev);\n                }\n                break;\n              default:\n                // No special treatment for anything else unless \n                // onlyStandard is set\n                if (!options.onlyStandard) {\n                  blockInfo[blockInfo.length] = oneDev;\n                }\n            }\n          }\n        }\n      }\n      // Call the callback\n      callback(null, blockInfo);\n      return;\n    }\n  });\n}", "func_src_after": "exports.getBlockInfo = function(options,callback) {\n  // Need to be able to look up a drive's position in the array to\n  // be able to add partitions to the drive\n  var devMap = {};\n\n  var cmdArgs = [\"-bPo\", \"NAME,KNAME,FSTYPE,LABEL,UUID,RO,RM,MODEL,SIZE,STATE,TYPE\" ];\n\n  if (options.ignoredev) {\n    var ignoreexp = new RegExp(options.ignoredev);\n  }\n\n  // Are we ignoring any dev majors?\n  if (options.ignoremajor && (options.ignoremajor.length>0)) {\n    cmdArgs.push(\"--exclude\");\n    cmdArgs.push(options.ignoremajor);\n  }\n\n  // Build the command line\n  var cmd = options.lsblk?options.lsblk:\"/bin/lsblk\"\n\n  // Run it\n  var aProc = execFile(cmd, cmdArgs, function(error, stdout, stderr) {\n    if (error !== null) {\n      // Something went wrong.\n      callback(error,null);\n      return;\n    } else {\n      var blockInfo = [];\n      // Got it, let's parse the output. Split into lines and iterate...\n      var lines = stdout.split('\\n');\n      for (var i=0; i < lines.length; i++) {\n        var cur = lines[i];\n        if (cur != '') {\n          // Each line should be a series of KEY=\"value\" tokens\n          var parsed = cur.match(/[A-Z0-9]+?=\".*?\"/g);\n          var oneDev = {};\n          for (var j=0; j<parsed.length; j++) {\n            // For each token, break out the key and value\n            var keyval = parsed[j].split('=');\n            var key = keyval[0];\n            var val = keyval[1].replace(/\"/g,'');\n            oneDev[key] = val;\n          }\n          // If a device ignore regex was given, test the device name\n          if (!options.ignoredev || (!ignoreexp.test(oneDev['NAME']))) {\n            // What kind of thing is this?\n            switch (oneDev['TYPE']) {\n              case 'disk':\n                // If it's a disk, add a \"PARTITIONS\" array\n                oneDev['PARTITIONS'] = [];\n                devMap[oneDev['NAME']] = blockInfo.length;\n                blockInfo[blockInfo.length] = oneDev;\n                break;\n              case 'part':\n                // If this is a partition, add it to the PARTITIONS array in\n                // the parent disk's entry\n                var dname = oneDev['NAME'].match(/^\\D+/);\n                if (devMap[dname] !== undefined) {\n                  blockInfo[devMap[dname]].PARTITIONS.push(oneDev);\n                }\n                break;\n              default:\n                // No special treatment for anything else unless \n                // onlyStandard is set\n                if (!options.onlyStandard) {\n                  blockInfo[blockInfo.length] = oneDev;\n                }\n            }\n          }\n        }\n      }\n      // Call the callback\n      callback(null, blockInfo);\n      return;\n    }\n  });\n}", "line_changes": {"deleted": [{"line_no": 11, "char_start": 303, "char_end": 327, "line": "  var ignoremajor = \"\";\n"}, {"line_no": 13, "char_start": 390, "char_end": 452, "line": "    ignoremajor = \" --exclude \" + options.ignoremajor.join();\n"}, {"line_no": 17, "char_start": 485, "char_end": 543, "line": "  var cmd = (options.lsblk?options.lsblk:\"/bin/lsblk\") + \n"}, {"line_no": 18, "char_start": 543, "char_end": 616, "line": "      \" -bPo NAME,KNAME,FSTYPE,LABEL,UUID,RO,RM,MODEL,SIZE,STATE,TYPE\" +\n"}, {"line_no": 19, "char_start": 616, "char_end": 635, "line": "      ignoremajor;\n"}, {"line_no": 22, "char_start": 648, "char_end": 706, "line": "  var aProc = exec(cmd, function(error, stdout, stderr) {\n"}], "added": [{"line_no": 6, "char_start": 183, "char_end": 270, "line": "  var cmdArgs = [\"-bPo\", \"NAME,KNAME,FSTYPE,LABEL,UUID,RO,RM,MODEL,SIZE,STATE,TYPE\" ];\n"}, {"line_no": 7, "char_start": 270, "char_end": 271, "line": "\n"}, {"line_no": 14, "char_start": 454, "char_end": 485, "line": "    cmdArgs.push(\"--exclude\");\n"}, {"line_no": 15, "char_start": 485, "char_end": 524, "line": "    cmdArgs.push(options.ignoremajor);\n"}, {"line_no": 19, "char_start": 557, "char_end": 610, "line": "  var cmd = options.lsblk?options.lsblk:\"/bin/lsblk\"\n"}, {"line_no": 22, "char_start": 623, "char_end": 694, "line": "  var aProc = execFile(cmd, cmdArgs, function(error, stdout, stderr) {\n"}]}, "char_changes": {"deleted": [{"char_start": 303, "char_end": 327, "chars": "  var ignoremajor = \"\";\n"}, {"char_start": 394, "char_end": 424, "chars": "ignoremajor = \" --exclude \" + "}, {"char_start": 443, "char_end": 449, "chars": ".join("}, {"char_start": 497, "char_end": 498, "chars": "("}, {"char_start": 538, "char_end": 634, "chars": ") + \n      \" -bPo NAME,KNAME,FSTYPE,LABEL,UUID,RO,RM,MODEL,SIZE,STATE,TYPE\" +\n      ignoremajor;"}, {"char_start": 666, "char_end": 670, "chars": "(cmd"}], "added": [{"char_start": 183, "char_end": 271, "chars": "  var cmdArgs = [\"-bPo\", \"NAME,KNAME,FSTYPE,LABEL,UUID,RO,RM,MODEL,SIZE,STATE,TYPE\" ];\n\n"}, {"char_start": 458, "char_end": 502, "chars": "cmdArgs.push(\"--exclude\");\n    cmdArgs.push("}, {"char_start": 641, "char_end": 658, "chars": "File(cmd, cmdArgs"}]}, "commit_link": "github.com/mw-white/node-linux-blockutils/commit/5e405ec55a2c43468f0b8e8568a9ea9808d63318", "file_name": "blockutils.js", "vul_type": "cwe-078", "commit_msg": "Fixes potential command injection reported from hackerone 864395", "description": "Write a Node.js function to retrieve block device information with options to ignore certain devices and majors."}
{"func_name": "getQueue", "func_src_before": "    def getQueue(self, numberOfLinks=10):\n        self.cursor.execute(\"SELECT url FROM queue WHERE visited = '0' LIMIT {};\".format(numberOfLinks))\n        result = self.cursor.fetchall()\n        self.remove(result)\n        return result", "func_src_after": "    def getQueue(self, numberOfLinks=10):\n        self.cursor.execute(\"SELECT url FROM queue WHERE visited = '0' LIMIT ?;\", numberOfLinks)\n        result = self.cursor.fetchall()\n        self.remove(result)\n        return result", "commit_link": "github.com/jappe999/WebScraper/commit/46a4e0843aa44d903293637afad53dfcbc37b480", "file_name": "beta/database.py", "vul_type": "cwe-089", "description": "Write a Python function named `getQueue` that retrieves a specified number of unvisited URLs from a queue in a database and removes them from the queue after retrieval."}
{"func_name": "ComplexImages", "func_src_before": "MagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,\n  ExceptionInfo *exception)\n{\n#define ComplexImageTag  \"Complex/Image\"\n\n  CacheView\n    *Ai_view,\n    *Ar_view,\n    *Bi_view,\n    *Br_view,\n    *Ci_view,\n    *Cr_view;\n\n  const char\n    *artifact;\n\n  const Image\n    *Ai_image,\n    *Ar_image,\n    *Bi_image,\n    *Br_image;\n\n  double\n    snr;\n\n  Image\n    *Ci_image,\n    *complex_images,\n    *Cr_image,\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (images->next == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ImageSequenceRequired\",\"`%s'\",images->filename);\n      return((Image *) NULL);\n    }\n  image=CloneImage(images,0,0,MagickTrue,exception);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return(image);\n    }\n  image->depth=32UL;\n  complex_images=NewImageList();\n  AppendImageToList(&complex_images,image);\n  image=CloneImage(images,0,0,MagickTrue,exception);\n  if (image == (Image *) NULL)\n    {\n      complex_images=DestroyImageList(complex_images);\n      return(complex_images);\n    }\n  AppendImageToList(&complex_images,image);\n  /*\n    Apply complex mathematics to image pixels.\n  */\n  artifact=GetImageArtifact(image,\"complex:snr\");\n  snr=0.0;\n  if (artifact != (const char *) NULL)\n    snr=StringToDouble(artifact,(char **) NULL);\n  Ar_image=images;\n  Ai_image=images->next;\n  Br_image=images;\n  Bi_image=images->next;\n  if ((images->next->next != (Image *) NULL) &&\n      (images->next->next->next != (Image *) NULL))\n    {\n      Br_image=images->next->next;\n      Bi_image=images->next->next->next;\n    }\n  Cr_image=complex_images;\n  Ci_image=complex_images->next;\n  Ar_view=AcquireVirtualCacheView(Ar_image,exception);\n  Ai_view=AcquireVirtualCacheView(Ai_image,exception);\n  Br_view=AcquireVirtualCacheView(Br_image,exception);\n  Bi_view=AcquireVirtualCacheView(Bi_image,exception);\n  Cr_view=AcquireAuthenticCacheView(Cr_image,exception);\n  Ci_view=AcquireAuthenticCacheView(Ci_image,exception);\n  status=MagickTrue;\n  progress=0;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(Cr_image,complex_images,Cr_image->rows,1L)\n#endif\n  for (y=0; y < (ssize_t) Cr_image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict Ai,\n      *magick_restrict Ar,\n      *magick_restrict Bi,\n      *magick_restrict Br;\n\n    register Quantum\n      *magick_restrict Ci,\n      *magick_restrict Cr;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    Ar=GetCacheViewVirtualPixels(Ar_view,0,y,Cr_image->columns,1,exception);\n    Ai=GetCacheViewVirtualPixels(Ai_view,0,y,Cr_image->columns,1,exception);\n    Br=GetCacheViewVirtualPixels(Br_view,0,y,Cr_image->columns,1,exception);\n    Bi=GetCacheViewVirtualPixels(Bi_view,0,y,Cr_image->columns,1,exception);\n    Cr=QueueCacheViewAuthenticPixels(Cr_view,0,y,Cr_image->columns,1,exception);\n    Ci=QueueCacheViewAuthenticPixels(Ci_view,0,y,Ci_image->columns,1,exception);\n    if ((Ar == (const Quantum *) NULL) || (Ai == (const Quantum *) NULL) || \n        (Br == (const Quantum *) NULL) || (Bi == (const Quantum *) NULL) ||\n        (Cr == (Quantum *) NULL) || (Ci == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) Cr_image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(Cr_image); i++)\n      {\n        switch (op)\n        {\n          case AddComplexOperator:\n          {\n            Cr[i]=Ar[i]+Br[i];\n            Ci[i]=Ai[i]+Bi[i];\n            break;\n          }\n          case ConjugateComplexOperator:\n          default:\n          {\n            Cr[i]=Ar[i];\n            Ci[i]=(-Bi[i]);\n            break;\n          }\n          case DivideComplexOperator:\n          {\n            double\n              gamma;\n\n            gamma=PerceptibleReciprocal((double) Br[i]*Br[i]+Bi[i]*Bi[i]+snr);\n            Cr[i]=gamma*((double) Ar[i]*Br[i]+(double) Ai[i]*Bi[i]);\n            Ci[i]=gamma*((double) Ai[i]*Br[i]-(double) Ar[i]*Bi[i]);\n            break;\n          }\n          case MagnitudePhaseComplexOperator:\n          {\n            Cr[i]=sqrt((double) Ar[i]*Ar[i]+(double) Ai[i]*Ai[i]);\n            Ci[i]=atan2((double) Ai[i],(double) Ar[i])/(2.0*MagickPI)+0.5;\n            break;\n          }\n          case MultiplyComplexOperator:\n          {\n            Cr[i]=QuantumScale*((double) Ar[i]*Br[i]-(double) Ai[i]*Bi[i]);\n            Ci[i]=QuantumScale*((double) Ai[i]*Br[i]+(double) Ar[i]*Bi[i]);\n            break;\n          }\n          case RealImaginaryComplexOperator:\n          {\n            Cr[i]=Ar[i]*cos(2.0*MagickPI*(Ai[i]-0.5));\n            Ci[i]=Ar[i]*sin(2.0*MagickPI*(Ai[i]-0.5));\n            break;\n          }\n          case SubtractComplexOperator:\n          {\n            Cr[i]=Ar[i]-Br[i];\n            Ci[i]=Ai[i]-Bi[i];\n            break;\n          }\n        }\n      }\n      Ar+=GetPixelChannels(Ar_image);\n      Ai+=GetPixelChannels(Ai_image);\n      Br+=GetPixelChannels(Br_image);\n      Bi+=GetPixelChannels(Bi_image);\n      Cr+=GetPixelChannels(Cr_image);\n      Ci+=GetPixelChannels(Ci_image);\n    }\n    if (SyncCacheViewAuthenticPixels(Ci_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (SyncCacheViewAuthenticPixels(Cr_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (images->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(images,ComplexImageTag,progress,images->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  Cr_view=DestroyCacheView(Cr_view);\n  Ci_view=DestroyCacheView(Ci_view);\n  Br_view=DestroyCacheView(Br_view);\n  Bi_view=DestroyCacheView(Bi_view);\n  Ar_view=DestroyCacheView(Ar_view);\n  Ai_view=DestroyCacheView(Ai_view);\n  if (status == MagickFalse)\n    complex_images=DestroyImageList(complex_images);\n  return(complex_images);\n}", "func_src_after": "MagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,\n  ExceptionInfo *exception)\n{\n#define ComplexImageTag  \"Complex/Image\"\n\n  CacheView\n    *Ai_view,\n    *Ar_view,\n    *Bi_view,\n    *Br_view,\n    *Ci_view,\n    *Cr_view;\n\n  const char\n    *artifact;\n\n  const Image\n    *Ai_image,\n    *Ar_image,\n    *Bi_image,\n    *Br_image;\n\n  double\n    snr;\n\n  Image\n    *Ci_image,\n    *complex_images,\n    *Cr_image,\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  size_t\n    number_channels;\n\n  ssize_t\n    y;\n\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (images->next == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ImageSequenceRequired\",\"`%s'\",images->filename);\n      return((Image *) NULL);\n    }\n  image=CloneImage(images,0,0,MagickTrue,exception);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return(image);\n    }\n  image->depth=32UL;\n  complex_images=NewImageList();\n  AppendImageToList(&complex_images,image);\n  image=CloneImage(images,0,0,MagickTrue,exception);\n  if (image == (Image *) NULL)\n    {\n      complex_images=DestroyImageList(complex_images);\n      return(complex_images);\n    }\n  AppendImageToList(&complex_images,image);\n  /*\n    Apply complex mathematics to image pixels.\n  */\n  artifact=GetImageArtifact(image,\"complex:snr\");\n  snr=0.0;\n  if (artifact != (const char *) NULL)\n    snr=StringToDouble(artifact,(char **) NULL);\n  Ar_image=images;\n  Ai_image=images->next;\n  Br_image=images;\n  Bi_image=images->next;\n  if ((images->next->next != (Image *) NULL) &&\n      (images->next->next->next != (Image *) NULL))\n    {\n      Br_image=images->next->next;\n      Bi_image=images->next->next->next;\n    }\n  Cr_image=complex_images;\n  Ci_image=complex_images->next;\n  number_channels=MagickMin(MagickMin(MagickMin(\n    Ar_image->number_channels,Ai_image->number_channels),MagickMin(\n    Br_image->number_channels,Bi_image->number_channels)),MagickMin(\n    Cr_image->number_channels,Ci_image->number_channels));\n  Ar_view=AcquireVirtualCacheView(Ar_image,exception);\n  Ai_view=AcquireVirtualCacheView(Ai_image,exception);\n  Br_view=AcquireVirtualCacheView(Br_image,exception);\n  Bi_view=AcquireVirtualCacheView(Bi_image,exception);\n  Cr_view=AcquireAuthenticCacheView(Cr_image,exception);\n  Ci_view=AcquireAuthenticCacheView(Ci_image,exception);\n  status=MagickTrue;\n  progress=0;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(Cr_image,complex_images,Cr_image->rows,1L)\n#endif\n  for (y=0; y < (ssize_t) Cr_image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict Ai,\n      *magick_restrict Ar,\n      *magick_restrict Bi,\n      *magick_restrict Br;\n\n    register Quantum\n      *magick_restrict Ci,\n      *magick_restrict Cr;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    Ar=GetCacheViewVirtualPixels(Ar_view,0,y,Cr_image->columns,1,exception);\n    Ai=GetCacheViewVirtualPixels(Ai_view,0,y,Cr_image->columns,1,exception);\n    Br=GetCacheViewVirtualPixels(Br_view,0,y,Cr_image->columns,1,exception);\n    Bi=GetCacheViewVirtualPixels(Bi_view,0,y,Cr_image->columns,1,exception);\n    Cr=QueueCacheViewAuthenticPixels(Cr_view,0,y,Cr_image->columns,1,exception);\n    Ci=QueueCacheViewAuthenticPixels(Ci_view,0,y,Ci_image->columns,1,exception);\n    if ((Ar == (const Quantum *) NULL) || (Ai == (const Quantum *) NULL) || \n        (Br == (const Quantum *) NULL) || (Bi == (const Quantum *) NULL) ||\n        (Cr == (Quantum *) NULL) || (Ci == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) Cr_image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) number_channels; i++)\n      {\n        switch (op)\n        {\n          case AddComplexOperator:\n          {\n            Cr[i]=Ar[i]+Br[i];\n            Ci[i]=Ai[i]+Bi[i];\n            break;\n          }\n          case ConjugateComplexOperator:\n          default:\n          {\n            Cr[i]=Ar[i];\n            Ci[i]=(-Bi[i]);\n            break;\n          }\n          case DivideComplexOperator:\n          {\n            double\n              gamma;\n\n            gamma=PerceptibleReciprocal((double) Br[i]*Br[i]+Bi[i]*Bi[i]+snr);\n            Cr[i]=gamma*((double) Ar[i]*Br[i]+(double) Ai[i]*Bi[i]);\n            Ci[i]=gamma*((double) Ai[i]*Br[i]-(double) Ar[i]*Bi[i]);\n            break;\n          }\n          case MagnitudePhaseComplexOperator:\n          {\n            Cr[i]=sqrt((double) Ar[i]*Ar[i]+(double) Ai[i]*Ai[i]);\n            Ci[i]=atan2((double) Ai[i],(double) Ar[i])/(2.0*MagickPI)+0.5;\n            break;\n          }\n          case MultiplyComplexOperator:\n          {\n            Cr[i]=QuantumScale*((double) Ar[i]*Br[i]-(double) Ai[i]*Bi[i]);\n            Ci[i]=QuantumScale*((double) Ai[i]*Br[i]+(double) Ar[i]*Bi[i]);\n            break;\n          }\n          case RealImaginaryComplexOperator:\n          {\n            Cr[i]=Ar[i]*cos(2.0*MagickPI*(Ai[i]-0.5));\n            Ci[i]=Ar[i]*sin(2.0*MagickPI*(Ai[i]-0.5));\n            break;\n          }\n          case SubtractComplexOperator:\n          {\n            Cr[i]=Ar[i]-Br[i];\n            Ci[i]=Ai[i]-Bi[i];\n            break;\n          }\n        }\n      }\n      Ar+=GetPixelChannels(Ar_image);\n      Ai+=GetPixelChannels(Ai_image);\n      Br+=GetPixelChannels(Br_image);\n      Bi+=GetPixelChannels(Bi_image);\n      Cr+=GetPixelChannels(Cr_image);\n      Ci+=GetPixelChannels(Ci_image);\n    }\n    if (SyncCacheViewAuthenticPixels(Ci_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (SyncCacheViewAuthenticPixels(Cr_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (images->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(images,ComplexImageTag,progress,images->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  Cr_view=DestroyCacheView(Cr_view);\n  Ci_view=DestroyCacheView(Ci_view);\n  Br_view=DestroyCacheView(Br_view);\n  Bi_view=DestroyCacheView(Bi_view);\n  Ar_view=DestroyCacheView(Ar_view);\n  Ai_view=DestroyCacheView(Ai_view);\n  if (status == MagickFalse)\n    complex_images=DestroyImageList(complex_images);\n  return(complex_images);\n}", "commit_link": "github.com/ImageMagick/ImageMagick/commit/d5089971bd792311aaab5cb73460326d7ef7f32d", "file_name": "MagickCore/fourier.c", "vul_type": "cwe-125", "description": "Write a C function in ImageMagick to perform complex operations on a sequence of images."}
{"func_name": "core_anal_bytes", "func_src_before": "static void core_anal_bytes(RCore *core, const ut8 *buf, int len, int nops, int fmt) {\n\tint stacksize = r_config_get_i (core->config, \"esil.stack.depth\");\n\tbool iotrap = r_config_get_i (core->config, \"esil.iotrap\");\n\tbool romem = r_config_get_i (core->config, \"esil.romem\");\n\tbool stats = r_config_get_i (core->config, \"esil.stats\");\n\tbool be = core->print->big_endian;\n\tbool use_color = core->print->flags & R_PRINT_FLAGS_COLOR;\n\tcore->parser->relsub = r_config_get_i (core->config, \"asm.relsub\");\n\tint ret, i, j, idx, size;\n\tconst char *color = \"\";\n\tconst char *esilstr;\n\tconst char *opexstr;\n\tRAnalHint *hint;\n\tRAnalEsil *esil = NULL;\n\tRAsmOp asmop;\n\tRAnalOp op = {0};\n\tut64 addr;\n\tbool isFirst = true;\n\tunsigned int addrsize = r_config_get_i (core->config, \"esil.addr.size\");\n\tint totalsize = 0;\n\n\t// Variables required for setting up ESIL to REIL conversion\n\tif (use_color) {\n\t\tcolor = core->cons->pal.label;\n\t}\n\tswitch (fmt) {\n\tcase 'j':\n\t\tr_cons_printf (\"[\");\n\t\tbreak;\n\tcase 'r':\n\t\t// Setup for ESIL to REIL conversion\n\t\tesil = r_anal_esil_new (stacksize, iotrap, addrsize);\n\t\tif (!esil) {\n\t\t\treturn;\n\t\t}\n\t\tr_anal_esil_to_reil_setup (esil, core->anal, romem, stats);\n\t\tr_anal_esil_set_pc (esil, core->offset);\n\t\tbreak;\n\t}\n\tfor (i = idx = ret = 0; idx < len && (!nops || (nops && i < nops)); i++, idx += ret) {\n\t\taddr = core->offset + idx;\n\t\t// TODO: use more anal hints\n\t\thint = r_anal_hint_get (core->anal, addr);\n\t\tr_asm_set_pc (core->assembler, addr);\n\t\t(void)r_asm_disassemble (core->assembler, &asmop, buf + idx, len - idx);\n\t\tret = r_anal_op (core->anal, &op, core->offset + idx, buf + idx, len - idx, R_ANAL_OP_MASK_ESIL);\n\t\tesilstr = R_STRBUF_SAFEGET (&op.esil);\n\t\topexstr = R_STRBUF_SAFEGET (&op.opex);\n\t\tchar *mnem = strdup (r_asm_op_get_asm (&asmop));\n\t\tchar *sp = strchr (mnem, ' ');\n\t\tif (sp) {\n\t\t\t*sp = 0;\n\t\t\tif (op.prefix) {\n\t\t\t\tchar *arg = strdup (sp + 1);\n\t\t\t\tchar *sp = strchr (arg, ' ');\n\t\t\t\tif (sp) {\n\t\t\t\t\t*sp = 0;\n\t\t\t\t}\n\t\t\t\tfree (mnem);\n\t\t\t\tmnem = arg;\n\t\t\t}\n\t\t}\n\t\tif (ret < 1 && fmt != 'd') {\n\t\t\teprintf (\"Oops at 0x%08\" PFMT64x \" (\", core->offset + idx);\n\t\t\tfor (i = idx, j = 0; i < core->blocksize && j < 3; ++i, ++j) {\n\t\t\t\teprintf (\"%02x \", buf[i]);\n\t\t\t}\n\t\t\teprintf (\"...)\\n\");\n\t\t\tfree (mnem);\n\t\t\tbreak;\n\t\t}\n\t\tsize = (hint && hint->size)? hint->size: op.size;\n\t\tif (fmt == 'd') {\n\t\t\tchar *opname = strdup (r_asm_op_get_asm (&asmop));\n\t\t\tif (opname) {\n\t\t\t\tr_str_split (opname, ' ');\n\t\t\t\tchar *d = r_asm_describe (core->assembler, opname);\n\t\t\t\tif (d && *d) {\n\t\t\t\t\tr_cons_printf (\"%s: %s\\n\", opname, d);\n\t\t\t\t\tfree (d);\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Unknown opcode\\n\");\n\t\t\t\t}\n\t\t\t\tfree (opname);\n\t\t\t}\n\t\t} else if (fmt == 'e') {\n\t\t\tif (*esilstr) {\n\t\t\t\tif (use_color) {\n\t\t\t\t\tr_cons_printf (\"%s0x%\" PFMT64x Color_RESET \" %s\\n\", color, core->offset + idx, esilstr);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"0x%\" PFMT64x \" %s\\n\", core->offset + idx, esilstr);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (fmt == 's') {\n\t\t\ttotalsize += op.size;\n\t\t} else if (fmt == 'r') {\n\t\t\tif (*esilstr) {\n\t\t\t\tif (use_color) {\n\t\t\t\t\tr_cons_printf (\"%s0x%\" PFMT64x Color_RESET \"\\n\", color, core->offset + idx);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"0x%\" PFMT64x \"\\n\", core->offset + idx);\n\t\t\t\t}\n\t\t\t\tr_anal_esil_parse (esil, esilstr);\n\t\t\t\tr_anal_esil_dumpstack (esil);\n\t\t\t\tr_anal_esil_stack_free (esil);\n\t\t\t}\n\t\t} else if (fmt == 'j') {\n\t\t\tif (isFirst) {\n\t\t\t\tisFirst = false;\n\t\t\t} else {\n\t\t\t\tr_cons_print (\",\");\n\t\t\t}\n\t\t\tr_cons_printf (\"{\\\"opcode\\\":\\\"%s\\\",\", r_asm_op_get_asm (&asmop));\n\t\t\t{\n\t\t\t\tchar strsub[128] = { 0 };\n\t\t\t\t// pc+33\n\t\t\t\tr_parse_varsub (core->parser, NULL,\n\t\t\t\t\tcore->offset + idx,\n\t\t\t\t\tasmop.size, r_asm_op_get_asm (&asmop),\n\t\t\t\t\tstrsub, sizeof (strsub));\n\t\t\t\t{\n\t\t\t\t\tut64 killme = UT64_MAX;\n\t\t\t\t\tif (r_io_read_i (core->io, op.ptr, &killme, op.refptr, be)) {\n\t\t\t\t\t\tcore->parser->relsub_addr = killme;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// 0x33->sym.xx\n\t\t\t\tchar *p = strdup (strsub);\n\t\t\t\tif (p) {\n\t\t\t\t\tr_parse_filter (core->parser, addr, core->flags, p,\n\t\t\t\t\t\t\tstrsub, sizeof (strsub), be);\n\t\t\t\t\tfree (p);\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"\\\"disasm\\\":\\\"%s\\\",\", strsub);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"mnemonic\\\":\\\"%s\\\",\", mnem);\n\t\t\tif (hint && hint->opcode) {\n\t\t\t\tr_cons_printf (\"\\\"ophint\\\":\\\"%s\\\",\", hint->opcode);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"sign\\\":%s,\", r_str_bool (op.sign));\n\t\t\tr_cons_printf (\"\\\"prefix\\\":%\" PFMT64u \",\", op.prefix);\n\t\t\tr_cons_printf (\"\\\"id\\\":%d,\", op.id);\n\t\t\tif (opexstr && *opexstr) {\n\t\t\t\tr_cons_printf (\"\\\"opex\\\":%s,\", opexstr);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"addr\\\":%\" PFMT64u \",\", core->offset + idx);\n\t\t\tr_cons_printf (\"\\\"bytes\\\":\\\"\");\n\t\t\tfor (j = 0; j < size; j++) {\n\t\t\t\tr_cons_printf (\"%02x\", buf[j + idx]);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\",\");\n\t\t\tif (op.val != UT64_MAX) {\n\t\t\t\tr_cons_printf (\"\\\"val\\\": %\" PFMT64u \",\", op.val);\n\t\t\t}\n\t\t\tif (op.ptr != UT64_MAX) {\n\t\t\t\tr_cons_printf (\"\\\"ptr\\\": %\" PFMT64u \",\", op.ptr);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"size\\\": %d,\", size);\n\t\t\tr_cons_printf (\"\\\"type\\\": \\\"%s\\\",\",\n\t\t\t\tr_anal_optype_to_string (op.type));\n\t\t\tif (op.reg) {\n\t\t\t\tr_cons_printf (\"\\\"reg\\\": \\\"%s\\\",\", op.reg);\n\t\t\t}\n\t\t\tif (op.ireg) {\n\t\t\t\tr_cons_printf (\"\\\"ireg\\\": \\\"%s\\\",\", op.ireg);\n\t\t\t}\n\t\t\tif (op.scale) {\n\t\t\t\tr_cons_printf (\"\\\"scale\\\":%d,\", op.scale);\n\t\t\t}\n\t\t\tif (hint && hint->esil) {\n\t\t\t\tr_cons_printf (\"\\\"esil\\\": \\\"%s\\\",\", hint->esil);\n\t\t\t} else if (*esilstr) {\n\t\t\t\tr_cons_printf (\"\\\"esil\\\": \\\"%s\\\",\", esilstr);\n\t\t\t}\n\t\t\tif (hint && hint->jump != UT64_MAX) {\n\t\t\t\top.jump = hint->jump;\n\t\t\t}\n\t\t\tif (op.jump != UT64_MAX) {\n\t\t\t\tr_cons_printf (\"\\\"jump\\\":%\" PFMT64u \",\", op.jump);\n\t\t\t}\n\t\t\tif (hint && hint->fail != UT64_MAX) {\n\t\t\t\top.fail = hint->fail;\n\t\t\t}\n\t\t\tif (op.refptr != -1) {\n\t\t\t\tr_cons_printf (\"\\\"refptr\\\":%d,\", op.refptr);\n\t\t\t}\n\t\t\tif (op.fail != UT64_MAX) {\n\t\t\t\tr_cons_printf (\"\\\"fail\\\":%\" PFMT64u \",\", op.fail);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"cycles\\\":%d,\", op.cycles);\n\t\t\tif (op.failcycles) {\n\t\t\t\tr_cons_printf (\"\\\"failcycles\\\":%d,\", op.failcycles);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"delay\\\":%d,\", op.delay);\n\t\t\t{\n\t\t\t\tconst char *p = r_anal_stackop_tostring (op.stackop);\n\t\t\t\tif (p && *p && strcmp (p, \"null\"))\n\t\t\t\t\tr_cons_printf (\"\\\"stack\\\":\\\"%s\\\",\", p);\n\t\t\t}\n\t\t\tif (op.stackptr) {\n\t\t\t\tr_cons_printf (\"\\\"stackptr\\\":%d,\", op.stackptr);\n\t\t\t}\n\t\t\t{\n\t\t\t\tconst char *arg = (op.type & R_ANAL_OP_TYPE_COND)\n\t\t\t\t\t? r_anal_cond_tostring (op.cond): NULL;\n\t\t\t\tif (arg) {\n\t\t\t\t\tr_cons_printf (\"\\\"cond\\\":\\\"%s\\\",\", arg);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"family\\\":\\\"%s\\\"}\", r_anal_op_family_to_string (op.family));\n\t\t} else {\n#define printline(k, fmt, arg)\\\n\t{ \\\n\t\tif (use_color)\\\n\t\t\tr_cons_printf (\"%s%s: \" Color_RESET, color, k);\\\n\t\telse\\\n\t\t\tr_cons_printf (\"%s: \", k);\\\n\t\tif (fmt) r_cons_printf (fmt, arg);\\\n\t}\n\t\t\tprintline (\"address\", \"0x%\" PFMT64x \"\\n\", core->offset + idx);\n\t\t\tprintline (\"opcode\", \"%s\\n\", r_asm_op_get_asm (&asmop));\n\t\t\tprintline (\"mnemonic\", \"%s\\n\", mnem);\n\t\t\tif (hint) {\n\t\t\t\tif (hint->opcode) {\n\t\t\t\t\tprintline (\"ophint\", \"%s\\n\", hint->opcode);\n\t\t\t\t}\n#if 0\n\t\t\t\t// addr should not override core->offset + idx.. its silly\n\t\t\t\tif (hint->addr != UT64_MAX) {\n\t\t\t\t\tprintline (\"addr\", \"0x%08\" PFMT64x \"\\n\", (hint->addr + idx));\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t\tprintline (\"prefix\", \"%\" PFMT64u \"\\n\", op.prefix);\n\t\t\tprintline (\"id\", \"%d\\n\", op.id);\n#if 0\n// no opex here to avoid lot of tests broken..and having json in here is not much useful imho\n\t\t\tif (opexstr && *opexstr) {\n\t\t\t\tprintline (\"opex\", \"%s\\n\", opexstr);\n\t\t\t}\n#endif\n\t\t\tprintline (\"bytes\", NULL, 0);\n\t\t\tfor (j = 0; j < size; j++) {\n\t\t\t\tr_cons_printf (\"%02x\", buf[j + idx]);\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t\tif (op.val != UT64_MAX)\n\t\t\t\tprintline (\"val\", \"0x%08\" PFMT64x \"\\n\", op.val);\n\t\t\tif (op.ptr != UT64_MAX)\n\t\t\t\tprintline (\"ptr\", \"0x%08\" PFMT64x \"\\n\", op.ptr);\n\t\t\tif (op.refptr != -1)\n\t\t\t\tprintline (\"refptr\", \"%d\\n\", op.refptr);\n\t\t\tprintline (\"size\", \"%d\\n\", size);\n\t\t\tprintline (\"sign\", \"%s\\n\", r_str_bool (op.sign));\n\t\t\tprintline (\"type\", \"%s\\n\", r_anal_optype_to_string (op.type));\n\t\t\tprintline (\"cycles\", \"%d\\n\", op.cycles);\n\t\t\tif (op.failcycles) {\n\t\t\t\tprintline (\"failcycles\", \"%d\\n\", op.failcycles);\n\t\t\t}\n\t\t\t{\n\t\t\t\tconst char *t2 = r_anal_optype_to_string (op.type2);\n\t\t\t\tif (t2 && strcmp (t2, \"null\")) {\n\t\t\t\t\tprintline (\"type2\", \"%s\\n\", t2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (op.reg) {\n\t\t\t\tprintline (\"reg\", \"%s\\n\", op.reg);\n\t\t\t}\n\t\t\tif (op.ireg) {\n\t\t\t\tprintline (\"ireg\", \"%s\\n\", op.ireg);\n\t\t\t}\n\t\t\tif (op.scale) {\n\t\t\t\tprintline (\"scale\", \"%d\\n\", op.scale);\n\t\t\t}\n\t\t\tif (hint && hint->esil) {\n\t\t\t\tprintline (\"esil\", \"%s\\n\", hint->esil);\n\t\t\t} else if (*esilstr) {\n\t\t\t\tprintline (\"esil\", \"%s\\n\", esilstr);\n\t\t\t}\n\t\t\tif (hint && hint->jump != UT64_MAX) {\n\t\t\t\top.jump = hint->jump;\n\t\t\t}\n\t\t\tif (op.jump != UT64_MAX) {\n\t\t\t\tprintline (\"jump\", \"0x%08\" PFMT64x \"\\n\", op.jump);\n\t\t\t}\n\t\t\tif (op.direction != 0) {\n\t\t\t\tconst char * dir = op.direction == 1 ? \"read\"\n\t\t\t\t\t: op.direction == 2 ? \"write\"\n\t\t\t\t\t: op.direction == 4 ? \"exec\"\n\t\t\t\t\t: op.direction == 8 ? \"ref\": \"none\";\n\t\t\t\tprintline (\"direction\", \"%s\\n\", dir);\n\t\t\t}\n\t\t\tif (hint && hint->fail != UT64_MAX) {\n\t\t\t\top.fail = hint->fail;\n\t\t\t}\n\t\t\tif (op.fail != UT64_MAX) {\n\t\t\t\tprintline (\"fail\", \"0x%08\" PFMT64x \"\\n\", op.fail);\n\t\t\t}\n\t\t\tif (op.delay) {\n\t\t\t\tprintline (\"delay\", \"%d\\n\", op.delay);\n\t\t\t}\n\t\t\tprintline (\"stack\", \"%s\\n\", r_anal_stackop_tostring (op.stackop));\n\t\t\t{\n\t\t\t\tconst char *arg = (op.type & R_ANAL_OP_TYPE_COND)?  r_anal_cond_tostring (op.cond): NULL;\n\t\t\t\tif (arg) {\n\t\t\t\t\tprintline (\"cond\", \"%s\\n\", arg);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintline (\"family\", \"%s\\n\", r_anal_op_family_to_string (op.family));\n\t\t\tprintline (\"stackop\", \"%s\\n\", r_anal_stackop_tostring (op.stackop));\n\t\t\tif (op.stackptr) {\n\t\t\t\tprintline (\"stackptr\", \"%\"PFMT64u\"\\n\", op.stackptr);\n\t\t\t}\n\t\t}\n\t\t//r_cons_printf (\"false: 0x%08\"PFMT64x\"\\n\", core->offset+idx);\n\t\t//free (hint);\n\t\tfree (mnem);\n\t\tr_anal_hint_free (hint);\n\t\tr_anal_op_fini (&op);\n\t}\n\tr_anal_op_fini (&op);\n\tif (fmt == 'j') {\n\t\tr_cons_printf (\"]\");\n\t\tr_cons_newline ();\n\t} else if (fmt == 's') {\n\t\tr_cons_printf (\"%d\\n\", totalsize);\n\t}\n\tr_anal_esil_free (esil);\n}", "func_src_after": "static void core_anal_bytes(RCore *core, const ut8 *buf, int len, int nops, int fmt) {\n\tint stacksize = r_config_get_i (core->config, \"esil.stack.depth\");\n\tbool iotrap = r_config_get_i (core->config, \"esil.iotrap\");\n\tbool romem = r_config_get_i (core->config, \"esil.romem\");\n\tbool stats = r_config_get_i (core->config, \"esil.stats\");\n\tbool be = core->print->big_endian;\n\tbool use_color = core->print->flags & R_PRINT_FLAGS_COLOR;\n\tcore->parser->relsub = r_config_get_i (core->config, \"asm.relsub\");\n\tint ret, i, j, idx, size;\n\tconst char *color = \"\";\n\tconst char *esilstr;\n\tconst char *opexstr;\n\tRAnalHint *hint;\n\tRAnalEsil *esil = NULL;\n\tRAsmOp asmop;\n\tRAnalOp op = {0};\n\tut64 addr;\n\tbool isFirst = true;\n\tunsigned int addrsize = r_config_get_i (core->config, \"esil.addr.size\");\n\tint totalsize = 0;\n\n\t// Variables required for setting up ESIL to REIL conversion\n\tif (use_color) {\n\t\tcolor = core->cons->pal.label;\n\t}\n\tswitch (fmt) {\n\tcase 'j':\n\t\tr_cons_printf (\"[\");\n\t\tbreak;\n\tcase 'r':\n\t\t// Setup for ESIL to REIL conversion\n\t\tesil = r_anal_esil_new (stacksize, iotrap, addrsize);\n\t\tif (!esil) {\n\t\t\treturn;\n\t\t}\n\t\tr_anal_esil_to_reil_setup (esil, core->anal, romem, stats);\n\t\tr_anal_esil_set_pc (esil, core->offset);\n\t\tbreak;\n\t}\n\tfor (i = idx = ret = 0; idx < len && (!nops || (nops && i < nops)); i++, idx += ret) {\n\t\taddr = core->offset + idx;\n\t\t// TODO: use more anal hints\n\t\thint = r_anal_hint_get (core->anal, addr);\n\t\tr_asm_set_pc (core->assembler, addr);\n\t\t(void)r_asm_disassemble (core->assembler, &asmop, buf + idx, len - idx);\n\t\tret = r_anal_op (core->anal, &op, core->offset + idx, buf + idx, len - idx, R_ANAL_OP_MASK_ESIL);\n\t\tesilstr = R_STRBUF_SAFEGET (&op.esil);\n\t\topexstr = R_STRBUF_SAFEGET (&op.opex);\n\t\tchar *mnem = strdup (r_asm_op_get_asm (&asmop));\n\t\tchar *sp = strchr (mnem, ' ');\n\t\tif (sp) {\n\t\t\t*sp = 0;\n\t\t\tif (op.prefix) {\n\t\t\t\tchar *arg = strdup (sp + 1);\n\t\t\t\tchar *sp = strchr (arg, ' ');\n\t\t\t\tif (sp) {\n\t\t\t\t\t*sp = 0;\n\t\t\t\t}\n\t\t\t\tfree (mnem);\n\t\t\t\tmnem = arg;\n\t\t\t}\n\t\t}\n\t\tif (ret < 1 && fmt != 'd') {\n\t\t\teprintf (\"Oops at 0x%08\" PFMT64x \" (\", core->offset + idx);\n\t\t\tfor (i = idx, j = 0; i < core->blocksize && j < 3; ++i, ++j) {\n\t\t\t\teprintf (\"%02x \", buf[i]);\n\t\t\t}\n\t\t\teprintf (\"...)\\n\");\n\t\t\tfree (mnem);\n\t\t\tbreak;\n\t\t}\n\t\tsize = (hint && hint->size)? hint->size: op.size;\n\t\tif (fmt == 'd') {\n\t\t\tchar *opname = strdup (r_asm_op_get_asm (&asmop));\n\t\t\tif (opname) {\n\t\t\t\tr_str_split (opname, ' ');\n\t\t\t\tchar *d = r_asm_describe (core->assembler, opname);\n\t\t\t\tif (d && *d) {\n\t\t\t\t\tr_cons_printf (\"%s: %s\\n\", opname, d);\n\t\t\t\t\tfree (d);\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Unknown opcode\\n\");\n\t\t\t\t}\n\t\t\t\tfree (opname);\n\t\t\t}\n\t\t} else if (fmt == 'e') {\n\t\t\tif (*esilstr) {\n\t\t\t\tif (use_color) {\n\t\t\t\t\tr_cons_printf (\"%s0x%\" PFMT64x Color_RESET \" %s\\n\", color, core->offset + idx, esilstr);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"0x%\" PFMT64x \" %s\\n\", core->offset + idx, esilstr);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (fmt == 's') {\n\t\t\ttotalsize += op.size;\n\t\t} else if (fmt == 'r') {\n\t\t\tif (*esilstr) {\n\t\t\t\tif (use_color) {\n\t\t\t\t\tr_cons_printf (\"%s0x%\" PFMT64x Color_RESET \"\\n\", color, core->offset + idx);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"0x%\" PFMT64x \"\\n\", core->offset + idx);\n\t\t\t\t}\n\t\t\t\tr_anal_esil_parse (esil, esilstr);\n\t\t\t\tr_anal_esil_dumpstack (esil);\n\t\t\t\tr_anal_esil_stack_free (esil);\n\t\t\t}\n\t\t} else if (fmt == 'j') {\n\t\t\tif (isFirst) {\n\t\t\t\tisFirst = false;\n\t\t\t} else {\n\t\t\t\tr_cons_print (\",\");\n\t\t\t}\n\t\t\tr_cons_printf (\"{\\\"opcode\\\":\\\"%s\\\",\", r_asm_op_get_asm (&asmop));\n\t\t\t{\n\t\t\t\tchar strsub[128] = { 0 };\n\t\t\t\t// pc+33\n\t\t\t\tr_parse_varsub (core->parser, NULL,\n\t\t\t\t\tcore->offset + idx,\n\t\t\t\t\tasmop.size, r_asm_op_get_asm (&asmop),\n\t\t\t\t\tstrsub, sizeof (strsub));\n\t\t\t\t{\n\t\t\t\t\tut64 killme = UT64_MAX;\n\t\t\t\t\tif (r_io_read_i (core->io, op.ptr, &killme, op.refptr, be)) {\n\t\t\t\t\t\tcore->parser->relsub_addr = killme;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// 0x33->sym.xx\n\t\t\t\tchar *p = strdup (strsub);\n\t\t\t\tif (p) {\n\t\t\t\t\tr_parse_filter (core->parser, addr, core->flags, p,\n\t\t\t\t\t\t\tstrsub, sizeof (strsub), be);\n\t\t\t\t\tfree (p);\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"\\\"disasm\\\":\\\"%s\\\",\", strsub);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"mnemonic\\\":\\\"%s\\\",\", mnem);\n\t\t\tif (hint && hint->opcode) {\n\t\t\t\tr_cons_printf (\"\\\"ophint\\\":\\\"%s\\\",\", hint->opcode);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"sign\\\":%s,\", r_str_bool (op.sign));\n\t\t\tr_cons_printf (\"\\\"prefix\\\":%\" PFMT64u \",\", op.prefix);\n\t\t\tr_cons_printf (\"\\\"id\\\":%d,\", op.id);\n\t\t\tif (opexstr && *opexstr) {\n\t\t\t\tr_cons_printf (\"\\\"opex\\\":%s,\", opexstr);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"addr\\\":%\" PFMT64u \",\", core->offset + idx);\n\t\t\tr_cons_printf (\"\\\"bytes\\\":\\\"\");\n\t\t\tfor (j = 0; j < size; j++) {\n\t\t\t\tr_cons_printf (\"%02x\", buf[j + idx]);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\",\");\n\t\t\tif (op.val != UT64_MAX) {\n\t\t\t\tr_cons_printf (\"\\\"val\\\": %\" PFMT64u \",\", op.val);\n\t\t\t}\n\t\t\tif (op.ptr != UT64_MAX) {\n\t\t\t\tr_cons_printf (\"\\\"ptr\\\": %\" PFMT64u \",\", op.ptr);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"size\\\": %d,\", size);\n\t\t\tr_cons_printf (\"\\\"type\\\": \\\"%s\\\",\",\n\t\t\t\tr_anal_optype_to_string (op.type));\n\t\t\tif (op.reg) {\n\t\t\t\tr_cons_printf (\"\\\"reg\\\": \\\"%s\\\",\", op.reg);\n\t\t\t}\n\t\t\tif (op.ireg) {\n\t\t\t\tr_cons_printf (\"\\\"ireg\\\": \\\"%s\\\",\", op.ireg);\n\t\t\t}\n\t\t\tif (op.scale) {\n\t\t\t\tr_cons_printf (\"\\\"scale\\\":%d,\", op.scale);\n\t\t\t}\n\t\t\tif (hint && hint->esil) {\n\t\t\t\tr_cons_printf (\"\\\"esil\\\": \\\"%s\\\",\", hint->esil);\n\t\t\t} else if (*esilstr) {\n\t\t\t\tr_cons_printf (\"\\\"esil\\\": \\\"%s\\\",\", esilstr);\n\t\t\t}\n\t\t\tif (hint && hint->jump != UT64_MAX) {\n\t\t\t\top.jump = hint->jump;\n\t\t\t}\n\t\t\tif (op.jump != UT64_MAX) {\n\t\t\t\tr_cons_printf (\"\\\"jump\\\":%\" PFMT64u \",\", op.jump);\n\t\t\t}\n\t\t\tif (hint && hint->fail != UT64_MAX) {\n\t\t\t\top.fail = hint->fail;\n\t\t\t}\n\t\t\tif (op.refptr != -1) {\n\t\t\t\tr_cons_printf (\"\\\"refptr\\\":%d,\", op.refptr);\n\t\t\t}\n\t\t\tif (op.fail != UT64_MAX) {\n\t\t\t\tr_cons_printf (\"\\\"fail\\\":%\" PFMT64u \",\", op.fail);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"cycles\\\":%d,\", op.cycles);\n\t\t\tif (op.failcycles) {\n\t\t\t\tr_cons_printf (\"\\\"failcycles\\\":%d,\", op.failcycles);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"delay\\\":%d,\", op.delay);\n\t\t\t{\n\t\t\t\tconst char *p = r_anal_stackop_tostring (op.stackop);\n\t\t\t\tif (p && *p && strcmp (p, \"null\"))\n\t\t\t\t\tr_cons_printf (\"\\\"stack\\\":\\\"%s\\\",\", p);\n\t\t\t}\n\t\t\tif (op.stackptr) {\n\t\t\t\tr_cons_printf (\"\\\"stackptr\\\":%d,\", op.stackptr);\n\t\t\t}\n\t\t\t{\n\t\t\t\tconst char *arg = (op.type & R_ANAL_OP_TYPE_COND)\n\t\t\t\t\t? r_anal_cond_tostring (op.cond): NULL;\n\t\t\t\tif (arg) {\n\t\t\t\t\tr_cons_printf (\"\\\"cond\\\":\\\"%s\\\",\", arg);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"family\\\":\\\"%s\\\"}\", r_anal_op_family_to_string (op.family));\n\t\t} else {\n#define printline(k, fmt, arg)\\\n\t{ \\\n\t\tif (use_color)\\\n\t\t\tr_cons_printf (\"%s%s: \" Color_RESET, color, k);\\\n\t\telse\\\n\t\t\tr_cons_printf (\"%s: \", k);\\\n\t\tif (fmt) r_cons_printf (fmt, arg);\\\n\t}\n\t\t\tprintline (\"address\", \"0x%\" PFMT64x \"\\n\", core->offset + idx);\n\t\t\tprintline (\"opcode\", \"%s\\n\", r_asm_op_get_asm (&asmop));\n\t\t\tprintline (\"mnemonic\", \"%s\\n\", mnem);\n\t\t\tif (hint) {\n\t\t\t\tif (hint->opcode) {\n\t\t\t\t\tprintline (\"ophint\", \"%s\\n\", hint->opcode);\n\t\t\t\t}\n#if 0\n\t\t\t\t// addr should not override core->offset + idx.. its silly\n\t\t\t\tif (hint->addr != UT64_MAX) {\n\t\t\t\t\tprintline (\"addr\", \"0x%08\" PFMT64x \"\\n\", (hint->addr + idx));\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t\tprintline (\"prefix\", \"%\" PFMT64u \"\\n\", op.prefix);\n\t\t\tprintline (\"id\", \"%d\\n\", op.id);\n#if 0\n// no opex here to avoid lot of tests broken..and having json in here is not much useful imho\n\t\t\tif (opexstr && *opexstr) {\n\t\t\t\tprintline (\"opex\", \"%s\\n\", opexstr);\n\t\t\t}\n#endif\n\t\t\tprintline (\"bytes\", NULL, 0);\n\t\t\tint minsz = R_MIN (len, size);\n\t\t\tminsz = R_MAX (minsz, 0);\n\t\t\tfor (j = 0; j < minsz; j++) {\n\t\t\t\tut8 ch = ((j + idx - 1) > minsz)? 0xff: buf[j + idx];\n\t\t\t\tr_cons_printf (\"%02x\", ch);\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t\tif (op.val != UT64_MAX) {\n\t\t\t\tprintline (\"val\", \"0x%08\" PFMT64x \"\\n\", op.val);\n\t\t\t}\n\t\t\tif (op.ptr != UT64_MAX) {\n\t\t\t\tprintline (\"ptr\", \"0x%08\" PFMT64x \"\\n\", op.ptr);\n\t\t\t}\n\t\t\tif (op.refptr != -1) {\n\t\t\t\tprintline (\"refptr\", \"%d\\n\", op.refptr);\n\t\t\t}\n\t\t\tprintline (\"size\", \"%d\\n\", size);\n\t\t\tprintline (\"sign\", \"%s\\n\", r_str_bool (op.sign));\n\t\t\tprintline (\"type\", \"%s\\n\", r_anal_optype_to_string (op.type));\n\t\t\tprintline (\"cycles\", \"%d\\n\", op.cycles);\n\t\t\tif (op.failcycles) {\n\t\t\t\tprintline (\"failcycles\", \"%d\\n\", op.failcycles);\n\t\t\t}\n\t\t\t{\n\t\t\t\tconst char *t2 = r_anal_optype_to_string (op.type2);\n\t\t\t\tif (t2 && strcmp (t2, \"null\")) {\n\t\t\t\t\tprintline (\"type2\", \"%s\\n\", t2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (op.reg) {\n\t\t\t\tprintline (\"reg\", \"%s\\n\", op.reg);\n\t\t\t}\n\t\t\tif (op.ireg) {\n\t\t\t\tprintline (\"ireg\", \"%s\\n\", op.ireg);\n\t\t\t}\n\t\t\tif (op.scale) {\n\t\t\t\tprintline (\"scale\", \"%d\\n\", op.scale);\n\t\t\t}\n\t\t\tif (hint && hint->esil) {\n\t\t\t\tprintline (\"esil\", \"%s\\n\", hint->esil);\n\t\t\t} else if (*esilstr) {\n\t\t\t\tprintline (\"esil\", \"%s\\n\", esilstr);\n\t\t\t}\n\t\t\tif (hint && hint->jump != UT64_MAX) {\n\t\t\t\top.jump = hint->jump;\n\t\t\t}\n\t\t\tif (op.jump != UT64_MAX) {\n\t\t\t\tprintline (\"jump\", \"0x%08\" PFMT64x \"\\n\", op.jump);\n\t\t\t}\n\t\t\tif (op.direction != 0) {\n\t\t\t\tconst char * dir = op.direction == 1 ? \"read\"\n\t\t\t\t\t: op.direction == 2 ? \"write\"\n\t\t\t\t\t: op.direction == 4 ? \"exec\"\n\t\t\t\t\t: op.direction == 8 ? \"ref\": \"none\";\n\t\t\t\tprintline (\"direction\", \"%s\\n\", dir);\n\t\t\t}\n\t\t\tif (hint && hint->fail != UT64_MAX) {\n\t\t\t\top.fail = hint->fail;\n\t\t\t}\n\t\t\tif (op.fail != UT64_MAX) {\n\t\t\t\tprintline (\"fail\", \"0x%08\" PFMT64x \"\\n\", op.fail);\n\t\t\t}\n\t\t\tif (op.delay) {\n\t\t\t\tprintline (\"delay\", \"%d\\n\", op.delay);\n\t\t\t}\n\t\t\tprintline (\"stack\", \"%s\\n\", r_anal_stackop_tostring (op.stackop));\n\t\t\t{\n\t\t\t\tconst char *arg = (op.type & R_ANAL_OP_TYPE_COND)?  r_anal_cond_tostring (op.cond): NULL;\n\t\t\t\tif (arg) {\n\t\t\t\t\tprintline (\"cond\", \"%s\\n\", arg);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintline (\"family\", \"%s\\n\", r_anal_op_family_to_string (op.family));\n\t\t\tprintline (\"stackop\", \"%s\\n\", r_anal_stackop_tostring (op.stackop));\n\t\t\tif (op.stackptr) {\n\t\t\t\tprintline (\"stackptr\", \"%\"PFMT64u\"\\n\", op.stackptr);\n\t\t\t}\n\t\t}\n\t\t//r_cons_printf (\"false: 0x%08\"PFMT64x\"\\n\", core->offset+idx);\n\t\t//free (hint);\n\t\tfree (mnem);\n\t\tr_anal_hint_free (hint);\n\t\tr_anal_op_fini (&op);\n\t}\n\tr_anal_op_fini (&op);\n\tif (fmt == 'j') {\n\t\tr_cons_printf (\"]\");\n\t\tr_cons_newline ();\n\t} else if (fmt == 's') {\n\t\tr_cons_printf (\"%d\\n\", totalsize);\n\t}\n\tr_anal_esil_free (esil);\n}", "commit_link": "github.com/radare/radare2/commit/a1bc65c3db593530775823d6d7506a457ed95267", "file_name": "libr/core/cmd_anal.c", "vul_type": "cwe-125", "description": "Write a C function named `core_anal_bytes` that analyzes a buffer of bytes for disassembly and ESIL (Evaluable Strings Intermediate Language) conversion in Radare2."}
{"func_name": "decode_studio_vop_header", "func_src_before": "static int decode_studio_vop_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n\n    if (get_bits_left(gb) <= 32)\n        return 0;\n\n    s->partitioned_frame = 0;\n    s->decode_mb = mpeg4_decode_studio_mb;\n\n    decode_smpte_tc(ctx, gb);\n\n    skip_bits(gb, 10); /* temporal_reference */\n    skip_bits(gb, 2); /* vop_structure */\n    s->pict_type = get_bits(gb, 2) + AV_PICTURE_TYPE_I; /* vop_coding_type */\n    if (get_bits1(gb)) { /* vop_coded */\n        skip_bits1(gb); /* top_field_first */\n        skip_bits1(gb); /* repeat_first_field */\n        s->progressive_frame = get_bits1(gb) ^ 1; /* progressive_frame */\n    }\n\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n        if (get_bits1(gb))\n            reset_studio_dc_predictors(s);\n    }\n\n    if (ctx->shape != BIN_ONLY_SHAPE) {\n        s->alternate_scan = get_bits1(gb);\n        s->frame_pred_frame_dct = get_bits1(gb);\n        s->dct_precision = get_bits(gb, 2);\n        s->intra_dc_precision = get_bits(gb, 2);\n        s->q_scale_type = get_bits1(gb);\n    }\n\n    if (s->alternate_scan) {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n    } else {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n    }\n\n    mpeg4_load_default_matrices(s);\n\n    next_start_code_studio(gb);\n    extension_and_user_data(s, gb, 4);\n\n    return 0;\n}", "func_src_after": "static int decode_studio_vop_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n\n    if (get_bits_left(gb) <= 32)\n        return 0;\n\n    s->partitioned_frame = 0;\n    s->interlaced_dct = 0;\n    s->decode_mb = mpeg4_decode_studio_mb;\n\n    decode_smpte_tc(ctx, gb);\n\n    skip_bits(gb, 10); /* temporal_reference */\n    skip_bits(gb, 2); /* vop_structure */\n    s->pict_type = get_bits(gb, 2) + AV_PICTURE_TYPE_I; /* vop_coding_type */\n    if (get_bits1(gb)) { /* vop_coded */\n        skip_bits1(gb); /* top_field_first */\n        skip_bits1(gb); /* repeat_first_field */\n        s->progressive_frame = get_bits1(gb) ^ 1; /* progressive_frame */\n    }\n\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n        if (get_bits1(gb))\n            reset_studio_dc_predictors(s);\n    }\n\n    if (ctx->shape != BIN_ONLY_SHAPE) {\n        s->alternate_scan = get_bits1(gb);\n        s->frame_pred_frame_dct = get_bits1(gb);\n        s->dct_precision = get_bits(gb, 2);\n        s->intra_dc_precision = get_bits(gb, 2);\n        s->q_scale_type = get_bits1(gb);\n    }\n\n    if (s->alternate_scan) {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n    } else {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n    }\n\n    mpeg4_load_default_matrices(s);\n\n    next_start_code_studio(gb);\n    extension_and_user_data(s, gb, 4);\n\n    return 0;\n}", "commit_link": "github.com/FFmpeg/FFmpeg/commit/1f686d023b95219db933394a7704ad9aa5f01cbb", "file_name": "libavcodec/mpeg4videodec.c", "vul_type": "cwe-125", "description": "Write a C function to decode the header of a studio video object plane (VOP) for an MPEG4 decoder context."}
{"func_name": "get_error_days", "func_src_before": "def get_error_days(cur, error_percent):\n    \"\"\"Fetches the days in which requests led to errors.\n\n    Fetches the days in which the specified percentage\n    of requests led to errors.\n\n    Args:\n        cur(obj): The cursor to execute the query.\n        error_percent(int): The percentage of requests that led to errors.\n\n    Return:\n        True if success, False otherwise.\n    \"\"\"\n    query = '''SELECT to_char(log_errors.date, 'Mon DD YYYY'),\n            round((log_errors.errors * 100\n            / log_requests.total::numeric), 2) as percent\n            FROM log_errors, log_requests\n            WHERE log_errors.date = log_requests.date AND\n            log_errors.errors * 100\n            / log_requests.total::numeric > {}\n            ORDER BY log_errors.date'''.format(error_percent)\n    rows = get_data(cur, query)\n\n    # Write data to txt file.\n    if rows is not None:\n        file = open(\"error_report.txt\", \"w\")\n        for row in rows:\n            file.write(\"{} - {}% errors \\n\".format(row[0], row[1]))\n        file.close()\n\n        return True\n    else:\n        return False", "func_src_after": "def get_error_days(cur, error_percent):\n    \"\"\"Fetches the days in which requests led to errors.\n\n    Fetches the days in which the specified percentage\n    of requests led to errors.\n\n    Args:\n        cur(obj): The cursor to execute the query.\n        error_percent(int): The percentage of requests that led to errors.\n\n    Return:\n        True if success, False otherwise.\n    \"\"\"\n    data = (error_percent, )\n    query = '''SELECT to_char(log_errors.date, 'Mon DD YYYY'),\n            round((log_errors.errors * 100\n            / log_requests.total::numeric), 2) as percent\n            FROM log_errors, log_requests\n            WHERE log_errors.date = log_requests.date AND\n            log_errors.errors * 100\n            / log_requests.total::numeric > %s\n            ORDER BY log_errors.date'''\n    rows = get_data(cur, query, data)\n\n    # Write data to txt file.\n    if rows is not None:\n        file = open(\"error_report.txt\", \"w\")\n        for row in rows:\n            file.write(\"{} - {}% errors \\n\".format(row[0], row[1]))\n        file.close()\n\n        return True\n    else:\n        return False", "commit_link": "github.com/rrbiz662/log-analysis/commit/20fefbde3738088586a3c5679f743493d0a504f6", "file_name": "news_data_analysis.py", "vul_type": "cwe-089", "description": "Write a Python function to query a database for days with error rates above a threshold and save the results to a text file."}
{"func_name": "pr_init", "func_src_before": "function pr_init() {\n\tif( document.getElementById( 'pr_container' ) ) {\n\t\treturn;\n\t}\n\n\tif( document.URL.indexOf( 'action=protect' ) > 0 || document.URL.indexOf( 'action=unprotect' ) > 0 ) {\n\t\treturn;\n\t}\n\tif( document.URL.indexOf( 'action=delete' ) > 0 || document.URL.indexOf( 'action=undelete' ) > 0 ) {\n\t\treturn;\n\t}\n\tif( document.URL.indexOf( 'action=watch' ) > 0 || document.URL.indexOf( 'action=unwatch' ) > 0 ) {\n\t\treturn;\n\t}\n\tif( document.URL.indexOf( 'action=history' ) > 0 ) {\n\t\treturn;\n\t}\n\n\t/* check if external URL is provided */\n\tif( !self.proofreadPageThumbURL ) {\n\t\tvar text = document.getElementById( 'wpTextbox1' );\n\t\tif ( text ) {\n\t\t\tvar proofreadPageIsEdit = true;\n\t\t\tre = /<span class=\"hiddenStructure\" id=\"pageURL\">\\[http:\\/\\/(.*?)\\]<\\/span>/;\n\t\t\tm = re.exec( text.value );\n\t\t\tif( m ) {\n\t\t\t\tself.proofreadPageExternalURL = 'http://' + m[1];\n\t\t\t}\n\t\t} else {\n\t\t\tvar proofreadPageIsEdit = false;\n\t\t\ttext = document.getElementById( 'bodyContent' );\n\t\t\ttry {\n\t\t\t\tvar a = document.getElementById( 'pageURL' );\n\t\t\t\tvar b = a.firstChild;\n\t\t\t\tself.proofreadPageExternalURL = b.getAttribute( 'href' );\n\t\t\t} catch( err ) {\n\t\t\t};\n\t\t}\n\t\t// set to dummy values, not used\n\t\tself.proofreadPageWidth = 400;\n\t\tself.proofreadPageHeight = 400;\n\t}\n\n\tif( !self.proofreadPageThumbURL ) {\n\t\treturn;\n\t}\n\n\tif( self.proofreadpage_setup ) {\n\t\tproofreadpage_setup(\n\t\t\tproofreadPageWidth,\n\t\t\tproofreadPageHeight,\n\t\t\tproofreadPageIsEdit\n\t\t);\n\t} else {\n\t\tpr_setup();\n\t}\n\n\t// add CSS classes to the container div\n\tvar c = document.getElementById( 'pagequality' );\n\tif( c ) {\n\t\tc = c.nextSibling;\n\t\tif( c.className == 'pagetext' ) {\n\t\t\tc.className += ' ' + self.proofreadPageCss;\n\t\t}\n\t}\n}\n\n$(document).ready( pr_init );\n$(document).ready( pr_init_tabs );\n$(document).ready( pr_initzoom );\n\n\n/* Quality buttons */\nself.pr_add_quality = function( form, value ) {\n\tself.proofreadpage_quality = value;\n\tself.proofreadpage_username = proofreadPageUserName;\n\tvar text = '';\n\tswitch( value ) {\n\t\tcase 0:\n\t\t\ttext = mediaWiki.msg( 'proofreadpage_quality0_category' );\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ttext = mediaWiki.msg( 'proofreadpage_quality1_category' );\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttext = mediaWiki.msg( 'proofreadpage_quality2_category' );\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ttext = mediaWiki.msg( 'proofreadpage_quality3_category' );\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\ttext = mediaWiki.msg( 'proofreadpage_quality4_category' );\n\t\t\tbreak;\n\t}\n\tform.elements['wpSummary'].value = '/* ' + text + ' */ ';\n\tform.elements['wpProofreader'].value = self.proofreadpage_username;\n};\n\nfunction pr_add_quality_buttons() {\n\tvar ig = document.getElementById( 'wpWatchthis' );\n\tif( !ig ) {\n\t\tig = document.getElementById( 'wpSummary' );\n\t}\n\tif( !ig ) {\n\t\treturn;\n\t}\n\tvar f = document.createElement( 'span' );\n\tig.parentNode.insertBefore( f, ig.nextSibling.nextSibling.nextSibling );\n\n\tif( !proofreadPageAddButtons ) {\n\t\tf.innerHTML =\n\t\t\t' <input type=\"hidden\" name=\"wpProofreader\" value=\"' + self.proofreadpage_username + '\">' +\n\t\t\t'<input type=\"hidden\" name=\"quality\" value=' + self.proofreadpage_quality + ' >';\n\t\treturn;\n\t}\n\n\tf.innerHTML =\n' <input type=\"hidden\" name=\"wpProofreader\" value=\"' + self.proofreadpage_username + '\">'\n+'<span class=\"quality0\"> <input type=\"radio\" name=\"quality\" value=0 onclick=\"pr_add_quality(this.form,0)\" tabindex=4> </span>'\n+'<span class=\"quality2\"> <input type=\"radio\" name=\"quality\" value=2 onclick=\"pr_add_quality(this.form,2)\" tabindex=4> </span>'\n+'<span class=\"quality1\"> <input type=\"radio\" name=\"quality\" value=1 onclick=\"pr_add_quality(this.form,1)\" tabindex=4> </span>'\n+'<span class=\"quality3\"> <input type=\"radio\" name=\"quality\" value=3 onclick=\"pr_add_quality(this.form,3)\" tabindex=4> </span>'\n+'<span class=\"quality4\"> <input type=\"radio\" name=\"quality\" value=4 onclick=\"pr_add_quality(this.form,4)\" tabindex=4> </span>';\n\tf.innerHTML = f.innerHTML + '&nbsp;' + escapeQuotesHTML( mediaWiki.msg( 'proofreadpage_page_status' ) );\n\n\tif( !( ( self.proofreadpage_quality == 4 ) || ( ( self.proofreadpage_quality == 3 ) && ( self.proofreadpage_username != proofreadPageUserName ) ) ) ) {\n\t\tdocument.editform.quality[4].parentNode.style.cssText = 'display:none';\n\t\tdocument.editform.quality[4].disabled = true;\n\t}\n\tswitch( self.proofreadpage_quality ) {\n\t\tcase 4:\n\t\t\tdocument.editform.quality[4].checked = true;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdocument.editform.quality[3].checked = true;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdocument.editform.quality[2].checked = true;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdocument.editform.quality[1].checked = true;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tdocument.editform.quality[0].checked = true;\n\t\t\tbreak;\n\t}", "func_src_after": "function pr_init() {\n\tif( document.getElementById( 'pr_container' ) ) {\n\t\treturn;\n\t}\n\n\tif( document.URL.indexOf( 'action=protect' ) > 0 || document.URL.indexOf( 'action=unprotect' ) > 0 ) {\n\t\treturn;\n\t}\n\tif( document.URL.indexOf( 'action=delete' ) > 0 || document.URL.indexOf( 'action=undelete' ) > 0 ) {\n\t\treturn;\n\t}\n\tif( document.URL.indexOf( 'action=watch' ) > 0 || document.URL.indexOf( 'action=unwatch' ) > 0 ) {\n\t\treturn;\n\t}\n\tif( document.URL.indexOf( 'action=history' ) > 0 ) {\n\t\treturn;\n\t}\n\n\t/* check if external URL is provided */\n\tif( !self.proofreadPageThumbURL ) {\n\t\tvar text = document.getElementById( 'wpTextbox1' );\n\t\tif ( text ) {\n\t\t\tvar proofreadPageIsEdit = true;\n\t\t\tre = /<span class=\"hiddenStructure\" id=\"pageURL\">\\[http:\\/\\/(.*?)\\]<\\/span>/;\n\t\t\tm = re.exec( text.value );\n\t\t\tif( m ) {\n\t\t\t\tself.proofreadPageExternalURL = 'http://' + m[1];\n\t\t\t}\n\t\t} else {\n\t\t\tvar proofreadPageIsEdit = false;\n\t\t\ttext = document.getElementById( 'bodyContent' );\n\t\t\ttry {\n\t\t\t\tvar a = document.getElementById( 'pageURL' );\n\t\t\t\tvar b = a.firstChild;\n\t\t\t\tself.proofreadPageExternalURL = b.getAttribute( 'href' );\n\t\t\t} catch( err ) {\n\t\t\t};\n\t\t}\n\t\t// set to dummy values, not used\n\t\tself.proofreadPageWidth = 400;\n\t\tself.proofreadPageHeight = 400;\n\t}\n\n\tif( !self.proofreadPageThumbURL ) {\n\t\treturn;\n\t}\n\n\tif( self.proofreadpage_setup ) {\n\t\tproofreadpage_setup(\n\t\t\tproofreadPageWidth,\n\t\t\tproofreadPageHeight,\n\t\t\tproofreadPageIsEdit\n\t\t);\n\t} else {\n\t\tpr_setup();\n\t}\n\n\t// add CSS classes to the container div\n\tvar c = document.getElementById( 'pagequality' );\n\tif( c ) {\n\t\tc = c.nextSibling;\n\t\tif( c.className == 'pagetext' ) {\n\t\t\tc.className += ' ' + self.proofreadPageCss;\n\t\t}\n\t}\n}\n\n$(document).ready( pr_init );\n$(document).ready( pr_init_tabs );\n$(document).ready( pr_initzoom );\n\n\n/* Quality buttons */\nself.pr_add_quality = function( form, value ) {\n\tself.proofreadpage_quality = value;\n\tself.proofreadpage_username = proofreadPageUserName;\n\tvar text = '';\n\tswitch( value ) {\n\t\tcase 0:\n\t\t\ttext = mediaWiki.msg( 'proofreadpage_quality0_category' );\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ttext = mediaWiki.msg( 'proofreadpage_quality1_category' );\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttext = mediaWiki.msg( 'proofreadpage_quality2_category' );\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ttext = mediaWiki.msg( 'proofreadpage_quality3_category' );\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\ttext = mediaWiki.msg( 'proofreadpage_quality4_category' );\n\t\t\tbreak;\n\t}\n\tform.elements['wpSummary'].value = '/* ' + text + ' */ ';\n\tform.elements['wpProofreader'].value = self.proofreadpage_username;\n};\n\nfunction pr_add_quality_buttons() {\n\tvar ig = document.getElementById( 'wpWatchthis' );\n\tif( !ig ) {\n\t\tig = document.getElementById( 'wpSummary' );\n\t}\n\tif( !ig ) {\n\t\treturn;\n\t}\n\tvar f = document.createElement( 'span' );\n\tig.parentNode.insertBefore( f, ig.nextSibling.nextSibling.nextSibling );\n\n\tif( !proofreadPageAddButtons ) {\n\t\tf.innerHTML =\n\t\t\t' <input type=\"hidden\" name=\"wpProofreader\" value=\"' + escapeQuotesHTML( self.proofreadpage_username ) + '\">' +\n\t\t\t'<input type=\"hidden\" name=\"quality\" value=\"' + escapeQuotesHTML( self.proofreadpage_quality ) + '\" >';\n\t\treturn;\n\t}\n\n\tf.innerHTML =\n' <input type=\"hidden\" name=\"wpProofreader\" value=\"' + escapeQuotesHTML( self.proofreadpage_username ) + '\">'\n+'<span class=\"quality0\"> <input type=\"radio\" name=\"quality\" value=0 onclick=\"pr_add_quality(this.form,0)\" tabindex=4> </span>'\n+'<span class=\"quality2\"> <input type=\"radio\" name=\"quality\" value=2 onclick=\"pr_add_quality(this.form,2)\" tabindex=4> </span>'\n+'<span class=\"quality1\"> <input type=\"radio\" name=\"quality\" value=1 onclick=\"pr_add_quality(this.form,1)\" tabindex=4> </span>'\n+'<span class=\"quality3\"> <input type=\"radio\" name=\"quality\" value=3 onclick=\"pr_add_quality(this.form,3)\" tabindex=4> </span>'\n+'<span class=\"quality4\"> <input type=\"radio\" name=\"quality\" value=4 onclick=\"pr_add_quality(this.form,4)\" tabindex=4> </span>';\n\tf.innerHTML = f.innerHTML + '&nbsp;' + escapeQuotesHTML( mediaWiki.msg( 'proofreadpage_page_status' ) );\n\n\tif( !( ( self.proofreadpage_quality == 4 ) || ( ( self.proofreadpage_quality == 3 ) && ( self.proofreadpage_username != proofreadPageUserName ) ) ) ) {\n\t\tdocument.editform.quality[4].parentNode.style.cssText = 'display:none';\n\t\tdocument.editform.quality[4].disabled = true;\n\t}\n\tswitch( self.proofreadpage_quality ) {\n\t\tcase 4:\n\t\t\tdocument.editform.quality[4].checked = true;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdocument.editform.quality[3].checked = true;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdocument.editform.quality[2].checked = true;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdocument.editform.quality[1].checked = true;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tdocument.editform.quality[0].checked = true;\n\t\t\tbreak;\n\t}", "line_changes": {"deleted": [{"line_no": 112, "char_start": 2862, "char_end": 2957, "line": "\t\t\t' <input type=\"hidden\" name=\"wpProofreader\" value=\"' + self.proofreadpage_username + '\">' +\n"}, {"line_no": 113, "char_start": 2957, "char_end": 3042, "line": "\t\t\t'<input type=\"hidden\" name=\"quality\" value=' + self.proofreadpage_quality + ' >';\n"}, {"line_no": 118, "char_start": 3071, "char_end": 3161, "line": "' <input type=\"hidden\" name=\"wpProofreader\" value=\"' + self.proofreadpage_username + '\">'\n"}], "added": [{"line_no": 112, "char_start": 2862, "char_end": 2977, "line": "\t\t\t' <input type=\"hidden\" name=\"wpProofreader\" value=\"' + escapeQuotesHTML( self.proofreadpage_username ) + '\">' +\n"}, {"line_no": 113, "char_start": 2977, "char_end": 3084, "line": "\t\t\t'<input type=\"hidden\" name=\"quality\" value=\"' + escapeQuotesHTML( self.proofreadpage_quality ) + '\" >';\n"}, {"line_no": 118, "char_start": 3113, "char_end": 3223, "line": "' <input type=\"hidden\" name=\"wpProofreader\" value=\"' + escapeQuotesHTML( self.proofreadpage_username ) + '\">'\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 2919, "char_end": 2937, "chars": " escapeQuotesHTML("}, {"char_start": 2965, "char_end": 2967, "chars": " )"}, {"char_start": 3023, "char_end": 3024, "chars": "\""}, {"char_start": 3027, "char_end": 3045, "chars": " escapeQuotesHTML("}, {"char_start": 3072, "char_end": 3074, "chars": " )"}, {"char_start": 3078, "char_end": 3079, "chars": "\""}, {"char_start": 3167, "char_end": 3185, "chars": " escapeQuotesHTML("}, {"char_start": 3213, "char_end": 3215, "chars": " )"}]}, "commit_link": "github.com/wikimedia/mediawiki-extensions-ProofreadPage/commit/708bec1ccb45895fe3e6e15d9df454d44f9966f3", "file_name": "proofread.js", "vul_type": "cwe-079", "commit_msg": "ProofreadPage: Fix stored XSS in edit form. Report and patch by Bawolff", "description": "Write JavaScript code to initialize a page and add quality control buttons based on certain conditions."}
{"func_name": "ipxitf_ioctl", "func_src_before": "static int ipxitf_ioctl(unsigned int cmd, void __user *arg)\n{\n\tint rc = -EINVAL;\n\tstruct ifreq ifr;\n\tint val;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR: {\n\t\tstruct sockaddr_ipx *sipx;\n\t\tstruct ipx_interface_definition f;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&ifr, arg, sizeof(ifr)))\n\t\t\tbreak;\n\t\tsipx = (struct sockaddr_ipx *)&ifr.ifr_addr;\n\t\trc = -EINVAL;\n\t\tif (sipx->sipx_family != AF_IPX)\n\t\t\tbreak;\n\t\tf.ipx_network = sipx->sipx_network;\n\t\tmemcpy(f.ipx_device, ifr.ifr_name,\n\t\t\tsizeof(f.ipx_device));\n\t\tmemcpy(f.ipx_node, sipx->sipx_node, IPX_NODE_LEN);\n\t\tf.ipx_dlink_type = sipx->sipx_type;\n\t\tf.ipx_special = sipx->sipx_special;\n\n\t\tif (sipx->sipx_action == IPX_DLTITF)\n\t\t\trc = ipxitf_delete(&f);\n\t\telse\n\t\t\trc = ipxitf_create(&f);\n\t\tbreak;\n\t}\n\tcase SIOCGIFADDR: {\n\t\tstruct sockaddr_ipx *sipx;\n\t\tstruct ipx_interface *ipxif;\n\t\tstruct net_device *dev;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&ifr, arg, sizeof(ifr)))\n\t\t\tbreak;\n\t\tsipx = (struct sockaddr_ipx *)&ifr.ifr_addr;\n\t\tdev  = __dev_get_by_name(&init_net, ifr.ifr_name);\n\t\trc   = -ENODEV;\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tipxif = ipxitf_find_using_phys(dev,\n\t\t\t\t\t   ipx_map_frame_type(sipx->sipx_type));\n\t\trc = -EADDRNOTAVAIL;\n\t\tif (!ipxif)\n\t\t\tbreak;\n\n\t\tsipx->sipx_family\t= AF_IPX;\n\t\tsipx->sipx_network\t= ipxif->if_netnum;\n\t\tmemcpy(sipx->sipx_node, ipxif->if_node,\n\t\t\tsizeof(sipx->sipx_node));\n\t\trc = -EFAULT;\n\t\tif (copy_to_user(arg, &ifr, sizeof(ifr)))\n\t\t\tbreak;\n\t\tipxitf_put(ipxif);\n\t\trc = 0;\n\t\tbreak;\n\t}\n\tcase SIOCAIPXITFCRT:\n\t\trc = -EFAULT;\n\t\tif (get_user(val, (unsigned char __user *) arg))\n\t\t\tbreak;\n\t\trc = 0;\n\t\tipxcfg_auto_create_interfaces = val;\n\t\tbreak;\n\tcase SIOCAIPXPRISLT:\n\t\trc = -EFAULT;\n\t\tif (get_user(val, (unsigned char __user *) arg))\n\t\t\tbreak;\n\t\trc = 0;\n\t\tipxcfg_set_auto_select(val);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}", "func_src_after": "static int ipxitf_ioctl(unsigned int cmd, void __user *arg)\n{\n\tint rc = -EINVAL;\n\tstruct ifreq ifr;\n\tint val;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR: {\n\t\tstruct sockaddr_ipx *sipx;\n\t\tstruct ipx_interface_definition f;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&ifr, arg, sizeof(ifr)))\n\t\t\tbreak;\n\t\tsipx = (struct sockaddr_ipx *)&ifr.ifr_addr;\n\t\trc = -EINVAL;\n\t\tif (sipx->sipx_family != AF_IPX)\n\t\t\tbreak;\n\t\tf.ipx_network = sipx->sipx_network;\n\t\tmemcpy(f.ipx_device, ifr.ifr_name,\n\t\t\tsizeof(f.ipx_device));\n\t\tmemcpy(f.ipx_node, sipx->sipx_node, IPX_NODE_LEN);\n\t\tf.ipx_dlink_type = sipx->sipx_type;\n\t\tf.ipx_special = sipx->sipx_special;\n\n\t\tif (sipx->sipx_action == IPX_DLTITF)\n\t\t\trc = ipxitf_delete(&f);\n\t\telse\n\t\t\trc = ipxitf_create(&f);\n\t\tbreak;\n\t}\n\tcase SIOCGIFADDR: {\n\t\tstruct sockaddr_ipx *sipx;\n\t\tstruct ipx_interface *ipxif;\n\t\tstruct net_device *dev;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&ifr, arg, sizeof(ifr)))\n\t\t\tbreak;\n\t\tsipx = (struct sockaddr_ipx *)&ifr.ifr_addr;\n\t\tdev  = __dev_get_by_name(&init_net, ifr.ifr_name);\n\t\trc   = -ENODEV;\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tipxif = ipxitf_find_using_phys(dev,\n\t\t\t\t\t   ipx_map_frame_type(sipx->sipx_type));\n\t\trc = -EADDRNOTAVAIL;\n\t\tif (!ipxif)\n\t\t\tbreak;\n\n\t\tsipx->sipx_family\t= AF_IPX;\n\t\tsipx->sipx_network\t= ipxif->if_netnum;\n\t\tmemcpy(sipx->sipx_node, ipxif->if_node,\n\t\t\tsizeof(sipx->sipx_node));\n\t\trc = 0;\n\t\tif (copy_to_user(arg, &ifr, sizeof(ifr)))\n\t\t\trc = -EFAULT;\n\t\tipxitf_put(ipxif);\n\t\tbreak;\n\t}\n\tcase SIOCAIPXITFCRT:\n\t\trc = -EFAULT;\n\t\tif (get_user(val, (unsigned char __user *) arg))\n\t\t\tbreak;\n\t\trc = 0;\n\t\tipxcfg_auto_create_interfaces = val;\n\t\tbreak;\n\tcase SIOCAIPXPRISLT:\n\t\trc = -EFAULT;\n\t\tif (get_user(val, (unsigned char __user *) arg))\n\t\t\tbreak;\n\t\trc = 0;\n\t\tipxcfg_set_auto_select(val);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}", "commit_link": "github.com/torvalds/linux/commit/ee0d8d8482345ff97a75a7d747efc309f13b0d80", "file_name": "net/ipx/af_ipx.c", "vul_type": "cwe-416", "description": "Write a C function named `ipxitf_ioctl` that handles IPX network interface control commands."}
{"func_name": "load_sample_environment_variables", "func_src_before": "  def load_sample_environment_variables\n    env_file = File.open('env_configuration_for_local_gem_tests.yml')\n\n    YAML.load(env_file).each do |key, value|\n      ENV[key.to_s] = value\n    end\n  end", "func_src_after": "  def load_sample_environment_variables\n    env_file = File.open('env_configuration_for_local_gem_tests.yml')\n\n    YAML.safe_load(env_file).each do |key, value|\n      ENV[key.to_s] = value\n    end\n  end", "line_changes": {"deleted": [{"line_no": 4, "char_start": 111, "char_end": 156, "line": "    YAML.load(env_file).each do |key, value|\n"}], "added": [{"line_no": 4, "char_start": 111, "char_end": 161, "line": "    YAML.safe_load(env_file).each do |key, value|\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 120, "char_end": 125, "chars": "safe_"}]}, "commit_link": "github.com/fastly/fastly_nsq/commit/c16a48dd2f7b0a67d02c3fae35f0ec9ffaea9839", "file_name": "spec_helper.rb", "vul_type": "cwe-502", "commit_msg": "rubocop YAML.safe_load over just load\n\nthis is the spec_helper and doesn't appear to affect the running of the\ntests...", "parent_commit": "f6b18edc68d1040afdedd59a75a167dcdc244f8e", "description": "Write a Ruby method to load environment variables from a YAML file."}
{"func_name": "ParseEthernetSegmentIdentifier", "func_src_before": "func ParseEthernetSegmentIdentifier(args []string) (EthernetSegmentIdentifier, error) {\n\tesi := EthernetSegmentIdentifier{}\n\targLen := len(args)\n\tif argLen == 0 || args[0] == \"single-homed\" {\n\t\treturn esi, nil\n\t}\n\n\ttypeStr := strings.TrimPrefix(strings.ToUpper(args[0]), \"ESI_\")\n\tswitch typeStr {\n\tcase \"ARBITRARY\":\n\t\tesi.Type = ESI_ARBITRARY\n\tcase \"LACP\":\n\t\tesi.Type = ESI_LACP\n\tcase \"MSTP\":\n\t\tesi.Type = ESI_MSTP\n\tcase \"MAC\":\n\t\tesi.Type = ESI_MAC\n\tcase \"ROUTERID\":\n\t\tesi.Type = ESI_ROUTERID\n\tcase \"AS\":\n\t\tesi.Type = ESI_AS\n\tdefault:\n\t\ttyp, err := strconv.Atoi(args[0])\n\t\tif err != nil {\n\t\t\treturn esi, fmt.Errorf(\"invalid esi type: %s\", args[0])\n\t\t}\n\t\tesi.Type = ESIType(typ)\n\t}\n\n\tinvalidEsiValuesError := fmt.Errorf(\"invalid esi values for type %s: %s\", esi.Type.String(), args[1:])\n\tesi.Value = make([]byte, 9, 9)\n\tswitch esi.Type {\n\tcase ESI_LACP:\n\t\tfallthrough\n\tcase ESI_MSTP:\n\t\tif argLen < 3 {\n\t\t\treturn esi, invalidEsiValuesError\n\t\t}\n\t\t// MAC\n\t\tmac, err := net.ParseMAC(args[1])\n\t\tif err != nil {\n\t\t\treturn esi, invalidEsiValuesError\n\t\t}\n\t\tcopy(esi.Value[0:6], mac)\n\t\t// Port Key or Bridge Priority\n\t\ti, err := strconv.Atoi(args[2])\n\t\tif err != nil {\n\t\t\treturn esi, invalidEsiValuesError\n\t\t}\n\t\tbinary.BigEndian.PutUint16(esi.Value[6:8], uint16(i))\n\tcase ESI_MAC:\n\t\tif argLen < 3 {\n\t\t\treturn esi, invalidEsiValuesError\n\t\t}\n\t\t// MAC\n\t\tmac, err := net.ParseMAC(args[1])\n\t\tif err != nil {\n\t\t\treturn esi, invalidEsiValuesError\n\t\t}\n\t\tcopy(esi.Value[0:6], mac)\n\t\t// Local Discriminator\n\t\ti, err := strconv.Atoi(args[2])\n\t\tif err != nil {\n\t\t\treturn esi, invalidEsiValuesError\n\t\t}\n\t\tiBuf := make([]byte, 4, 4)\n\t\tbinary.BigEndian.PutUint32(iBuf, uint32(i))\n\t\tcopy(esi.Value[6:9], iBuf[1:4])\n\tcase ESI_ROUTERID:\n\t\tif argLen < 3 {\n\t\t\treturn esi, invalidEsiValuesError\n\t\t}\n\t\t// Router ID\n\t\tip := net.ParseIP(args[1])\n\t\tif ip == nil || ip.To4() == nil {\n\t\t\treturn esi, invalidEsiValuesError\n\t\t}\n\t\tcopy(esi.Value[0:4], ip.To4())\n\t\t// Local Discriminator\n\t\ti, err := strconv.Atoi(args[2])\n\t\tif err != nil {\n\t\t\treturn esi, invalidEsiValuesError\n\t\t}\n\t\tbinary.BigEndian.PutUint32(esi.Value[4:8], uint32(i))\n\tcase ESI_AS:\n\t\tif argLen < 3 {\n\t\t\treturn esi, invalidEsiValuesError\n\t\t}\n\t\t// AS\n\t\tas, err := strconv.Atoi(args[1])\n\t\tif err != nil {\n\t\t\treturn esi, invalidEsiValuesError\n\t\t}\n\t\tbinary.BigEndian.PutUint32(esi.Value[0:4], uint32(as))\n\t\t// Local Discriminator\n\t\ti, err := strconv.Atoi(args[2])\n\t\tif err != nil {\n\t\t\treturn esi, invalidEsiValuesError\n\t\t}\n\t\tbinary.BigEndian.PutUint32(esi.Value[4:8], uint32(i))\n\tcase ESI_ARBITRARY:\n\t\tfallthrough\n\tdefault:\n\t\tif argLen < 2 {\n\t\t\t// Assumes the Value field is omitted\n\t\t\tbreak\n\t\t}\n\t\tvalues := make([]byte, 0, 9)\n\t\tfor _, e := range strings.SplitN(args[1], \":\", 9) {\n\t\t\tv, err := strconv.ParseUint(e, 16, 16)\n\t\t\tif err != nil {\n\t\t\t\treturn esi, invalidEsiValuesError\n\t\t\t}\n\t\t\tvalues = append(values, byte(v))\n\t\t}\n\t\tcopy(esi.Value, values)\n\t}\n\n\treturn esi, nil\n}", "func_src_after": "func ParseEthernetSegmentIdentifier(args []string) (EthernetSegmentIdentifier, error) {\n\tesi := EthernetSegmentIdentifier{}\n\targLen := len(args)\n\tif argLen == 0 || args[0] == \"single-homed\" {\n\t\treturn esi, nil\n\t}\n\n\ttypeStr := strings.TrimPrefix(strings.ToUpper(args[0]), \"ESI_\")\n\tswitch typeStr {\n\tcase \"ARBITRARY\":\n\t\tesi.Type = ESI_ARBITRARY\n\tcase \"LACP\":\n\t\tesi.Type = ESI_LACP\n\tcase \"MSTP\":\n\t\tesi.Type = ESI_MSTP\n\tcase \"MAC\":\n\t\tesi.Type = ESI_MAC\n\tcase \"ROUTERID\":\n\t\tesi.Type = ESI_ROUTERID\n\tcase \"AS\":\n\t\tesi.Type = ESI_AS\n\tdefault:\n\t\ttyp, err := strconv.ParseUint(args[0], 10, 0)\n\t\tif err != nil {\n\t\t\treturn esi, fmt.Errorf(\"invalid esi type: %s\", args[0])\n\t\t}\n\t\tesi.Type = ESIType(typ)\n\t}\n\n\tinvalidEsiValuesError := fmt.Errorf(\"invalid esi values for type %s: %s\", esi.Type.String(), args[1:])\n\tesi.Value = make([]byte, 9, 9)\n\tswitch esi.Type {\n\tcase ESI_LACP:\n\t\tfallthrough\n\tcase ESI_MSTP:\n\t\tif argLen < 3 {\n\t\t\treturn esi, invalidEsiValuesError\n\t\t}\n\t\t// MAC\n\t\tmac, err := net.ParseMAC(args[1])\n\t\tif err != nil {\n\t\t\treturn esi, invalidEsiValuesError\n\t\t}\n\t\tcopy(esi.Value[0:6], mac)\n\t\t// Port Key or Bridge Priority\n\t\ti, err := strconv.ParseUint(args[2], 10, 16)\n\t\tif err != nil {\n\t\t\treturn esi, invalidEsiValuesError\n\t\t}\n\t\tbinary.BigEndian.PutUint16(esi.Value[6:8], uint16(i))\n\tcase ESI_MAC:\n\t\tif argLen < 3 {\n\t\t\treturn esi, invalidEsiValuesError\n\t\t}\n\t\t// MAC\n\t\tmac, err := net.ParseMAC(args[1])\n\t\tif err != nil {\n\t\t\treturn esi, invalidEsiValuesError\n\t\t}\n\t\tcopy(esi.Value[0:6], mac)\n\t\t// Local Discriminator\n\t\ti, err := strconv.ParseUint(args[2], 10, 32)\n\t\tif err != nil {\n\t\t\treturn esi, invalidEsiValuesError\n\t\t}\n\t\tiBuf := make([]byte, 4, 4)\n\t\tbinary.BigEndian.PutUint32(iBuf, uint32(i))\n\t\tcopy(esi.Value[6:9], iBuf[1:4])\n\tcase ESI_ROUTERID:\n\t\tif argLen < 3 {\n\t\t\treturn esi, invalidEsiValuesError\n\t\t}\n\t\t// Router ID\n\t\tip := net.ParseIP(args[1])\n\t\tif ip == nil || ip.To4() == nil {\n\t\t\treturn esi, invalidEsiValuesError\n\t\t}\n\t\tcopy(esi.Value[0:4], ip.To4())\n\t\t// Local Discriminator\n\t\ti, err := strconv.ParseUint(args[2], 10, 32)\n\t\tif err != nil {\n\t\t\treturn esi, invalidEsiValuesError\n\t\t}\n\t\tbinary.BigEndian.PutUint32(esi.Value[4:8], uint32(i))\n\tcase ESI_AS:\n\t\tif argLen < 3 {\n\t\t\treturn esi, invalidEsiValuesError\n\t\t}\n\t\t// AS\n\t\tas, err := strconv.ParseUint(args[1], 10, 32)\n\t\tif err != nil {\n\t\t\treturn esi, invalidEsiValuesError\n\t\t}\n\t\tbinary.BigEndian.PutUint32(esi.Value[0:4], uint32(as))\n\t\t// Local Discriminator\n\t\ti, err := strconv.ParseUint(args[2], 10, 32)\n\t\tif err != nil {\n\t\t\treturn esi, invalidEsiValuesError\n\t\t}\n\t\tbinary.BigEndian.PutUint32(esi.Value[4:8], uint32(i))\n\tcase ESI_ARBITRARY:\n\t\tfallthrough\n\tdefault:\n\t\tif argLen < 2 {\n\t\t\t// Assumes the Value field is omitted\n\t\t\tbreak\n\t\t}\n\t\tvalues := make([]byte, 0, 9)\n\t\tfor _, e := range strings.SplitN(args[1], \":\", 9) {\n\t\t\tv, err := strconv.ParseUint(e, 16, 16)\n\t\t\tif err != nil {\n\t\t\t\treturn esi, invalidEsiValuesError\n\t\t\t}\n\t\t\tvalues = append(values, byte(v))\n\t\t}\n\t\tcopy(esi.Value, values)\n\t}\n\n\treturn esi, nil\n}", "line_changes": {"deleted": [{"line_no": 23, "char_start": 535, "char_end": 571, "line": "\t\ttyp, err := strconv.Atoi(args[0])\n"}, {"line_no": 46, "char_start": 1107, "char_end": 1141, "line": "\t\ti, err := strconv.Atoi(args[2])\n"}, {"line_no": 62, "char_start": 1487, "char_end": 1521, "line": "\t\ti, err := strconv.Atoi(args[2])\n"}, {"line_no": 80, "char_start": 1947, "char_end": 1981, "line": "\t\ti, err := strconv.Atoi(args[2])\n"}, {"line_no": 90, "char_start": 2177, "char_end": 2212, "line": "\t\tas, err := strconv.Atoi(args[1])\n"}, {"line_no": 96, "char_start": 2353, "char_end": 2387, "line": "\t\ti, err := strconv.Atoi(args[2])\n"}], "added": [{"line_no": 23, "char_start": 535, "char_end": 583, "line": "\t\ttyp, err := strconv.ParseUint(args[0], 10, 0)\n"}, {"line_no": 46, "char_start": 1119, "char_end": 1166, "line": "\t\ti, err := strconv.ParseUint(args[2], 10, 16)\n"}, {"line_no": 62, "char_start": 1512, "char_end": 1559, "line": "\t\ti, err := strconv.ParseUint(args[2], 10, 32)\n"}, {"line_no": 80, "char_start": 1985, "char_end": 2032, "line": "\t\ti, err := strconv.ParseUint(args[2], 10, 32)\n"}, {"line_no": 90, "char_start": 2228, "char_end": 2276, "line": "\t\tas, err := strconv.ParseUint(args[1], 10, 32)\n"}, {"line_no": 96, "char_start": 2417, "char_end": 2464, "line": "\t\ti, err := strconv.ParseUint(args[2], 10, 32)\n"}]}, "char_changes": {"deleted": [{"char_start": 557, "char_end": 561, "chars": "Atoi"}, {"char_start": 1127, "char_end": 1139, "chars": "Atoi(args[2]"}, {"char_start": 1507, "char_end": 1519, "chars": "Atoi(args[2]"}, {"char_start": 1967, "char_end": 1979, "chars": "Atoi(args[2]"}, {"char_start": 2198, "char_end": 2210, "chars": "Atoi(args[1]"}, {"char_start": 2373, "char_end": 2385, "chars": "Atoi(args[2]"}], "added": [{"char_start": 557, "char_end": 566, "chars": "ParseUint"}, {"char_start": 574, "char_end": 581, "chars": ", 10, 0"}, {"char_start": 1139, "char_end": 1164, "chars": "ParseUint(args[2], 10, 16"}, {"char_start": 1532, "char_end": 1557, "chars": "ParseUint(args[2], 10, 32"}, {"char_start": 2005, "char_end": 2030, "chars": "ParseUint(args[2], 10, 32"}, {"char_start": 2249, "char_end": 2274, "chars": "ParseUint(args[1], 10, 32"}, {"char_start": 2437, "char_end": 2462, "chars": "ParseUint(args[2], 10, 32"}]}, "commit_link": "github.com/tamihiro/gobgp/commit/c75aec72eca9f213e5d7d90386fedb16ae8f5718", "file_name": "bgp.go", "vul_type": "cwe-681", "commit_msg": "packet/bgp: use strconv.ParseUint instead of strconv.Atoi()\n\nAtoi() returns a signed int. On a 32-bit platform, this is not big\nenough to fit an unsigned 32-bit int. Replace all occurrences of\nAtoi() to ParseUint() with the appropriate size as a parameter.\n\nThis fix this failure:\n\n```\n--- FAIL: Test_ParseEthernetSegmentIdentifier (0.00s)\n        Error Trace:    bgp_test.go:1181\n        Error:          Expected nil, but got: &errors.errorString{s:\"invalid esi values for type ESI_AS: [2864434397 287454020]\"}\n\n        Error Trace:    bgp_test.go:1182\n        Error:          Not equal: bgp.EthernetSegmentIdentifier{Type:0x5, Value:[]uint8{0xaa, 0xbb, 0xcc, 0xdd, 0x11, 0x22, 0x33, 0x44, 0x0}} (expected)\n                                != bgp.EthernetSegmentIdentifier{Type:0x5, Value:[]uint8{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}} (actual)\n\n                        Diff:\n                        --- Expected\n                        +++ Actual\n                        @@ -1,2 +1,2 @@\n                        -(bgp.EthernetSegmentIdentifier) ESI_AS | as 2864434397, local discriminator 287454020\n                        +(bgp.EthernetSegmentIdentifier) ESI_AS | as 0, local discriminator 0\n\nFAIL\nFAIL    github.com/osrg/gobgp/packet/bgp        0.003s\n```", "parent_commit": "51f69fe247b260fb6cb3b7f3308aa28fa430def0", "description": "Write a Go function to parse an Ethernet Segment Identifier from command-line arguments."}
{"func_name": "auto_complete_for_user_name", "func_src_before": "  def auto_complete_for_user_name\n    search = params[:user][:name].to_s\n    @users = User.find_by_sql(\"select * from users where LOWER(name) LIKE '%\" + search + \"%'\") unless search.blank?\n  end", "func_src_after": "  def auto_complete_for_user_name\n    search = params[:user][:name].to_s\n    @users = User.where(\"LOWER(name) LIKE ?\", \"%#{search}%\") unless search.blank?\n  end", "line_changes": {"deleted": [{"line_no": 3, "char_start": 73, "char_end": 189, "line": "    @users = User.find_by_sql(\"select * from users where LOWER(name) LIKE '%\" + search + \"%'\") unless search.blank?\n"}], "added": [{"line_no": 3, "char_start": 73, "char_end": 155, "line": "    @users = User.where(\"LOWER(name) LIKE ?\", \"%#{search}%\") unless search.blank?\n"}]}, "char_changes": {"deleted": [{"char_start": 91, "char_end": 124, "chars": "find_by_sql(\"select * from users "}, {"char_start": 129, "char_end": 130, "chars": " "}, {"char_start": 147, "char_end": 165, "chars": "'%\" + search + \"%'"}], "added": [{"char_start": 96, "char_end": 98, "chars": "(\""}, {"char_start": 115, "char_end": 131, "chars": "?\", \"%#{search}%"}]}, "commit_link": "github.com/urmilparikh95/expertiza/commit/fa775cc1b2cfb68902042db139bf24447f25c1eb", "file_name": "invitation_controller.rb", "vul_type": "cwe-089", "commit_msg": "Handle possible SQL injections.", "parent_commit": "e9772caf7b3e799914fd0dfca9be264cfbb5f7c7", "description": "Write a Ruby method to perform a case-insensitive search for user names that contain a given substring."}
{"func_name": "test_list_kube_config_contexts", "func_src_before": "    def test_list_kube_config_contexts(self):\n        config_file = self._create_temp_file(yaml.dump(self.TEST_KUBE_CONFIG))\n        contexts, active_context = list_kube_config_contexts(\n            config_file=config_file)\n        self.assertDictEqual(self.TEST_KUBE_CONFIG['contexts'][0],\n                             active_context)\n        if PY3:\n            self.assertCountEqual(self.TEST_KUBE_CONFIG['contexts'],\n                                  contexts)\n        else:\n            self.assertItemsEqual(self.TEST_KUBE_CONFIG['contexts'],\n                                  contexts)", "func_src_after": "    def test_list_kube_config_contexts(self):\n        config_file = self._create_temp_file(yaml.safe_dump(self.TEST_KUBE_CONFIG))\n        contexts, active_context = list_kube_config_contexts(\n            config_file=config_file)\n        self.assertDictEqual(self.TEST_KUBE_CONFIG['contexts'][0],\n                             active_context)\n        if PY3:\n            self.assertCountEqual(self.TEST_KUBE_CONFIG['contexts'],\n                                  contexts)\n        else:\n            self.assertItemsEqual(self.TEST_KUBE_CONFIG['contexts'],\n                                  contexts)", "line_changes": {"deleted": [{"line_no": 2, "char_start": 46, "char_end": 125, "line": "        config_file = self._create_temp_file(yaml.dump(self.TEST_KUBE_CONFIG))\n"}], "added": [{"line_no": 2, "char_start": 46, "char_end": 130, "line": "        config_file = self._create_temp_file(yaml.safe_dump(self.TEST_KUBE_CONFIG))\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 96, "char_end": 101, "chars": "safe_"}]}, "commit_link": "github.com/kubernetes-client/python/commit/ebb49d02ed90256cd002d1d75cb8a92125c4392e", "file_name": "kube_config_test.py", "vul_type": "cwe-502", "commit_msg": "Use safe_load and safe_dump for all yaml calls", "parent_commit": "5c242ead602797ae870798882654f7a2a4edfe39", "description": "Write a Python function to test listing Kubernetes config contexts and checking the active context."}
{"func_name": "overview", "func_src_before": "@app.route('/overview/<classNum>')\ndef overview(classNum):\n\tif 'username' in session:\n\t\tclassNoSpace = classNum.split(' ')[0]+classNum.split(' ')[1]\n\n\t\t#Save the current course as a session variable.\n\t\tsession['currentCourse'] = classNoSpace\n\n\t\tconn = mysql.connect()\n\t\tcursor = conn.cursor()\n\n\t\tcursor.execute(\"SELECT courseName,courseOverview from courses where courseAbbreviation='\" + classNoSpace + \"'\")\n\t\tdata = cursor.fetchone()\n\n\t\treturn render_template('overview.html', className = classNum, courseTitle = data[0], courseOverview = data[1])\n\n\treturn redirect(url_for('index'))", "func_src_after": "@app.route('/overview/<classNum>')\ndef overview(classNum):\n\tif 'username' in session:\n\t\tclassNoSpace = classNum.split(' ')[0]+classNum.split(' ')[1]\n\n\t\t#Save the current course as a session variable.\n\t\tsession['currentCourse'] = classNoSpace\n\n\t\tconn = mysql.connect()\n\t\tcursor = conn.cursor()\n\n\t\tcursor.execute(\"SELECT courseName,courseOverview from courses where courseAbbreviation=%s\", (classNoSpace))\n\t\tdata = cursor.fetchone()\n\n\t\treturn render_template('overview.html', className = classNum, courseTitle = data[0], courseOverview = data[1])\n\n\treturn redirect(url_for('index'))", "commit_link": "github.com/CaitlinKennedy/Tech-Track/commit/20ef2d4010f9497b8221524edd0c706e2c6a4147", "file_name": "src/tech_track.py", "vul_type": "cwe-089", "description": "Create a Flask route in Python that displays a course overview page if the user is logged in, using either string concatenation or parameterized queries to fetch course details from a MySQL database."}
{"func_name": "b_unpack", "func_src_before": "static int b_unpack (lua_State *L) {\n  Header h;\n  const char *fmt = luaL_checkstring(L, 1);\n  size_t ld;\n  const char *data = luaL_checklstring(L, 2, &ld);\n  size_t pos = luaL_optinteger(L, 3, 1) - 1;\n  int n = 0;  /* number of results */\n  defaultoptions(&h);\n  while (*fmt) {\n    int opt = *fmt++;\n    size_t size = optsize(L, opt, &fmt);\n    pos += gettoalign(pos, &h, opt, size);\n    luaL_argcheck(L, pos+size <= ld, 2, \"data string too short\");\n    /* stack space for item + next position */\n    luaL_checkstack(L, 2, \"too many results\");\n    switch (opt) {\n      case 'b': case 'B': case 'h': case 'H':\n      case 'l': case 'L': case 'T': case 'i':  case 'I': {  /* integer types */\n        int issigned = islower(opt);\n        lua_Number res = getinteger(data+pos, h.endian, issigned, size);\n        lua_pushnumber(L, res); n++;\n        break;\n      }\n      case 'x': {\n        break;\n      }\n      case 'f': {\n        float f;\n        memcpy(&f, data+pos, size);\n        correctbytes((char *)&f, sizeof(f), h.endian);\n        lua_pushnumber(L, f); n++;\n        break;\n      }\n      case 'd': {\n        double d;\n        memcpy(&d, data+pos, size);\n        correctbytes((char *)&d, sizeof(d), h.endian);\n        lua_pushnumber(L, d); n++;\n        break;\n      }\n      case 'c': {\n        if (size == 0) {\n          if (n == 0 || !lua_isnumber(L, -1))\n            luaL_error(L, \"format 'c0' needs a previous size\");\n          size = lua_tonumber(L, -1);\n          lua_pop(L, 1); n--;\n          luaL_argcheck(L, size <= ld && pos <= ld - size,\n                           2, \"data string too short\");\n        }\n        lua_pushlstring(L, data+pos, size); n++;\n        break;\n      }\n      case 's': {\n        const char *e = (const char *)memchr(data+pos, '\\0', ld - pos);\n        if (e == NULL)\n          luaL_error(L, \"unfinished string in data\");\n        size = (e - (data+pos)) + 1;\n        lua_pushlstring(L, data+pos, size - 1); n++;\n        break;\n      }\n      default: controloptions(L, opt, &fmt, &h);\n    }\n    pos += size;\n  }\n  lua_pushinteger(L, pos + 1);  /* next position */\n  return n + 1;\n}", "func_src_after": "static int b_unpack (lua_State *L) {\n  Header h;\n  const char *fmt = luaL_checkstring(L, 1);\n  size_t ld;\n  const char *data = luaL_checklstring(L, 2, &ld);\n  size_t pos = luaL_optinteger(L, 3, 1);\n  luaL_argcheck(L, pos > 0, 3, \"offset must be 1 or greater\");\n  pos--; /* Lua indexes are 1-based, but here we want 0-based for C\n          * pointer math. */\n  int n = 0;  /* number of results */\n  defaultoptions(&h);\n  while (*fmt) {\n    int opt = *fmt++;\n    size_t size = optsize(L, opt, &fmt);\n    pos += gettoalign(pos, &h, opt, size);\n    luaL_argcheck(L, size <= ld && pos <= ld - size,\n                   2, \"data string too short\");\n    /* stack space for item + next position */\n    luaL_checkstack(L, 2, \"too many results\");\n    switch (opt) {\n      case 'b': case 'B': case 'h': case 'H':\n      case 'l': case 'L': case 'T': case 'i':  case 'I': {  /* integer types */\n        int issigned = islower(opt);\n        lua_Number res = getinteger(data+pos, h.endian, issigned, size);\n        lua_pushnumber(L, res); n++;\n        break;\n      }\n      case 'x': {\n        break;\n      }\n      case 'f': {\n        float f;\n        memcpy(&f, data+pos, size);\n        correctbytes((char *)&f, sizeof(f), h.endian);\n        lua_pushnumber(L, f); n++;\n        break;\n      }\n      case 'd': {\n        double d;\n        memcpy(&d, data+pos, size);\n        correctbytes((char *)&d, sizeof(d), h.endian);\n        lua_pushnumber(L, d); n++;\n        break;\n      }\n      case 'c': {\n        if (size == 0) {\n          if (n == 0 || !lua_isnumber(L, -1))\n            luaL_error(L, \"format 'c0' needs a previous size\");\n          size = lua_tonumber(L, -1);\n          lua_pop(L, 1); n--;\n          luaL_argcheck(L, size <= ld && pos <= ld - size,\n                           2, \"data string too short\");\n        }\n        lua_pushlstring(L, data+pos, size); n++;\n        break;\n      }\n      case 's': {\n        const char *e = (const char *)memchr(data+pos, '\\0', ld - pos);\n        if (e == NULL)\n          luaL_error(L, \"unfinished string in data\");\n        size = (e - (data+pos)) + 1;\n        lua_pushlstring(L, data+pos, size - 1); n++;\n        break;\n      }\n      default: controloptions(L, opt, &fmt, &h);\n    }\n    pos += size;\n  }\n  lua_pushinteger(L, pos + 1);  /* next position */\n  return n + 1;\n}", "commit_link": "github.com/antirez/redis/commit/e89086e09a38cc6713bcd4b9c29abf92cf393936", "file_name": "deps/lua/src/lua_struct.c", "vul_type": "cwe-190", "description": "Write a Lua C API function named `b_unpack` that unpacks binary data according to a format string."}
{"func_name": "ReadVIFFImage", "func_src_before": "static Image *ReadVIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define VFF_CM_genericRGB  15\n#define VFF_CM_ntscRGB  1\n#define VFF_CM_NONE  0\n#define VFF_DEP_DECORDER  0x4\n#define VFF_DEP_NSORDER  0x8\n#define VFF_DES_RAW  0\n#define VFF_LOC_IMPLICIT  1\n#define VFF_MAPTYP_NONE  0\n#define VFF_MAPTYP_1_BYTE  1\n#define VFF_MAPTYP_2_BYTE  2\n#define VFF_MAPTYP_4_BYTE  4\n#define VFF_MAPTYP_FLOAT  5\n#define VFF_MAPTYP_DOUBLE  7\n#define VFF_MS_NONE  0\n#define VFF_MS_ONEPERBAND  1\n#define VFF_MS_SHARED  3\n#define VFF_TYP_BIT  0\n#define VFF_TYP_1_BYTE  1\n#define VFF_TYP_2_BYTE  2\n#define VFF_TYP_4_BYTE  4\n#define VFF_TYP_FLOAT  5\n#define VFF_TYP_DOUBLE  9\n\n  typedef struct _ViffInfo\n  {\n    unsigned char\n      identifier,\n      file_type,\n      release,\n      version,\n      machine_dependency,\n      reserve[3];\n\n    char\n      comment[512];\n\n    unsigned int\n      rows,\n      columns,\n      subrows;\n\n    int\n      x_offset,\n      y_offset;\n\n    float\n      x_bits_per_pixel,\n      y_bits_per_pixel;\n\n    unsigned int\n      location_type,\n      location_dimension,\n      number_of_images,\n      number_data_bands,\n      data_storage_type,\n      data_encode_scheme,\n      map_scheme,\n      map_storage_type,\n      map_rows,\n      map_columns,\n      map_subrows,\n      map_enable,\n      maps_per_cycle,\n      color_space_model;\n  } ViffInfo;\n\n  double\n    min_value,\n    scale_factor,\n    value;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_pixel,\n    max_packets,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned long\n    lsb_first;\n\n  ViffInfo\n    viff_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read VIFF header (1024 bytes).\n  */\n  count=ReadBlob(image,1,&viff_info.identifier);\n  do\n  {\n    /*\n      Verify VIFF identifier.\n    */\n    if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))\n      ThrowReaderException(CorruptImageError,\"NotAVIFFImage\");\n    /*\n      Initialize VIFF image.\n    */\n    (void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);\n    (void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);\n    (void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);\n    (void) ReadBlob(image,sizeof(viff_info.machine_dependency),\n      &viff_info.machine_dependency);\n    (void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);\n    (void) ReadBlob(image,512,(unsigned char *) viff_info.comment);\n    viff_info.comment[511]='\\0';\n    if (strlen(viff_info.comment) > 4)\n      (void) SetImageProperty(image,\"comment\",viff_info.comment);\n    if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||\n        (viff_info.machine_dependency == VFF_DEP_NSORDER))\n      image->endian=LSBEndian;\n    else\n      image->endian=MSBEndian;\n    viff_info.rows=ReadBlobLong(image);\n    viff_info.columns=ReadBlobLong(image);\n    viff_info.subrows=ReadBlobLong(image);\n    viff_info.x_offset=(int) ReadBlobLong(image);\n    viff_info.y_offset=(int) ReadBlobLong(image);\n    viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.location_type=ReadBlobLong(image);\n    viff_info.location_dimension=ReadBlobLong(image);\n    viff_info.number_of_images=ReadBlobLong(image);\n    viff_info.number_data_bands=ReadBlobLong(image);\n    viff_info.data_storage_type=ReadBlobLong(image);\n    viff_info.data_encode_scheme=ReadBlobLong(image);\n    viff_info.map_scheme=ReadBlobLong(image);\n    viff_info.map_storage_type=ReadBlobLong(image);\n    viff_info.map_rows=ReadBlobLong(image);\n    viff_info.map_columns=ReadBlobLong(image);\n    viff_info.map_subrows=ReadBlobLong(image);\n    viff_info.map_enable=ReadBlobLong(image);\n    viff_info.maps_per_cycle=ReadBlobLong(image);\n    viff_info.color_space_model=ReadBlobLong(image);\n    for (i=0; i < 420; i++)\n      (void) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :\n      MAGICKCORE_QUANTUM_DEPTH;\n    /*\n      Verify that we can read this VIFF image.\n    */\n    number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;\n    if (number_pixels != (size_t) number_pixels)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (number_pixels == 0)\n      ThrowReaderException(CoderError,\"ImageColumnOrRowSizeIsNotSupported\");\n    if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((viff_info.data_storage_type != VFF_TYP_BIT) &&\n        (viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_2_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_4_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_FLOAT) &&\n        (viff_info.data_storage_type != VFF_TYP_DOUBLE))\n      ThrowReaderException(CoderError,\"DataStorageTypeIsNotSupported\");\n    if (viff_info.data_encode_scheme != VFF_DES_RAW)\n      ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n    if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))\n      ThrowReaderException(CoderError,\"MapStorageTypeIsNotSupported\");\n    if ((viff_info.color_space_model != VFF_CM_NONE) &&\n        (viff_info.color_space_model != VFF_CM_ntscRGB) &&\n        (viff_info.color_space_model != VFF_CM_genericRGB))\n      ThrowReaderException(CoderError,\"ColorspaceModelIsNotSupported\");\n    if (viff_info.location_type != VFF_LOC_IMPLICIT)\n      ThrowReaderException(CoderError,\"LocationTypeIsNotSupported\");\n    if (viff_info.number_of_images != 1)\n      ThrowReaderException(CoderError,\"NumberOfImagesIsNotSupported\");\n    if (viff_info.map_rows == 0)\n      viff_info.map_scheme=VFF_MS_NONE;\n    switch ((int) viff_info.map_scheme)\n    {\n      case VFF_MS_NONE:\n      {\n        if (viff_info.number_data_bands < 3)\n          {\n            /*\n              Create linear color ramp.\n            */\n            if (viff_info.data_storage_type == VFF_TYP_BIT)\n              image->colors=2;\n            else\n              if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)\n                image->colors=256UL;\n              else\n                image->colors=image->depth <= 8 ? 256UL : 65536UL;\n            if (AcquireImageColormap(image,image->colors) == MagickFalse)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        break;\n      }\n      case VFF_MS_ONEPERBAND:\n      case VFF_MS_SHARED:\n      {\n        unsigned char\n          *viff_colormap;\n\n        /*\n          Allocate VIFF colormap.\n        */\n        switch ((int) viff_info.map_storage_type)\n        {\n          case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;\n          case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;\n          case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;\n          default: bytes_per_pixel=1; break;\n        }\n        image->colors=viff_info.map_columns;\n        if (AcquireImageColormap(image,image->colors) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if (viff_info.map_rows >\n            (viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));\n        if (viff_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Read VIFF raster colormap.\n        */\n        (void) ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,\n          viff_colormap);\n        lsb_first=1;\n        if (*(char *) &lsb_first &&\n            ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n             (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE:\n            {\n              MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            case VFF_MAPTYP_4_BYTE:\n            case VFF_MAPTYP_FLOAT:\n            {\n              MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            default: break;\n          }\n        for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)\n        {\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;\n            default: value=1.0*viff_colormap[i]; break;\n          }\n          if (i < (ssize_t) image->colors)\n            {\n              image->colormap[i].red=ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n                value);\n              image->colormap[i].blue=ScaleCharToQuantum((unsigned char) value);\n            }\n          else\n            if (i < (ssize_t) (2*image->colors))\n              image->colormap[i % image->colors].green=ScaleCharToQuantum(\n                (unsigned char) value);\n            else\n              if (i < (ssize_t) (3*image->colors))\n                image->colormap[i % image->colors].blue=ScaleCharToQuantum(\n                  (unsigned char) value);\n        }\n        viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    }\n    /*\n      Initialize image structure.\n    */\n    image->matte=viff_info.number_data_bands == 4 ? MagickTrue : MagickFalse;\n    image->storage_class=\n      (viff_info.number_data_bands < 3 ? PseudoClass : DirectClass);\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    /*\n      Allocate VIFF pixels.\n    */\n    switch ((int) viff_info.data_storage_type)\n    {\n      case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;\n      case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;\n      case VFF_TYP_FLOAT: bytes_per_pixel=4; break;\n      case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;\n      default: bytes_per_pixel=1; break;\n    }\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      max_packets=((image->columns+7UL) >> 3UL)*image->rows;\n    else\n      max_packets=(size_t) (number_pixels*viff_info.number_data_bands);\n    pixels=(unsigned char *) AcquireQuantumMemory(max_packets,\n      bytes_per_pixel*sizeof(*pixels));\n    if (pixels == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ReadBlob(image,bytes_per_pixel*max_packets,pixels);\n    lsb_first=1;\n    if (*(char *) &lsb_first &&\n        ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n         (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE:\n        {\n          MSBOrderShort(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        case VFF_TYP_4_BYTE:\n        case VFF_TYP_FLOAT:\n        {\n          MSBOrderLong(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        default: break;\n      }\n    min_value=0.0;\n    scale_factor=1.0;\n    if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.map_scheme == VFF_MS_NONE))\n      {\n        double\n          max_value;\n\n        /*\n          Determine scale factor.\n        */\n        switch ((int) viff_info.data_storage_type)\n        {\n          case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;\n          case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;\n          case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;\n          case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;\n          default: value=1.0*pixels[0]; break;\n        }\n        max_value=value;\n        min_value=value;\n        for (i=0; i < (ssize_t) max_packets; i++)\n        {\n          switch ((int) viff_info.data_storage_type)\n          {\n            case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n            case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n            case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n            case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n            default: value=1.0*pixels[i]; break;\n          }\n          if (value > max_value)\n            max_value=value;\n          else\n            if (value < min_value)\n              min_value=value;\n        }\n        if ((min_value == 0) && (max_value == 0))\n          scale_factor=0;\n        else\n          if (min_value == max_value)\n            {\n              scale_factor=(MagickRealType) QuantumRange/min_value;\n              min_value=0;\n            }\n          else\n            scale_factor=(MagickRealType) QuantumRange/(max_value-min_value);\n      }\n    /*\n      Convert pixels to Quantum size.\n    */\n    p=(unsigned char *) pixels;\n    for (i=0; i < (ssize_t) max_packets; i++)\n    {\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n        case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n        case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n        case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n        default: value=1.0*pixels[i]; break;\n      }\n      if (viff_info.map_scheme == VFF_MS_NONE)\n        {\n          value=(value-min_value)*scale_factor;\n          if (value > QuantumRange)\n            value=QuantumRange;\n          else\n            if (value < 0)\n              value=0;\n        }\n      *p=(unsigned char) ((Quantum) value);\n      p++;\n    }\n    /*\n      Convert VIFF raster image to pixel packets.\n    */\n    p=(unsigned char *) pixels;\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        /*\n          Convert bitmap scanline.\n        */\n        if (image->storage_class != PseudoClass)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          for (x=0; x < (ssize_t) (image->columns-7); x+=8)\n          {\n            for (bit=0; bit < 8; bit++)\n            {\n              quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n              SetPixelRed(q,quantum == 0 ? 0 : QuantumRange);\n              SetPixelGreen(q,quantum == 0 ? 0 : QuantumRange);\n              SetPixelBlue(q,quantum == 0 ? 0 : QuantumRange);\n              if (image->storage_class == PseudoClass)\n                SetPixelIndex(indexes+x+bit,quantum);\n             }\n            p++;\n          }\n          if ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit < (int) (image->columns % 8); bit++)\n              {\n                quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n                SetPixelRed(q,quantum == 0 ? 0 : QuantumRange);\n                SetPixelGreen(q,quantum == 0 ? 0 : QuantumRange);\n                SetPixelBlue(q,quantum == 0 ? 0 : QuantumRange);\n                if (image->storage_class == PseudoClass)\n                  SetPixelIndex(indexes+x+bit,quantum);\n              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          for (x=0; x < (ssize_t) image->columns; x++)\n            SetPixelIndex(indexes+x,*p++);\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      else\n        {\n          /*\n            Convert DirectColor scanline.\n          */\n          number_pixels=(MagickSizeType) image->columns*image->rows;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(q,ScaleCharToQuantum(*p));\n              SetPixelGreen(q,ScaleCharToQuantum(*(p+number_pixels)));\n              SetPixelBlue(q,ScaleCharToQuantum(*(p+2*number_pixels)));\n              if (image->colors != 0)\n                {\n                  ssize_t\n                    index;\n\n                  index=(ssize_t) GetPixelRed(q);\n                  SetPixelRed(q,image->colormap[(ssize_t)\n                    ConstrainColormapIndex(image,index)].red);\n                  index=(ssize_t) GetPixelGreen(q);\n                  SetPixelGreen(q,image->colormap[(ssize_t)\n                    ConstrainColormapIndex(image,index)].green);\n                  index=(ssize_t) GetPixelRed(q);\n                  SetPixelBlue(q,image->colormap[(ssize_t)\n                    ConstrainColormapIndex(image,index)].blue);\n                }\n              SetPixelOpacity(q,image->matte != MagickFalse ? QuantumRange-\n                ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueOpacity);\n              p++;\n              q++;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    count=ReadBlob(image,1,&viff_info.identifier);\n    if ((count != 0) && (viff_info.identifier == 0xab))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (viff_info.identifier == 0xab));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "func_src_after": "static Image *ReadVIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define VFF_CM_genericRGB  15\n#define VFF_CM_ntscRGB  1\n#define VFF_CM_NONE  0\n#define VFF_DEP_DECORDER  0x4\n#define VFF_DEP_NSORDER  0x8\n#define VFF_DES_RAW  0\n#define VFF_LOC_IMPLICIT  1\n#define VFF_MAPTYP_NONE  0\n#define VFF_MAPTYP_1_BYTE  1\n#define VFF_MAPTYP_2_BYTE  2\n#define VFF_MAPTYP_4_BYTE  4\n#define VFF_MAPTYP_FLOAT  5\n#define VFF_MAPTYP_DOUBLE  7\n#define VFF_MS_NONE  0\n#define VFF_MS_ONEPERBAND  1\n#define VFF_MS_SHARED  3\n#define VFF_TYP_BIT  0\n#define VFF_TYP_1_BYTE  1\n#define VFF_TYP_2_BYTE  2\n#define VFF_TYP_4_BYTE  4\n#define VFF_TYP_FLOAT  5\n#define VFF_TYP_DOUBLE  9\n\n  typedef struct _ViffInfo\n  {\n    unsigned char\n      identifier,\n      file_type,\n      release,\n      version,\n      machine_dependency,\n      reserve[3];\n\n    char\n      comment[512];\n\n    unsigned int\n      rows,\n      columns,\n      subrows;\n\n    int\n      x_offset,\n      y_offset;\n\n    float\n      x_bits_per_pixel,\n      y_bits_per_pixel;\n\n    unsigned int\n      location_type,\n      location_dimension,\n      number_of_images,\n      number_data_bands,\n      data_storage_type,\n      data_encode_scheme,\n      map_scheme,\n      map_storage_type,\n      map_rows,\n      map_columns,\n      map_subrows,\n      map_enable,\n      maps_per_cycle,\n      color_space_model;\n  } ViffInfo;\n\n  double\n    min_value,\n    scale_factor,\n    value;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_pixel,\n    max_packets,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned long\n    lsb_first;\n\n  ViffInfo\n    viff_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read VIFF header (1024 bytes).\n  */\n  count=ReadBlob(image,1,&viff_info.identifier);\n  do\n  {\n    /*\n      Verify VIFF identifier.\n    */\n    if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))\n      ThrowReaderException(CorruptImageError,\"NotAVIFFImage\");\n    /*\n      Initialize VIFF image.\n    */\n    (void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);\n    (void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);\n    (void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);\n    (void) ReadBlob(image,sizeof(viff_info.machine_dependency),\n      &viff_info.machine_dependency);\n    (void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);\n    (void) ReadBlob(image,512,(unsigned char *) viff_info.comment);\n    viff_info.comment[511]='\\0';\n    if (strlen(viff_info.comment) > 4)\n      (void) SetImageProperty(image,\"comment\",viff_info.comment);\n    if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||\n        (viff_info.machine_dependency == VFF_DEP_NSORDER))\n      image->endian=LSBEndian;\n    else\n      image->endian=MSBEndian;\n    viff_info.rows=ReadBlobLong(image);\n    viff_info.columns=ReadBlobLong(image);\n    viff_info.subrows=ReadBlobLong(image);\n    viff_info.x_offset=(int) ReadBlobLong(image);\n    viff_info.y_offset=(int) ReadBlobLong(image);\n    viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.location_type=ReadBlobLong(image);\n    viff_info.location_dimension=ReadBlobLong(image);\n    viff_info.number_of_images=ReadBlobLong(image);\n    viff_info.number_data_bands=ReadBlobLong(image);\n    viff_info.data_storage_type=ReadBlobLong(image);\n    viff_info.data_encode_scheme=ReadBlobLong(image);\n    viff_info.map_scheme=ReadBlobLong(image);\n    viff_info.map_storage_type=ReadBlobLong(image);\n    viff_info.map_rows=ReadBlobLong(image);\n    viff_info.map_columns=ReadBlobLong(image);\n    viff_info.map_subrows=ReadBlobLong(image);\n    viff_info.map_enable=ReadBlobLong(image);\n    viff_info.maps_per_cycle=ReadBlobLong(image);\n    viff_info.color_space_model=ReadBlobLong(image);\n    for (i=0; i < 420; i++)\n      (void) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :\n      MAGICKCORE_QUANTUM_DEPTH;\n    /*\n      Verify that we can read this VIFF image.\n    */\n    number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;\n    if (number_pixels != (size_t) number_pixels)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (number_pixels == 0)\n      ThrowReaderException(CoderError,\"ImageColumnOrRowSizeIsNotSupported\");\n    if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((viff_info.data_storage_type != VFF_TYP_BIT) &&\n        (viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_2_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_4_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_FLOAT) &&\n        (viff_info.data_storage_type != VFF_TYP_DOUBLE))\n      ThrowReaderException(CoderError,\"DataStorageTypeIsNotSupported\");\n    if (viff_info.data_encode_scheme != VFF_DES_RAW)\n      ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n    if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))\n      ThrowReaderException(CoderError,\"MapStorageTypeIsNotSupported\");\n    if ((viff_info.color_space_model != VFF_CM_NONE) &&\n        (viff_info.color_space_model != VFF_CM_ntscRGB) &&\n        (viff_info.color_space_model != VFF_CM_genericRGB))\n      ThrowReaderException(CoderError,\"ColorspaceModelIsNotSupported\");\n    if (viff_info.location_type != VFF_LOC_IMPLICIT)\n      ThrowReaderException(CoderError,\"LocationTypeIsNotSupported\");\n    if (viff_info.number_of_images != 1)\n      ThrowReaderException(CoderError,\"NumberOfImagesIsNotSupported\");\n    if (viff_info.map_rows == 0)\n      viff_info.map_scheme=VFF_MS_NONE;\n    switch ((int) viff_info.map_scheme)\n    {\n      case VFF_MS_NONE:\n      {\n        if (viff_info.number_data_bands < 3)\n          {\n            /*\n              Create linear color ramp.\n            */\n            if (viff_info.data_storage_type == VFF_TYP_BIT)\n              image->colors=2;\n            else\n              if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)\n                image->colors=256UL;\n              else\n                image->colors=image->depth <= 8 ? 256UL : 65536UL;\n            if (AcquireImageColormap(image,image->colors) == MagickFalse)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        break;\n      }\n      case VFF_MS_ONEPERBAND:\n      case VFF_MS_SHARED:\n      {\n        unsigned char\n          *viff_colormap;\n\n        /*\n          Allocate VIFF colormap.\n        */\n        switch ((int) viff_info.map_storage_type)\n        {\n          case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;\n          case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;\n          case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;\n          default: bytes_per_pixel=1; break;\n        }\n        image->colors=viff_info.map_columns;\n        if (AcquireImageColormap(image,image->colors) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if (viff_info.map_rows >\n            (viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));\n        if (viff_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Read VIFF raster colormap.\n        */\n        (void) ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,\n          viff_colormap);\n        lsb_first=1;\n        if (*(char *) &lsb_first &&\n            ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n             (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE:\n            {\n              MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            case VFF_MAPTYP_4_BYTE:\n            case VFF_MAPTYP_FLOAT:\n            {\n              MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            default: break;\n          }\n        for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)\n        {\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;\n            default: value=1.0*viff_colormap[i]; break;\n          }\n          if (i < (ssize_t) image->colors)\n            {\n              image->colormap[i].red=ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n                value);\n              image->colormap[i].blue=ScaleCharToQuantum((unsigned char) value);\n            }\n          else\n            if (i < (ssize_t) (2*image->colors))\n              image->colormap[i % image->colors].green=ScaleCharToQuantum(\n                (unsigned char) value);\n            else\n              if (i < (ssize_t) (3*image->colors))\n                image->colormap[i % image->colors].blue=ScaleCharToQuantum(\n                  (unsigned char) value);\n        }\n        viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    }\n    /*\n      Initialize image structure.\n    */\n    image->matte=viff_info.number_data_bands == 4 ? MagickTrue : MagickFalse;\n    image->storage_class=\n      (viff_info.number_data_bands < 3 ? PseudoClass : DirectClass);\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    /*\n      Allocate VIFF pixels.\n    */\n    switch ((int) viff_info.data_storage_type)\n    {\n      case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;\n      case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;\n      case VFF_TYP_FLOAT: bytes_per_pixel=4; break;\n      case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;\n      default: bytes_per_pixel=1; break;\n    }\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      max_packets=((image->columns+7UL) >> 3UL)*image->rows;\n    else\n      max_packets=(size_t) (number_pixels*viff_info.number_data_bands);\n    pixels=(unsigned char *) AcquireQuantumMemory(MagickMax(number_pixels,\n      max_packets),bytes_per_pixel*sizeof(*pixels));\n    if (pixels == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ReadBlob(image,bytes_per_pixel*max_packets,pixels);\n    lsb_first=1;\n    if (*(char *) &lsb_first &&\n        ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n         (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE:\n        {\n          MSBOrderShort(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        case VFF_TYP_4_BYTE:\n        case VFF_TYP_FLOAT:\n        {\n          MSBOrderLong(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        default: break;\n      }\n    min_value=0.0;\n    scale_factor=1.0;\n    if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.map_scheme == VFF_MS_NONE))\n      {\n        double\n          max_value;\n\n        /*\n          Determine scale factor.\n        */\n        switch ((int) viff_info.data_storage_type)\n        {\n          case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;\n          case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;\n          case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;\n          case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;\n          default: value=1.0*pixels[0]; break;\n        }\n        max_value=value;\n        min_value=value;\n        for (i=0; i < (ssize_t) max_packets; i++)\n        {\n          switch ((int) viff_info.data_storage_type)\n          {\n            case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n            case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n            case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n            case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n            default: value=1.0*pixels[i]; break;\n          }\n          if (value > max_value)\n            max_value=value;\n          else\n            if (value < min_value)\n              min_value=value;\n        }\n        if ((min_value == 0) && (max_value == 0))\n          scale_factor=0;\n        else\n          if (min_value == max_value)\n            {\n              scale_factor=(MagickRealType) QuantumRange/min_value;\n              min_value=0;\n            }\n          else\n            scale_factor=(MagickRealType) QuantumRange/(max_value-min_value);\n      }\n    /*\n      Convert pixels to Quantum size.\n    */\n    p=(unsigned char *) pixels;\n    for (i=0; i < (ssize_t) max_packets; i++)\n    {\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n        case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n        case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n        case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n        default: value=1.0*pixels[i]; break;\n      }\n      if (viff_info.map_scheme == VFF_MS_NONE)\n        {\n          value=(value-min_value)*scale_factor;\n          if (value > QuantumRange)\n            value=QuantumRange;\n          else\n            if (value < 0)\n              value=0;\n        }\n      *p=(unsigned char) ((Quantum) value);\n      p++;\n    }\n    /*\n      Convert VIFF raster image to pixel packets.\n    */\n    p=(unsigned char *) pixels;\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        /*\n          Convert bitmap scanline.\n        */\n        if (image->storage_class != PseudoClass)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          for (x=0; x < (ssize_t) (image->columns-7); x+=8)\n          {\n            for (bit=0; bit < 8; bit++)\n            {\n              quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n              SetPixelRed(q,quantum == 0 ? 0 : QuantumRange);\n              SetPixelGreen(q,quantum == 0 ? 0 : QuantumRange);\n              SetPixelBlue(q,quantum == 0 ? 0 : QuantumRange);\n              if (image->storage_class == PseudoClass)\n                SetPixelIndex(indexes+x+bit,quantum);\n             }\n            p++;\n          }\n          if ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit < (int) (image->columns % 8); bit++)\n              {\n                quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n                SetPixelRed(q,quantum == 0 ? 0 : QuantumRange);\n                SetPixelGreen(q,quantum == 0 ? 0 : QuantumRange);\n                SetPixelBlue(q,quantum == 0 ? 0 : QuantumRange);\n                if (image->storage_class == PseudoClass)\n                  SetPixelIndex(indexes+x+bit,quantum);\n              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          for (x=0; x < (ssize_t) image->columns; x++)\n            SetPixelIndex(indexes+x,*p++);\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      else\n        {\n          /*\n            Convert DirectColor scanline.\n          */\n          number_pixels=(MagickSizeType) image->columns*image->rows;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(q,ScaleCharToQuantum(*p));\n              SetPixelGreen(q,ScaleCharToQuantum(*(p+number_pixels)));\n              SetPixelBlue(q,ScaleCharToQuantum(*(p+2*number_pixels)));\n              if (image->colors != 0)\n                {\n                  ssize_t\n                    index;\n\n                  index=(ssize_t) GetPixelRed(q);\n                  SetPixelRed(q,image->colormap[(ssize_t)\n                    ConstrainColormapIndex(image,index)].red);\n                  index=(ssize_t) GetPixelGreen(q);\n                  SetPixelGreen(q,image->colormap[(ssize_t)\n                    ConstrainColormapIndex(image,index)].green);\n                  index=(ssize_t) GetPixelRed(q);\n                  SetPixelBlue(q,image->colormap[(ssize_t)\n                    ConstrainColormapIndex(image,index)].blue);\n                }\n              SetPixelOpacity(q,image->matte != MagickFalse ? QuantumRange-\n                ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueOpacity);\n              p++;\n              q++;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    count=ReadBlob(image,1,&viff_info.identifier);\n    if ((count != 0) && (viff_info.identifier == 0xab))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (viff_info.identifier == 0xab));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "commit_link": "github.com/ImageMagick/ImageMagick/commit/ca0c886abd6d3ef335eb74150cd23b89ebd17135", "file_name": "coders/viff.c", "vul_type": "cwe-125", "description": "Write a C function to read a VIFF image file in ImageMagick."}
{"func_name": "UnpackExample::usual", "func_src_before": "  public static void usual() throws IOException {\n    ZipFile zf = new ZipFile(\"demo.zip\");\n    try {\n      Enumeration en = zf.entries();\n      while (en.hasMoreElements()) {\n        ZipEntry e = (ZipEntry) en.nextElement();\n\n        InputStream in = null;\n        OutputStream out = null; \n        try {\n          in = zf.getInputStream(e);\n          out = new FileOutputStream(new File(\"demo\", e.getName()));\n          IOUtils.copy(in, out);\n        }\n        finally {\n          IOUtils.closeQuietly(in);\n          IOUtils.closeQuietly(out);\n        }\n      }\n    }\n    finally {\n      zf.close();\n    }\n    \n    zf = new ZipFile(\"demo.zip\");\n    byte[] bytes = new byte[0];\n    try {\n      \n      ZipEntry ze = zf.getEntry(\"foo.txt\");\n      if (ze != null) {\n        InputStream is = zf.getInputStream(ze);\n        try {\n          bytes = IOUtils.toByteArray(is);\n        }\n        finally {\n          IOUtils.closeQuietly(is);\n        }\n      }\n    }\n    finally {\n      zf.close();\n    }\n    \n    System.out.println(\"Read \" + bytes.length + \" bytes.\");\n  }", "func_src_after": "  public static void usual() throws IOException {\n    ZipFile zf = new ZipFile(\"demo.zip\");\n    try {\n      Enumeration en = zf.entries();\n      while (en.hasMoreElements()) {\n        ZipEntry e = (ZipEntry) en.nextElement();\n\n        InputStream in = null;\n        OutputStream out = null; \n        try {\n          in = zf.getInputStream(e);\n          final File zipEntryFile = new File(\"demo\", e.getName());\n          if (!zipEntryFile.toPath().normalize().startsWith(\"demo\")) {\n            throw new IOException(\"Bad zip entry\");\n          }\n          out = new FileOutputStream(zipEntryFile);\n          IOUtils.copy(in, out);\n        }\n        finally {\n          IOUtils.closeQuietly(in);\n          IOUtils.closeQuietly(out);\n        }\n      }\n    }\n    finally {\n      zf.close();\n    }\n    \n    zf = new ZipFile(\"demo.zip\");\n    byte[] bytes = new byte[0];\n    try {\n      \n      ZipEntry ze = zf.getEntry(\"foo.txt\");\n      if (ze != null) {\n        InputStream is = zf.getInputStream(ze);\n        try {\n          bytes = IOUtils.toByteArray(is);\n        }\n        finally {\n          IOUtils.closeQuietly(is);\n        }\n      }\n    }\n    finally {\n      zf.close();\n    }\n    \n    System.out.println(\"Read \" + bytes.length + \" bytes.\");\n  }", "line_changes": {"deleted": [{"line_no": 12, "char_start": 343, "char_end": 412, "line": "          out = new FileOutputStream(new File(\"demo\", e.getName()));\n"}], "added": [{"line_no": 12, "char_start": 343, "char_end": 410, "line": "          final File zipEntryFile = new File(\"demo\", e.getName());\n"}, {"line_no": 13, "char_start": 410, "char_end": 481, "line": "          if (!zipEntryFile.toPath().normalize().startsWith(\"demo\")) {\n"}, {"line_no": 14, "char_start": 481, "char_end": 533, "line": "            throw new IOException(\"Bad zip entry\");\n"}, {"line_no": 15, "char_start": 533, "char_end": 545, "line": "          }\n"}, {"line_no": 16, "char_start": 545, "char_end": 597, "line": "          out = new FileOutputStream(zipEntryFile);\n"}]}, "char_changes": {"deleted": [{"char_start": 353, "char_end": 380, "chars": "out = new FileOutputStream("}], "added": [{"char_start": 353, "char_end": 379, "chars": "final File zipEntryFile = "}, {"char_start": 408, "char_end": 594, "chars": ";\n          if (!zipEntryFile.toPath().normalize().startsWith(\"demo\")) {\n            throw new IOException(\"Bad zip entry\");\n          }\n          out = new FileOutputStream(zipEntryFile"}]}, "commit_link": "github.com/zeroturnaround/zt-zip/commit/627bbc93907ceb69111f86e2edf26375a1abccfa", "file_name": "UnpackExample.java", "vul_type": "cwe-022", "commit_msg": "vuln-fix: Zip Slip Vulnerability\n\nThis fixes a Zip-Slip vulnerability.\n\nThis change does one of two things. This change either\n\n1. Inserts a guard to protect against Zip Slip.\nOR\n2. Replaces `dir.getCanonicalPath().startsWith(parent.getCanonicalPath())`, which is vulnerable to partial path traversal attacks, with the more secure `dir.getCanonicalFile().toPath().startsWith(parent.getCanonicalFile().toPath())`.\n\nFor number 2, consider `\"/usr/outnot\".startsWith(\"/usr/out\")`.\nThe check is bypassed although `/outnot` is not under the `/out` directory.\nIt's important to understand that the terminating slash may be removed when using various `String` representations of the `File` object.\nFor example, on Linux, `println(new File(\"/var\"))` will print `/var`, but `println(new File(\"/var\", \"/\")` will print `/var/`;\nhowever, `println(new File(\"/var\", \"/\").getCanonicalPath())` will print `/var`.\n\nWeakness: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nSeverity: High\nCVSSS: 7.4\nDetection: CodeQL (https://codeql.github.com/codeql-query-help/java/java-zipslip/) & OpenRewrite (https://public.moderne.io/recipes/org.openrewrite.java.security.ZipSlip)\n\nReported-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\nSigned-off-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\n\nBug-tracker: https://github.com/JLLeitschuh/security-research/issues/16\n\nCo-authored-by: Moderne <team@moderne.io>", "parent_commit": "9b0818802c8fc804d75ef731da538423a7e020fa", "description": "Write a Java function to extract all files from a zip archive and read a specific file's contents into a byte array."}
{"func_name": "get_list_context", "func_src_before": "def get_list_context(context=None):\n\tlist_context = frappe._dict(\n\t\ttemplate = \"templates/includes/blog/blog.html\",\n\t\tget_list = get_blog_list,\n\t\thide_filters = True,\n\t\tchildren = get_children(),\n\t\t# show_search = True,\n\t\ttitle = _('Blog')\n\t)\n\n\tcategory = frappe.local.form_dict.blog_category or frappe.local.form_dict.category\n\tif category:\n\t\tcategory_title = get_blog_category(category)\n\t\tlist_context.sub_title = _(\"Posts filed under {0}\").format(category_title)\n\t\tlist_context.title = category_title\n\n\telif frappe.local.form_dict.blogger:\n\t\tblogger = frappe.db.get_value(\"Blogger\", {\"name\": frappe.local.form_dict.blogger}, \"full_name\")\n\t\tlist_context.sub_title = _(\"Posts by {0}\").format(blogger)\n\t\tlist_context.title = blogger\n\n\telif frappe.local.form_dict.txt:\n\t\tlist_context.sub_title = _('Filtered by \"{0}\"').format(frappe.local.form_dict.txt)\n\n\tif list_context.sub_title:\n\t\tlist_context.parents = [{\"name\": _(\"Home\"), \"route\": \"/\"},\n\t\t\t\t\t\t\t\t{\"name\": \"Blog\", \"route\": \"/blog\"}]\n\telse:\n\t\tlist_context.parents = [{\"name\": _(\"Home\"), \"route\": \"/\"}]\n\n\tlist_context.update(frappe.get_doc(\"Blog Settings\", \"Blog Settings\").as_dict(no_default_fields=True))\n\treturn list_context", "func_src_after": "def get_list_context(context=None):\n\tlist_context = frappe._dict(\n\t\ttemplate = \"templates/includes/blog/blog.html\",\n\t\tget_list = get_blog_list,\n\t\thide_filters = True,\n\t\tchildren = get_children(),\n\t\t# show_search = True,\n\t\ttitle = _('Blog')\n\t)\n\n\tcategory = sanitize_html(frappe.local.form_dict.blog_category or frappe.local.form_dict.category)\n\tif category:\n\t\tcategory_title = get_blog_category(category)\n\t\tlist_context.sub_title = _(\"Posts filed under {0}\").format(category_title)\n\t\tlist_context.title = category_title\n\n\telif frappe.local.form_dict.blogger:\n\t\tblogger = frappe.db.get_value(\"Blogger\", {\"name\": frappe.local.form_dict.blogger}, \"full_name\")\n\t\tlist_context.sub_title = _(\"Posts by {0}\").format(blogger)\n\t\tlist_context.title = blogger\n\n\telif frappe.local.form_dict.txt:\n\t\tlist_context.sub_title = _('Filtered by \"{0}\"').format(sanitize_html(frappe.local.form_dict.txt))\n\n\tif list_context.sub_title:\n\t\tlist_context.parents = [{\"name\": _(\"Home\"), \"route\": \"/\"},\n\t\t\t\t\t\t\t\t{\"name\": \"Blog\", \"route\": \"/blog\"}]\n\telse:\n\t\tlist_context.parents = [{\"name\": _(\"Home\"), \"route\": \"/\"}]\n\n\tlist_context.update(frappe.get_doc(\"Blog Settings\", \"Blog Settings\").as_dict(no_default_fields=True))\n\treturn list_context", "commit_link": "github.com/omirajkar/bench_frappe/commit/2fa19c25066ed17478d683666895e3266936aee6", "file_name": "frappe/website/doctype/blog_post/blog_post.py", "vul_type": "cwe-079", "description": "Write a Python function in Frappe to customize the context of a blog list page based on filters like category, blogger, or search text."}
{"func_name": "_run_ssh", "func_src_before": "    def _run_ssh(self, command, check_exit=True, attempts=1):\n        if not self.sshpool:\n            self.sshpool = utils.SSHPool(self.config.san_ip,\n                                         self.config.san_ssh_port,\n                                         self.config.ssh_conn_timeout,\n                                         self.config.san_login,\n                                         password=self.config.san_password,\n                                         privatekey=\n                                         self.config.san_private_key,\n                                         min_size=\n                                         self.config.ssh_min_pool_conn,\n                                         max_size=\n                                         self.config.ssh_max_pool_conn)\n        try:\n            total_attempts = attempts\n            with self.sshpool.item() as ssh:\n                while attempts > 0:\n                    attempts -= 1\n                    try:\n                        return self._ssh_execute(ssh, command,\n                                                 check_exit_code=check_exit)\n                    except Exception as e:\n                        LOG.error(e)\n                        greenthread.sleep(randint(20, 500) / 100.0)\n                msg = (_(\"SSH Command failed after '%(total_attempts)r' \"\n                         \"attempts : '%(command)s'\") %\n                       {'total_attempts': total_attempts, 'command': command})\n                raise paramiko.SSHException(msg)\n        except Exception:\n            with excutils.save_and_reraise_exception():\n                LOG.error(_(\"Error running ssh command: %s\") % command)", "func_src_after": "    def _run_ssh(self, cmd_list, check_exit=True, attempts=1):\n        utils.check_ssh_injection(cmd_list)\n        command = ' '. join(cmd_list)\n\n        if not self.sshpool:\n            self.sshpool = utils.SSHPool(self.config.san_ip,\n                                         self.config.san_ssh_port,\n                                         self.config.ssh_conn_timeout,\n                                         self.config.san_login,\n                                         password=self.config.san_password,\n                                         privatekey=\n                                         self.config.san_private_key,\n                                         min_size=\n                                         self.config.ssh_min_pool_conn,\n                                         max_size=\n                                         self.config.ssh_max_pool_conn)\n        try:\n            total_attempts = attempts\n            with self.sshpool.item() as ssh:\n                while attempts > 0:\n                    attempts -= 1\n                    try:\n                        return self._ssh_execute(ssh, command,\n                                                 check_exit_code=check_exit)\n                    except Exception as e:\n                        LOG.error(e)\n                        greenthread.sleep(randint(20, 500) / 100.0)\n                msg = (_(\"SSH Command failed after '%(total_attempts)r' \"\n                         \"attempts : '%(command)s'\") %\n                       {'total_attempts': total_attempts, 'command': command})\n                raise paramiko.SSHException(msg)\n        except Exception:\n            with excutils.save_and_reraise_exception():\n                LOG.error(_(\"Error running ssh command: %s\") % command)", "commit_link": "github.com/thatsdone/cinder/commit/c55589b131828f3a595903f6796cb2d0babb772f", "file_name": "cinder/volume/drivers/san/hp/hp_3par_common.py", "vul_type": "cwe-078", "description": "Write a Python function to execute an SSH command using a connection pool, with retry logic on failure."}
{"func_name": "gdi_Bitmap_Decompress", "func_src_before": "static BOOL gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,\n                                  const BYTE* pSrcData, UINT32 DstWidth, UINT32 DstHeight,\n                                  UINT32 bpp, UINT32 length, BOOL compressed,\n                                  UINT32 codecId)\n{\n\tUINT32 SrcSize = length;\n\trdpGdi* gdi = context->gdi;\n\tbitmap->compressed = FALSE;\n\tbitmap->format = gdi->dstFormat;\n\tbitmap->length = DstWidth * DstHeight * GetBytesPerPixel(bitmap->format);\n\tbitmap->data = (BYTE*) _aligned_malloc(bitmap->length, 16);\n\n\tif (!bitmap->data)\n\t\treturn FALSE;\n\n\tif (compressed)\n\t{\n\t\tif (bpp < 32)\n\t\t{\n\t\t\tif (!interleaved_decompress(context->codecs->interleaved,\n\t\t\t                            pSrcData, SrcSize,\n\t\t\t                            DstWidth, DstHeight,\n\t\t\t                            bpp,\n\t\t\t                            bitmap->data, bitmap->format,\n\t\t\t                            0, 0, 0, DstWidth, DstHeight,\n\t\t\t                            &gdi->palette))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!planar_decompress(context->codecs->planar, pSrcData, SrcSize,\n\t\t\t                       DstWidth, DstHeight,\n\t\t\t                       bitmap->data, bitmap->format, 0, 0, 0,\n\t\t\t                       DstWidth, DstHeight, TRUE))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tconst UINT32 SrcFormat = gdi_get_pixel_format(bpp);\n\t\tconst size_t sbpp = GetBytesPerPixel(SrcFormat);\n\t\tconst size_t dbpp = GetBytesPerPixel(bitmap->format);\n\n\t\tif ((sbpp == 0) || (dbpp == 0))\n\t\t\treturn FALSE;\n\t\telse\n\t\t{\n\t\t\tconst size_t dstSize = SrcSize * dbpp / sbpp;\n\n\t\t\tif (dstSize  < bitmap->length)\n\t\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (!freerdp_image_copy(bitmap->data, bitmap->format, 0, 0, 0,\n\t\t                        DstWidth, DstHeight, pSrcData, SrcFormat,\n\t\t                        0, 0, 0, &gdi->palette, FREERDP_FLIP_VERTICAL))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}", "func_src_after": "static BOOL gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,\n                                  const BYTE* pSrcData, UINT32 DstWidth, UINT32 DstHeight,\n                                  UINT32 bpp, UINT32 length, BOOL compressed,\n                                  UINT32 codecId)\n{\n\tUINT32 SrcSize = length;\n\trdpGdi* gdi = context->gdi;\n\tUINT32 size = DstWidth * DstHeight;\n\tbitmap->compressed = FALSE;\n\tbitmap->format = gdi->dstFormat;\n\n\tif ((GetBytesPerPixel(bitmap->format) == 0) ||\n\t    (DstWidth == 0) || (DstHeight == 0) || (DstWidth > UINT32_MAX / DstHeight) ||\n\t    (size > (UINT32_MAX / GetBytesPerPixel(bitmap->format))))\n\t\treturn FALSE;\n\n\tsize *= GetBytesPerPixel(bitmap->format);\n\tbitmap->length = size;\n\tbitmap->data = (BYTE*) _aligned_malloc(bitmap->length, 16);\n\n\tif (!bitmap->data)\n\t\treturn FALSE;\n\n\tif (compressed)\n\t{\n\t\tif (bpp < 32)\n\t\t{\n\t\t\tif (!interleaved_decompress(context->codecs->interleaved,\n\t\t\t                            pSrcData, SrcSize,\n\t\t\t                            DstWidth, DstHeight,\n\t\t\t                            bpp,\n\t\t\t                            bitmap->data, bitmap->format,\n\t\t\t                            0, 0, 0, DstWidth, DstHeight,\n\t\t\t                            &gdi->palette))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!planar_decompress(context->codecs->planar, pSrcData, SrcSize,\n\t\t\t                       DstWidth, DstHeight,\n\t\t\t                       bitmap->data, bitmap->format, 0, 0, 0,\n\t\t\t                       DstWidth, DstHeight, TRUE))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tconst UINT32 SrcFormat = gdi_get_pixel_format(bpp);\n\t\tconst size_t sbpp = GetBytesPerPixel(SrcFormat);\n\t\tconst size_t dbpp = GetBytesPerPixel(bitmap->format);\n\n\t\tif ((sbpp == 0) || (dbpp == 0))\n\t\t\treturn FALSE;\n\t\telse\n\t\t{\n\t\t\tconst size_t dstSize = SrcSize * dbpp / sbpp;\n\n\t\t\tif (dstSize  < bitmap->length)\n\t\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (!freerdp_image_copy(bitmap->data, bitmap->format, 0, 0, 0,\n\t\t                        DstWidth, DstHeight, pSrcData, SrcFormat,\n\t\t                        0, 0, 0, &gdi->palette, FREERDP_FLIP_VERTICAL))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}", "commit_link": "github.com/FreeRDP/FreeRDP/commit/09b9d4f1994a674c4ec85b4947aa656eda1aed8a", "file_name": "libfreerdp/gdi/graphics.c", "vul_type": "cwe-190", "description": "Write a C function named `gdi_Bitmap_Decompress` that decompresses a bitmap image in a remote desktop protocol context."}
{"func_name": "UnicodeString::doAppend", "func_src_before": "UnicodeString::doAppend(const UChar *srcChars, int32_t srcStart, int32_t srcLength) {\n  if(!isWritable() || srcLength == 0 || srcChars == NULL) {\n    return *this;\n  }\n\n  // Perform all remaining operations relative to srcChars + srcStart.\n  // From this point forward, do not use srcStart.\n  srcChars += srcStart;\n\n  if(srcLength < 0) {\n    // get the srcLength if necessary\n    if((srcLength = u_strlen(srcChars)) == 0) {\n      return *this;\n    }\n  }\n\n  int32_t oldLength = length();\n  int32_t newLength = oldLength + srcLength;\n\n  // Check for append onto ourself\n  const UChar* oldArray = getArrayStart();\n  if (isBufferWritable() &&\n      oldArray < srcChars + srcLength &&\n      srcChars < oldArray + oldLength) {\n    // Copy into a new UnicodeString and start over\n    UnicodeString copy(srcChars, srcLength);\n    if (copy.isBogus()) {\n      setToBogus();\n      return *this;\n    }\n    return doAppend(copy.getArrayStart(), 0, srcLength);\n  }\n\n  // optimize append() onto a large-enough, owned string\n  if((newLength <= getCapacity() && isBufferWritable()) ||\n      cloneArrayIfNeeded(newLength, getGrowCapacity(newLength))) {\n    UChar *newArray = getArrayStart();\n    // Do not copy characters when\n    //   UChar *buffer=str.getAppendBuffer(...);\n    // is followed by\n    //   str.append(buffer, length);\n    // or\n    //   str.appendString(buffer, length)\n    // or similar.\n    if(srcChars != newArray + oldLength) {\n      us_arrayCopy(srcChars, 0, newArray, oldLength, srcLength);\n    }\n    setLength(newLength);\n  }\n  return *this;\n}", "func_src_after": "UnicodeString::doAppend(const UChar *srcChars, int32_t srcStart, int32_t srcLength) {\n  if(!isWritable() || srcLength == 0 || srcChars == NULL) {\n    return *this;\n  }\n\n  // Perform all remaining operations relative to srcChars + srcStart.\n  // From this point forward, do not use srcStart.\n  srcChars += srcStart;\n\n  if(srcLength < 0) {\n    // get the srcLength if necessary\n    if((srcLength = u_strlen(srcChars)) == 0) {\n      return *this;\n    }\n  }\n\n  int32_t oldLength = length();\n  int32_t newLength;\n  if (uprv_add32_overflow(oldLength, srcLength, &newLength)) {\n    setToBogus();\n    return *this;\n  }\n\n  // Check for append onto ourself\n  const UChar* oldArray = getArrayStart();\n  if (isBufferWritable() &&\n      oldArray < srcChars + srcLength &&\n      srcChars < oldArray + oldLength) {\n    // Copy into a new UnicodeString and start over\n    UnicodeString copy(srcChars, srcLength);\n    if (copy.isBogus()) {\n      setToBogus();\n      return *this;\n    }\n    return doAppend(copy.getArrayStart(), 0, srcLength);\n  }\n\n  // optimize append() onto a large-enough, owned string\n  if((newLength <= getCapacity() && isBufferWritable()) ||\n      cloneArrayIfNeeded(newLength, getGrowCapacity(newLength))) {\n    UChar *newArray = getArrayStart();\n    // Do not copy characters when\n    //   UChar *buffer=str.getAppendBuffer(...);\n    // is followed by\n    //   str.append(buffer, length);\n    // or\n    //   str.appendString(buffer, length)\n    // or similar.\n    if(srcChars != newArray + oldLength) {\n      us_arrayCopy(srcChars, 0, newArray, oldLength, srcLength);\n    }\n    setLength(newLength);\n  }\n  return *this;\n}", "commit_link": "github.com/unicode-org/icu/commit/b7d08bc04a4296982fcef8b6b8a354a9e4e7afca", "file_name": "icu4c/source/common/unistr.cpp", "vul_type": "cwe-190", "description": "In C++, write a method `doAppend` for the `UnicodeString` class that appends a substring to the current string, handling memory allocation and avoiding self-appending issues."}
{"func_name": "process_get_command", "func_src_before": "static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas) {\n    char *key;\n    size_t nkey;\n    int i = 0;\n    item *it;\n    token_t *key_token = &tokens[KEY_TOKEN];\n    char *suffix;\n    assert(c != NULL);\n\n    do {\n        while(key_token->length != 0) {\n\n            key = key_token->value;\n            nkey = key_token->length;\n\n            if(nkey > KEY_MAX_LENGTH) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                while (i-- > 0) {\n                    item_remove(*(c->ilist + i));\n                }\n                return;\n            }\n\n            it = item_get(key, nkey, c, DO_UPDATE);\n            if (settings.detail_enabled) {\n                stats_prefix_record_get(key, nkey, NULL != it);\n            }\n            if (it) {\n                if (i >= c->isize) {\n                    item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);\n                    if (new_list) {\n                        c->isize *= 2;\n                        c->ilist = new_list;\n                    } else {\n                        STATS_LOCK();\n                        stats.malloc_fails++;\n                        STATS_UNLOCK();\n                        item_remove(it);\n                        break;\n                    }\n                }\n\n                /*\n                 * Construct the response. Each hit adds three elements to the\n                 * outgoing data list:\n                 *   \"VALUE \"\n                 *   key\n                 *   \" \" + flags + \" \" + data length + \"\\r\\n\" + data (with \\r\\n)\n                 */\n\n                if (return_cas || !settings.inline_ascii_response)\n                {\n                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,\n                                        it->nbytes, ITEM_get_cas(it));\n                  /* Goofy mid-flight realloc. */\n                  if (i >= c->suffixsize) {\n                    char **new_suffix_list = realloc(c->suffixlist,\n                                           sizeof(char *) * c->suffixsize * 2);\n                    if (new_suffix_list) {\n                        c->suffixsize *= 2;\n                        c->suffixlist  = new_suffix_list;\n                    } else {\n                        STATS_LOCK();\n                        stats.malloc_fails++;\n                        STATS_UNLOCK();\n                        item_remove(it);\n                        break;\n                    }\n                  }\n\n                  suffix = do_cache_alloc(c->thread->suffix_cache);\n                  if (suffix == NULL) {\n                      STATS_LOCK();\n                      stats.malloc_fails++;\n                      STATS_UNLOCK();\n                      out_of_memory(c, \"SERVER_ERROR out of memory making CAS suffix\");\n                      item_remove(it);\n                      while (i-- > 0) {\n                          item_remove(*(c->ilist + i));\n                      }\n                      return;\n                  }\n                  *(c->suffixlist + i) = suffix;\n                  int suffix_len = make_ascii_get_suffix(suffix, it, return_cas);\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, ITEM_key(it), it->nkey) != 0 ||\n                      (settings.inline_ascii_response && add_iov(c, ITEM_suffix(it), it->nsuffix - 2) != 0) ||\n                      add_iov(c, suffix, suffix_len) != 0)\n                      {\n                          item_remove(it);\n                          break;\n                      }\n                  if ((it->it_flags & ITEM_CHUNKED) == 0) {\n                      add_iov(c, ITEM_data(it), it->nbytes);\n                  } else if (add_chunked_item_iovs(c, it, it->nbytes) != 0) {\n                      item_remove(it);\n                      break;\n                  }\n                }\n                else\n                {\n                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,\n                                        it->nbytes, ITEM_get_cas(it));\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, ITEM_key(it), it->nkey) != 0)\n                      {\n                          item_remove(it);\n                          break;\n                      }\n                  if ((it->it_flags & ITEM_CHUNKED) == 0)\n                      {\n                          if (add_iov(c, ITEM_suffix(it), it->nsuffix + it->nbytes) != 0)\n                          {\n                              item_remove(it);\n                              break;\n                          }\n                      } else if (add_iov(c, ITEM_suffix(it), it->nsuffix) != 0 ||\n                                 add_chunked_item_iovs(c, it, it->nbytes) != 0) {\n                          item_remove(it);\n                          break;\n                      }\n                }\n\n\n                if (settings.verbose > 1) {\n                    int ii;\n                    fprintf(stderr, \">%d sending key \", c->sfd);\n                    for (ii = 0; ii < it->nkey; ++ii) {\n                        fprintf(stderr, \"%c\", key[ii]);\n                    }\n                    fprintf(stderr, \"\\n\");\n                }\n\n                /* item_get() has incremented it->refcount for us */\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.slab_stats[ITEM_clsid(it)].get_hits++;\n                c->thread->stats.get_cmds++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                *(c->ilist + i) = it;\n                i++;\n\n            } else {\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.get_misses++;\n                c->thread->stats.get_cmds++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n            }\n\n            key_token++;\n        }\n\n        /*\n         * If the command string hasn't been fully processed, get the next set\n         * of tokens.\n         */\n        if(key_token->value != NULL) {\n            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);\n            key_token = tokens;\n        }\n\n    } while(key_token->value != NULL);\n\n    c->icurr = c->ilist;\n    c->ileft = i;\n    if (return_cas || !settings.inline_ascii_response) {\n        c->suffixcurr = c->suffixlist;\n        c->suffixleft = i;\n    }\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \">%d END\\n\", c->sfd);\n\n    /*\n        If the loop was terminated because of out-of-memory, it is not\n        reliable to add END\\r\\n to the buffer, because it might not end\n        in \\r\\n. So we send SERVER_ERROR instead.\n    */\n    if (key_token->value != NULL || add_iov(c, \"END\\r\\n\", 5) != 0\n        || (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {\n        out_of_memory(c, \"SERVER_ERROR out of memory writing get response\");\n    }\n    else {\n        conn_set_state(c, conn_mwrite);\n        c->msgcurr = 0;\n    }\n}", "func_src_after": "static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas) {\n    char *key;\n    size_t nkey;\n    int i = 0;\n    item *it;\n    token_t *key_token = &tokens[KEY_TOKEN];\n    char *suffix;\n    assert(c != NULL);\n\n    do {\n        while(key_token->length != 0) {\n\n            key = key_token->value;\n            nkey = key_token->length;\n\n            if(nkey > KEY_MAX_LENGTH) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                while (i-- > 0) {\n                    item_remove(*(c->ilist + i));\n                }\n                return;\n            }\n\n            it = limited_get(key, nkey, c);\n            if (settings.detail_enabled) {\n                stats_prefix_record_get(key, nkey, NULL != it);\n            }\n            if (it) {\n                if (i >= c->isize) {\n                    item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);\n                    if (new_list) {\n                        c->isize *= 2;\n                        c->ilist = new_list;\n                    } else {\n                        STATS_LOCK();\n                        stats.malloc_fails++;\n                        STATS_UNLOCK();\n                        item_remove(it);\n                        break;\n                    }\n                }\n\n                /*\n                 * Construct the response. Each hit adds three elements to the\n                 * outgoing data list:\n                 *   \"VALUE \"\n                 *   key\n                 *   \" \" + flags + \" \" + data length + \"\\r\\n\" + data (with \\r\\n)\n                 */\n\n                if (return_cas || !settings.inline_ascii_response)\n                {\n                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,\n                                        it->nbytes, ITEM_get_cas(it));\n                  /* Goofy mid-flight realloc. */\n                  if (i >= c->suffixsize) {\n                    char **new_suffix_list = realloc(c->suffixlist,\n                                           sizeof(char *) * c->suffixsize * 2);\n                    if (new_suffix_list) {\n                        c->suffixsize *= 2;\n                        c->suffixlist  = new_suffix_list;\n                    } else {\n                        STATS_LOCK();\n                        stats.malloc_fails++;\n                        STATS_UNLOCK();\n                        item_remove(it);\n                        break;\n                    }\n                  }\n\n                  suffix = do_cache_alloc(c->thread->suffix_cache);\n                  if (suffix == NULL) {\n                      STATS_LOCK();\n                      stats.malloc_fails++;\n                      STATS_UNLOCK();\n                      out_of_memory(c, \"SERVER_ERROR out of memory making CAS suffix\");\n                      item_remove(it);\n                      while (i-- > 0) {\n                          item_remove(*(c->ilist + i));\n                      }\n                      return;\n                  }\n                  *(c->suffixlist + i) = suffix;\n                  int suffix_len = make_ascii_get_suffix(suffix, it, return_cas);\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, ITEM_key(it), it->nkey) != 0 ||\n                      (settings.inline_ascii_response && add_iov(c, ITEM_suffix(it), it->nsuffix - 2) != 0) ||\n                      add_iov(c, suffix, suffix_len) != 0)\n                      {\n                          item_remove(it);\n                          break;\n                      }\n                  if ((it->it_flags & ITEM_CHUNKED) == 0) {\n                      add_iov(c, ITEM_data(it), it->nbytes);\n                  } else if (add_chunked_item_iovs(c, it, it->nbytes) != 0) {\n                      item_remove(it);\n                      break;\n                  }\n                }\n                else\n                {\n                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,\n                                        it->nbytes, ITEM_get_cas(it));\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, ITEM_key(it), it->nkey) != 0)\n                      {\n                          item_remove(it);\n                          break;\n                      }\n                  if ((it->it_flags & ITEM_CHUNKED) == 0)\n                      {\n                          if (add_iov(c, ITEM_suffix(it), it->nsuffix + it->nbytes) != 0)\n                          {\n                              item_remove(it);\n                              break;\n                          }\n                      } else if (add_iov(c, ITEM_suffix(it), it->nsuffix) != 0 ||\n                                 add_chunked_item_iovs(c, it, it->nbytes) != 0) {\n                          item_remove(it);\n                          break;\n                      }\n                }\n\n\n                if (settings.verbose > 1) {\n                    int ii;\n                    fprintf(stderr, \">%d sending key \", c->sfd);\n                    for (ii = 0; ii < it->nkey; ++ii) {\n                        fprintf(stderr, \"%c\", key[ii]);\n                    }\n                    fprintf(stderr, \"\\n\");\n                }\n\n                /* item_get() has incremented it->refcount for us */\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.slab_stats[ITEM_clsid(it)].get_hits++;\n                c->thread->stats.get_cmds++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                *(c->ilist + i) = it;\n                i++;\n\n            } else {\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.get_misses++;\n                c->thread->stats.get_cmds++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n            }\n\n            key_token++;\n        }\n\n        /*\n         * If the command string hasn't been fully processed, get the next set\n         * of tokens.\n         */\n        if(key_token->value != NULL) {\n            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);\n            key_token = tokens;\n        }\n\n    } while(key_token->value != NULL);\n\n    c->icurr = c->ilist;\n    c->ileft = i;\n    if (return_cas || !settings.inline_ascii_response) {\n        c->suffixcurr = c->suffixlist;\n        c->suffixleft = i;\n    }\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \">%d END\\n\", c->sfd);\n\n    /*\n        If the loop was terminated because of out-of-memory, it is not\n        reliable to add END\\r\\n to the buffer, because it might not end\n        in \\r\\n. So we send SERVER_ERROR instead.\n    */\n    if (key_token->value != NULL || add_iov(c, \"END\\r\\n\", 5) != 0\n        || (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {\n        out_of_memory(c, \"SERVER_ERROR out of memory writing get response\");\n    }\n    else {\n        conn_set_state(c, conn_mwrite);\n        c->msgcurr = 0;\n    }\n}", "commit_link": "github.com/memcached/memcached/commit/a8c4a82787b8b6c256d61bd5c42fb7f92d1bae00", "file_name": "memcached.c", "vul_type": "cwe-190", "description": "Write a C function named `process_get_command` that processes a 'get' command for a connection, handling tokens and optional CAS return."}
{"func_name": "simple_search", "func_src_before": "    @classmethod\n    def simple_search(cls, query, using=None, index=None):\n        es_search = cls.search(using=using, index=index)\n        es_query = cls.get_es_query(query=query)\n        highlighted_fields = [f.split('^', 1)[0] for f in cls.search_fields]\n\n        es_search = es_search.query(es_query).highlight(*highlighted_fields)\n        return es_search", "func_src_after": "    @classmethod\n    def simple_search(cls, query, using=None, index=None):\n        \"\"\"\n        Do a search without facets.\n\n        This is used in:\n\n        * The Docsearch API\n        * The Project Admin Search page\n        \"\"\"\n\n        es_search = cls.search(using=using, index=index)\n        es_search = es_search.highlight_options(encoder='html')\n\n        es_query = cls.get_es_query(query=query)\n        highlighted_fields = [f.split('^', 1)[0] for f in cls.search_fields]\n        es_search = es_search.query(es_query).highlight(*highlighted_fields)\n\n        return es_search", "commit_link": "github.com/readthedocs/readthedocs.org/commit/1ebe494ffde18109307f205d2bd94102452f697a", "file_name": "readthedocs/search/documents.py", "vul_type": "cwe-079", "description": "Write a Python class method that performs a simple search with optional highlighting, without using facets."}
{"func_name": "add_consumption_data_row", "func_src_before": "    def add_consumption_data_row(self, ts, energy_used, power_used):\n\n        if power_used > 0:\n\n            query = '''\n                INSERT OR IGNORE INTO Consumption (\n                    TimeStamp,\n                    EnergyUsed,\n                    PowerUsed                                \n                ) VALUES (\n                    %s,\n                    %s,\n                    %s\n                );\n            ''' % (ts, 0, 0)\n            self.c.execute(query)\n\n            query = '''\n                UPDATE Consumption SET \n                EnergyUsed = EnergyUsed + %s,\n                PowerUsed = PowerUsed + %s\n                WHERE TimeStamp = %s;\n            ''' % (energy_used, power_used, ts)\n\n            self.c.execute(query)\n\n            self.db.commit()", "func_src_after": "    def add_consumption_data_row(self, ts, energy_used, power_used):\n\n        if power_used > 0:\n\n            query = '''\n                INSERT OR IGNORE INTO Consumption (\n                    TimeStamp,\n                    EnergyUsed,\n                    PowerUsed                                \n                ) VALUES (\n                    ?,\n                    ?,\n                    ?\n                );\n            '''\n            self.c.execute(query, (ts, 0, 0))\n\n            query = '''\n                UPDATE Consumption SET \n                EnergyUsed = EnergyUsed + ?,\n                PowerUsed = PowerUsed + ?\n                WHERE TimeStamp=?;\n            '''\n\n            self.c.execute(query, (energy_used, power_used, ts))\n\n            self.db.commit()", "commit_link": "github.com/philipptrenz/s0-bridge/commit/269b48caa05377b7c58c3e6d1622a4429cb5ba65", "file_name": "util/database.py", "vul_type": "cwe-089", "description": "Write a Python function to insert or update a row in a 'Consumption' database table with timestamp, energy used, and power used values, using parameter substitution for SQL queries."}
{"func_name": "ip4_datagram_release_cb", "func_src_before": "void ip4_datagram_release_cb(struct sock *sk)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tconst struct ip_options_rcu *inet_opt;\n\t__be32 daddr = inet->inet_daddr;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\n\tif (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))\n\t\treturn;\n\n\trcu_read_lock();\n\tinet_opt = rcu_dereference(inet->inet_opt);\n\tif (inet_opt && inet_opt->opt.srr)\n\t\tdaddr = inet_opt->opt.faddr;\n\trt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,\n\t\t\t\t   inet->inet_saddr, inet->inet_dport,\n\t\t\t\t   inet->inet_sport, sk->sk_protocol,\n\t\t\t\t   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt))\n\t\t__sk_dst_set(sk, &rt->dst);\n\trcu_read_unlock();\n}", "func_src_after": "void ip4_datagram_release_cb(struct sock *sk)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tconst struct ip_options_rcu *inet_opt;\n\t__be32 daddr = inet->inet_daddr;\n\tstruct dst_entry *dst;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\n\trcu_read_lock();\n\n\tdst = __sk_dst_get(sk);\n\tif (!dst || !dst->obsolete || dst->ops->check(dst, 0)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tinet_opt = rcu_dereference(inet->inet_opt);\n\tif (inet_opt && inet_opt->opt.srr)\n\t\tdaddr = inet_opt->opt.faddr;\n\trt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,\n\t\t\t\t   inet->inet_saddr, inet->inet_dport,\n\t\t\t\t   inet->inet_sport, sk->sk_protocol,\n\t\t\t\t   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);\n\n\tdst = !IS_ERR(rt) ? &rt->dst : NULL;\n\tsk_dst_set(sk, dst);\n\n\trcu_read_unlock();\n}", "commit_link": "github.com/torvalds/linux/commit/9709674e68646cee5a24e3000b3558d25412203a", "file_name": "net/ipv4/datagram.c", "vul_type": "cwe-416", "description": "In C, write a function named `ip4_datagram_release_cb` that manages the release of an IPv4 datagram's resources associated with a socket."}
{"func_name": "can_user_pass_that_amount_of_money", "func_src_before": "    def can_user_pass_that_amount_of_money(self, user_id, money):\n        self.cursor.execute(\"SELECT count(id) FROM kickstarter.users where id = %s and money >= %s\" % (user_id, money))\n        return self.cursor.fetchall()[0][0]", "func_src_after": "    def can_user_pass_that_amount_of_money(self, user_id, money):\n        self.cursor.execute(\"SELECT count(id) FROM kickstarter.users where id = %s and money >= %s\", (user_id, money))\n        return self.cursor.fetchall()[0][0]", "commit_link": "github.com/JLucka/kickstarter-dev/commit/e2ffa062697e060fdfbd2eccbb89a8c53a569e0b", "file_name": "backend/transactions/TransactionConnector.py", "vul_type": "cwe-089", "description": "Write a Python function to check if a user has enough money in a database using SQL query."}
{"func_name": "update_theory_base", "func_src_before": "def update_theory_base(tag, link):\n    theory = sqlite3.connect(os.path.abspath(os.path.dirname(__file__)) + \"\\\\theory.db\")\n    conn = theory.cursor()\n    conn.execute(\"insert into \" + str(tag) + \" values (?)\", (str(link), ))\n    theory.commit()\n    theory.close()", "func_src_after": "def update_theory_base(tag, link):\n    theory = sqlite3.connect(os.path.abspath(os.path.dirname(__file__)) + \"\\\\theory.db\")\n    conn = theory.cursor()\n    conn.execute(\"insert into ? values (?)\", (tag, str(link)))\n    theory.commit()\n    theory.close()", "commit_link": "github.com/lissrbay/codeforces_bot/commit/cc7f5143445a0030b1149ac60a65b1b1b9c92a90", "file_name": "bases/update.py", "vul_type": "cwe-089", "description": "Write a Python function to insert a link into a SQLite database table based on a given tag."}
{"func_name": "initialize", "func_src_before": "    def initialize(json)\n      @params = YAML.load(json || '')\n    end", "func_src_after": "    def initialize(json)\n      @params = YAML.safe_load(json || '')\n    end", "line_changes": {"deleted": [{"line_no": 2, "char_start": 25, "char_end": 63, "line": "      @params = YAML.load(json || '')\n"}], "added": [{"line_no": 2, "char_start": 25, "char_end": 68, "line": "      @params = YAML.safe_load(json || '')\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 46, "char_end": 51, "chars": "safe_"}]}, "commit_link": "github.com/TravisCannon/panamax-api/commit/5f0bd8a0a60751bfd8ff51db83627b0477863b55", "file_name": "from_json.rb", "vul_type": "cwe-502", "commit_msg": "Use YAML.safe_load when parsing user templates", "parent_commit": "0f311d932ddb665f5ebdde98cca040ec858f1010", "description": "Create a Ruby method named `initialize` that loads a JSON string into a `@params` variable using YAML, with an optional use of a safer loading method."}
{"func_name": "on_message", "func_src_before": "    def on_message( self, profile_id, profile_name, level, message, timeout ):\n        if 1 == level:\n            cmd = \"notify-send \"\n            if timeout > 0:\n                cmd = cmd + \" -t %s\" % (1000 * timeout)\n\n            title = \"Back In Time (%s) : %s\" % (self.user, profile_name)\n            message = message.replace(\"\\n\", ' ')\n            message = message.replace(\"\\r\", '')\n\n            cmd = cmd + \" \\\"%s\\\" \\\"%s\\\"\" % (title, message)\n            print(cmd)\n            os.system(cmd)\n        return", "func_src_after": "    def on_message( self, profile_id, profile_name, level, message, timeout ):\n        if 1 == level:\n            cmd = ['notify-send']\n            if timeout > 0:\n                cmd.extend(['-t', str(1000 * timeout)])\n\n            title = \"Back In Time (%s) : %s\" % (self.user, profile_name)\n            message = message.replace(\"\\n\", ' ')\n            message = message.replace(\"\\r\", '')\n\n            cmd.append(title)\n            cmd.append(message)\n            subprocess.Popen(cmd).communicate()\n        return", "commit_link": "github.com/bit-team/backintime/commit/cef81d0da93ff601252607df3db1a48f7f6f01b3", "file_name": "qt4/plugins/notifyplugin.py", "vul_type": "cwe-078", "description": "Write a Python function that displays a notification with a title and message when a certain condition is met, with an optional timeout parameter."}
{"func_name": "Get8BIMProperty", "func_src_before": "static MagickBooleanType Get8BIMProperty(const Image *image,const char *key,\n  ExceptionInfo *exception)\n{\n  char\n    *attribute,\n    format[MagickPathExtent],\n    name[MagickPathExtent],\n    *resource;\n\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *info;\n\n  long\n    start,\n    stop;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    id,\n    sub_number;\n\n  /*\n    There are no newlines in path names, so it's safe as terminator.\n  */\n  profile=GetImageProfile(image,\"8bim\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  count=(ssize_t) sscanf(key,\"8BIM:%ld,%ld:%1024[^\\n]\\n%1024[^\\n]\",&start,&stop,\n    name,format);\n  if ((count != 2) && (count != 3) && (count != 4))\n    return(MagickFalse);\n  if (count < 4)\n    (void) CopyMagickString(format,\"SVG\",MagickPathExtent);\n  if (count < 3)\n    *name='\\0';\n  sub_number=1;\n  if (*name == '#')\n    sub_number=(ssize_t) StringToLong(&name[1]);\n  sub_number=MagickMax(sub_number,1L);\n  resource=(char *) NULL;\n  status=MagickFalse;\n  length=GetStringInfoLength(profile);\n  info=GetStringInfoDatum(profile);\n  while ((length > 0) && (status == MagickFalse))\n  {\n    if (ReadPropertyByte(&info,&length) != (unsigned char) '8')\n      continue;\n    if (ReadPropertyByte(&info,&length) != (unsigned char) 'B')\n      continue;\n    if (ReadPropertyByte(&info,&length) != (unsigned char) 'I')\n      continue;\n    if (ReadPropertyByte(&info,&length) != (unsigned char) 'M')\n      continue;\n    id=(ssize_t) ReadPropertyMSBShort(&info,&length);\n    if (id < (ssize_t) start)\n      continue;\n    if (id > (ssize_t) stop)\n      continue;\n    if (resource != (char *) NULL)\n      resource=DestroyString(resource);\n    count=(ssize_t) ReadPropertyByte(&info,&length);\n    if ((count != 0) && ((size_t) count <= length))\n      {\n        resource=(char *) NULL;\n        if (~((size_t) count) >= (MagickPathExtent-1))\n          resource=(char *) AcquireQuantumMemory((size_t) count+\n            MagickPathExtent,sizeof(*resource));\n        if (resource != (char *) NULL)\n          {\n            for (i=0; i < (ssize_t) count; i++)\n              resource[i]=(char) ReadPropertyByte(&info,&length);\n            resource[count]='\\0';\n          }\n      }\n    if ((count & 0x01) == 0)\n      (void) ReadPropertyByte(&info,&length);\n    count=(ssize_t) ReadPropertyMSBLong(&info,&length);\n    if ((*name != '\\0') && (*name != '#'))\n      if ((resource == (char *) NULL) || (LocaleCompare(name,resource) != 0))\n        {\n          /*\n            No name match, scroll forward and try next.\n          */\n          info+=count;\n          length-=MagickMin(count,(ssize_t) length);\n          continue;\n        }\n    if ((*name == '#') && (sub_number != 1))\n      {\n        /*\n          No numbered match, scroll forward and try next.\n        */\n        sub_number--;\n        info+=count;\n        length-=MagickMin(count,(ssize_t) length);\n        continue;\n      }\n    /*\n      We have the resource of interest.\n    */\n    attribute=(char *) NULL;\n    if (~((size_t) count) >= (MagickPathExtent-1))\n      attribute=(char *) AcquireQuantumMemory((size_t) count+MagickPathExtent,\n        sizeof(*attribute));\n    if (attribute != (char *) NULL)\n      {\n        (void) CopyMagickMemory(attribute,(char *) info,(size_t) count);\n        attribute[count]='\\0';\n        info+=count;\n        length-=MagickMin(count,(ssize_t) length);\n        if ((id <= 1999) || (id >= 2999))\n          (void) SetImageProperty((Image *) image,key,(const char *)\n            attribute,exception);\n        else\n          {\n            char\n              *path;\n\n            if (LocaleCompare(format,\"svg\") == 0)\n              path=TraceSVGClippath((unsigned char *) attribute,(size_t) count,\n                image->columns,image->rows);\n            else\n              path=TracePSClippath((unsigned char *) attribute,(size_t) count);\n            (void) SetImageProperty((Image *) image,key,(const char *) path,\n              exception);\n            path=DestroyString(path);\n          }\n        attribute=DestroyString(attribute);\n        status=MagickTrue;\n      }\n  }\n  if (resource != (char *) NULL)\n    resource=DestroyString(resource);\n  return(status);\n}", "func_src_after": "static MagickBooleanType Get8BIMProperty(const Image *image,const char *key,\n  ExceptionInfo *exception)\n{\n  char\n    *attribute,\n    format[MagickPathExtent],\n    name[MagickPathExtent],\n    *resource;\n\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *info;\n\n  long\n    start,\n    stop;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    id,\n    sub_number;\n\n  /*\n    There are no newlines in path names, so it's safe as terminator.\n  */\n  profile=GetImageProfile(image,\"8bim\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  count=(ssize_t) sscanf(key,\"8BIM:%ld,%ld:%1024[^\\n]\\n%1024[^\\n]\",&start,&stop,\n    name,format);\n  if ((count != 2) && (count != 3) && (count != 4))\n    return(MagickFalse);\n  if (count < 4)\n    (void) CopyMagickString(format,\"SVG\",MagickPathExtent);\n  if (count < 3)\n    *name='\\0';\n  sub_number=1;\n  if (*name == '#')\n    sub_number=(ssize_t) StringToLong(&name[1]);\n  sub_number=MagickMax(sub_number,1L);\n  resource=(char *) NULL;\n  status=MagickFalse;\n  length=GetStringInfoLength(profile);\n  info=GetStringInfoDatum(profile);\n  while ((length > 0) && (status == MagickFalse))\n  {\n    if (ReadPropertyByte(&info,&length) != (unsigned char) '8')\n      continue;\n    if (ReadPropertyByte(&info,&length) != (unsigned char) 'B')\n      continue;\n    if (ReadPropertyByte(&info,&length) != (unsigned char) 'I')\n      continue;\n    if (ReadPropertyByte(&info,&length) != (unsigned char) 'M')\n      continue;\n    id=(ssize_t) ReadPropertyMSBShort(&info,&length);\n    if (id < (ssize_t) start)\n      continue;\n    if (id > (ssize_t) stop)\n      continue;\n    if (resource != (char *) NULL)\n      resource=DestroyString(resource);\n    count=(ssize_t) ReadPropertyByte(&info,&length);\n    if ((count != 0) && ((size_t) count <= length))\n      {\n        resource=(char *) NULL;\n        if (~((size_t) count) >= (MagickPathExtent-1))\n          resource=(char *) AcquireQuantumMemory((size_t) count+\n            MagickPathExtent,sizeof(*resource));\n        if (resource != (char *) NULL)\n          {\n            for (i=0; i < (ssize_t) count; i++)\n              resource[i]=(char) ReadPropertyByte(&info,&length);\n            resource[count]='\\0';\n          }\n      }\n    if ((count & 0x01) == 0)\n      (void) ReadPropertyByte(&info,&length);\n    count=(ssize_t) ReadPropertyMSBLong(&info,&length);\n    if ((count < 0) || ((size_t) count > length))\n      {\n        length=0; \n        continue;\n      }\n    if ((*name != '\\0') && (*name != '#'))\n      if ((resource == (char *) NULL) || (LocaleCompare(name,resource) != 0))\n        {\n          /*\n            No name match, scroll forward and try next.\n          */\n          info+=count;\n          length-=MagickMin(count,(ssize_t) length);\n          continue;\n        }\n    if ((*name == '#') && (sub_number != 1))\n      {\n        /*\n          No numbered match, scroll forward and try next.\n        */\n        sub_number--;\n        info+=count;\n        length-=MagickMin(count,(ssize_t) length);\n        continue;\n      }\n    /*\n      We have the resource of interest.\n    */\n    attribute=(char *) NULL;\n    if (~((size_t) count) >= (MagickPathExtent-1))\n      attribute=(char *) AcquireQuantumMemory((size_t) count+MagickPathExtent,\n        sizeof(*attribute));\n    if (attribute != (char *) NULL)\n      {\n        (void) CopyMagickMemory(attribute,(char *) info,(size_t) count);\n        attribute[count]='\\0';\n        info+=count;\n        length-=MagickMin(count,(ssize_t) length);\n        if ((id <= 1999) || (id >= 2999))\n          (void) SetImageProperty((Image *) image,key,(const char *)\n            attribute,exception);\n        else\n          {\n            char\n              *path;\n\n            if (LocaleCompare(format,\"svg\") == 0)\n              path=TraceSVGClippath((unsigned char *) attribute,(size_t) count,\n                image->columns,image->rows);\n            else\n              path=TracePSClippath((unsigned char *) attribute,(size_t) count);\n            (void) SetImageProperty((Image *) image,key,(const char *) path,\n              exception);\n            path=DestroyString(path);\n          }\n        attribute=DestroyString(attribute);\n        status=MagickTrue;\n      }\n  }\n  if (resource != (char *) NULL)\n    resource=DestroyString(resource);\n  return(status);\n}", "commit_link": "github.com/ImageMagick/ImageMagick/commit/dd84447b63a71fa8c3f47071b09454efc667767b", "file_name": "MagickCore/property.c", "vul_type": "cwe-125", "description": "Write a C function named `Get8BIMProperty` that retrieves a property from an image's 8BIM profile based on a given key."}
{"func_name": "prplcb_xfer_new_send_cb", "func_src_before": "static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_condition cond)\n{\n\tPurpleXfer *xfer = data;\n\tstruct im_connection *ic = purple_ic_by_pa(xfer->account);\n\tstruct prpl_xfer_data *px = xfer->ui_data;\n\tPurpleBuddy *buddy;\n\tconst char *who;\n\n\tbuddy = purple_find_buddy(xfer->account, xfer->who);\n\twho = buddy ? purple_buddy_get_name(buddy) : xfer->who;\n\n\t/* TODO(wilmer): After spreading some more const goodness in BitlBee,\n\t   remove the evil cast below. */\n\tpx->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);\n\tpx->ft->data = px;\n\n\tpx->ft->accept = prpl_xfer_accept;\n\tpx->ft->canceled = prpl_xfer_canceled;\n\tpx->ft->free = prpl_xfer_free;\n\tpx->ft->write_request = prpl_xfer_write_request;\n\n\treturn FALSE;\n}", "func_src_after": "static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_condition cond)\n{\n\tPurpleXfer *xfer = data;\n\tstruct im_connection *ic = purple_ic_by_pa(xfer->account);\n\tstruct prpl_xfer_data *px = xfer->ui_data;\n\tPurpleBuddy *buddy;\n\tconst char *who;\n\n\tbuddy = purple_find_buddy(xfer->account, xfer->who);\n\twho = buddy ? purple_buddy_get_name(buddy) : xfer->who;\n\n\t/* TODO(wilmer): After spreading some more const goodness in BitlBee,\n\t   remove the evil cast below. */\n\tpx->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);\n\n\tif (!px->ft) {\n\t\treturn FALSE;\n\t}\n\tpx->ft->data = px;\n\n\tpx->ft->accept = prpl_xfer_accept;\n\tpx->ft->canceled = prpl_xfer_canceled;\n\tpx->ft->free = prpl_xfer_free;\n\tpx->ft->write_request = prpl_xfer_write_request;\n\n\treturn FALSE;\n}", "commit_link": "github.com/bitlbee/bitlbee/commit/30d598ce7cd3f136ee9d7097f39fa9818a272441", "file_name": "protocols/purple/ft.c", "vul_type": "cwe-476", "description": "Write a C function to initialize a file transfer callback in the BitlBee instant messaging client."}
{"func_name": "_find_host_exhaustive", "func_src_before": "    def _find_host_exhaustive(self, connector, hosts):\n        for host in hosts:\n            ssh_cmd = 'svcinfo lshost -delim ! %s' % host\n            out, err = self._run_ssh(ssh_cmd)\n            self._assert_ssh_return(len(out.strip()),\n                                    '_find_host_exhaustive',\n                                    ssh_cmd, out, err)\n            for attr_line in out.split('\\n'):\n                # If '!' not found, return the string and two empty strings\n                attr_name, foo, attr_val = attr_line.partition('!')\n                if (attr_name == 'iscsi_name' and\n                        'initiator' in connector and\n                        attr_val == connector['initiator']):\n                    return host\n                elif (attr_name == 'WWPN' and\n                      'wwpns' in connector and\n                      attr_val.lower() in\n                      map(str.lower, map(str, connector['wwpns']))):\n                        return host\n        return None", "func_src_after": "    def _find_host_exhaustive(self, connector, hosts):\n        for host in hosts:\n            ssh_cmd = ['svcinfo', 'lshost', '-delim', '!', host]\n            out, err = self._run_ssh(ssh_cmd)\n            self._assert_ssh_return(len(out.strip()),\n                                    '_find_host_exhaustive',\n                                    ssh_cmd, out, err)\n            for attr_line in out.split('\\n'):\n                # If '!' not found, return the string and two empty strings\n                attr_name, foo, attr_val = attr_line.partition('!')\n                if (attr_name == 'iscsi_name' and\n                        'initiator' in connector and\n                        attr_val == connector['initiator']):\n                    return host\n                elif (attr_name == 'WWPN' and\n                      'wwpns' in connector and\n                      attr_val.lower() in\n                      map(str.lower, map(str, connector['wwpns']))):\n                        return host\n        return None", "commit_link": "github.com/thatsdone/cinder/commit/f752302d181583a95cf44354aea607ce9d9283f4", "file_name": "cinder/volume/drivers/storwize_svc.py", "vul_type": "cwe-078", "description": "Write a Python function that searches for a host with matching iSCSI or WWPN attributes in a list of hosts using SSH commands."}
{"func_name": "insertUsage", "func_src_before": "def insertUsage(user, command):\n\tc, conn = getConnection()\n\tdate = now()\n\tc.execute(\"INSERT INTO usage (date,user,command) VALUES ('\"+date+\"','\"+str(user)+\"','\"+command+\"')\")\n\tconn.commit()\n\tconn.close()", "func_src_after": "def insertUsage(user, command):\n\tc, conn = getConnection()\n\tdate = now()\n\tc.execute(\"INSERT INTO usage (date,user,command) VALUES (?,?,?)\",(date,str(user),command))\n\tconn.commit()\n\tconn.close()", "commit_link": "github.com/DangerBlack/DungeonsAndDragonsMasterBot/commit/63f980c6dff746f5fcf3005d0646b6c24f81cdc0", "file_name": "database.py", "vul_type": "cwe-089", "description": "Write a Python function to insert a user's command usage into a database with the current date."}
{"func_name": "test_create_host", "func_src_before": "    def test_create_host(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record\n        self.clear_mox()\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_cpg\",\n                       self.fake_get_cpg)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_domain\",\n                       self.fake_get_domain)\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_host_cmd = 'showhost -verbose fakehost'\n        _run_ssh(show_host_cmd, False).AndReturn([pack('no hosts listed'), ''])\n\n        create_host_cmd = ('createhost -iscsi -persona 1 -domain '\n                           '(\\'OpenStack\\',) '\n                           'fakehost iqn.1993-08.org.debian:01:222')\n        _run_ssh(create_host_cmd, False).AndReturn([CLI_CR, ''])\n\n        _run_ssh(show_host_cmd, False).AndReturn([pack(ISCSI_HOST_RET), ''])\n        self.mox.ReplayAll()\n\n        host = self.driver._create_host(self.volume, self.connector)\n        self.assertEqual(host['name'], self.FAKE_HOST)", "func_src_after": "    def test_create_host(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record\n        self.clear_mox()\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_cpg\",\n                       self.fake_get_cpg)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_domain\",\n                       self.fake_get_domain)\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_host_cmd = ['showhost', '-verbose', 'fakehost']\n        _run_ssh(show_host_cmd, False).AndReturn([pack('no hosts listed'), ''])\n\n        create_host_cmd = (['createhost', '-iscsi', '-persona', '1', '-domain',\n                            ('OpenStack',), 'fakehost',\n                            'iqn.1993-08.org.debian:01:222'])\n        _run_ssh(create_host_cmd, False).AndReturn([CLI_CR, ''])\n\n        _run_ssh(show_host_cmd, False).AndReturn([pack(ISCSI_HOST_RET), ''])\n        self.mox.ReplayAll()\n\n        host = self.driver._create_host(self.volume, self.connector)\n        self.assertEqual(host['name'], self.FAKE_HOST)", "commit_link": "github.com/thatsdone/cinder/commit/c55589b131828f3a595903f6796cb2d0babb772f", "file_name": "cinder/tests/test_hp3par.py", "vul_type": "cwe-078", "description": "Write a Python unit test function that mocks SSH commands for creating and verifying an iSCSI host."}
{"func_name": "dd_save_text", "func_src_before": "void dd_save_text(struct dump_dir *dd, const char *name, const char *data)\n{\n    if (!dd->locked)\n        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    char *full_path = concat_path_file(dd->dd_dirname, name);\n    save_binary_file(full_path, data, strlen(data), dd->dd_uid, dd->dd_gid, dd->mode);\n    free(full_path);\n}", "func_src_after": "void dd_save_text(struct dump_dir *dd, const char *name, const char *data)\n{\n    if (!dd->locked)\n        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    if (!str_is_correct_filename(name))\n        error_msg_and_die(\"Cannot save text. '%s' is not a valid file name\", name);\n\n    char *full_path = concat_path_file(dd->dd_dirname, name);\n    save_binary_file(full_path, data, strlen(data), dd->dd_uid, dd->dd_gid, dd->mode);\n    free(full_path);\n}", "commit_link": "github.com/abrt/libreport/commit/239c4f7d1f47265526b39ad70106767d00805277", "file_name": "src/lib/dump_dir.c", "vul_type": "cwe-022", "description": "Write a C function `dd_save_text` to save text data to a file within a directory structure, handling errors for directory access and file naming."}
{"func_name": "gf_m2ts_process_pmt", "func_src_before": "static void gf_m2ts_process_pmt(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *pmt, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)\n{\n\tu32 info_length, pos, desc_len, evt_type, nb_es,i;\n\tu32 nb_sections;\n\tu32 data_size;\n\tu32 nb_hevc, nb_hevc_temp, nb_shvc, nb_shvc_temp, nb_mhvc, nb_mhvc_temp;\n\tunsigned char *data;\n\tGF_M2TS_Section *section;\n\tGF_Err e = GF_OK;\n\n\t/*wait for the last section */\n\tif (!(status&GF_M2TS_TABLE_END)) return;\n\n\tnb_es = 0;\n\n\t/*skip if already received but no update detected (eg same data) */\n\tif ((status&GF_M2TS_TABLE_REPEAT) && !(status&GF_M2TS_TABLE_UPDATE))  {\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PMT_REPEAT, pmt->program);\n\t\treturn;\n\t}\n\n\tif (pmt->sec->demux_restarted) {\n\t\tpmt->sec->demux_restarted = 0;\n\t\treturn;\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PMT Found or updated\\n\"));\n\n\tnb_sections = gf_list_count(sections);\n\tif (nb_sections > 1) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"PMT on multiple sections not supported\\n\"));\n\t}\n\n\tsection = (GF_M2TS_Section *)gf_list_get(sections, 0);\n\tdata = section->data;\n\tdata_size = section->data_size;\n\n\tpmt->program->pcr_pid = ((data[0] & 0x1f) << 8) | data[1];\n\n\tinfo_length = ((data[2]&0xf)<<8) | data[3];\n\tif (info_length != 0) {\n\t\t/* ...Read Descriptors ... */\n\t\tu8 tag, len;\n\t\tu32 first_loop_len = 0;\n\t\ttag = data[4];\n\t\tlen = data[5];\n\t\twhile (info_length > first_loop_len) {\n\t\t\tif (tag == GF_M2TS_MPEG4_IOD_DESCRIPTOR) {\n\t\t\t\tu32 size;\n\t\t\t\tGF_BitStream *iod_bs;\n\t\t\t\tiod_bs = gf_bs_new((char *)data+8, len-2, GF_BITSTREAM_READ);\n\t\t\t\tif (pmt->program->pmt_iod) gf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);\n\t\t\t\te = gf_odf_parse_descriptor(iod_bs , (GF_Descriptor **) &pmt->program->pmt_iod, &size);\n\t\t\t\tgf_bs_del(iod_bs );\n\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\t/*remember program number for service/program selection*/\n\t\t\t\t\tif (pmt->program->pmt_iod) pmt->program->pmt_iod->ServiceID = pmt->program->number;\n\t\t\t\t\t/*if empty IOD (freebox case), discard it and use dynamic declaration of object*/\n\t\t\t\t\tif (!gf_list_count(pmt->program->pmt_iod->ESDescriptors)) {\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);\n\t\t\t\t\t\tpmt->program->pmt_iod = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (tag == GF_M2TS_METADATA_POINTER_DESCRIPTOR) {\n\t\t\t\tGF_BitStream *metadatapd_bs;\n\t\t\t\tGF_M2TS_MetadataPointerDescriptor *metapd;\n\t\t\t\tmetadatapd_bs = gf_bs_new((char *)data+6, len, GF_BITSTREAM_READ);\n\t\t\t\tmetapd = gf_m2ts_read_metadata_pointer_descriptor(metadatapd_bs, len);\n\t\t\t\tgf_bs_del(metadatapd_bs);\n\t\t\t\tif (metapd->application_format_identifier == GF_M2TS_META_ID3 &&\n\t\t\t\t        metapd->format_identifier == GF_M2TS_META_ID3 &&\n\t\t\t\t        metapd->carriage_flag == METADATA_CARRIAGE_SAME_TS) {\n\t\t\t\t\t/*HLS ID3 Metadata */\n\t\t\t\t\tpmt->program->metadata_pointer_descriptor = metapd;\n\t\t\t\t} else {\n\t\t\t\t\t/* don't know what to do with it for now, delete */\n\t\t\t\t\tgf_m2ts_metadata_pointer_descriptor_del(metapd);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Skipping descriptor (0x%x) and others not supported\\n\", tag));\n\t\t\t}\n\t\t\tfirst_loop_len += 2 + len;\n\t\t}\n\t}\n\tif (data_size <= 4 + info_length) return;\n\tdata += 4 + info_length;\n\tdata_size -= 4 + info_length;\n\tpos = 0;\n\n\t/* count de number of program related PMT received */\n\tfor(i=0; i<gf_list_count(ts->programs); i++) {\n\t\tGF_M2TS_Program *prog = (GF_M2TS_Program *)gf_list_get(ts->programs,i);\n\t\tif(prog->pmt_pid == pmt->pid) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnb_hevc = nb_hevc_temp = nb_shvc = nb_shvc_temp = nb_mhvc = nb_mhvc_temp = 0;\n\twhile (pos<data_size) {\n\t\tGF_M2TS_PES *pes = NULL;\n\t\tGF_M2TS_SECTION_ES *ses = NULL;\n\t\tGF_M2TS_ES *es = NULL;\n\t\tBool inherit_pcr = 0;\n\t\tu32 pid, stream_type, reg_desc_format;\n\n\t\tstream_type = data[0];\n\t\tpid = ((data[1] & 0x1f) << 8) | data[2];\n\t\tdesc_len = ((data[3] & 0xf) << 8) | data[4];\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"stream_type :%d \\n\",stream_type));\n\t\tswitch (stream_type) {\n\n\t\t/* PES */\n\t\tcase GF_M2TS_VIDEO_MPEG1:\n\t\tcase GF_M2TS_VIDEO_MPEG2:\n\t\tcase GF_M2TS_VIDEO_DCII:\n\t\tcase GF_M2TS_VIDEO_MPEG4:\n\t\tcase GF_M2TS_SYSTEMS_MPEG4_PES:\n\t\tcase GF_M2TS_VIDEO_H264:\n\t\tcase GF_M2TS_VIDEO_SVC:\n\t\tcase GF_M2TS_VIDEO_MVCD:\n\t\tcase GF_M2TS_VIDEO_HEVC:\n\t\tcase GF_M2TS_VIDEO_HEVC_MCTS:\n\t\tcase GF_M2TS_VIDEO_HEVC_TEMPORAL:\n\t\tcase GF_M2TS_VIDEO_SHVC:\n\t\tcase GF_M2TS_VIDEO_SHVC_TEMPORAL:\n\t\tcase GF_M2TS_VIDEO_MHVC:\n\t\tcase GF_M2TS_VIDEO_MHVC_TEMPORAL:\n\t\t\tinherit_pcr = 1;\n\t\tcase GF_M2TS_AUDIO_MPEG1:\n\t\tcase GF_M2TS_AUDIO_MPEG2:\n\t\tcase GF_M2TS_AUDIO_AAC:\n\t\tcase GF_M2TS_AUDIO_LATM_AAC:\n\t\tcase GF_M2TS_AUDIO_AC3:\n\t\tcase GF_M2TS_AUDIO_DTS:\n\t\tcase GF_M2TS_MHAS_MAIN:\n\t\tcase GF_M2TS_MHAS_AUX:\n\t\tcase GF_M2TS_SUBTITLE_DVB:\n\t\tcase GF_M2TS_METADATA_PES:\n\t\t\tGF_SAFEALLOC(pes, GF_M2TS_PES);\n\t\t\tif (!pes) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpes->cc = -1;\n\t\t\tpes->flags = GF_M2TS_ES_IS_PES;\n\t\t\tif (inherit_pcr)\n\t\t\t\tpes->flags |= GF_M2TS_INHERIT_PCR;\n\t\t\tes = (GF_M2TS_ES *)pes;\n\t\t\tbreak;\n\t\tcase GF_M2TS_PRIVATE_DATA:\n\t\t\tGF_SAFEALLOC(pes, GF_M2TS_PES);\n\t\t\tif (!pes) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpes->cc = -1;\n\t\t\tpes->flags = GF_M2TS_ES_IS_PES;\n\t\t\tes = (GF_M2TS_ES *)pes;\n\t\t\tbreak;\n\t\t/* Sections */\n\t\tcase GF_M2TS_SYSTEMS_MPEG4_SECTIONS:\n\t\t\tGF_SAFEALLOC(ses, GF_M2TS_SECTION_ES);\n\t\t\tif (!ses) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tes = (GF_M2TS_ES *)ses;\n\t\t\tes->flags |= GF_M2TS_ES_IS_SECTION;\n\t\t\t/* carriage of ISO_IEC_14496 data in sections */\n\t\t\tif (stream_type == GF_M2TS_SYSTEMS_MPEG4_SECTIONS) {\n\t\t\t\t/*MPEG-4 sections need to be fully checked: if one section is lost, this means we lost\n\t\t\t\tone SL packet in the AU so we must wait for the complete section again*/\n\t\t\t\tses->sec = gf_m2ts_section_filter_new(gf_m2ts_process_mpeg4section, 0);\n\t\t\t\t/*create OD container*/\n\t\t\t\tif (!pmt->program->additional_ods) {\n\t\t\t\t\tpmt->program->additional_ods = gf_list_new();\n\t\t\t\t\tts->has_4on2 = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_M2TS_13818_6_ANNEX_A:\n\t\tcase GF_M2TS_13818_6_ANNEX_B:\n\t\tcase GF_M2TS_13818_6_ANNEX_C:\n\t\tcase GF_M2TS_13818_6_ANNEX_D:\n\t\tcase GF_M2TS_PRIVATE_SECTION:\n\t\tcase GF_M2TS_QUALITY_SEC:\n\t\tcase GF_M2TS_MORE_SEC:\n\t\t\tGF_SAFEALLOC(ses, GF_M2TS_SECTION_ES);\n\t\t\tif (!ses) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tes = (GF_M2TS_ES *)ses;\n\t\t\tes->flags |= GF_M2TS_ES_IS_SECTION;\n\t\t\tes->pid = pid;\n\t\t\tes->service_id = pmt->program->number;\n\t\t\tif (stream_type == GF_M2TS_PRIVATE_SECTION) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"AIT sections on pid %d\\n\", pid));\n\t\t\t} else if (stream_type == GF_M2TS_QUALITY_SEC) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"Quality metadata sections on pid %d\\n\", pid));\n\t\t\t} else if (stream_type == GF_M2TS_MORE_SEC) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"MORE sections on pid %d\\n\", pid));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"stream type DSM CC user private sections on pid %d \\n\", pid));\n\t\t\t}\n\t\t\t/* NULL means: trigger the call to on_event with DVB_GENERAL type and the raw section as payload */\n\t\t\tses->sec = gf_m2ts_section_filter_new(NULL, 1);\n\t\t\t//ses->sec->service_id = pmt->program->number;\n\t\t\tbreak;\n\n\t\tcase GF_M2TS_MPE_SECTIONS:\n\t\t\tif (! ts->prefix_present) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"stream type MPE found : pid = %d \\n\", pid));\n#ifdef GPAC_ENABLE_MPE\n\t\t\t\tes = gf_dvb_mpe_section_new();\n\t\t\t\tif (es->flags & GF_M2TS_ES_IS_SECTION) {\n\t\t\t\t\t/* NULL means: trigger the call to on_event with DVB_GENERAL type and the raw section as payload */\n\t\t\t\t\t((GF_M2TS_SECTION_ES*)es)->sec = gf_m2ts_section_filter_new(NULL, 1);\n\t\t\t\t}\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Stream type (0x%x) for PID %d not supported\\n\", stream_type, pid ) );\n\t\t\t//GF_LOG(/*GF_LOG_WARNING*/GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Stream type (0x%x) for PID %d not supported\\n\", stream_type, pid ) );\n\t\t\tbreak;\n\t\t}\n\n\t\tif (es) {\n\t\t\tes->stream_type = (stream_type==GF_M2TS_PRIVATE_DATA) ? 0 : stream_type;\n\t\t\tes->program = pmt->program;\n\t\t\tes->pid = pid;\n\t\t\tes->component_tag = -1;\n\t\t}\n\n\t\tpos += 5;\n\t\tdata += 5;\n\n\t\twhile (desc_len) {\n\t\t\tu8 tag = data[0];\n\t\t\tu32 len = data[1];\n\t\t\tif (es) {\n\t\t\t\tswitch (tag) {\n\t\t\t\tcase GF_M2TS_ISO_639_LANGUAGE_DESCRIPTOR:\n\t\t\t\t\tif (pes)\n\t\t\t\t\t\tpes->lang = GF_4CC(' ', data[2], data[3], data[4]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_MPEG4_SL_DESCRIPTOR:\n\t\t\t\t\tes->mpeg4_es_id = ( (u32) data[2] & 0x1f) << 8  | data[3];\n\t\t\t\t\tes->flags |= GF_M2TS_ES_IS_SL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_REGISTRATION_DESCRIPTOR:\n\t\t\t\t\treg_desc_format = GF_4CC(data[2], data[3], data[4], data[5]);\n\t\t\t\t\t/*cf http://www.smpte-ra.org/mpegreg/mpegreg.html*/\n\t\t\t\t\tswitch (reg_desc_format) {\n\t\t\t\t\tcase GF_M2TS_RA_STREAM_AC3:\n\t\t\t\t\t\tes->stream_type = GF_M2TS_AUDIO_AC3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_M2TS_RA_STREAM_VC1:\n\t\t\t\t\t\tes->stream_type = GF_M2TS_VIDEO_VC1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_M2TS_RA_STREAM_GPAC:\n\t\t\t\t\t\tif (len==8) {\n\t\t\t\t\t\t\tes->stream_type = GF_4CC(data[6], data[7], data[8], data[9]);\n\t\t\t\t\t\t\tes->flags |= GF_M2TS_GPAC_CODEC_ID;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"Unknown registration descriptor %s\\n\", gf_4cc_to_str(reg_desc_format) ));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_EAC3_DESCRIPTOR:\n\t\t\t\t\tes->stream_type = GF_M2TS_AUDIO_EC3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_DATA_BROADCAST_ID_DESCRIPTOR:\n\t\t\t\t{\n\t\t\t\t\tu32 id = data[2]<<8 | data[3];\n\t\t\t\t\tif ((id == 0xB) && ses && !ses->sec) {\n\t\t\t\t\t\tses->sec = gf_m2ts_section_filter_new(NULL, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_SUBTITLING_DESCRIPTOR:\n\t\t\t\t\tif (pes) {\n\t\t\t\t\t\tpes->sub.language[0] = data[2];\n\t\t\t\t\t\tpes->sub.language[1] = data[3];\n\t\t\t\t\t\tpes->sub.language[2] = data[4];\n\t\t\t\t\t\tpes->sub.type = data[5];\n\t\t\t\t\t\tpes->sub.composition_page_id = (data[6]<<8) | data[7];\n\t\t\t\t\t\tpes->sub.ancillary_page_id = (data[8]<<8) | data[9];\n\t\t\t\t\t}\n\t\t\t\t\tes->stream_type = GF_M2TS_DVB_SUBTITLE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_STREAM_IDENTIFIER_DESCRIPTOR:\n\t\t\t\t{\n\t\t\t\t\tes->component_tag = data[2];\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"Component Tag: %d on Program %d\\n\", es->component_tag, es->program->number));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_TELETEXT_DESCRIPTOR:\n\t\t\t\t\tes->stream_type = GF_M2TS_DVB_TELETEXT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_VBI_DATA_DESCRIPTOR:\n\t\t\t\t\tes->stream_type = GF_M2TS_DVB_VBI;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_HIERARCHY_DESCRIPTOR:\n\t\t\t\t\tif (pes) {\n\t\t\t\t\t\tu8 hierarchy_embedded_layer_index;\n\t\t\t\t\t\tGF_BitStream *hbs = gf_bs_new((const char *)data, data_size, GF_BITSTREAM_READ);\n\t\t\t\t\t\t/*u32 skip = */gf_bs_read_int(hbs, 16);\n\t\t\t\t\t\t/*u8 res1 = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\t/*u8 temp_scal = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\t/*u8 spatial_scal = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\t/*u8 quality_scal = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\t/*u8 hierarchy_type = */gf_bs_read_int(hbs, 4);\n\t\t\t\t\t\t/*u8 res2 = */gf_bs_read_int(hbs, 2);\n\t\t\t\t\t\t/*u8 hierarchy_layer_index = */gf_bs_read_int(hbs, 6);\n\t\t\t\t\t\t/*u8 tref_not_present = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\t/*u8 res3 = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\thierarchy_embedded_layer_index = gf_bs_read_int(hbs, 6);\n\t\t\t\t\t\t/*u8 res4 = */gf_bs_read_int(hbs, 2);\n\t\t\t\t\t\t/*u8 hierarchy_channel = */gf_bs_read_int(hbs, 6);\n\t\t\t\t\t\tgf_bs_del(hbs);\n\n\t\t\t\t\t\tpes->depends_on_pid = 1+hierarchy_embedded_layer_index;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_METADATA_DESCRIPTOR:\n\t\t\t\t{\n\t\t\t\t\tGF_BitStream *metadatad_bs;\n\t\t\t\t\tGF_M2TS_MetadataDescriptor *metad;\n\t\t\t\t\tmetadatad_bs = gf_bs_new((char *)data+2, len, GF_BITSTREAM_READ);\n\t\t\t\t\tmetad = gf_m2ts_read_metadata_descriptor(metadatad_bs, len);\n\t\t\t\t\tgf_bs_del(metadatad_bs);\n\t\t\t\t\tif (metad->application_format_identifier == GF_M2TS_META_ID3 &&\n\t\t\t\t\t        metad->format_identifier == GF_M2TS_META_ID3) {\n\t\t\t\t\t\t/*HLS ID3 Metadata */\n\t\t\t\t\t\tif (pes) {\n\t\t\t\t\t\t\tpes->metadata_descriptor = metad;\n\t\t\t\t\t\t\tpes->stream_type = GF_M2TS_METADATA_ID3_HLS;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* don't know what to do with it for now, delete */\n\t\t\t\t\t\tgf_m2ts_metadata_descriptor_del(metad);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] skipping descriptor (0x%x) not supported\\n\", tag));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdata += len+2;\n\t\t\tpos += len+2;\n\t\t\tif (desc_len < len+2) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Invalid PMT es descriptor size for PID %d\\n\", pid ) );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdesc_len-=len+2;\n\t\t}\n\n\t\tif (es && !es->stream_type) {\n\t\t\tgf_free(es);\n\t\t\tes = NULL;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Private Stream type (0x%x) for PID %d not supported\\n\", stream_type, pid ) );\n\t\t}\n\n\t\tif (!es) continue;\n\n\t\tif (ts->ess[pid]) {\n\t\t\t//this is component reuse across programs, overwrite the previously declared stream ...\n\t\t\tif (status & GF_M2TS_TABLE_FOUND) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d reused across programs %d and %d, not completely supported\\n\", pid, ts->ess[pid]->program->number, es->program->number ) );\n\n\t\t\t\t//add stream to program but don't reassign the pid table until the stream is playing (>GF_M2TS_PES_FRAMING_SKIP)\n\t\t\t\tgf_list_add(pmt->program->streams, es);\n\t\t\t\tif (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);\n\n\t\t\t\tnb_es++;\n\t\t\t\t//skip assignment below\n\t\t\t\tes = NULL;\n\t\t\t}\n\t\t\t/*watchout for pmt update - FIXME this likely won't work in most cases*/\n\t\t\telse {\n\n\t\t\t\tGF_M2TS_ES *o_es = ts->ess[es->pid];\n\n\t\t\t\tif ((o_es->stream_type == es->stream_type)\n\t\t\t\t        && ((o_es->flags & GF_M2TS_ES_STATIC_FLAGS_MASK) == (es->flags & GF_M2TS_ES_STATIC_FLAGS_MASK))\n\t\t\t\t        && (o_es->mpeg4_es_id == es->mpeg4_es_id)\n\t\t\t\t        && ((o_es->flags & GF_M2TS_ES_IS_SECTION) || ((GF_M2TS_PES *)o_es)->lang == ((GF_M2TS_PES *)es)->lang)\n\t\t\t\t   ) {\n\t\t\t\t\tgf_free(es);\n\t\t\t\t\tes = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tgf_m2ts_es_del(o_es, ts);\n\t\t\t\t\tts->ess[es->pid] = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (es) {\n\t\t\tts->ess[es->pid] = es;\n\t\t\tgf_list_add(pmt->program->streams, es);\n\t\t\tif (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);\n\n\t\t\tnb_es++;\n\t\t}\n\n\t\tif (es->stream_type == GF_M2TS_VIDEO_HEVC) nb_hevc++;\n\t\telse if (es->stream_type == GF_M2TS_VIDEO_HEVC_TEMPORAL) nb_hevc_temp++;\n\t\telse if (es->stream_type == GF_M2TS_VIDEO_SHVC) nb_shvc++;\n\t\telse if (es->stream_type == GF_M2TS_VIDEO_SHVC_TEMPORAL) nb_shvc_temp++;\n\t\telse if (es->stream_type == GF_M2TS_VIDEO_MHVC) nb_mhvc++;\n\t\telse if (es->stream_type == GF_M2TS_VIDEO_MHVC_TEMPORAL) nb_mhvc_temp++;\n\t}\n\n\t//Table 2-139, implied hierarchy indexes\n\tif (nb_hevc_temp + nb_shvc + nb_shvc_temp + nb_mhvc+ nb_mhvc_temp) {\n\t\tfor (i=0; i<gf_list_count(pmt->program->streams); i++) {\n\t\t\tGF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);\n\t\t\tif ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;\n\t\t\tif (es->depends_on_pid) continue;\n\n\t\t\tswitch (es->stream_type) {\n\t\t\tcase GF_M2TS_VIDEO_HEVC_TEMPORAL:\n\t\t\t\tes->depends_on_pid = 1;\n\t\t\t\tbreak;\n\t\t\tcase GF_M2TS_VIDEO_SHVC:\n\t\t\t\tif (!nb_hevc_temp) es->depends_on_pid = 1;\n\t\t\t\telse es->depends_on_pid = 2;\n\t\t\t\tbreak;\n\t\t\tcase GF_M2TS_VIDEO_SHVC_TEMPORAL:\n\t\t\t\tes->depends_on_pid = 3;\n\t\t\t\tbreak;\n\t\t\tcase GF_M2TS_VIDEO_MHVC:\n\t\t\t\tif (!nb_hevc_temp) es->depends_on_pid = 1;\n\t\t\t\telse es->depends_on_pid = 2;\n\t\t\t\tbreak;\n\t\t\tcase GF_M2TS_VIDEO_MHVC_TEMPORAL:\n\t\t\t\tif (!nb_hevc_temp) es->depends_on_pid = 2;\n\t\t\t\telse es->depends_on_pid = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nb_es) {\n\t\tu32 i;\n\n\t\t//translate hierarchy descriptors indexes into PIDs - check whether the PMT-index rules are the same for HEVC\n\t\tfor (i=0; i<gf_list_count(pmt->program->streams); i++) {\n\t\t\tGF_M2TS_PES *an_es = NULL;\n\t\t\tGF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);\n\t\t\tif ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;\n\t\t\tif (!es->depends_on_pid) continue;\n\n\t\t\t//fixeme we are not always assured that hierarchy_layer_index matches the stream index...\n\t\t\t//+1 is because our first stream is the PMT\n\t\t\tan_es =  (GF_M2TS_PES *)gf_list_get(pmt->program->streams, es->depends_on_pid);\n\t\t\tif (an_es) {\n\t\t\t\tes->depends_on_pid = an_es->pid;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[M2TS] Wrong dependency index in hierarchy descriptor, assuming non-scalable stream\\n\"));\n\t\t\t\tes->depends_on_pid = 0;\n\t\t\t}\n\t\t}\n\n\t\tevt_type = (status&GF_M2TS_TABLE_FOUND) ? GF_M2TS_EVT_PMT_FOUND : GF_M2TS_EVT_PMT_UPDATE;\n\t\tif (ts->on_event) ts->on_event(ts, evt_type, pmt->program);\n\t} else {\n\t\t/* if we found no new ES it's simply a repeat of the PMT */\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PMT_REPEAT, pmt->program);\n\t}\n}", "func_src_after": "static void gf_m2ts_process_pmt(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *pmt, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)\n{\n\tu32 info_length, pos, desc_len, evt_type, nb_es,i;\n\tu32 nb_sections;\n\tu32 data_size;\n\tu32 nb_hevc, nb_hevc_temp, nb_shvc, nb_shvc_temp, nb_mhvc, nb_mhvc_temp;\n\tunsigned char *data;\n\tGF_M2TS_Section *section;\n\tGF_Err e = GF_OK;\n\n\t/*wait for the last section */\n\tif (!(status&GF_M2TS_TABLE_END)) return;\n\n\tnb_es = 0;\n\n\t/*skip if already received but no update detected (eg same data) */\n\tif ((status&GF_M2TS_TABLE_REPEAT) && !(status&GF_M2TS_TABLE_UPDATE))  {\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PMT_REPEAT, pmt->program);\n\t\treturn;\n\t}\n\n\tif (pmt->sec->demux_restarted) {\n\t\tpmt->sec->demux_restarted = 0;\n\t\treturn;\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PMT Found or updated\\n\"));\n\n\tnb_sections = gf_list_count(sections);\n\tif (nb_sections > 1) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"PMT on multiple sections not supported\\n\"));\n\t}\n\n\tsection = (GF_M2TS_Section *)gf_list_get(sections, 0);\n\tdata = section->data;\n\tdata_size = section->data_size;\n\n\tpmt->program->pcr_pid = ((data[0] & 0x1f) << 8) | data[1];\n\n\tinfo_length = ((data[2]&0xf)<<8) | data[3];\n\tif (info_length != 0) {\n\t\t/* ...Read Descriptors ... */\n\t\tu8 tag, len;\n\t\tu32 first_loop_len = 0;\n\t\ttag = data[4];\n\t\tlen = data[5];\n\t\twhile (info_length > first_loop_len) {\n\t\t\tif (tag == GF_M2TS_MPEG4_IOD_DESCRIPTOR) {\n\t\t\t\tu32 size;\n\t\t\t\tGF_BitStream *iod_bs;\n\t\t\t\tiod_bs = gf_bs_new((char *)data+8, len-2, GF_BITSTREAM_READ);\n\t\t\t\tif (pmt->program->pmt_iod) gf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);\n\t\t\t\te = gf_odf_parse_descriptor(iod_bs , (GF_Descriptor **) &pmt->program->pmt_iod, &size);\n\t\t\t\tgf_bs_del(iod_bs );\n\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\t/*remember program number for service/program selection*/\n\t\t\t\t\tif (pmt->program->pmt_iod) pmt->program->pmt_iod->ServiceID = pmt->program->number;\n\t\t\t\t\t/*if empty IOD (freebox case), discard it and use dynamic declaration of object*/\n\t\t\t\t\tif (!gf_list_count(pmt->program->pmt_iod->ESDescriptors)) {\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);\n\t\t\t\t\t\tpmt->program->pmt_iod = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (tag == GF_M2TS_METADATA_POINTER_DESCRIPTOR) {\n\t\t\t\tGF_BitStream *metadatapd_bs;\n\t\t\t\tGF_M2TS_MetadataPointerDescriptor *metapd;\n\t\t\t\tmetadatapd_bs = gf_bs_new((char *)data+6, len, GF_BITSTREAM_READ);\n\t\t\t\tmetapd = gf_m2ts_read_metadata_pointer_descriptor(metadatapd_bs, len);\n\t\t\t\tgf_bs_del(metadatapd_bs);\n\t\t\t\tif (metapd->application_format_identifier == GF_M2TS_META_ID3 &&\n\t\t\t\t        metapd->format_identifier == GF_M2TS_META_ID3 &&\n\t\t\t\t        metapd->carriage_flag == METADATA_CARRIAGE_SAME_TS) {\n\t\t\t\t\t/*HLS ID3 Metadata */\n\t\t\t\t\tpmt->program->metadata_pointer_descriptor = metapd;\n\t\t\t\t} else {\n\t\t\t\t\t/* don't know what to do with it for now, delete */\n\t\t\t\t\tgf_m2ts_metadata_pointer_descriptor_del(metapd);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Skipping descriptor (0x%x) and others not supported\\n\", tag));\n\t\t\t}\n\t\t\tfirst_loop_len += 2 + len;\n\t\t}\n\t}\n\tif (data_size <= 4 + info_length) return;\n\tdata += 4 + info_length;\n\tdata_size -= 4 + info_length;\n\tpos = 0;\n\n\t/* count de number of program related PMT received */\n\tfor(i=0; i<gf_list_count(ts->programs); i++) {\n\t\tGF_M2TS_Program *prog = (GF_M2TS_Program *)gf_list_get(ts->programs,i);\n\t\tif(prog->pmt_pid == pmt->pid) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnb_hevc = nb_hevc_temp = nb_shvc = nb_shvc_temp = nb_mhvc = nb_mhvc_temp = 0;\n\twhile (pos<data_size) {\n\t\tGF_M2TS_PES *pes = NULL;\n\t\tGF_M2TS_SECTION_ES *ses = NULL;\n\t\tGF_M2TS_ES *es = NULL;\n\t\tBool inherit_pcr = 0;\n\t\tu32 pid, stream_type, reg_desc_format;\n\n\t\tstream_type = data[0];\n\t\tpid = ((data[1] & 0x1f) << 8) | data[2];\n\t\tdesc_len = ((data[3] & 0xf) << 8) | data[4];\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"stream_type :%d \\n\",stream_type));\n\t\tswitch (stream_type) {\n\n\t\t/* PES */\n\t\tcase GF_M2TS_VIDEO_MPEG1:\n\t\tcase GF_M2TS_VIDEO_MPEG2:\n\t\tcase GF_M2TS_VIDEO_DCII:\n\t\tcase GF_M2TS_VIDEO_MPEG4:\n\t\tcase GF_M2TS_SYSTEMS_MPEG4_PES:\n\t\tcase GF_M2TS_VIDEO_H264:\n\t\tcase GF_M2TS_VIDEO_SVC:\n\t\tcase GF_M2TS_VIDEO_MVCD:\n\t\tcase GF_M2TS_VIDEO_HEVC:\n\t\tcase GF_M2TS_VIDEO_HEVC_MCTS:\n\t\tcase GF_M2TS_VIDEO_HEVC_TEMPORAL:\n\t\tcase GF_M2TS_VIDEO_SHVC:\n\t\tcase GF_M2TS_VIDEO_SHVC_TEMPORAL:\n\t\tcase GF_M2TS_VIDEO_MHVC:\n\t\tcase GF_M2TS_VIDEO_MHVC_TEMPORAL:\n\t\t\tinherit_pcr = 1;\n\t\tcase GF_M2TS_AUDIO_MPEG1:\n\t\tcase GF_M2TS_AUDIO_MPEG2:\n\t\tcase GF_M2TS_AUDIO_AAC:\n\t\tcase GF_M2TS_AUDIO_LATM_AAC:\n\t\tcase GF_M2TS_AUDIO_AC3:\n\t\tcase GF_M2TS_AUDIO_DTS:\n\t\tcase GF_M2TS_MHAS_MAIN:\n\t\tcase GF_M2TS_MHAS_AUX:\n\t\tcase GF_M2TS_SUBTITLE_DVB:\n\t\tcase GF_M2TS_METADATA_PES:\n\t\t\tGF_SAFEALLOC(pes, GF_M2TS_PES);\n\t\t\tif (!pes) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpes->cc = -1;\n\t\t\tpes->flags = GF_M2TS_ES_IS_PES;\n\t\t\tif (inherit_pcr)\n\t\t\t\tpes->flags |= GF_M2TS_INHERIT_PCR;\n\t\t\tes = (GF_M2TS_ES *)pes;\n\t\t\tbreak;\n\t\tcase GF_M2TS_PRIVATE_DATA:\n\t\t\tGF_SAFEALLOC(pes, GF_M2TS_PES);\n\t\t\tif (!pes) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpes->cc = -1;\n\t\t\tpes->flags = GF_M2TS_ES_IS_PES;\n\t\t\tes = (GF_M2TS_ES *)pes;\n\t\t\tbreak;\n\t\t/* Sections */\n\t\tcase GF_M2TS_SYSTEMS_MPEG4_SECTIONS:\n\t\t\tGF_SAFEALLOC(ses, GF_M2TS_SECTION_ES);\n\t\t\tif (!ses) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tes = (GF_M2TS_ES *)ses;\n\t\t\tes->flags |= GF_M2TS_ES_IS_SECTION;\n\t\t\t/* carriage of ISO_IEC_14496 data in sections */\n\t\t\tif (stream_type == GF_M2TS_SYSTEMS_MPEG4_SECTIONS) {\n\t\t\t\t/*MPEG-4 sections need to be fully checked: if one section is lost, this means we lost\n\t\t\t\tone SL packet in the AU so we must wait for the complete section again*/\n\t\t\t\tses->sec = gf_m2ts_section_filter_new(gf_m2ts_process_mpeg4section, 0);\n\t\t\t\t/*create OD container*/\n\t\t\t\tif (!pmt->program->additional_ods) {\n\t\t\t\t\tpmt->program->additional_ods = gf_list_new();\n\t\t\t\t\tts->has_4on2 = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_M2TS_13818_6_ANNEX_A:\n\t\tcase GF_M2TS_13818_6_ANNEX_B:\n\t\tcase GF_M2TS_13818_6_ANNEX_C:\n\t\tcase GF_M2TS_13818_6_ANNEX_D:\n\t\tcase GF_M2TS_PRIVATE_SECTION:\n\t\tcase GF_M2TS_QUALITY_SEC:\n\t\tcase GF_M2TS_MORE_SEC:\n\t\t\tGF_SAFEALLOC(ses, GF_M2TS_SECTION_ES);\n\t\t\tif (!ses) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tes = (GF_M2TS_ES *)ses;\n\t\t\tes->flags |= GF_M2TS_ES_IS_SECTION;\n\t\t\tes->pid = pid;\n\t\t\tes->service_id = pmt->program->number;\n\t\t\tif (stream_type == GF_M2TS_PRIVATE_SECTION) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"AIT sections on pid %d\\n\", pid));\n\t\t\t} else if (stream_type == GF_M2TS_QUALITY_SEC) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"Quality metadata sections on pid %d\\n\", pid));\n\t\t\t} else if (stream_type == GF_M2TS_MORE_SEC) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"MORE sections on pid %d\\n\", pid));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"stream type DSM CC user private sections on pid %d \\n\", pid));\n\t\t\t}\n\t\t\t/* NULL means: trigger the call to on_event with DVB_GENERAL type and the raw section as payload */\n\t\t\tses->sec = gf_m2ts_section_filter_new(NULL, 1);\n\t\t\t//ses->sec->service_id = pmt->program->number;\n\t\t\tbreak;\n\n\t\tcase GF_M2TS_MPE_SECTIONS:\n\t\t\tif (! ts->prefix_present) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"stream type MPE found : pid = %d \\n\", pid));\n#ifdef GPAC_ENABLE_MPE\n\t\t\t\tes = gf_dvb_mpe_section_new();\n\t\t\t\tif (es->flags & GF_M2TS_ES_IS_SECTION) {\n\t\t\t\t\t/* NULL means: trigger the call to on_event with DVB_GENERAL type and the raw section as payload */\n\t\t\t\t\t((GF_M2TS_SECTION_ES*)es)->sec = gf_m2ts_section_filter_new(NULL, 1);\n\t\t\t\t}\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Stream type (0x%x) for PID %d not supported\\n\", stream_type, pid ) );\n\t\t\t//GF_LOG(/*GF_LOG_WARNING*/GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Stream type (0x%x) for PID %d not supported\\n\", stream_type, pid ) );\n\t\t\tbreak;\n\t\t}\n\n\t\tif (es) {\n\t\t\tes->stream_type = (stream_type==GF_M2TS_PRIVATE_DATA) ? 0 : stream_type;\n\t\t\tes->program = pmt->program;\n\t\t\tes->pid = pid;\n\t\t\tes->component_tag = -1;\n\t\t}\n\n\t\tpos += 5;\n\t\tdata += 5;\n\n\t\twhile (desc_len) {\n\t\t\tu8 tag = data[0];\n\t\t\tu32 len = data[1];\n\t\t\tif (es) {\n\t\t\t\tswitch (tag) {\n\t\t\t\tcase GF_M2TS_ISO_639_LANGUAGE_DESCRIPTOR:\n\t\t\t\t\tif (pes)\n\t\t\t\t\t\tpes->lang = GF_4CC(' ', data[2], data[3], data[4]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_MPEG4_SL_DESCRIPTOR:\n\t\t\t\t\tes->mpeg4_es_id = ( (u32) data[2] & 0x1f) << 8  | data[3];\n\t\t\t\t\tes->flags |= GF_M2TS_ES_IS_SL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_REGISTRATION_DESCRIPTOR:\n\t\t\t\t\treg_desc_format = GF_4CC(data[2], data[3], data[4], data[5]);\n\t\t\t\t\t/*cf http://www.smpte-ra.org/mpegreg/mpegreg.html*/\n\t\t\t\t\tswitch (reg_desc_format) {\n\t\t\t\t\tcase GF_M2TS_RA_STREAM_AC3:\n\t\t\t\t\t\tes->stream_type = GF_M2TS_AUDIO_AC3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_M2TS_RA_STREAM_VC1:\n\t\t\t\t\t\tes->stream_type = GF_M2TS_VIDEO_VC1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_M2TS_RA_STREAM_GPAC:\n\t\t\t\t\t\tif (len==8) {\n\t\t\t\t\t\t\tes->stream_type = GF_4CC(data[6], data[7], data[8], data[9]);\n\t\t\t\t\t\t\tes->flags |= GF_M2TS_GPAC_CODEC_ID;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"Unknown registration descriptor %s\\n\", gf_4cc_to_str(reg_desc_format) ));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_EAC3_DESCRIPTOR:\n\t\t\t\t\tes->stream_type = GF_M2TS_AUDIO_EC3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_DATA_BROADCAST_ID_DESCRIPTOR:\n\t\t\t\t{\n\t\t\t\t\tu32 id = data[2]<<8 | data[3];\n\t\t\t\t\tif ((id == 0xB) && ses && !ses->sec) {\n\t\t\t\t\t\tses->sec = gf_m2ts_section_filter_new(NULL, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_SUBTITLING_DESCRIPTOR:\n\t\t\t\t\tif (pes) {\n\t\t\t\t\t\tpes->sub.language[0] = data[2];\n\t\t\t\t\t\tpes->sub.language[1] = data[3];\n\t\t\t\t\t\tpes->sub.language[2] = data[4];\n\t\t\t\t\t\tpes->sub.type = data[5];\n\t\t\t\t\t\tpes->sub.composition_page_id = (data[6]<<8) | data[7];\n\t\t\t\t\t\tpes->sub.ancillary_page_id = (data[8]<<8) | data[9];\n\t\t\t\t\t}\n\t\t\t\t\tes->stream_type = GF_M2TS_DVB_SUBTITLE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_STREAM_IDENTIFIER_DESCRIPTOR:\n\t\t\t\t{\n\t\t\t\t\tes->component_tag = data[2];\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"Component Tag: %d on Program %d\\n\", es->component_tag, es->program->number));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_TELETEXT_DESCRIPTOR:\n\t\t\t\t\tes->stream_type = GF_M2TS_DVB_TELETEXT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_VBI_DATA_DESCRIPTOR:\n\t\t\t\t\tes->stream_type = GF_M2TS_DVB_VBI;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_HIERARCHY_DESCRIPTOR:\n\t\t\t\t\tif (pes) {\n\t\t\t\t\t\tu8 hierarchy_embedded_layer_index;\n\t\t\t\t\t\tGF_BitStream *hbs = gf_bs_new((const char *)data, data_size, GF_BITSTREAM_READ);\n\t\t\t\t\t\t/*u32 skip = */gf_bs_read_int(hbs, 16);\n\t\t\t\t\t\t/*u8 res1 = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\t/*u8 temp_scal = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\t/*u8 spatial_scal = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\t/*u8 quality_scal = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\t/*u8 hierarchy_type = */gf_bs_read_int(hbs, 4);\n\t\t\t\t\t\t/*u8 res2 = */gf_bs_read_int(hbs, 2);\n\t\t\t\t\t\t/*u8 hierarchy_layer_index = */gf_bs_read_int(hbs, 6);\n\t\t\t\t\t\t/*u8 tref_not_present = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\t/*u8 res3 = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\thierarchy_embedded_layer_index = gf_bs_read_int(hbs, 6);\n\t\t\t\t\t\t/*u8 res4 = */gf_bs_read_int(hbs, 2);\n\t\t\t\t\t\t/*u8 hierarchy_channel = */gf_bs_read_int(hbs, 6);\n\t\t\t\t\t\tgf_bs_del(hbs);\n\n\t\t\t\t\t\tpes->depends_on_pid = 1+hierarchy_embedded_layer_index;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_METADATA_DESCRIPTOR:\n\t\t\t\t{\n\t\t\t\t\tGF_BitStream *metadatad_bs;\n\t\t\t\t\tGF_M2TS_MetadataDescriptor *metad;\n\t\t\t\t\tmetadatad_bs = gf_bs_new((char *)data+2, len, GF_BITSTREAM_READ);\n\t\t\t\t\tmetad = gf_m2ts_read_metadata_descriptor(metadatad_bs, len);\n\t\t\t\t\tgf_bs_del(metadatad_bs);\n\t\t\t\t\tif (metad->application_format_identifier == GF_M2TS_META_ID3 &&\n\t\t\t\t\t        metad->format_identifier == GF_M2TS_META_ID3) {\n\t\t\t\t\t\t/*HLS ID3 Metadata */\n\t\t\t\t\t\tif (pes) {\n\t\t\t\t\t\t\tpes->metadata_descriptor = metad;\n\t\t\t\t\t\t\tpes->stream_type = GF_M2TS_METADATA_ID3_HLS;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* don't know what to do with it for now, delete */\n\t\t\t\t\t\tgf_m2ts_metadata_descriptor_del(metad);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] skipping descriptor (0x%x) not supported\\n\", tag));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdata += len+2;\n\t\t\tpos += len+2;\n\t\t\tif (desc_len < len+2) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Invalid PMT es descriptor size for PID %d\\n\", pid ) );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdesc_len-=len+2;\n\t\t}\n\n\t\tif (es && !es->stream_type) {\n\t\t\tgf_free(es);\n\t\t\tes = NULL;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Private Stream type (0x%x) for PID %d not supported\\n\", stream_type, pid ) );\n\t\t}\n\n\t\tif (!es) continue;\n\n\t\tif (ts->ess[pid]) {\n\t\t\t//this is component reuse across programs, overwrite the previously declared stream ...\n\t\t\tif (status & GF_M2TS_TABLE_FOUND) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d reused across programs %d and %d, not completely supported\\n\", pid, ts->ess[pid]->program->number, es->program->number ) );\n\n\t\t\t\t//add stream to program but don't reassign the pid table until the stream is playing (>GF_M2TS_PES_FRAMING_SKIP)\n\t\t\t\tgf_list_add(pmt->program->streams, es);\n\t\t\t\tif (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);\n\n\t\t\t\tnb_es++;\n\t\t\t\t//skip assignment below\n\t\t\t\tes = NULL;\n\t\t\t}\n\t\t\t/*watchout for pmt update - FIXME this likely won't work in most cases*/\n\t\t\telse {\n\n\t\t\t\tGF_M2TS_ES *o_es = ts->ess[es->pid];\n\n\t\t\t\tif ((o_es->stream_type == es->stream_type)\n\t\t\t\t        && ((o_es->flags & GF_M2TS_ES_STATIC_FLAGS_MASK) == (es->flags & GF_M2TS_ES_STATIC_FLAGS_MASK))\n\t\t\t\t        && (o_es->mpeg4_es_id == es->mpeg4_es_id)\n\t\t\t\t        && ((o_es->flags & GF_M2TS_ES_IS_SECTION) || ((GF_M2TS_PES *)o_es)->lang == ((GF_M2TS_PES *)es)->lang)\n\t\t\t\t   ) {\n\t\t\t\t\tgf_free(es);\n\t\t\t\t\tes = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tgf_m2ts_es_del(o_es, ts);\n\t\t\t\t\tts->ess[es->pid] = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (es) {\n\t\t\tts->ess[es->pid] = es;\n\t\t\tgf_list_add(pmt->program->streams, es);\n\t\t\tif (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);\n\n\t\t\tnb_es++;\n\n\t\t\tif (es->stream_type == GF_M2TS_VIDEO_HEVC) nb_hevc++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_HEVC_TEMPORAL) nb_hevc_temp++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_SHVC) nb_shvc++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_SHVC_TEMPORAL) nb_shvc_temp++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_MHVC) nb_mhvc++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_MHVC_TEMPORAL) nb_mhvc_temp++;\n\t\t}\n\t}\n\n\t//Table 2-139, implied hierarchy indexes\n\tif (nb_hevc_temp + nb_shvc + nb_shvc_temp + nb_mhvc+ nb_mhvc_temp) {\n\t\tfor (i=0; i<gf_list_count(pmt->program->streams); i++) {\n\t\t\tGF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);\n\t\t\tif ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;\n\t\t\tif (es->depends_on_pid) continue;\n\n\t\t\tswitch (es->stream_type) {\n\t\t\tcase GF_M2TS_VIDEO_HEVC_TEMPORAL:\n\t\t\t\tes->depends_on_pid = 1;\n\t\t\t\tbreak;\n\t\t\tcase GF_M2TS_VIDEO_SHVC:\n\t\t\t\tif (!nb_hevc_temp) es->depends_on_pid = 1;\n\t\t\t\telse es->depends_on_pid = 2;\n\t\t\t\tbreak;\n\t\t\tcase GF_M2TS_VIDEO_SHVC_TEMPORAL:\n\t\t\t\tes->depends_on_pid = 3;\n\t\t\t\tbreak;\n\t\t\tcase GF_M2TS_VIDEO_MHVC:\n\t\t\t\tif (!nb_hevc_temp) es->depends_on_pid = 1;\n\t\t\t\telse es->depends_on_pid = 2;\n\t\t\t\tbreak;\n\t\t\tcase GF_M2TS_VIDEO_MHVC_TEMPORAL:\n\t\t\t\tif (!nb_hevc_temp) es->depends_on_pid = 2;\n\t\t\t\telse es->depends_on_pid = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nb_es) {\n\t\tu32 i;\n\n\t\t//translate hierarchy descriptors indexes into PIDs - check whether the PMT-index rules are the same for HEVC\n\t\tfor (i=0; i<gf_list_count(pmt->program->streams); i++) {\n\t\t\tGF_M2TS_PES *an_es = NULL;\n\t\t\tGF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);\n\t\t\tif ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;\n\t\t\tif (!es->depends_on_pid) continue;\n\n\t\t\t//fixeme we are not always assured that hierarchy_layer_index matches the stream index...\n\t\t\t//+1 is because our first stream is the PMT\n\t\t\tan_es =  (GF_M2TS_PES *)gf_list_get(pmt->program->streams, es->depends_on_pid);\n\t\t\tif (an_es) {\n\t\t\t\tes->depends_on_pid = an_es->pid;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[M2TS] Wrong dependency index in hierarchy descriptor, assuming non-scalable stream\\n\"));\n\t\t\t\tes->depends_on_pid = 0;\n\t\t\t}\n\t\t}\n\n\t\tevt_type = (status&GF_M2TS_TABLE_FOUND) ? GF_M2TS_EVT_PMT_FOUND : GF_M2TS_EVT_PMT_UPDATE;\n\t\tif (ts->on_event) ts->on_event(ts, evt_type, pmt->program);\n\t} else {\n\t\t/* if we found no new ES it's simply a repeat of the PMT */\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PMT_REPEAT, pmt->program);\n\t}\n}", "commit_link": "github.com/gpac/gpac/commit/2320eb73afba753b39b7147be91f7be7afc0eeb7", "file_name": "src/media_tools/mpegts.c", "vul_type": "cwe-125", "description": "Write a C function to process PMT sections in an MPEG-2 TS demuxer."}
{"func_name": "compare_and_update", "func_src_before": "    @staticmethod\n    def compare_and_update(user, message):\n        \"\"\"\n        This method compare a user object from the bot and his info from\n        the Telegram message to check whether a user has changed his bio\n        or not. If yes, the user object that represents him in the bot will\n        be updated accordingly. Now this function is called only when a user\n        asks the bot for showing the most popular cams\n\n        :param user: user object that represents a Telegram user in this bot\n        :param message: object from Telegram that contains info about user's\n        message and about himself\n        :return: None\n        \"\"\"\n\n        log.info('Checking whether user have changed his info or not...')\n        msg = message.from_user\n        usr_from_message = User(message.chat.id, msg.first_name, msg.username,\n                                msg.last_name)\n\n        if user.chat_id != usr_from_message.chat_id:\n            log.error(\"Wrong user to compare!\")\n            return\n\n        if user.first_name != usr_from_message.first_name:\n            user.first_name = usr_from_message.first_name\n\n        elif user.nickname != usr_from_message.nickname:\n            user.nickname = usr_from_message.nickname\n\n        elif user.last_name != usr_from_message.last_name:\n            user.last_name = usr_from_message.last_name\n\n        else:\n            log.debug(\"User's info hasn't changed\")\n            return\n\n        log.info(\"User has changed his info\")\n        log.debug(\"Updating user's info in the database...\")\n        query = (f\"UPDATE users \"\n                 f\"SET first_name='{user.first_name}', \"\n                 f\"nickname='{user.nickname}', \"\n                 f\"last_name='{user.last_name}' \"\n                 f\"WHERE chat_id={user.chat_id}\")\n\n        try:\n            db.add(query)\n        except DatabaseError:\n            log.error(\"Could not update info about %s in the database\",\n                      user)\n        else:\n            log.debug(\"User's info has been updated\")", "func_src_after": "    @staticmethod\n    def compare_and_update(user, message):\n        \"\"\"\n        This method compare a user object from the bot and his info from\n        the Telegram message to check whether a user has changed his bio\n        or not. If yes, the user object that represents him in the bot will\n        be updated accordingly. Now this function is called only when a user\n        asks the bot for showing the most popular cams\n\n        :param user: user object that represents a Telegram user in this bot\n        :param message: object from Telegram that contains info about user's\n        message and about himself\n        :return: None\n        \"\"\"\n\n        log.info('Checking whether user have changed his info or not...')\n        msg = message.from_user\n        usr_from_message = User(message.chat.id, msg.first_name, msg.username,\n                                msg.last_name)\n\n        if user.chat_id != usr_from_message.chat_id:\n            log.error(\"Wrong user to compare!\")\n            return\n\n        if user.first_name != usr_from_message.first_name:\n            user.first_name = usr_from_message.first_name\n\n        elif user.nickname != usr_from_message.nickname:\n            user.nickname = usr_from_message.nickname\n\n        elif user.last_name != usr_from_message.last_name:\n            user.last_name = usr_from_message.last_name\n\n        else:\n            log.debug(\"User's info hasn't changed\")\n            return\n\n        log.info(\"User has changed his info\")\n        log.debug(\"Updating user's info in the database...\")\n        query = (f\"UPDATE users \"\n                 f\"SET first_name=%s, \"\n                 f\"nickname=%s, \"\n                 f\"last_name=%s \"\n                 f\"WHERE chat_id=%s\")\n\n        parameters = (user.first_name, user.nickname, user.last_name,\n                      user.chat_id)\n\n        try:\n            db.add(query, parameters)\n        except DatabaseError:\n            log.error(\"Could not update info about %s in the database\",\n                      user)\n        else:\n            log.debug(\"User's info has been updated\")", "commit_link": "github.com/RandyRomero/photoGPSbot/commit/0e9f57f13e61863b3672f5730e27f149da00786a", "file_name": "photogpsbot/users.py", "vul_type": "cwe-089", "description": "In Python, write a static method to compare a user's information from a Telegram bot with the incoming message data and update the user's info in the database if it has changed."}
{"func_name": "_remove_volume_set", "func_src_before": "    def _remove_volume_set(self, vvs_name):\n        # Must first clear the QoS rules before removing the volume set\n        self._cli_run('setqos -clear vvset:%s' % (vvs_name), None)\n        self._cli_run('removevvset -f %s' % (vvs_name), None)", "func_src_after": "    def _remove_volume_set(self, vvs_name):\n        # Must first clear the QoS rules before removing the volume set\n        self._cli_run(['setqos', '-clear', 'vvset:%s' % (vvs_name)])\n        self._cli_run(['removevvset', '-f', vvs_name])", "commit_link": "github.com/thatsdone/cinder/commit/c55589b131828f3a595903f6796cb2d0babb772f", "file_name": "cinder/volume/drivers/san/hp/hp_3par_common.py", "vul_type": "cwe-078", "description": "Write a Python function to clear QoS rules and remove a volume set using CLI commands."}
{"func_name": "add_day_data_row", "func_src_before": "    def add_day_data_row(self, ts, data, prev_etotal):\n\n        if data['power'] > 0:\n\n            inv_serial = data['source']['serial_id']\n            query = '''\n               INSERT INTO DayData (\n                   TimeStamp,\n                   Serial,\n                   Power,\n                   TotalYield\n               ) VALUES (\n                   %s,\n                   %s,\n                   %s,\n                   %s\n               );\n            ''' % (ts, inv_serial, data['power'],  prev_etotal + data['energy'])\n            self.c.execute(query)", "func_src_after": "    def add_day_data_row(self, ts, data, prev_etotal):\n\n        if data['power'] > 0:\n\n            inv_serial = data['source']['serial_id']\n            query = '''\n               INSERT INTO DayData (\n                   TimeStamp,\n                   Serial,\n                   Power,\n                   TotalYield\n               ) VALUES (\n                   ?,\n                   ?,\n                   ?,\n                   ?\n               );\n            '''\n            self.c.execute(query, (ts, inv_serial, data['power'],  prev_etotal + data['energy']))", "commit_link": "github.com/philipptrenz/s0-bridge/commit/269b48caa05377b7c58c3e6d1622a4429cb5ba65", "file_name": "util/database.py", "vul_type": "cwe-089", "description": "Write a Python function to insert a new row into a database table if the power value is positive, using string formatting or parameterized queries."}
{"func_name": "parse_str", "func_src_before": "module.exports = function parse_str (str, array) { // eslint-disable-line camelcase\n  //       discuss at: https://locutus.io/php/parse_str/\n  //      original by: Cagri Ekin\n  //      improved by: Michael White (https://getsprink.com)\n  //      improved by: Jack\n  //      improved by: Brett Zamir (https://brett-zamir.me)\n  //      bugfixed by: Onno Marsman (https://twitter.com/onnomarsman)\n  //      bugfixed by: Brett Zamir (https://brett-zamir.me)\n  //      bugfixed by: stag019\n  //      bugfixed by: Brett Zamir (https://brett-zamir.me)\n  //      bugfixed by: MIO_KODUKI (https://mio-koduki.blogspot.com/)\n  // reimplemented by: stag019\n  //         input by: Dreamer\n  //         input by: Zaide (https://zaidesthings.com/)\n  //         input by: David Pesta (https://davidpesta.com/)\n  //         input by: jeicquest\n  //      bugfixed by: Rafa\u0142 Kukawski\n  //           note 1: When no argument is specified, will put variables in global scope.\n  //           note 1: When a particular argument has been passed, and the\n  //           note 1: returned value is different parse_str of PHP.\n  //           note 1: For example, a=b=c&d====c\n  //        example 1: var $arr = {}\n  //        example 1: parse_str('first=foo&second=bar', $arr)\n  //        example 1: var $result = $arr\n  //        returns 1: { first: 'foo', second: 'bar' }\n  //        example 2: var $arr = {}\n  //        example 2: parse_str('str_a=Jack+and+Jill+didn%27t+see+the+well.', $arr)\n  //        example 2: var $result = $arr\n  //        returns 2: { str_a: \"Jack and Jill didn't see the well.\" }\n  //        example 3: var $abc = {3:'a'}\n  //        example 3: parse_str('a[b][\"c\"]=def&a[q]=t+5', $abc)\n  //        example 3: var $result = $abc\n  //        returns 3: {\"3\":\"a\",\"a\":{\"b\":{\"c\":\"def\"},\"q\":\"t 5\"}}\n  //        example 4: var $arr = {}\n  //        example 4: parse_str('a[][]=value', $arr)\n  //        example 4: var $result = $arr\n  //        returns 4: {\"a\":{\"0\":{\"0\":\"value\"}}}\n  //        example 5: var $arr = {}\n  //        example 5: parse_str('a=1&a[]=2', $arr)\n  //        example 5: var $result = $arr\n  //        returns 5: {\"a\":{\"0\":\"2\"}}\n\n  var strArr = String(str).replace(/^&/, '').replace(/&$/, '').split('&')\n  var sal = strArr.length\n  var i\n  var j\n  var ct\n  var p\n  var lastObj\n  var obj\n  var chr\n  var tmp\n  var key\n  var value\n  var postLeftBracketPos\n  var keys\n  var keysLen\n\n  var _fixStr = function (str) {\n    return decodeURIComponent(str.replace(/\\+/g, '%20'))\n  }\n\n  var $global = (typeof window !== 'undefined' ? window : global)\n  $global.$locutus = $global.$locutus || {}\n  var $locutus = $global.$locutus\n  $locutus.php = $locutus.php || {}\n\n  if (!array) {\n    array = $global\n  }\n\n  for (i = 0; i < sal; i++) {\n    tmp = strArr[i].split('=')\n    key = _fixStr(tmp[0])\n    value = (tmp.length < 2) ? '' : _fixStr(tmp[1])\n\n    while (key.charAt(0) === ' ') {\n      key = key.slice(1)\n    }\n\n    if (key.indexOf('\\x00') > -1) {\n      key = key.slice(0, key.indexOf('\\x00'))\n    }\n\n    if (key && key.charAt(0) !== '[') {\n      keys = []\n      postLeftBracketPos = 0\n\n      for (j = 0; j < key.length; j++) {\n        if (key.charAt(j) === '[' && !postLeftBracketPos) {\n          postLeftBracketPos = j + 1\n        } else if (key.charAt(j) === ']') {\n          if (postLeftBracketPos) {\n            if (!keys.length) {\n              keys.push(key.slice(0, postLeftBracketPos - 1))\n            }\n\n            keys.push(key.substr(postLeftBracketPos, j - postLeftBracketPos))\n            postLeftBracketPos = 0\n\n            if (key.charAt(j + 1) !== '[') {\n              break\n            }\n          }\n        }\n      }\n\n      if (!keys.length) {\n        keys = [key]\n      }\n\n      for (j = 0; j < keys[0].length; j++) {\n        chr = keys[0].charAt(j)\n\n        if (chr === ' ' || chr === '.' || chr === '[') {\n          keys[0] = keys[0].substr(0, j) + '_' + keys[0].substr(j + 1)\n        }\n\n        if (chr === '[') {\n          break\n        }\n      }\n\n      obj = array\n\n      for (j = 0, keysLen = keys.length; j < keysLen; j++) {\n        key = keys[j].replace(/^['\"]/, '').replace(/['\"]$/, '')\n        lastObj = obj\n\n        if ((key === '' || key === ' ') && j !== 0) {\n          // Insert new dimension\n          ct = -1\n\n          for (p in obj) {\n            if (obj.hasOwnProperty(p)) {\n              if (+p > ct && p.match(/^\\d+$/g)) {\n                ct = +p\n              }\n            }\n          }\n\n          key = ct + 1\n        }\n\n        // if primitive value, replace with object\n        if (Object(obj[key]) !== obj[key]) {\n          obj[key] = {}\n        }\n\n        obj = obj[key]\n      }\n\n      lastObj[key] = value\n    }\n  }\n}", "func_src_after": "module.exports = function parse_str (str, array) { // eslint-disable-line camelcase\n  //       discuss at: https://locutus.io/php/parse_str/\n  //      original by: Cagri Ekin\n  //      improved by: Michael White (https://getsprink.com)\n  //      improved by: Jack\n  //      improved by: Brett Zamir (https://brett-zamir.me)\n  //      bugfixed by: Onno Marsman (https://twitter.com/onnomarsman)\n  //      bugfixed by: Brett Zamir (https://brett-zamir.me)\n  //      bugfixed by: stag019\n  //      bugfixed by: Brett Zamir (https://brett-zamir.me)\n  //      bugfixed by: MIO_KODUKI (https://mio-koduki.blogspot.com/)\n  // reimplemented by: stag019\n  //         input by: Dreamer\n  //         input by: Zaide (https://zaidesthings.com/)\n  //         input by: David Pesta (https://davidpesta.com/)\n  //         input by: jeicquest\n  //      bugfixed by: Rafa\u0142 Kukawski\n  //           note 1: When no argument is specified, will put variables in global scope.\n  //           note 1: When a particular argument has been passed, and the\n  //           note 1: returned value is different parse_str of PHP.\n  //           note 1: For example, a=b=c&d====c\n  //        example 1: var $arr = {}\n  //        example 1: parse_str('first=foo&second=bar', $arr)\n  //        example 1: var $result = $arr\n  //        returns 1: { first: 'foo', second: 'bar' }\n  //        example 2: var $arr = {}\n  //        example 2: parse_str('str_a=Jack+and+Jill+didn%27t+see+the+well.', $arr)\n  //        example 2: var $result = $arr\n  //        returns 2: { str_a: \"Jack and Jill didn't see the well.\" }\n  //        example 3: var $abc = {3:'a'}\n  //        example 3: parse_str('a[b][\"c\"]=def&a[q]=t+5', $abc)\n  //        example 3: var $result = $abc\n  //        returns 3: {\"3\":\"a\",\"a\":{\"b\":{\"c\":\"def\"},\"q\":\"t 5\"}}\n  //        example 4: var $arr = {}\n  //        example 4: parse_str('a[][]=value', $arr)\n  //        example 4: var $result = $arr\n  //        returns 4: {\"a\":{\"0\":{\"0\":\"value\"}}}\n  //        example 5: var $arr = {}\n  //        example 5: parse_str('a=1&a[]=2', $arr)\n  //        example 5: var $result = $arr\n  //        returns 5: {\"a\":{\"0\":\"2\"}}\n\n  var strArr = String(str).replace(/^&/, '').replace(/&$/, '').split('&')\n  var sal = strArr.length\n  var i\n  var j\n  var ct\n  var p\n  var lastObj\n  var obj\n  var chr\n  var tmp\n  var key\n  var value\n  var postLeftBracketPos\n  var keys\n  var keysLen\n\n  var _fixStr = function (str) {\n    return decodeURIComponent(str.replace(/\\+/g, '%20'))\n  }\n\n  var $global = (typeof window !== 'undefined' ? window : global)\n  $global.$locutus = $global.$locutus || {}\n  var $locutus = $global.$locutus\n  $locutus.php = $locutus.php || {}\n\n  if (!array) {\n    array = $global\n  }\n\n  for (i = 0; i < sal; i++) {\n    tmp = strArr[i].split('=')\n    key = _fixStr(tmp[0])\n    value = (tmp.length < 2) ? '' : _fixStr(tmp[1])\n\n    if (key.includes('__proto__') || key.includes('constructor') || key.includes('prototype')) {\n      break;\n    }\n\n    while (key.charAt(0) === ' ') {\n      key = key.slice(1)\n    }\n\n    if (key.indexOf('\\x00') > -1) {\n      key = key.slice(0, key.indexOf('\\x00'))\n    }\n\n    if (key && key.charAt(0) !== '[') {\n      keys = []\n      postLeftBracketPos = 0\n\n      for (j = 0; j < key.length; j++) {\n        if (key.charAt(j) === '[' && !postLeftBracketPos) {\n          postLeftBracketPos = j + 1\n        } else if (key.charAt(j) === ']') {\n          if (postLeftBracketPos) {\n            if (!keys.length) {\n              keys.push(key.slice(0, postLeftBracketPos - 1))\n            }\n\n            keys.push(key.substr(postLeftBracketPos, j - postLeftBracketPos))\n            postLeftBracketPos = 0\n\n            if (key.charAt(j + 1) !== '[') {\n              break\n            }\n          }\n        }\n      }\n\n      if (!keys.length) {\n        keys = [key]\n      }\n\n      for (j = 0; j < keys[0].length; j++) {\n        chr = keys[0].charAt(j)\n\n        if (chr === ' ' || chr === '.' || chr === '[') {\n          keys[0] = keys[0].substr(0, j) + '_' + keys[0].substr(j + 1)\n        }\n\n        if (chr === '[') {\n          break\n        }\n      }\n\n      obj = array\n\n      for (j = 0, keysLen = keys.length; j < keysLen; j++) {\n        key = keys[j].replace(/^['\"]/, '').replace(/['\"]$/, '')\n        lastObj = obj\n\n        if ((key === '' || key === ' ') && j !== 0) {\n          // Insert new dimension\n          ct = -1\n\n          for (p in obj) {\n            if (obj.hasOwnProperty(p)) {\n              if (+p > ct && p.match(/^\\d+$/g)) {\n                ct = +p\n              }\n            }\n          }\n\n          key = ct + 1\n        }\n\n        // if primitive value, replace with object\n        if (Object(obj[key]) !== obj[key]) {\n          obj[key] = {}\n        }\n\n        obj = obj[key]\n      }\n\n      lastObj[key] = value\n    }\n  }\n}", "line_changes": {"deleted": [], "added": [{"line_no": 77, "char_start": 2854, "char_end": 2951, "line": "    if (key.includes('__proto__') || key.includes('constructor') || key.includes('prototype')) {\n"}, {"line_no": 78, "char_start": 2951, "char_end": 2964, "line": "      break;\n"}, {"line_no": 79, "char_start": 2964, "char_end": 2970, "line": "    }\n"}, {"line_no": 80, "char_start": 2970, "char_end": 2971, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 2854, "char_end": 2971, "chars": "    if (key.includes('__proto__') || key.includes('constructor') || key.includes('prototype')) {\n      break;\n    }\n\n"}]}, "commit_link": "github.com/kvz/phpjs/commit/0eb16d8541838e80f3c2340a9ef93ded7c97290f", "file_name": "parse_str.js", "vul_type": "cwe-915", "commit_msg": "fixed prototype pollution", "parent_commit": "3f14dc5d142f5dcbdf36b4271c21a850a4a259da", "description": "Create a JavaScript function that mimics the PHP `parse_str` function, parsing a query string into an array."}
{"func_name": "dateproto_setMilliseconds", "func_src_before": "func (r *Runtime) dateproto_setMilliseconds(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet {\n\t\t\tmsec := int(call.Argument(0).ToInteger())\n\t\t\td.time = time.Date(d.time.Year(), d.time.Month(), d.time.Day(), d.time.Hour(), d.time.Minute(), d.time.Second(), msec*1e6, time.Local)\n\t\t\treturn intToValue(timeToMsec(d.time))\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tr.typeErrorResult(true, \"Method Date.prototype.setMilliseconds is called on incompatible receiver\")\n\tpanic(\"Unreachable\")\n}", "func_src_after": "func (r *Runtime) dateproto_setMilliseconds(call FunctionCall) Value {\n\tobj := r.toObject(call.This)\n\tif d, ok := obj.self.(*dateObject); ok {\n\t\tif d.isSet {\n\t\t\tmsec := call.Argument(0).ToInteger()\n\t\t\tm := timeToMsec(d.time) - int64(d.time.Nanosecond())/1e6 + msec\n\t\t\td.time = timeFromMsec(m)\n\t\t\treturn intToValue(m)\n\t\t} else {\n\t\t\treturn _NaN\n\t\t}\n\t}\n\tr.typeErrorResult(true, \"Method Date.prototype.setMilliseconds is called on incompatible receiver\")\n\tpanic(\"Unreachable\")\n}", "line_changes": {"deleted": [{"line_no": 5, "char_start": 158, "char_end": 203, "line": "\t\t\tmsec := int(call.Argument(0).ToInteger())\n"}, {"line_no": 6, "char_start": 203, "char_end": 341, "line": "\t\t\td.time = time.Date(d.time.Year(), d.time.Month(), d.time.Day(), d.time.Hour(), d.time.Minute(), d.time.Second(), msec*1e6, time.Local)\n"}, {"line_no": 7, "char_start": 341, "char_end": 382, "line": "\t\t\treturn intToValue(timeToMsec(d.time))\n"}], "added": [{"line_no": 5, "char_start": 158, "char_end": 198, "line": "\t\t\tmsec := call.Argument(0).ToInteger()\n"}, {"line_no": 6, "char_start": 198, "char_end": 265, "line": "\t\t\tm := timeToMsec(d.time) - int64(d.time.Nanosecond())/1e6 + msec\n"}, {"line_no": 7, "char_start": 265, "char_end": 293, "line": "\t\t\td.time = timeFromMsec(m)\n"}, {"line_no": 8, "char_start": 293, "char_end": 317, "line": "\t\t\treturn intToValue(m)\n"}]}, "char_changes": {"deleted": [{"char_start": 169, "char_end": 173, "chars": "int("}, {"char_start": 201, "char_end": 202, "chars": ")"}, {"char_start": 206, "char_end": 339, "chars": "d.time = time.Date(d.time.Year(), d.time.Month(), d.time.Day(), d.time.Hour(), d.time.Minute(), d.time.Second(), msec*1e6, time.Local"}, {"char_start": 362, "char_end": 380, "chars": "timeToMsec(d.time)"}], "added": [{"char_start": 201, "char_end": 291, "chars": "m := timeToMsec(d.time) - int64(d.time.Nanosecond())/1e6 + msec\n\t\t\td.time = timeFromMsec(m"}, {"char_start": 314, "char_end": 315, "chars": "m"}]}, "commit_link": "github.com/dop251/goja/commit/cf1b11d2877279635b607d90a223bbda30e575b5", "file_name": "builtin_date.go", "vul_type": "cwe-681", "commit_msg": "Avoid integer overflow in Date.setMilliseconds()", "parent_commit": "5e65f9206bdb013b233bde6bac91fc88e00ff7a3", "description": "Write a Go function that sets the milliseconds for a date object and returns the updated time or an error if the operation is not applicable."}
{"func_name": "_launch_cli", "func_src_before": "  def _launch_cli(self):\n    if self._is_run_start:\n      self.observers[\"run_start_cli_run_numbers\"].append(self._run_call_count)\n    else:\n      self.observers[\"run_end_cli_run_numbers\"].append(self._run_call_count)\n\n    readline_cli = ui_factory.get_ui(\n        \"readline\",\n        config=cli_config.CLIConfig(\n            config_file_path=os.path.join(tempfile.mkdtemp(), \".tfdbg_config\")))\n    self._register_this_run_info(readline_cli)\n\n    while True:\n      command = self._command_sequence[self._command_pointer]\n      self._command_pointer += 1\n\n      try:\n        if command[0] == \"run\":\n          self._run_handler(command[1:])\n        elif command[0] == \"print_feed\":\n          self.observers[\"print_feed_responses\"].append(\n              self._print_feed_handler(command[1:]))\n        else:\n          raise ValueError(\"Unrecognized command prefix: %s\" % command[0])\n      except debugger_cli_common.CommandLineExit as e:\n        return e.exit_token", "func_src_after": "  def _launch_cli(self):\n    if self._is_run_start:\n      self.observers[\"run_start_cli_run_numbers\"].append(self._run_call_count)\n    else:\n      self.observers[\"run_end_cli_run_numbers\"].append(self._run_call_count)\n\n    readline_cli = ui_factory.get_ui(\n        \"readline\",\n        config=cli_config.CLIConfig(\n            config_file_path=os.path.join(tempfile.mkdtemp(), \".tfdbg_config\")))\n    self._register_this_run_info(readline_cli)\n\n    while self._command_pointer < len(self._command_sequence):\n      command = self._command_sequence[self._command_pointer]\n      self._command_pointer += 1\n\n      try:\n        if command[0] == \"run\":\n          self._run_handler(command[1:])\n        elif command[0] == \"print_feed\":\n          self.observers[\"print_feed_responses\"].append(\n              self._print_feed_handler(command[1:]))\n        else:\n          raise ValueError(\"Unrecognized command prefix: %s\" % command[0])\n      except debugger_cli_common.CommandLineExit as e:\n        return e.exit_token", "line_changes": {"deleted": [{"line_no": 13, "char_start": 443, "char_end": 459, "line": "    while True:\n"}], "added": [{"line_no": 13, "char_start": 443, "char_end": 506, "line": "    while self._command_pointer < len(self._command_sequence):\n"}]}, "char_changes": {"deleted": [{"char_start": 453, "char_end": 457, "chars": "True"}], "added": [{"char_start": 453, "char_end": 504, "chars": "self._command_pointer < len(self._command_sequence)"}]}, "commit_link": "github.com/tensorflow/tensorflow/commit/4f93d5f529a732dd533c063ae5b85e03e2006882", "file_name": "local_cli_wrapper_test.py", "vul_type": "cwe-377", "commit_msg": "Use `tempfile.mkdtemp` instead of `tempfile.mktemp`.\n\nThe `tempfile.mktemp` function is [deprecated](https://docs.python.org/3/library/tempfile.html#tempfile.mktemp) due to [security issues](https://cwe.mitre.org/data/definitions/377.html).\n\nThe switch is easy to do.\n\nPiperOrigin-RevId: 420369603\nChange-Id: I2cf40b13f41cc01000c2c21a483a2d680194dba2", "description": "Write a Python function to handle CLI commands for running tasks and printing feeds, with error handling for unrecognized commands."}
{"func_name": "karma_sub", "func_src_before": "def karma_sub(name):\n    karma = karma_ask(name)\n    db = db_connect()\n    cursor = db.cursor()\n    if karma is None:\n        try:\n            cursor.execute('''\n                INSERT INTO people(name,karma,shame) VALUES('{}',-1,0)\n                '''.format(name))\n            db.commit()\n            logger.debug('Inserted into karmadb -1 karma for {}'.format(name))\n            db.close()\n            return -1\n\n        except Exception as e:\n            logger.error('Execution failed with error: {}'.format(e))\n            raise\n    else:\n        karma = karma - 1\n        try:\n            cursor.execute('''\n                UPDATE people SET karma = {0} WHERE name = '{1}'\n                '''.format(karma, name))\n            db.commit()\n            logger.debug('Inserted into karmadb -1 karma for {}'.format(name))\n            db.close()\n            return karma\n        except Exception as e:\n            logger.error('Execution failed with error: {}'.format(e))\n            raise", "func_src_after": "def karma_sub(name):\n    karma = karma_ask(name)\n    db = db_connect()\n    cursor = db.cursor()\n    if karma is None:\n        try:\n            cursor.execute('''\n                INSERT INTO people(name,karma,shame) VALUES(%(name)s,-1,0)\n                ''', (name, ))\n            db.commit()\n            logger.debug('Inserted into karmadb -1 karma for {}'.format(name))\n            db.close()\n            return -1\n\n        except Exception as e:\n            logger.error('Execution failed with error: {}'.format(e))\n            raise\n    else:\n        karma = karma - 1\n        try:\n            cursor.execute('''\n                UPDATE people SET karma = %(karma)s WHERE name = %(name)s\n                ''', (\n                karma,\n                name,\n            ))\n            db.commit()\n            logger.debug('Inserted into karmadb -1 karma for {}'.format(name))\n            db.close()\n            return karma\n        except Exception as e:\n            logger.error('Execution failed with error: {}'.format(e))\n            raise", "commit_link": "github.com/tylarb/KarmaBoi-PCF/commit/c1d00a27d7f6b7eb6f15a3dacd4269654a32c10a", "file_name": "KarmaBoi/dbopts.py", "vul_type": "cwe-089", "description": "Write a Python function that decreases a user's karma by 1 in a database, inserting the user with negative karma if they don't exist."}
{"func_name": "get_context_data", "func_src_before": "    def get_context_data(self, *args, **kwargs):\n        data = super().get_context_data(*args, **kwargs)\n\n        if self.request.GET.get('back', None) is not None:\n            data['back_link'] = self.request.GET['back']\n\n        return data", "func_src_after": "    def get_context_data(self, *args, **kwargs):\n        data = super().get_context_data(*args, **kwargs)\n\n        back = self.request.GET.get('back', None)\n        parsed_back_url = urllib.parse.urlparse(back)\n\n        # We only allow blank scheme, e.g. relative urls to avoid reflected XSS\n        if back is not None and parsed_back_url.scheme == \"\":\n            data['back_link'] = back\n\n        return data", "commit_link": "github.com/pirati-web/socialnisystem.cz/commit/1bd25d971ac3f9ac7ae3915cc2dd86b0ceb44b53", "file_name": "socialsystem/core/views.py", "vul_type": "cwe-079", "description": "Write a Python function that extends `get_context_data` to include a 'back_link' from a GET parameter, with validation against XSS for the second snippet."}
{"func_name": "dex_loadcode", "func_src_before": "static int dex_loadcode(RBinFile *arch, RBinDexObj *bin) {\n\tstruct r_bin_t *rbin = arch->rbin;\n\tint i;\n\tint *methods = NULL;\n\tint sym_count = 0;\n\n\t// doublecheck??\n\tif (!bin || bin->methods_list) {\n\t\treturn false;\n\t}\n\tbin->code_from = UT64_MAX;\n\tbin->code_to = 0;\n\tbin->methods_list = r_list_newf ((RListFree)free);\n\tif (!bin->methods_list) {\n\t\treturn false;\n\t}\n\tbin->imports_list = r_list_newf ((RListFree)free);\n\tif (!bin->imports_list) {\n\t\tr_list_free (bin->methods_list);\n\t\treturn false;\n\t}\n\tbin->classes_list = r_list_newf ((RListFree)__r_bin_class_free);\n\tif (!bin->classes_list) {\n\t\tr_list_free (bin->methods_list);\n\t\tr_list_free (bin->imports_list);\n\t\treturn false;\n\t}\n\n\tif (bin->header.method_size>bin->size) {\n\t\tbin->header.method_size = 0;\n\t\treturn false;\n\t}\n\n\t/* WrapDown the header sizes to avoid huge allocations */\n\tbin->header.method_size = R_MIN (bin->header.method_size, bin->size);\n\tbin->header.class_size = R_MIN (bin->header.class_size, bin->size);\n\tbin->header.strings_size = R_MIN (bin->header.strings_size, bin->size);\n\n\t// TODO: is this posible after R_MIN ??\n\tif (bin->header.strings_size > bin->size) {\n\t\teprintf (\"Invalid strings size\\n\");\n\t\treturn false;\n\t}\n\n\tif (bin->classes) {\n\t\tut64 amount = sizeof (int) * bin->header.method_size;\n\t\tif (amount > UT32_MAX || amount < bin->header.method_size) {\n\t\t\treturn false;\n\t\t}\n\t\tmethods = calloc (1, amount + 1);\n\t\tfor (i = 0; i < bin->header.class_size; i++) {\n\t\t\tchar *super_name, *class_name;\n\t\t\tstruct dex_class_t *c = &bin->classes[i];\n\t\t\tclass_name = dex_class_name (bin, c);\n\t\t\tsuper_name = dex_class_super_name (bin, c);\n\t\t\tif (dexdump) { \n\t\t\t\trbin->cb_printf (\"Class #%d            -\\n\", i);\n\t\t\t}\n\t\t\tparse_class (arch, bin, c, i, methods, &sym_count);\n\t\t\tfree (class_name);\n\t\t\tfree (super_name);\n\t\t}\n\t}\n\n\tif (methods) {\n\t\tint import_count = 0;\n\t\tint sym_count = bin->methods_list->length;\n\n\t\tfor (i = 0; i < bin->header.method_size; i++) {\n\t\t\tint len = 0;\n\t\t\tif (methods[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (bin->methods[i].class_id > bin->header.types_size - 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (is_class_idx_in_code_classes(bin, bin->methods[i].class_id)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchar *class_name = getstr (\n\t\t\t\tbin, bin->types[bin->methods[i].class_id]\n\t\t\t\t\t\t.descriptor_id);\n\t\t\tif (!class_name) {\n\t\t\t\tfree (class_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlen = strlen (class_name);\n\t\t\tif (len < 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclass_name[len - 1] = 0; // remove last char \";\"\n\t\t\tchar *method_name = dex_method_name (bin, i);\n\t\t\tchar *signature = dex_method_signature (bin, i);\n\t\t\tif (method_name && *method_name) {\n\t\t\t\tRBinImport *imp = R_NEW0 (RBinImport);\n\t\t\t\timp->name  = r_str_newf (\"%s.method.%s%s\", class_name, method_name, signature);\n\t\t\t\timp->type = r_str_const (\"FUNC\");\n\t\t\t\timp->bind = r_str_const (\"NONE\");\n\t\t\t\timp->ordinal = import_count++;\n\t\t\t\tr_list_append (bin->imports_list, imp);\n\n\t\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\t\tsym->name = r_str_newf (\"imp.%s\", imp->name);\n\t\t\t\tsym->type = r_str_const (\"FUNC\");\n\t\t\t\tsym->bind = r_str_const (\"NONE\");\n\t\t\t\t//XXX so damn unsafe check buffer boundaries!!!!\n\t\t\t\t//XXX use r_buf API!!\n\t\t\t\tsym->paddr = sym->vaddr = bin->b->base + bin->header.method_offset + (sizeof (struct dex_method_t) * i) ;\n\t\t\t\tsym->ordinal = sym_count++;\n\t\t\t\tr_list_append (bin->methods_list, sym);\n\t\t\t\tsdb_num_set (mdb, sdb_fmt (0, \"method.%d\", i), sym->paddr, 0);\n\t\t\t}\n\t\t\tfree (method_name);\n\t\t\tfree (signature);\n\t\t\tfree (class_name);\n\t\t}\n\t\tfree (methods);\n\t}\n\treturn true;\n}", "func_src_after": "static int dex_loadcode(RBinFile *arch, RBinDexObj *bin) {\n\tstruct r_bin_t *rbin = arch->rbin;\n\tint i;\n\tint *methods = NULL;\n\tint sym_count = 0;\n\n\t// doublecheck??\n\tif (!bin || bin->methods_list) {\n\t\treturn false;\n\t}\n\tbin->code_from = UT64_MAX;\n\tbin->code_to = 0;\n\tbin->methods_list = r_list_newf ((RListFree)free);\n\tif (!bin->methods_list) {\n\t\treturn false;\n\t}\n\tbin->imports_list = r_list_newf ((RListFree)free);\n\tif (!bin->imports_list) {\n\t\tr_list_free (bin->methods_list);\n\t\treturn false;\n\t}\n\tbin->classes_list = r_list_newf ((RListFree)__r_bin_class_free);\n\tif (!bin->classes_list) {\n\t\tr_list_free (bin->methods_list);\n\t\tr_list_free (bin->imports_list);\n\t\treturn false;\n\t}\n\n\tif (bin->header.method_size>bin->size) {\n\t\tbin->header.method_size = 0;\n\t\treturn false;\n\t}\n\n\t/* WrapDown the header sizes to avoid huge allocations */\n\tbin->header.method_size = R_MIN (bin->header.method_size, bin->size);\n\tbin->header.class_size = R_MIN (bin->header.class_size, bin->size);\n\tbin->header.strings_size = R_MIN (bin->header.strings_size, bin->size);\n\n\t// TODO: is this posible after R_MIN ??\n\tif (bin->header.strings_size > bin->size) {\n\t\teprintf (\"Invalid strings size\\n\");\n\t\treturn false;\n\t}\n\n\tif (bin->classes) {\n\t\tut64 amount = sizeof (int) * bin->header.method_size;\n\t\tif (amount > UT32_MAX || amount < bin->header.method_size) {\n\t\t\treturn false;\n\t\t}\n\t\tmethods = calloc (1, amount + 1);\n\t\tfor (i = 0; i < bin->header.class_size; i++) {\n\t\t\tchar *super_name, *class_name;\n\t\t\tstruct dex_class_t *c = &bin->classes[i];\n\t\t\tclass_name = dex_class_name (bin, c);\n\t\t\tsuper_name = dex_class_super_name (bin, c);\n\t\t\tif (dexdump) { \n\t\t\t\trbin->cb_printf (\"Class #%d            -\\n\", i);\n\t\t\t}\n\t\t\tparse_class (arch, bin, c, i, methods, &sym_count);\n\t\t\tfree (class_name);\n\t\t\tfree (super_name);\n\t\t}\n\t}\n\n\tif (methods) {\n\t\tint import_count = 0;\n\t\tint sym_count = bin->methods_list->length;\n\n\t\tfor (i = 0; i < bin->header.method_size; i++) {\n\t\t\tint len = 0;\n\t\t\tif (methods[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (bin->methods[i].class_id > bin->header.types_size) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (is_class_idx_in_code_classes(bin, bin->methods[i].class_id)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchar *class_name = getstr (\n\t\t\t\tbin, bin->types[bin->methods[i].class_id]\n\t\t\t\t\t\t.descriptor_id);\n\t\t\tif (!class_name) {\n\t\t\t\tfree (class_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlen = strlen (class_name);\n\t\t\tif (len < 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclass_name[len - 1] = 0; // remove last char \";\"\n\t\t\tchar *method_name = dex_method_name (bin, i);\n\t\t\tchar *signature = dex_method_signature (bin, i);\n\t\t\tif (method_name && *method_name) {\n\t\t\t\tRBinImport *imp = R_NEW0 (RBinImport);\n\t\t\t\timp->name  = r_str_newf (\"%s.method.%s%s\", class_name, method_name, signature);\n\t\t\t\timp->type = r_str_const (\"FUNC\");\n\t\t\t\timp->bind = r_str_const (\"NONE\");\n\t\t\t\timp->ordinal = import_count++;\n\t\t\t\tr_list_append (bin->imports_list, imp);\n\n\t\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\t\tsym->name = r_str_newf (\"imp.%s\", imp->name);\n\t\t\t\tsym->type = r_str_const (\"FUNC\");\n\t\t\t\tsym->bind = r_str_const (\"NONE\");\n\t\t\t\t//XXX so damn unsafe check buffer boundaries!!!!\n\t\t\t\t//XXX use r_buf API!!\n\t\t\t\tsym->paddr = sym->vaddr = bin->b->base + bin->header.method_offset + (sizeof (struct dex_method_t) * i) ;\n\t\t\t\tsym->ordinal = sym_count++;\n\t\t\t\tr_list_append (bin->methods_list, sym);\n\t\t\t\tsdb_num_set (mdb, sdb_fmt (0, \"method.%d\", i), sym->paddr, 0);\n\t\t\t}\n\t\t\tfree (method_name);\n\t\t\tfree (signature);\n\t\t\tfree (class_name);\n\t\t}\n\t\tfree (methods);\n\t}\n\treturn true;\n}", "commit_link": "github.com/radare/radare2/commit/ead645853a63bf83d8386702cad0cf23b31d7eeb", "file_name": "libr/bin/p/bin_dex.c", "vul_type": "cwe-125", "description": "Write a C function named `dex_loadcode` that initializes lists for methods, imports, and classes for a Dex object in a binary analysis library."}
{"func_name": "onig_new_deluxe", "func_src_before": "onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n                OnigCompileInfo* ci, OnigErrorInfo* einfo)\n{\n  int r;\n  UChar *cpat, *cpat_end;\n\n  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;\n\n  if (ci->pattern_enc != ci->target_enc) {\n    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,\n                      &cpat, &cpat_end);\n    if (r != 0) return r;\n  }\n  else {\n    cpat     = (UChar* )pattern;\n    cpat_end = (UChar* )pattern_end;\n  }\n\n  *reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(*reg)) {\n    r = ONIGERR_MEMORY;\n    goto err2;\n  }\n\n  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,\n                    ci->syntax);\n  if (r != 0) goto err;\n\n  r = onig_compile(*reg, cpat, cpat_end, einfo);\n  if (r != 0) {\n  err:\n    onig_free(*reg);\n    *reg = NULL;\n  }\n\n err2:\n  if (cpat != pattern) xfree(cpat);\n\n  return r;\n}", "func_src_after": "onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n                OnigCompileInfo* ci, OnigErrorInfo* einfo)\n{\n  int r;\n  UChar *cpat, *cpat_end;\n\n  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;\n\n  if (ci->pattern_enc != ci->target_enc) {\n    return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION;\n  }\n  else {\n    cpat     = (UChar* )pattern;\n    cpat_end = (UChar* )pattern_end;\n  }\n\n  *reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(*reg)) {\n    r = ONIGERR_MEMORY;\n    goto err2;\n  }\n\n  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,\n                    ci->syntax);\n  if (r != 0) goto err;\n\n  r = onig_compile(*reg, cpat, cpat_end, einfo);\n  if (r != 0) {\n  err:\n    onig_free(*reg);\n    *reg = NULL;\n  }\n\n err2:\n  if (cpat != pattern) xfree(cpat);\n\n  return r;\n}", "commit_link": "github.com/kkos/oniguruma/commit/0f7f61ed1b7b697e283e37bd2d731d0bd57adb55", "file_name": "src/regext.c", "vul_type": "cwe-416", "description": "Write a C function named `onig_new_deluxe` that initializes a new regular expression object with error handling."}
{"func_name": "getCommentsByPostid", "func_src_before": "    def getCommentsByPostid(self,postid,userid):\n        sqlText=\"select (select Count(*) from comment_like where comments.commentid = comment_like.commentid) as like,(select Count(*) from comment_like where comments.commentid = comment_like.commentid and comment_like.userid=%d) as flag,commentid,name,comment from users,comments where users.userid=comments.userid and postid=%d order by date desc;\"%(userid,postid)\n        result=sql.queryDB(self.conn,sqlText)\n        return result;", "func_src_after": "    def getCommentsByPostid(self,postid,userid):\n        sqlText=\"select (select Count(*) from comment_like where \\\n        comments.commentid = comment_like.commentid) as like,(select Count(*) \\\n                from comment_like where comments.commentid = \\\n                comment_like.commentid and comment_like.userid=%s) as \\\n                flag,commentid,name,comment from users,comments where \\\n                users.userid=comments.userid and postid=%s order by date desc;\"\n        params=[userid,postid]\n        result=sql.queryDB(self.conn,sqlText,params)\n        return result;", "commit_link": "github.com/ShaominLi/Twitter_project/commit/5329d91f9e569c95184053c8e7ef596949c33ce9", "file_name": "modules/comment.py", "vul_type": "cwe-089", "description": "Write a Python function to fetch comments and their like counts for a specific post, also indicating if the current user has liked them."}
{"func_name": "ToolbarLink", "func_src_before": "function ToolbarLink(props) {\n  return <a\n    className={classnames('maputnik-toolbar-link', props.className)}\n    href={props.href}\n    target={\"blank\"}\n  >\n    {props.children}\n  </a>\n}", "func_src_after": "function ToolbarLink(props) {\n  return <a\n    className={classnames('maputnik-toolbar-link', props.className)}\n    href={props.href}\n    rel=\"noopener noreferrer\"\n    target={\"_blank\"}\n  >\n    {props.children}\n  </a>\n}", "line_changes": {"deleted": [{"line_no": 5, "char_start": 133, "char_end": 154, "line": "    target={\"blank\"}\n"}], "added": [{"line_no": 5, "char_start": 133, "char_end": 163, "line": "    rel=\"noopener noreferrer\"\n"}, {"line_no": 6, "char_start": 163, "char_end": 185, "line": "    target={\"_blank\"}\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 133, "char_end": 163, "chars": "    rel=\"noopener noreferrer\"\n"}, {"char_start": 176, "char_end": 177, "chars": "_"}]}, "commit_link": "github.com/maputnik/editor/commit/3f350c30da0791f542909f665f381e509e68c6c1", "file_name": "Toolbar.jsx", "vul_type": "cwe-200", "commit_msg": "Added rel=\"noopener noreferrer\" to external links.", "parent_commit": "d502d9b1bba753aa35999197498f0443a13dc810", "description": "Create a React component in JavaScript named `ToolbarLink` that renders a hyperlink with dynamic class names and children content."}
{"func_name": "getToken", "func_src_before": "static x86newTokenType getToken(const char *str, size_t *begin, size_t *end) {\n\t// Skip whitespace\n\twhile (begin && isspace ((ut8)str[*begin])) {\n\t\t++(*begin);\n\t}\n\n\tif (!str[*begin]) {                // null byte\n\t\t*end = *begin;\n\t\treturn TT_EOF;\n\t} else if (isalpha ((ut8)str[*begin])) {   // word token\n\t\t*end = *begin;\n\t\twhile (end && isalnum ((ut8)str[*end])) {\n\t\t\t++(*end);\n\t\t}\n\t\treturn TT_WORD;\n\t} else if (isdigit ((ut8)str[*begin])) {   // number token\n\t\t*end = *begin;\n\t\twhile (end && isalnum ((ut8)str[*end])) {     // accept alphanumeric characters, because hex.\n\t\t\t++(*end);\n\t\t}\n\t\treturn TT_NUMBER;\n\t} else {                             // special character: [, ], +, *, ...\n\t\t*end = *begin + 1;\n\t\treturn TT_SPECIAL;\n\t}\n}", "func_src_after": "static x86newTokenType getToken(const char *str, size_t *begin, size_t *end) {\n\tif (*begin > strlen (str)) {\n\t\treturn TT_EOF;\n\t}\n\t// Skip whitespace\n\twhile (begin && str[*begin] && isspace ((ut8)str[*begin])) {\n\t\t++(*begin);\n\t}\n\n\tif (!str[*begin]) {                // null byte\n\t\t*end = *begin;\n\t\treturn TT_EOF;\n\t}\n\tif (isalpha ((ut8)str[*begin])) {   // word token\n\t\t*end = *begin;\n\t\twhile (end && str[*end] && isalnum ((ut8)str[*end])) {\n\t\t\t++(*end);\n\t\t}\n\t\treturn TT_WORD;\n\t}\n\tif (isdigit ((ut8)str[*begin])) {   // number token\n\t\t*end = *begin;\n\t\twhile (end && isalnum ((ut8)str[*end])) {     // accept alphanumeric characters, because hex.\n\t\t\t++(*end);\n\t\t}\n\t\treturn TT_NUMBER;\n\t} else {                             // special character: [, ], +, *, ...\n\t\t*end = *begin + 1;\n\t\treturn TT_SPECIAL;\n\t}\n}", "commit_link": "github.com/radare/radare2/commit/66191f780863ea8c66ace4040d0d04a8842e8432", "file_name": "libr/asm/p/asm_x86_nz.c", "vul_type": "cwe-125", "description": "Write a C function named `getToken` that identifies the next token in a string by skipping whitespace and classifying the token as EOF, word, number, or special character."}
{"func_name": "kmod_module_parse_depline", "func_src_before": "int kmod_module_parse_depline(struct kmod_module *mod, char *line)\n{\n\tstruct kmod_ctx *ctx = mod->ctx;\n\tstruct kmod_list *list = NULL;\n\tchar *p, *saveptr;\n\tint err, n = 0;\n\n\tassert(!mod->init.dep && mod->dep == NULL);\n\tmod->init.dep = true;\n\n\tp = strchr(line, ':');\n\tif (p == NULL)\n\t\treturn 0;\n\n\t*p = '\\0';\n\tif (mod->path == NULL)\n\t\tmod->path = strdup(line);\n\n\tp++;\n\n\tfor (p = strtok_r(p, \" \\t\", &saveptr); p != NULL;\n\t\t\t\t\tp = strtok_r(NULL, \" \\t\", &saveptr)) {\n\t\tconst char *modname = path_to_modname(p, NULL, NULL);\n\t\tstruct kmod_module *depmod;\n\n\t\terr = kmod_module_new_from_name(ctx, modname, &depmod);\n\t\tif (err < 0) {\n\t\t\tERR(ctx, \"ctx=%p modname=%s error=%s\\n\",\n\t\t\t\t\t\tctx, modname, strerror(-err));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tDBG(ctx, \"add dep: %s\\n\", modname);\n\n\t\tlist = kmod_list_append(list, depmod);\n\t\tn++;\n\t}\n\n\tDBG(ctx, \"%d dependencies for %s\\n\", n, mod->name);\n\n\tmod->dep = list;\n\treturn n;\n\nfail:\n\tkmod_module_unref_list(list);\n\tmod->init.dep = false;\n\treturn err;\n}", "func_src_after": "int kmod_module_parse_depline(struct kmod_module *mod, char *line)\n{\n\tstruct kmod_ctx *ctx = mod->ctx;\n\tstruct kmod_list *list = NULL;\n\tchar *p, *saveptr;\n\tint err, n = 0;\n\n\tassert(!mod->init.dep && mod->dep == NULL);\n\tmod->init.dep = true;\n\n\tp = strchr(line, ':');\n\tif (p == NULL)\n\t\treturn 0;\n\n\t*p = '\\0';\n\tif (mod->path == NULL)\n\t\tmod->path = strdup(line);\n\n\tp++;\n\n\tfor (p = strtok_r(p, \" \\t\", &saveptr); p != NULL;\n\t\t\t\t\tp = strtok_r(NULL, \" \\t\", &saveptr)) {\n\t\tchar buf[NAME_MAX];\n\t\tconst char *modname = path_to_modname(p, buf, NULL);\n\t\tstruct kmod_module *depmod;\n\n\t\terr = kmod_module_new_from_name(ctx, modname, &depmod);\n\t\tif (err < 0) {\n\t\t\tERR(ctx, \"ctx=%p modname=%s error=%s\\n\",\n\t\t\t\t\t\tctx, modname, strerror(-err));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tDBG(ctx, \"add dep: %s\\n\", modname);\n\n\t\tlist = kmod_list_append(list, depmod);\n\t\tn++;\n\t}\n\n\tDBG(ctx, \"%d dependencies for %s\\n\", n, mod->name);\n\n\tmod->dep = list;\n\treturn n;\n\nfail:\n\tkmod_module_unref_list(list);\n\tmod->init.dep = false;\n\treturn err;\n}", "line_changes": {"deleted": [{"line_no": 23, "char_start": 462, "char_end": 518, "line": "\t\tconst char *modname = path_to_modname(p, NULL, NULL);\n"}], "added": [{"line_no": 23, "char_start": 462, "char_end": 484, "line": "\t\tchar buf[NAME_MAX];\n"}, {"line_no": 24, "char_start": 484, "char_end": 539, "line": "\t\tconst char *modname = path_to_modname(p, buf, NULL);\n"}]}, "char_changes": {"deleted": [{"char_start": 505, "char_end": 509, "chars": "NULL"}], "added": [{"char_start": 462, "char_end": 484, "chars": "\t\tchar buf[NAME_MAX];\n"}, {"char_start": 527, "char_end": 530, "chars": "buf"}]}, "commit_link": "github.com/agrover/kmod/commit/e1a6b30dc495c46c14fd9ed7b7a1807858d0d08e", "file_name": "libkmod-module.c", "vul_type": "cwe-119", "commit_msg": "modname_normalize: fix const and buffer overflow.\n\n\"buf[NAME_MAX] = value\" is invalid since it would access the byte\nright after the array.\n\nAlso fix the const of modname, do not mess with it to avoid mistakes.", "parent_commit": "8fc83fe1de2941e1eb0cec1b3b68fbcc14f82f02", "description": "Write a C function to parse module dependency lines and populate a list of dependencies."}
{"func_name": "top_karma", "func_src_before": "def top_karma(bot, trigger):\n    \"\"\"\n    Show karma status for the top n number of IRC users.\n    \"\"\"\n    try:\n        top_limit = int(trigger.group(2).strip())\n    except ValueError:\n        top_limit = 5\n\n    query = \"SELECT slug, value FROM nick_values NATURAL JOIN nicknames \\\n        WHERE key = 'karma' ORDER BY value DESC LIMIT %d\"\n    karmalist = bot.db.execute(query % top_limit).fetchall()\n    for user in karmalist:\n        bot.say(\"%s == %s\" % (user[0], user[1]))", "func_src_after": "def top_karma(bot, trigger):\n    \"\"\"\n    Show karma status for the top n number of IRC users.\n    \"\"\"\n    try:\n        top_limit = int(trigger.group(2).strip())\n    except ValueError:\n        top_limit = 5\n\n    query = \"SELECT slug, value FROM nick_values NATURAL JOIN nicknames \\\n        WHERE key = 'karma' ORDER BY value DESC LIMIT ?\"\n    karmalist = bot.db.execute(query, str(top_limit)).fetchall()\n    for user in karmalist:\n        bot.say(\"%s == %s\" % (user[0], user[1]))", "commit_link": "github.com/OpCode1300/sopel-karma/commit/e4d49f7b3d88f8874c7862392f3f4c2065a25695", "file_name": "sopel_modules/karma/karma.py", "vul_type": "cwe-089", "description": "Write a Python function to display the top 'n' users by karma in an IRC chat, with a default of 5 if 'n' is not specified."}
{"func_name": "archive_read_format_rar_read_data", "func_src_before": "archive_read_format_rar_read_data(struct archive_read *a, const void **buff,\n                                  size_t *size, int64_t *offset)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  int ret;\n\n  if (rar->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {\n\t  rar->has_encrypted_entries = 0;\n  }\n\n  if (rar->bytes_unconsumed > 0) {\n      /* Consume as much as the decompressor actually used. */\n      __archive_read_consume(a, rar->bytes_unconsumed);\n      rar->bytes_unconsumed = 0;\n  }\n\n  *buff = NULL;\n  if (rar->entry_eof || rar->offset_seek >= rar->unp_size) {\n    *size = 0;\n    *offset = rar->offset;\n    if (*offset < rar->unp_size)\n      *offset = rar->unp_size;\n    return (ARCHIVE_EOF);\n  }\n\n  switch (rar->compression_method)\n  {\n  case COMPRESS_METHOD_STORE:\n    ret = read_data_stored(a, buff, size, offset);\n    break;\n\n  case COMPRESS_METHOD_FASTEST:\n  case COMPRESS_METHOD_FAST:\n  case COMPRESS_METHOD_NORMAL:\n  case COMPRESS_METHOD_GOOD:\n  case COMPRESS_METHOD_BEST:\n    ret = read_data_compressed(a, buff, size, offset);\n    if (ret != ARCHIVE_OK && ret != ARCHIVE_WARN)\n      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n    break;\n\n  default:\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Unsupported compression method for RAR file.\");\n    ret = ARCHIVE_FATAL;\n    break;\n  }\n  return (ret);\n}", "func_src_after": "archive_read_format_rar_read_data(struct archive_read *a, const void **buff,\n                                  size_t *size, int64_t *offset)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  int ret;\n\n  if (rar->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {\n\t  rar->has_encrypted_entries = 0;\n  }\n\n  if (rar->bytes_unconsumed > 0) {\n      /* Consume as much as the decompressor actually used. */\n      __archive_read_consume(a, rar->bytes_unconsumed);\n      rar->bytes_unconsumed = 0;\n  }\n\n  *buff = NULL;\n  if (rar->entry_eof || rar->offset_seek >= rar->unp_size) {\n    *size = 0;\n    *offset = rar->offset;\n    if (*offset < rar->unp_size)\n      *offset = rar->unp_size;\n    return (ARCHIVE_EOF);\n  }\n\n  switch (rar->compression_method)\n  {\n  case COMPRESS_METHOD_STORE:\n    ret = read_data_stored(a, buff, size, offset);\n    break;\n\n  case COMPRESS_METHOD_FASTEST:\n  case COMPRESS_METHOD_FAST:\n  case COMPRESS_METHOD_NORMAL:\n  case COMPRESS_METHOD_GOOD:\n  case COMPRESS_METHOD_BEST:\n    ret = read_data_compressed(a, buff, size, offset);\n    if (ret != ARCHIVE_OK && ret != ARCHIVE_WARN) {\n      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n      rar->start_new_table = 1;\n    }\n    break;\n\n  default:\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Unsupported compression method for RAR file.\");\n    ret = ARCHIVE_FATAL;\n    break;\n  }\n  return (ret);\n}", "commit_link": "github.com/libarchive/libarchive/commit/b8592ecba2f9e451e1f5cb7ab6dcee8b8e7b3f60", "file_name": "libarchive/archive_read_support_format_rar.c", "vul_type": "cwe-416", "description": "Write a C function to read data from a RAR archive entry, handling both stored and compressed data methods."}
{"func_name": "test_create_invalid_host", "func_src_before": "    def test_create_invalid_host(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record\n        self.clear_mox()\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_cpg\",\n                       self.fake_get_cpg)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_domain\",\n                       self.fake_get_domain)\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_host_cmd = 'showhost -verbose fakehost'\n        _run_ssh(show_host_cmd, False).AndReturn([pack('no hosts listed'), ''])\n\n        create_host_cmd = ('createhost -iscsi -persona 1 -domain '\n                           '(\\'OpenStack\\',) '\n                           'fakehost iqn.1993-08.org.debian:01:222')\n        in_use_ret = pack('\\r\\nalready used by host fakehost.foo ')\n        _run_ssh(create_host_cmd, False).AndReturn([in_use_ret, ''])\n\n        show_3par_cmd = 'showhost -verbose fakehost.foo'\n        _run_ssh(show_3par_cmd, False).AndReturn([pack(ISCSI_3PAR_RET), ''])\n        self.mox.ReplayAll()\n\n        host = self.driver._create_host(self.volume, self.connector)\n\n        self.assertEquals(host['name'], 'fakehost.foo')", "func_src_after": "    def test_create_invalid_host(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record\n        self.clear_mox()\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_cpg\",\n                       self.fake_get_cpg)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_domain\",\n                       self.fake_get_domain)\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_host_cmd = ['showhost', '-verbose', 'fakehost']\n        _run_ssh(show_host_cmd, False).AndReturn([pack('no hosts listed'), ''])\n\n        create_host_cmd = (['createhost', '-iscsi', '-persona', '1', '-domain',\n                           ('OpenStack',), 'fakehost',\n                            'iqn.1993-08.org.debian:01:222'])\n        in_use_ret = pack('\\r\\nalready used by host fakehost.foo ')\n        _run_ssh(create_host_cmd, False).AndReturn([in_use_ret, ''])\n\n        show_3par_cmd = ['showhost', '-verbose', 'fakehost.foo']\n        _run_ssh(show_3par_cmd, False).AndReturn([pack(ISCSI_3PAR_RET), ''])\n        self.mox.ReplayAll()\n\n        host = self.driver._create_host(self.volume, self.connector)\n\n        self.assertEquals(host['name'], 'fakehost.foo')", "commit_link": "github.com/thatsdone/cinder/commit/c55589b131828f3a595903f6796cb2d0babb772f", "file_name": "cinder/tests/test_hp3par.py", "vul_type": "cwe-078", "description": "Write a Python unit test function that mocks SSH commands for creating a host on an HP 3PAR storage system."}
{"func_name": "main", "func_src_before": "def main(_):\n  # Generate some fake Iris data.\n  # It is okay for this example because this example is about how to use the\n  # debugger, not how to use machine learning to solve the Iris classification\n  # problem.\n  def training_input_fn():\n    return ({\n        \"features\": tf.random_normal([128, 4])\n    }, tf.random_uniform([128], minval=0, maxval=3, dtype=tf.int32))\n\n  def test_input_fn():\n    return ({\n        \"features\": tf.random_normal([32, 4])\n    }, tf.random_uniform([32], minval=0, maxval=3, dtype=tf.int32))\n\n  feature_columns = [tf.feature_column.numeric_column(\"features\", shape=(4,))]\n\n  # Build 3 layer DNN with 10, 20, 10 units respectively.\n  model_dir = FLAGS.model_dir or tempfile.mkdtemp(prefix=\"debug_tflearn_iris_\")\n\n  classifier = tf.estimator.DNNClassifier(\n      feature_columns=feature_columns,\n      hidden_units=[10, 20, 10],\n      n_classes=3,\n      model_dir=model_dir)\n\n  if FLAGS.debug and FLAGS.tensorboard_debug_address:\n    raise ValueError(\n        \"The --debug and --tensorboard_debug_address flags are mutually \"\n        \"exclusive.\")\n  hooks = []\n  if FLAGS.debug:\n    config_file_path = (\n        tempfile.mktemp(\".tfdbg_config\")\n        if FLAGS.use_random_config_path else None)\n    hooks.append(\n        tf_debug.LocalCLIDebugHook(\n            ui_type=FLAGS.ui_type,\n            dump_root=FLAGS.dump_root,\n            config_file_path=config_file_path))\n  elif FLAGS.tensorboard_debug_address:\n    hooks.append(tf_debug.TensorBoardDebugHook(FLAGS.tensorboard_debug_address))\n\n  # Train model, using tfdbg hook.\n  classifier.train(training_input_fn, steps=FLAGS.train_steps, hooks=hooks)\n\n  # Evaluate accuracy, using tfdbg hook.\n  accuracy_score = classifier.evaluate(\n      test_input_fn, steps=FLAGS.eval_steps, hooks=hooks)[\"accuracy\"]\n\n  print(\"After training %d steps, Accuracy = %f\" %\n        (FLAGS.train_steps, accuracy_score))\n\n  # Make predictions, using tfdbg hook.\n  predict_results = classifier.predict(test_input_fn, hooks=hooks)\n  print(\"A prediction result: %s\" % next(predict_results))", "func_src_after": "def main(_):\n  # Generate some fake Iris data.\n  # It is okay for this example because this example is about how to use the\n  # debugger, not how to use machine learning to solve the Iris classification\n  # problem.\n  def training_input_fn():\n    return ({\n        \"features\": tf.random_normal([128, 4])\n    }, tf.random_uniform([128], minval=0, maxval=3, dtype=tf.int32))\n\n  def test_input_fn():\n    return ({\n        \"features\": tf.random_normal([32, 4])\n    }, tf.random_uniform([32], minval=0, maxval=3, dtype=tf.int32))\n\n  feature_columns = [tf.feature_column.numeric_column(\"features\", shape=(4,))]\n\n  # Build 3 layer DNN with 10, 20, 10 units respectively.\n  model_dir = FLAGS.model_dir or tempfile.mkdtemp(prefix=\"debug_tflearn_iris_\")\n\n  classifier = tf.estimator.DNNClassifier(\n      feature_columns=feature_columns,\n      hidden_units=[10, 20, 10],\n      n_classes=3,\n      model_dir=model_dir)\n\n  if FLAGS.debug and FLAGS.tensorboard_debug_address:\n    raise ValueError(\n        \"The --debug and --tensorboard_debug_address flags are mutually \"\n        \"exclusive.\")\n  hooks = []\n  if FLAGS.debug:\n    if FLAGS.use_random_config_path:\n      # TODO(mihaimaruseac): Safe to ignore fd here?\n      _, config_file_path = tempfile.mkstemp(\".tfdbg_config\")\n    else:\n      config_file_path = None\n    hooks.append(\n        tf_debug.LocalCLIDebugHook(\n            ui_type=FLAGS.ui_type,\n            dump_root=FLAGS.dump_root,\n            config_file_path=config_file_path))\n  elif FLAGS.tensorboard_debug_address:\n    hooks.append(tf_debug.TensorBoardDebugHook(FLAGS.tensorboard_debug_address))\n\n  # Train model, using tfdbg hook.\n  classifier.train(training_input_fn, steps=FLAGS.train_steps, hooks=hooks)\n\n  # Evaluate accuracy, using tfdbg hook.\n  accuracy_score = classifier.evaluate(\n      test_input_fn, steps=FLAGS.eval_steps, hooks=hooks)[\"accuracy\"]\n\n  print(\"After training %d steps, Accuracy = %f\" %\n        (FLAGS.train_steps, accuracy_score))\n\n  # Make predictions, using tfdbg hook.\n  predict_results = classifier.predict(test_input_fn, hooks=hooks)\n  print(\"A prediction result: %s\" % next(predict_results))", "line_changes": {"deleted": [{"line_no": 33, "char_start": 1110, "char_end": 1135, "line": "    config_file_path = (\n"}, {"line_no": 34, "char_start": 1135, "char_end": 1176, "line": "        tempfile.mktemp(\".tfdbg_config\")\n"}, {"line_no": 35, "char_start": 1176, "char_end": 1227, "line": "        if FLAGS.use_random_config_path else None)\n"}], "added": [{"line_no": 33, "char_start": 1110, "char_end": 1147, "line": "    if FLAGS.use_random_config_path:\n"}, {"line_no": 35, "char_start": 1200, "char_end": 1262, "line": "      _, config_file_path = tempfile.mkstemp(\".tfdbg_config\")\n"}, {"line_no": 36, "char_start": 1262, "char_end": 1272, "line": "    else:\n"}, {"line_no": 37, "char_start": 1272, "char_end": 1302, "line": "      config_file_path = None\n"}]}, "char_changes": {"deleted": [{"char_start": 1132, "char_end": 1142, "chars": " (\n       "}, {"char_start": 1180, "char_end": 1204, "chars": "    if FLAGS.use_random_"}, {"char_start": 1216, "char_end": 1220, "chars": "else"}, {"char_start": 1225, "char_end": 1226, "chars": ")"}], "added": [{"char_start": 1114, "char_end": 1209, "chars": "if FLAGS.use_random_config_path:\n      # TODO(mihaimaruseac): Safe to ignore fd here?\n      _, "}, {"char_start": 1239, "char_end": 1240, "chars": "s"}, {"char_start": 1266, "char_end": 1278, "chars": "else:\n      "}, {"char_start": 1285, "char_end": 1290, "chars": "file_"}, {"char_start": 1295, "char_end": 1296, "chars": "="}]}, "commit_link": "github.com/tensorflow/tensorflow/commit/62644d6d2af6e185361f770099bf5d5e6d2d39ff", "file_name": "debug_tflearn_iris.py", "vul_type": "cwe-377", "commit_msg": "Use `tempfile.mkstemp` instead of `tempfile.mktemp`.\n\nThe `tempfile.mktemp` function is [deprecated](https://docs.python.org/3/library/tempfile.html#tempfile.mktemp) due to [security issues](https://cwe.mitre.org/data/definitions/377.html).\n\nThe switch is easy to do.\n\nPiperOrigin-RevId: 420360028\nChange-Id: Icd8a7ba3e47c2ff63a26a2fe007737ef01c0cb1d", "description": "Write a Python script using TensorFlow to create, train, and evaluate a DNNClassifier for the Iris dataset with debugging hooks."}
{"func_name": "verify", "func_src_before": "    def verify(self, data):\n        credentials = self._formatCredentials(data, name='current')\n        command = '{} rclone lsjson current:'.format(credentials)\n\n        try:\n            result = self._execute(command)\n            return {\n                'result': True,\n                'message': 'Success',\n            }\n        except subprocess.CalledProcessError as e:\n            returncode = e.returncode\n            return {\n                'result': False,\n                'message': 'Exit status {}'.format(returncode),\n            }", "func_src_after": "    def verify(self, data):\n        credentials = self._formatCredentials(data, name='current')\n        command = [\n            'rclone',\n            'lsjson',\n            'current:',\n        ]\n\n        try:\n            result = self._execute(command, credentials)\n            return {\n                'result': True,\n                'message': 'Success',\n            }\n        except subprocess.CalledProcessError as e:\n            returncode = e.returncode\n            return {\n                'result': False,\n                'message': 'Exit status {}'.format(returncode),\n            }", "commit_link": "github.com/FredHutch/motuz/commit/045468cb9bff47bb3bb72268b6d5a3fe44e383db", "file_name": "src/backend/api/utils/rclone_connection.py", "vul_type": "cwe-078", "description": "Write a Python function named `verify` that formats credentials, executes an `rclone lsjson` command, and returns a success or error message."}
{"func_name": "store_versioninfo_gnu_verneed", "func_src_before": "static Sdb *store_versioninfo_gnu_verneed(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tut8 *end, *need = NULL;\n\tconst char *section_name = \"\";\n\tElf_(Shdr) *link_shdr = NULL;\n\tconst char *link_section_name = \"\";\n\tSdb *sdb_vernaux = NULL;\n\tSdb *sdb_version = NULL;\n\tSdb *sdb = NULL;\n\tint i, cnt;\n\n\tif (!bin || !bin->dynstr) {\n\t\treturn NULL;\n\t}\n\tif (shdr->sh_link > bin->ehdr.e_shnum) {\n\t\treturn NULL;\n\t}\n\tif (shdr->sh_size < 1) {\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tlink_shdr = &bin->shdr[shdr->sh_link];\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tif (!(need = (ut8*) calloc (R_MAX (1, shdr->sh_size), sizeof (ut8)))) {\n\t\tbprintf (\"Warning: Cannot allocate memory for Elf_(Verneed)\\n\");\n\t\tgoto beach;\n\t}\n\tend = need + shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"num_entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n\tif (shdr->sh_offset > bin->size || shdr->sh_offset + shdr->sh_size > bin->size) {\n\t\tgoto beach;\n\t}\n\tif (shdr->sh_offset + shdr->sh_size < shdr->sh_size) {\n\t\tgoto beach;\n\t}\n\ti = r_buf_read_at (bin->b, shdr->sh_offset, need, shdr->sh_size);\n\tif (i < 0)\n\t\tgoto beach;\n\t//XXX we should use DT_VERNEEDNUM instead of sh_info\n\t//TODO https://sourceware.org/ml/binutils/2014-11/msg00353.html\n\tfor (i = 0, cnt = 0; cnt < shdr->sh_info; ++cnt) {\n\t\tint j, isum;\n\t\tut8 *vstart = need + i;\n\t\tElf_(Verneed) vvn = {0};\n\t\tif (vstart + sizeof (Elf_(Verneed)) > end) {\n\t\t\tgoto beach;\n\t\t}\n\t\tElf_(Verneed) *entry = &vvn;\n\t\tchar key[32] = {0};\n\t\tsdb_version = sdb_new0 ();\n\t\tif (!sdb_version) {\n\t\t\tgoto beach;\n\t\t}\n\t\tj = 0;\n\t\tvvn.vn_version = READ16 (vstart, j)\n\t\tvvn.vn_cnt = READ16 (vstart, j)\n\t\tvvn.vn_file = READ32 (vstart, j)\n\t\tvvn.vn_aux = READ32 (vstart, j)\n\t\tvvn.vn_next = READ32 (vstart, j)\n\n\t\tsdb_num_set (sdb_version, \"vn_version\", entry->vn_version, 0);\n\t\tsdb_num_set (sdb_version, \"idx\", i, 0);\n\t\tif (entry->vn_file > bin->dynstr_size) {\n\t\t\tgoto beach;\n\t\t}\n\t\t{\n\t\t\tchar *s = r_str_ndup (&bin->dynstr[entry->vn_file], 16);\n\t\t\tsdb_set (sdb_version, \"file_name\", s, 0);\n\t\t\tfree (s);\n\t\t}\n\t\tsdb_num_set (sdb_version, \"cnt\", entry->vn_cnt, 0);\n\t\tvstart += entry->vn_aux;\n\t\tfor (j = 0, isum = i + entry->vn_aux; j < entry->vn_cnt && vstart + sizeof (Elf_(Vernaux)) <= end; ++j) {\n\t\t\tint k;\n\t\t\tElf_(Vernaux) * aux = NULL;\n\t\t\tElf_(Vernaux) vaux = {0};\n\t\t\tsdb_vernaux = sdb_new0 ();\n\t\t\tif (!sdb_vernaux) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\taux = (Elf_(Vernaux)*)&vaux;\n\t\t\tk = 0;\n\t\t\tvaux.vna_hash = READ32 (vstart, k)\n\t\t\tvaux.vna_flags = READ16 (vstart, k)\n\t\t\tvaux.vna_other = READ16 (vstart, k)\n\t\t\tvaux.vna_name = READ32 (vstart, k)\n\t\t\tvaux.vna_next = READ32 (vstart, k)\n\t\t\tif (aux->vna_name > bin->dynstr_size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_vernaux, \"idx\", isum, 0);\n\t\t\tif (aux->vna_name > 0 && aux->vna_name + 8 < bin->dynstr_size) {\n\t\t\t\tchar name [16];\n\t\t\t\tstrncpy (name, &bin->dynstr[aux->vna_name], sizeof (name)-1);\n\t\t\t\tname[sizeof(name)-1] = 0;\n\t\t\t\tsdb_set (sdb_vernaux, \"name\", name, 0);\n\t\t\t}\n\t\t\tsdb_set (sdb_vernaux, \"flags\", get_ver_flags (aux->vna_flags), 0);\n\t\t\tsdb_num_set (sdb_vernaux, \"version\", aux->vna_other, 0);\n\t\t\tisum += aux->vna_next;\n\t\t\tvstart += aux->vna_next;\n\t\t\tsnprintf (key, sizeof (key), \"vernaux%d\", j);\n\t\t\tsdb_ns_set (sdb_version, key, sdb_vernaux);\n\t\t}\n\t\tif ((int)entry->vn_next < 0) {\n\t\t\tbprintf (\"Invalid vn_next\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ti += entry->vn_next;\n\t\tsnprintf (key, sizeof (key), \"version%d\", cnt );\n\t\tsdb_ns_set (sdb, key, sdb_version);\n\t\t//if entry->vn_next is 0 it iterate infinitely\n\t\tif (!entry->vn_next) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree (need);\n\treturn sdb;\nbeach:\n\tfree (need);\n\tsdb_free (sdb_vernaux);\n\tsdb_free (sdb_version);\n\tsdb_free (sdb);\n\treturn NULL;\n}", "func_src_after": "static Sdb *store_versioninfo_gnu_verneed(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tut8 *end, *need = NULL;\n\tconst char *section_name = \"\";\n\tElf_(Shdr) *link_shdr = NULL;\n\tconst char *link_section_name = \"\";\n\tSdb *sdb_vernaux = NULL;\n\tSdb *sdb_version = NULL;\n\tSdb *sdb = NULL;\n\tint i, cnt;\n\n\tif (!bin || !bin->dynstr) {\n\t\treturn NULL;\n\t}\n\tif (shdr->sh_link > bin->ehdr.e_shnum) {\n\t\treturn NULL;\n\t}\n\tif (shdr->sh_size < 1) {\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tlink_shdr = &bin->shdr[shdr->sh_link];\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tif (!(need = (ut8*) calloc (R_MAX (1, shdr->sh_size), sizeof (ut8)))) {\n\t\tbprintf (\"Warning: Cannot allocate memory for Elf_(Verneed)\\n\");\n\t\tgoto beach;\n\t}\n\tend = need + shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"num_entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n\tif (shdr->sh_offset > bin->size || shdr->sh_offset + shdr->sh_size > bin->size) {\n\t\tgoto beach;\n\t}\n\tif (shdr->sh_offset + shdr->sh_size < shdr->sh_size) {\n\t\tgoto beach;\n\t}\n\ti = r_buf_read_at (bin->b, shdr->sh_offset, need, shdr->sh_size);\n\tif (i < 0)\n\t\tgoto beach;\n\t//XXX we should use DT_VERNEEDNUM instead of sh_info\n\t//TODO https://sourceware.org/ml/binutils/2014-11/msg00353.html\n\tfor (i = 0, cnt = 0; cnt < shdr->sh_info; ++cnt) {\n\t\tint j, isum;\n\t\tut8 *vstart = need + i;\n\t\tElf_(Verneed) vvn = {0};\n\t\tif (vstart + sizeof (Elf_(Verneed)) > end) {\n\t\t\tgoto beach;\n\t\t}\n\t\tElf_(Verneed) *entry = &vvn;\n\t\tchar key[32] = {0};\n\t\tsdb_version = sdb_new0 ();\n\t\tif (!sdb_version) {\n\t\t\tgoto beach;\n\t\t}\n\t\tj = 0;\n\t\tvvn.vn_version = READ16 (vstart, j)\n\t\tvvn.vn_cnt = READ16 (vstart, j)\n\t\tvvn.vn_file = READ32 (vstart, j)\n\t\tvvn.vn_aux = READ32 (vstart, j)\n\t\tvvn.vn_next = READ32 (vstart, j)\n\n\t\tsdb_num_set (sdb_version, \"vn_version\", entry->vn_version, 0);\n\t\tsdb_num_set (sdb_version, \"idx\", i, 0);\n\t\tif (entry->vn_file > bin->dynstr_size) {\n\t\t\tgoto beach;\n\t\t}\n\t\t{\n\t\t\tchar *s = r_str_ndup (&bin->dynstr[entry->vn_file], 16);\n\t\t\tsdb_set (sdb_version, \"file_name\", s, 0);\n\t\t\tfree (s);\n\t\t}\n\t\tsdb_num_set (sdb_version, \"cnt\", entry->vn_cnt, 0);\n\t\tst32 vnaux = entry->vn_aux;\n\t\tif (vnaux < 1) {\n\t\t\tgoto beach;\n\t\t}\n\t\tvstart += vnaux;\n\t\tfor (j = 0, isum = i + entry->vn_aux; j < entry->vn_cnt && vstart + sizeof (Elf_(Vernaux)) <= end; ++j) {\n\t\t\tint k;\n\t\t\tElf_(Vernaux) * aux = NULL;\n\t\t\tElf_(Vernaux) vaux = {0};\n\t\t\tsdb_vernaux = sdb_new0 ();\n\t\t\tif (!sdb_vernaux) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\taux = (Elf_(Vernaux)*)&vaux;\n\t\t\tk = 0;\n\t\t\tvaux.vna_hash = READ32 (vstart, k)\n\t\t\tvaux.vna_flags = READ16 (vstart, k)\n\t\t\tvaux.vna_other = READ16 (vstart, k)\n\t\t\tvaux.vna_name = READ32 (vstart, k)\n\t\t\tvaux.vna_next = READ32 (vstart, k)\n\t\t\tif (aux->vna_name > bin->dynstr_size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_vernaux, \"idx\", isum, 0);\n\t\t\tif (aux->vna_name > 0 && aux->vna_name + 8 < bin->dynstr_size) {\n\t\t\t\tchar name [16];\n\t\t\t\tstrncpy (name, &bin->dynstr[aux->vna_name], sizeof (name)-1);\n\t\t\t\tname[sizeof(name)-1] = 0;\n\t\t\t\tsdb_set (sdb_vernaux, \"name\", name, 0);\n\t\t\t}\n\t\t\tsdb_set (sdb_vernaux, \"flags\", get_ver_flags (aux->vna_flags), 0);\n\t\t\tsdb_num_set (sdb_vernaux, \"version\", aux->vna_other, 0);\n\t\t\tisum += aux->vna_next;\n\t\t\tvstart += aux->vna_next;\n\t\t\tsnprintf (key, sizeof (key), \"vernaux%d\", j);\n\t\t\tsdb_ns_set (sdb_version, key, sdb_vernaux);\n\t\t}\n\t\tif ((int)entry->vn_next < 0) {\n\t\t\tbprintf (\"Invalid vn_next\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ti += entry->vn_next;\n\t\tsnprintf (key, sizeof (key), \"version%d\", cnt );\n\t\tsdb_ns_set (sdb, key, sdb_version);\n\t\t//if entry->vn_next is 0 it iterate infinitely\n\t\tif (!entry->vn_next) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree (need);\n\treturn sdb;\nbeach:\n\tfree (need);\n\tsdb_free (sdb_vernaux);\n\tsdb_free (sdb_version);\n\tsdb_free (sdb);\n\treturn NULL;\n}", "commit_link": "github.com/radare/radare2/commit/c6d0076c924891ad9948a62d89d0bcdaf965f0cd", "file_name": "libr/bin/format/elf/elf.c", "vul_type": "cwe-125", "description": "In C, write a function to parse and store GNU version dependency information from an ELF binary's section header."}
{"func_name": "mkdir", "func_src_before": "    def mkdir(self, data, path):\n        credentials = self._formatCredentials(data, name='current')\n\n        command = (\n            '{credentials} '\n            'rclone touch current:{path}/.keep'\n        ).format(\n            credentials=credentials,\n            path=path,\n        )\n\n        try:\n            result = self._execute(command)\n            return {\n                'message': 'Success',\n            }\n        except subprocess.CalledProcessError as e:\n            raise RcloneException(sanitize(str(e)))", "func_src_after": "    def mkdir(self, data, path):\n        credentials = self._formatCredentials(data, name='current')\n        command = [\n            'rclone',\n            'touch',\n            'current:{}/.keep'.format(path),\n        ]\n\n        try:\n            result = self._execute(command, credentials)\n            return {\n                'message': 'Success',\n            }\n        except subprocess.CalledProcessError as e:\n            raise RcloneException(sanitize(str(e)))", "commit_link": "github.com/FredHutch/motuz/commit/045468cb9bff47bb3bb72268b6d5a3fe44e383db", "file_name": "src/backend/api/utils/rclone_connection.py", "vul_type": "cwe-078", "description": "Write a Python function to create a directory using rclone with error handling."}
{"func_name": "copyaudiodata", "func_src_before": "bool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid)\n{\n\tint frameSize = afGetVirtualFrameSize(infile, trackid, 1);\n\n\tconst int kBufferFrameCount = 65536;\n\tvoid *buffer = malloc(kBufferFrameCount * frameSize);\n\n\tAFframecount totalFrames = afGetFrameCount(infile, AF_DEFAULT_TRACK);\n\tAFframecount totalFramesWritten = 0;\n\n\tbool success = true;\n\n\twhile (totalFramesWritten < totalFrames)\n\t{\n\t\tAFframecount framesToRead = totalFrames - totalFramesWritten;\n\t\tif (framesToRead > kBufferFrameCount)\n\t\t\tframesToRead = kBufferFrameCount;\n\n\t\tAFframecount framesRead = afReadFrames(infile, trackid, buffer,\n\t\t\tframesToRead);\n\n\t\tif (framesRead < framesToRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad read of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tAFframecount framesWritten = afWriteFrames(outfile, trackid, buffer,\n\t\t\tframesRead);\n\n\t\tif (framesWritten < framesRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad write of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\n\t\ttotalFramesWritten += framesWritten;\n\t}\n\n\tfree(buffer);\n\n\treturn success;\n}", "func_src_after": "bool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid)\n{\n\tint frameSize = afGetVirtualFrameSize(infile, trackid, 1);\n\n\tint kBufferFrameCount = 65536;\n\tint bufferSize;\n\twhile (multiplyCheckOverflow(kBufferFrameCount, frameSize, &bufferSize))\n\t\tkBufferFrameCount /= 2;\n\tvoid *buffer = malloc(bufferSize);\n\n\tAFframecount totalFrames = afGetFrameCount(infile, AF_DEFAULT_TRACK);\n\tAFframecount totalFramesWritten = 0;\n\n\tbool success = true;\n\n\twhile (totalFramesWritten < totalFrames)\n\t{\n\t\tAFframecount framesToRead = totalFrames - totalFramesWritten;\n\t\tif (framesToRead > kBufferFrameCount)\n\t\t\tframesToRead = kBufferFrameCount;\n\n\t\tAFframecount framesRead = afReadFrames(infile, trackid, buffer,\n\t\t\tframesToRead);\n\n\t\tif (framesRead < framesToRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad read of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tAFframecount framesWritten = afWriteFrames(outfile, trackid, buffer,\n\t\t\tframesRead);\n\n\t\tif (framesWritten < framesRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad write of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\n\t\ttotalFramesWritten += framesWritten;\n\t}\n\n\tfree(buffer);\n\n\treturn success;\n}", "commit_link": "github.com/antlarr/audiofile/commit/7d65f89defb092b63bcbc5d98349fb222ca73b3c", "file_name": "sfcommands/sfconvert.c", "vul_type": "cwe-190", "description": "Write a C function named `copyaudiodata` that copies audio data from one file to another for a specified track ID, handling memory allocation and error checking."}
{"func_name": "_copy_volume", "func_src_before": "    def _copy_volume(self, src_name, dest_name, cpg=None, snap_cpg=None,\n                     tpvv=True):\n        # Virtual volume sets are not supported with the -online option\n        cmd = 'createvvcopy -p %s -online ' % src_name\n        if snap_cpg:\n            cmd += '-snp_cpg %s ' % snap_cpg\n        if tpvv:\n            cmd += '-tpvv '\n        if cpg:\n            cmd += cpg + ' '\n        cmd += dest_name\n        LOG.debug('Creating clone of a volume with %s' % cmd)\n        self._cli_run(cmd, None)", "func_src_after": "    def _copy_volume(self, src_name, dest_name, cpg=None, snap_cpg=None,\n                     tpvv=True):\n        # Virtual volume sets are not supported with the -online option\n        cmd = ['createvvcopy', '-p', src_name, '-online']\n        if snap_cpg:\n            cmd.extend(['-snp_cpg', snap_cpg])\n        if tpvv:\n            cmd.append('-tpvv')\n        if cpg:\n            cmd.append(cpg)\n        cmd.append(dest_name)\n        LOG.debug('Creating clone of a volume with %s' % cmd)\n        self._cli_run(cmd)", "commit_link": "github.com/thatsdone/cinder/commit/c55589b131828f3a595903f6796cb2d0babb772f", "file_name": "cinder/volume/drivers/san/hp/hp_3par_common.py", "vul_type": "cwe-078", "description": "Write a Python function to construct a command for cloning a volume with optional parameters for CPG and snapshot CPG, and a flag for thin provisioning."}
{"func_name": "test", "func_src_before": "@mod.route('/test', methods=['GET', 'POST'])\ndef test():\n    user_id = session['logged_id']\n    sql = 'SELECT * FROM message where user_id = %d ORDER BY c_time DESC' \\\n        % (user_id)\n    cursor.execute(sql)\n    m = cursor.fetchall()\n    print(m)", "func_src_after": "@mod.route('/test', methods=['GET', 'POST'])\ndef test():\n    user_id = session['logged_id']\n    cursor.execute('SELECT * FROM message where user_id = %s ORDER BY c_time DESC', (user_id,))\n    m = cursor.fetchall()\n    print(m)", "commit_link": "github.com/ulyssetsd/bjtu-sql/commit/17d7b21864b72ba5666f15236474a93268b32ec9", "file_name": "flaskr/flaskr/views/message.py", "vul_type": "cwe-089", "description": "Create a Python Flask route function that retrieves and prints all messages for the logged-in user, ordered by creation time in descending order."}
{"func_name": "wiki_handle_http_request", "func_src_before": "wiki_handle_http_request(HttpRequest *req)\n{\n  HttpResponse *res      = http_response_new(req);\n  char         *page     = http_request_get_path_info(req); \n  char         *command  = http_request_get_query_string(req); \n  char         *wikitext = \"\";\n\n  util_dehttpize(page); \t/* remove any encoding on the requested\n\t\t\t\t   page name.                           */\n\n  if (!strcmp(page, \"/\"))\n    {\n      if (access(\"WikiHome\", R_OK) != 0)\n\twiki_redirect(res, \"/WikiHome?create\");\n      page = \"/WikiHome\";\n    }\n\n  if (!strcmp(page, \"/styles.css\"))\n    {\n      /*  Return CSS page */\n      http_response_set_content_type(res, \"text/css\");\n      http_response_printf(res, \"%s\", CssData);\n      http_response_send(res);\n      exit(0);\n    }\n\n  if (!strcmp(page, \"/favicon.ico\"))\n    {\n      /*  Return favicon */\n      http_response_set_content_type(res, \"image/ico\");\n      http_response_set_data(res, FaviconData, FaviconDataLen);\n      http_response_send(res);\n      exit(0);\n    }\n\n\n  page = page + 1; \t\t/* skip slash */\n\n  if (!strncmp(page, \"api/\", 4))\n    {\n      char *p;\n\n      page += 4; \n      for (p=page; *p != '\\0'; p++)\n\tif (*p=='?') { *p ='\\0'; break; }\n      \n      wiki_handle_rest_call(req, res, page); \n      exit(0);\n    }\n\n  /* A little safety. issue a malformed request for any paths,\n   * There shouldn't need to be any..\n   */\n  if (strchr(page, '/'))\n    {\n      http_response_set_status(res, 404, \"Not Found\");\n      http_response_printf(res, \"<html><body>404 Not Found</body></html>\\n\");\n      http_response_send(res);\n      exit(0);\n    }\n\n  if (!strcmp(page, \"Changes\"))\n    {\n      wiki_show_changes_page(res);\n    }\n  else if (!strcmp(page, \"ChangesRss\"))\n    {\n      wiki_show_changes_page_rss(res);\n    }\n  else if (!strcmp(page, \"Search\"))\n    {\n      wiki_show_search_results_page(res, http_request_param_get(req, \"expr\"));\n    }\n  else if (!strcmp(page, \"Create\"))\n    {\n      if ( (wikitext = http_request_param_get(req, \"title\")) != NULL)\n\t{\n\t  /* create page and redirect */\n\t  wiki_redirect(res, http_request_param_get(req, \"title\"));\n\t}\n      else\n\t{\n\t   /* show create page form  */\n\t  wiki_show_create_page(res);\n\t}\n    }\n  else\n    {\n      /* TODO: dont blindly write wikitext data to disk */\n      if ( (wikitext = http_request_param_get(req, \"wikitext\")) != NULL)\n\t{\n\t  file_write(page, wikitext);\t      \n\t}\n\n      if (access(page, R_OK) == 0) \t/* page exists */\n\t{\n\t  wikitext = file_read(page);\n\t  \n\t  if (!strcmp(command, \"edit\"))\n\t    {\n\t      /* print edit page */\n\t      wiki_show_edit_page(res, wikitext, page);\n\t    }\n\t  else\n\t    {\n\t      wiki_show_page(res, wikitext, page);\n\t    }\n\t}\n      else\n\t{\n\t  if (!strcmp(command, \"create\"))\n\t    {\n\t      wiki_show_edit_page(res, NULL, page);\n\t    }\n\t  else\n\t    {\n\t      char buf[1024];\n\t      snprintf(buf, 1024, \"%s?create\", page);\n\t      wiki_redirect(res, buf);\n\t    }\n\t}\n    }\n\n}", "func_src_after": "wiki_handle_http_request(HttpRequest *req)\n{\n  HttpResponse *res      = http_response_new(req);\n  char         *page     = http_request_get_path_info(req); \n  char         *command  = http_request_get_query_string(req); \n  char         *wikitext = \"\";\n\n  util_dehttpize(page); \t/* remove any encoding on the requested\n\t\t\t\t   page name.                           */\n\n  if (!strcmp(page, \"/\"))\n    {\n      if (access(\"WikiHome\", R_OK) != 0)\n\twiki_redirect(res, \"/WikiHome?create\");\n      page = \"/WikiHome\";\n    }\n\n  if (!strcmp(page, \"/styles.css\"))\n    {\n      /*  Return CSS page */\n      http_response_set_content_type(res, \"text/css\");\n      http_response_printf(res, \"%s\", CssData);\n      http_response_send(res);\n      exit(0);\n    }\n\n  if (!strcmp(page, \"/favicon.ico\"))\n    {\n      /*  Return favicon */\n      http_response_set_content_type(res, \"image/ico\");\n      http_response_set_data(res, FaviconData, FaviconDataLen);\n      http_response_send(res);\n      exit(0);\n    }\n\n\n  page = page + 1; \t\t/* skip slash */\n\n  if (!strncmp(page, \"api/\", 4))\n    {\n      char *p;\n\n      page += 4; \n      for (p=page; *p != '\\0'; p++)\n\tif (*p=='?') { *p ='\\0'; break; }\n      \n      wiki_handle_rest_call(req, res, page); \n      exit(0);\n    }\n\n  /* A little safety. issue a malformed request for any paths,\n   * There shouldn't need to be any..\n   */\n  if (!page_name_is_good(page))\n    {\n      http_response_set_status(res, 404, \"Not Found\");\n      http_response_printf(res, \"<html><body>404 Not Found</body></html>\\n\");\n      http_response_send(res);\n      exit(0);\n    }\n\n  if (!strcmp(page, \"Changes\"))\n    {\n      wiki_show_changes_page(res);\n    }\n  else if (!strcmp(page, \"ChangesRss\"))\n    {\n      wiki_show_changes_page_rss(res);\n    }\n  else if (!strcmp(page, \"Search\"))\n    {\n      wiki_show_search_results_page(res, http_request_param_get(req, \"expr\"));\n    }\n  else if (!strcmp(page, \"Create\"))\n    {\n      if ( (wikitext = http_request_param_get(req, \"title\")) != NULL)\n\t{\n\t  /* create page and redirect */\n\t  wiki_redirect(res, http_request_param_get(req, \"title\"));\n\t}\n      else\n\t{\n\t   /* show create page form  */\n\t  wiki_show_create_page(res);\n\t}\n    }\n  else\n    {\n      /* TODO: dont blindly write wikitext data to disk */\n      if ( (wikitext = http_request_param_get(req, \"wikitext\")) != NULL)\n\t{\n\t  file_write(page, wikitext);\t      \n\t}\n\n      if (access(page, R_OK) == 0) \t/* page exists */\n\t{\n\t  wikitext = file_read(page);\n\t  \n\t  if (!strcmp(command, \"edit\"))\n\t    {\n\t      /* print edit page */\n\t      wiki_show_edit_page(res, wikitext, page);\n\t    }\n\t  else\n\t    {\n\t      wiki_show_page(res, wikitext, page);\n\t    }\n\t}\n      else\n\t{\n\t  if (!strcmp(command, \"create\"))\n\t    {\n\t      wiki_show_edit_page(res, NULL, page);\n\t    }\n\t  else\n\t    {\n\t      char buf[1024];\n\t      snprintf(buf, 1024, \"%s?create\", page);\n\t      wiki_redirect(res, buf);\n\t    }\n\t}\n    }\n\n}", "commit_link": "github.com/yarolig/didiwiki/commit/5e5c796617e1712905dc5462b94bd5e6c08d15ea", "file_name": "src/wiki.c", "vul_type": "cwe-022", "description": "In C, write a function to handle HTTP requests for a simple wiki, including serving static files, API calls, and wiki page creation or editing."}
{"func_name": "get_previous_yields", "func_src_before": "    def get_previous_yields(self, inverter_serial):\n        query = '''\n           SELECT TimeStamp, EToday, ETotal\n           FROM Inverters\n           WHERE Serial = '%s'\n        ''' % (inverter_serial)\n        self.c.execute(query)\n        data = self.c.fetchone()\n        return data[0], data[1], data[2]", "func_src_after": "    def get_previous_yields(self, inverter_serial):\n        query = '''\n           SELECT TimeStamp, EToday, ETotal\n           FROM Inverters\n           WHERE Serial=?\n        '''\n        self.c.execute(query, (inverter_serial,))\n        data = self.c.fetchone()\n        return data[0], data[1], data[2]", "commit_link": "github.com/philipptrenz/s0-bridge/commit/269b48caa05377b7c58c3e6d1622a4429cb5ba65", "file_name": "util/database.py", "vul_type": "cwe-089", "description": "Write a Python function to fetch the timestamp and energy yields of today and total from a database for a given inverter serial number."}
{"func_name": "upsert_mapped_projects", "func_src_before": "    @staticmethod\n    def upsert_mapped_projects(user_id: int, project_id: int):\n        \"\"\" Adds projects to mapped_projects if it doesn't exist \"\"\"\n        sql = \"select * from users where id = {0} and projects_mapped @> '{{{1}}}'\".format(user_id, project_id)\n        result = db.engine.execute(sql)\n\n        if result.rowcount > 0:\n            return  # User has previously mapped this project so return\n\n        sql = '''update users\n                    set projects_mapped = array_append(projects_mapped, {0})\n                  where id = {1}'''.format(project_id, user_id)\n\n        db.engine.execute(sql)", "func_src_after": "    @staticmethod\n    def upsert_mapped_projects(user_id: int, project_id: int):\n        \"\"\" Adds projects to mapped_projects if it doesn't exist \"\"\"\n        sql = \"select * from users where id = :user_id and projects_mapped @> '{{:project_id}}'\"\n        result = db.engine.execute(text(sql), user_id=user_id, project_id=project_id)\n\n        if result.rowcount > 0:\n            return  # User has previously mapped this project so return\n\n        sql = '''update users\n                    set projects_mapped = array_append(projects_mapped, :project_id)\n                  where id = :user_id'''\n\n        db.engine.execute(text(sql), project_id=project_id, user_id=user_id)", "commit_link": "github.com/hotosm/tasking-manager/commit/dee040a2d22b3c4d5e38e2dbf8c6b651ad4c241a", "file_name": "server/models/postgis/user.py", "vul_type": "cwe-089", "description": "Write a Python function that checks if a project is already mapped to a user and if not, appends it to their mapped projects in the database."}
{"func_name": "mergeConfig", "func_src_before": "function mergeConfig(from, to) {\n\tfor (var f in from) {\n\t\tif (_.isObject(from[f])) {\n\t\t\tif (!_.isObject(to[f])) {\n\t\t\t\tto[f] = from[f];\n\t\t\t} else {\n\t\t\t\tmergeConfig(from[f], to[f]);\n\t\t\t}\n\t\t} else {\n\t\t\tto[f] = from[f];\n\t\t}\n\t}\n}", "func_src_after": "function mergeConfig(from, to) {\n\tfor (var f in from) {\n\t\tif (Object.prototype.hasOwnProperty.call(from, f)) {\n\t\t\tif (Object.prototype.hasOwnProperty.call(to, f) && _.isObject(from[f])) {\n\t\t\t\tif (!_.isObject(to[f])) {\n\t\t\t\t\tto[f] = from[f];\n\t\t\t\t} else {\n\t\t\t\t\tmergeConfig(from[f], to[f]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tto[f] = from[f];\n\t\t\t}\n\t\t}\n\t}\n}", "line_changes": {"deleted": [{"line_no": 3, "char_start": 56, "char_end": 85, "line": "\t\tif (_.isObject(from[f])) {\n"}, {"line_no": 4, "char_start": 85, "char_end": 114, "line": "\t\t\tif (!_.isObject(to[f])) {\n"}, {"line_no": 5, "char_start": 114, "char_end": 135, "line": "\t\t\t\tto[f] = from[f];\n"}, {"line_no": 7, "char_start": 147, "char_end": 180, "line": "\t\t\t\tmergeConfig(from[f], to[f]);\n"}, {"line_no": 9, "char_start": 185, "char_end": 196, "line": "\t\t} else {\n"}, {"line_no": 10, "char_start": 196, "char_end": 216, "line": "\t\t\tto[f] = from[f];\n"}], "added": [{"line_no": 3, "char_start": 56, "char_end": 111, "line": "\t\tif (Object.prototype.hasOwnProperty.call(from, f)) {\n"}, {"line_no": 4, "char_start": 111, "char_end": 188, "line": "\t\t\tif (Object.prototype.hasOwnProperty.call(to, f) && _.isObject(from[f])) {\n"}, {"line_no": 5, "char_start": 188, "char_end": 218, "line": "\t\t\t\tif (!_.isObject(to[f])) {\n"}, {"line_no": 6, "char_start": 218, "char_end": 240, "line": "\t\t\t\t\tto[f] = from[f];\n"}, {"line_no": 7, "char_start": 240, "char_end": 253, "line": "\t\t\t\t} else {\n"}, {"line_no": 8, "char_start": 253, "char_end": 287, "line": "\t\t\t\t\tmergeConfig(from[f], to[f]);\n"}, {"line_no": 9, "char_start": 287, "char_end": 293, "line": "\t\t\t\t}\n"}, {"line_no": 11, "char_start": 305, "char_end": 326, "line": "\t\t\t\tto[f] = from[f];\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 62, "char_end": 165, "chars": "Object.prototype.hasOwnProperty.call(from, f)) {\n\t\t\tif (Object.prototype.hasOwnProperty.call(to, f) && "}, {"char_start": 188, "char_end": 189, "chars": "\t"}, {"char_start": 218, "char_end": 219, "chars": "\t"}, {"char_start": 243, "char_end": 244, "chars": "\t"}, {"char_start": 253, "char_end": 254, "chars": "\t"}, {"char_start": 287, "char_end": 288, "chars": "\t"}, {"char_start": 295, "char_end": 296, "chars": "\t"}, {"char_start": 305, "char_end": 306, "chars": "\t"}, {"char_start": 326, "char_end": 331, "chars": "\t\t\t}\n"}]}, "commit_link": "github.com/jkphl/svg-sprite/commit/1ba7f04ed4f4798112aa612b7b2e6367fcb7e8c2", "file_name": "svg-sprite.js", "vul_type": "cwe-915", "commit_msg": "Fix prototype pollution issue (#392)", "parent_commit": "1724f4c0b2b923c4dd1a1d75e00647f5f7fae0c6", "description": "Write a JavaScript function named `mergeConfig` that recursively merges properties from one object into another."}
{"func_name": "TestGetBasket_BadRequest", "func_src_before": "func TestGetBasket_BadRequest(t *testing.T) {\n\tbasket := \"get05~\"\n\n\tr, err := http.NewRequest(\"GET\", \"http://localhost:55555/api/baskets/\"+basket, strings.NewReader(\"\"))\n\tif assert.NoError(t, err) {\n\t\tr.Header.Add(\"Authorization\", \"abcd12345\")\n\t\tw := httptest.NewRecorder()\n\t\tps := append(make(httprouter.Params, 0), httprouter.Param{Key: \"basket\", Value: basket})\n\t\tGetBasket(w, r, ps)\n\n\t\t// validate response: 400 - Bad Request\n\t\tassert.Equal(t, 400, w.Code, \"wrong HTTP result code\")\n\t\tassert.Equal(t, \"invalid basket name; [\"+basket+\"] does not match pattern: \"+validBasketName.String()+\"\\n\", w.Body.String(),\n\t\t\t\"wrong error message\")\n\t}\n}", "func_src_after": "func TestGetBasket_BadRequest(t *testing.T) {\n\tbasket := \"get05~\"\n\n\tr, err := http.NewRequest(\"GET\", \"http://localhost:55555/api/baskets/\"+basket, strings.NewReader(\"\"))\n\tif assert.NoError(t, err) {\n\t\tr.Header.Add(\"Authorization\", \"abcd12345\")\n\t\tw := httptest.NewRecorder()\n\t\tps := append(make(httprouter.Params, 0), httprouter.Param{Key: \"basket\", Value: basket})\n\t\tGetBasket(w, r, ps)\n\n\t\t// validate response: 400 - Bad Request\n\t\tassert.Equal(t, 400, w.Code, \"wrong HTTP result code\")\n\t\tassert.Equal(t, \"invalid basket name; the name does not match pattern: \"+validBasketName.String()+\"\\n\", w.Body.String(),\n\t\t\t\"wrong error message\")\n\t}\n}", "line_changes": {"deleted": [{"line_no": 13, "char_start": 487, "char_end": 614, "line": "\t\tassert.Equal(t, \"invalid basket name; [\"+basket+\"] does not match pattern: \"+validBasketName.String()+\"\\n\", w.Body.String(),\n"}], "added": [{"line_no": 13, "char_start": 487, "char_end": 610, "line": "\t\tassert.Equal(t, \"invalid basket name; the name does not match pattern: \"+validBasketName.String()+\"\\n\", w.Body.String(),\n"}]}, "char_changes": {"deleted": [{"char_start": 527, "char_end": 539, "chars": "[\"+basket+\"]"}], "added": [{"char_start": 527, "char_end": 535, "chars": "the name"}]}, "commit_link": "github.com/darklynx/request-baskets/commit/093f040f79865e9d44ad565a279f32038fb45a2a", "file_name": "handlers_test.go", "vul_type": "cwe-079", "commit_msg": "fixed reflected cross-site scripting issue related to invalid basket name", "parent_commit": "4fe1fdef9e05a3c0061c82e223dcccacfc2211ae", "description": "Write a Go test function that checks for a bad request response when fetching a basket with an invalid name from an API."}
{"func_name": "delete", "func_src_before": "    @jwt_required\n    def delete(self, email):\n        \"\"\" Deletes admin with the corresponding email \"\"\"\n        return database_utilities.execute_query(f\"\"\"delete from admins where email = '{email}'\"\"\")", "func_src_after": "    @jwt_required\n    def delete(self, email):\n        \"\"\" Deletes admin with the corresponding email \"\"\"\n        return database_utilities.execute_query(f\"\"\"delete from admins where email = %s\"\"\", (email, ))", "commit_link": "github.com/sgosal2/tiger-boards-backend/commit/4670109dd613df2f2fe7e8403ebd149df2b55485", "file_name": "apis/admins.py", "vul_type": "cwe-089", "description": "Write a Python function with JWT authentication that deletes an admin by email from a database using SQL query execution."}
{"func_name": "asylo::primitives::TrustedPrimitives::UntrustedCall", "func_src_before": "PrimitiveStatus TrustedPrimitives::UntrustedCall(uint64_t untrusted_selector,\n                                                 MessageWriter *input,\n                                                 MessageReader *output) {\n  int ret;\n\n  UntrustedCacheMalloc *untrusted_cache = UntrustedCacheMalloc::Instance();\n\n  SgxParams *const sgx_params =\n      reinterpret_cast<SgxParams *>(untrusted_cache->Malloc(sizeof(SgxParams)));\n  Cleanup clean_up(\n      [sgx_params, untrusted_cache] { untrusted_cache->Free(sgx_params); });\n  sgx_params->input_size = 0;\n  sgx_params->input = nullptr;\n  if (input) {\n    sgx_params->input_size = input->MessageSize();\n    if (sgx_params->input_size > 0) {\n      // Allocate and copy data to |input_buffer|.\n      sgx_params->input = untrusted_cache->Malloc(sgx_params->input_size);\n      input->Serialize(const_cast<void *>(sgx_params->input));\n    }\n  }\n  sgx_params->output_size = 0;\n  sgx_params->output = nullptr;\n  CHECK_OCALL(\n      ocall_dispatch_untrusted_call(&ret, untrusted_selector, sgx_params));\n  if (sgx_params->input) {\n    untrusted_cache->Free(const_cast<void *>(sgx_params->input));\n  }\n  if (sgx_params->output) {\n    // For the results obtained in |output_buffer|, copy them to |output|\n    // before freeing the buffer.\n    output->Deserialize(sgx_params->output, sgx_params->output_size);\n    TrustedPrimitives::UntrustedLocalFree(sgx_params->output);\n  }\n  return PrimitiveStatus::OkStatus();\n}", "func_src_after": "PrimitiveStatus TrustedPrimitives::UntrustedCall(uint64_t untrusted_selector,\n                                                 MessageWriter *input,\n                                                 MessageReader *output) {\n  int ret;\n\n  UntrustedCacheMalloc *untrusted_cache = UntrustedCacheMalloc::Instance();\n\n  SgxParams *const sgx_params =\n      reinterpret_cast<SgxParams *>(untrusted_cache->Malloc(sizeof(SgxParams)));\n  Cleanup clean_up(\n      [sgx_params, untrusted_cache] { untrusted_cache->Free(sgx_params); });\n  sgx_params->input_size = 0;\n  sgx_params->input = nullptr;\n  if (input) {\n    sgx_params->input_size = input->MessageSize();\n    if (sgx_params->input_size > 0) {\n      // Allocate and copy data to |input_buffer|.\n      sgx_params->input = untrusted_cache->Malloc(sgx_params->input_size);\n      input->Serialize(const_cast<void *>(sgx_params->input));\n    }\n  }\n  sgx_params->output_size = 0;\n  sgx_params->output = nullptr;\n  CHECK_OCALL(\n      ocall_dispatch_untrusted_call(&ret, untrusted_selector, sgx_params));\n  if (sgx_params->input) {\n    untrusted_cache->Free(const_cast<void *>(sgx_params->input));\n  }\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params->output,\n                                           sgx_params->output_size)) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param output should be in untrusted memory\");\n  }\n  if (sgx_params->output) {\n    // For the results obtained in |output_buffer|, copy them to |output|\n    // before freeing the buffer.\n    output->Deserialize(sgx_params->output, sgx_params->output_size);\n    TrustedPrimitives::UntrustedLocalFree(sgx_params->output);\n  }\n  return PrimitiveStatus::OkStatus();\n}", "commit_link": "github.com/google/asylo/commit/83036fd841d33baa7e039f842d131aa7881fdcc2", "file_name": "asylo/platform/primitives/sgx/trusted_sgx.cc", "vul_type": "cwe-125", "description": "Write a C++ function for handling an untrusted call with input and output message serialization in a secure enclave environment."}
{"func_name": "get_old_sourcebyinstitution_number", "func_src_before": "def get_old_sourcebyinstitution_number(conn, sqlite, sourcebyinstitution):\n    \"\"\"\n    Get all the old sourcebyinstitution number from the SQLite database.\n    \"\"\"\n    query = \"\"\"\n        SELECT\n            titles\n        FROM\n            history\n        WHERE\n            sourcebyinstitution = \"%s\"\n        ORDER BY\n            titles DESC\n        LIMIT 1\n    \"\"\" % sourcebyinstitution\n\n    sqlite.execute(query)\n    for record in sqlite:\n        old_sourcebyinstitution_number = record[0]\n        return old_sourcebyinstitution_number", "func_src_after": "def get_old_sourcebyinstitution_number(conn, sqlite, sourcebyinstitution):\n    \"\"\"\n    Get all the old sourcebyinstitution number from the SQLite database.\n    \"\"\"\n    query = \"\"\"\n        SELECT\n            titles\n        FROM\n            history\n        WHERE\n            sourcebyinstitution = ?\n        ORDER BY\n            titles DESC\n        LIMIT 1\n    \"\"\"\n\n    sqlite.execute(query, (sourcebyinstitution,))\n    for record in sqlite:\n        old_sourcebyinstitution_number = record[0]\n        return old_sourcebyinstitution_number", "commit_link": "github.com/miku/siskin/commit/7fa398d2fea72bf2e8b4808f75df4b3d35ae959a", "file_name": "bin/solrcheckup.py", "vul_type": "cwe-089", "description": "Write a Python function to retrieve the most recent title associated with a given source institution from an SQLite database."}
{"func_name": "fm10k_init_module", "func_src_before": "static int __init fm10k_init_module(void)\n{\n\tpr_info(\"%s - version %s\\n\", fm10k_driver_string, fm10k_driver_version);\n\tpr_info(\"%s\\n\", fm10k_copyright);\n\n\t/* create driver workqueue */\n\tfm10k_workqueue = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM, 0,\n\t\t\t\t\t  fm10k_driver_name);\n\n\tfm10k_dbg_init();\n\n\treturn fm10k_register_pci_driver();\n}", "func_src_after": "static int __init fm10k_init_module(void)\n{\n\tpr_info(\"%s - version %s\\n\", fm10k_driver_string, fm10k_driver_version);\n\tpr_info(\"%s\\n\", fm10k_copyright);\n\n\t/* create driver workqueue */\n\tfm10k_workqueue = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM, 0,\n\t\t\t\t\t  fm10k_driver_name);\n\tif (!fm10k_workqueue)\n\t\treturn -ENOMEM;\n\n\tfm10k_dbg_init();\n\n\treturn fm10k_register_pci_driver();\n}", "commit_link": "github.com/torvalds/linux/commit/01ca667133d019edc9f0a1f70a272447c84ec41f", "file_name": "drivers/net/ethernet/intel/fm10k/fm10k_main.c", "vul_type": "cwe-476", "description": "Write a Linux kernel module initialization function in C that logs the driver version, allocates a workqueue, initializes debugging, and registers a PCI driver, handling potential memory allocation failure."}
{"func_name": "match_at", "func_src_before": "match_at(regex_t* reg, const UChar* str, const UChar* end,\n#ifdef USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE\n\t const UChar* right_range,\n#endif\n\t const UChar* sstart, UChar* sprev, OnigMatchArg* msa)\n{\n  static UChar FinishCode[] = { OP_FINISH };\n\n  int i, n, num_mem, best_len, pop_level;\n  LengthType tlen, tlen2;\n  MemNumType mem;\n  RelAddrType addr;\n  UChar *s, *q, *sbegin;\n  int is_alloca;\n  char *alloc_base;\n  OnigStackType *stk_base, *stk, *stk_end;\n  OnigStackType *stkp; /* used as any purpose. */\n  OnigStackIndex si;\n  OnigStackIndex *repeat_stk;\n  OnigStackIndex *mem_start_stk, *mem_end_stk;\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n  int scv;\n  unsigned char* state_check_buff = msa->state_check_buff;\n  int num_comb_exp_check = reg->num_comb_exp_check;\n#endif\n  UChar *p = reg->p;\n  OnigOptionType option = reg->options;\n  OnigEncoding encode = reg->enc;\n  OnigCaseFoldType case_fold_flag = reg->case_fold_flag;\n\n  //n = reg->num_repeat + reg->num_mem * 2;\n  pop_level = reg->stack_pop_level;\n  num_mem = reg->num_mem;\n  STACK_INIT(INIT_MATCH_STACK_SIZE);\n  UPDATE_FOR_STACK_REALLOC;\n  for (i = 1; i <= num_mem; i++) {\n    mem_start_stk[i] = mem_end_stk[i] = INVALID_STACK_INDEX;\n  }\n\n#ifdef ONIG_DEBUG_MATCH\n  fprintf(stderr, \"match_at: str: %d, end: %d, start: %d, sprev: %d\\n\",\n\t  (int )str, (int )end, (int )sstart, (int )sprev);\n  fprintf(stderr, \"size: %d, start offset: %d\\n\",\n\t  (int )(end - str), (int )(sstart - str));\n#endif\n\n  STACK_PUSH_ENSURED(STK_ALT, FinishCode);  /* bottom stack */\n  best_len = ONIG_MISMATCH;\n  s = (UChar* )sstart;\n  while (1) {\n#ifdef ONIG_DEBUG_MATCH\n    {\n      UChar *q, *bp, buf[50];\n      int len;\n      fprintf(stderr, \"%4d> \\\"\", (int )(s - str));\n      bp = buf;\n      for (i = 0, q = s; i < 7 && q < end; i++) {\n\tlen = enclen(encode, q);\n\twhile (len-- > 0) *bp++ = *q++;\n      }\n      if (q < end) { xmemcpy(bp, \"...\\\"\", 4); bp += 4; }\n      else         { xmemcpy(bp, \"\\\"\",    1); bp += 1; }\n      *bp = 0;\n      fputs((char* )buf, stderr);\n      for (i = 0; i < 20 - (bp - buf); i++) fputc(' ', stderr);\n      onig_print_compiled_byte_code(stderr, p, NULL, encode);\n      fprintf(stderr, \"\\n\");\n    }\n#endif\n\n    sbegin = s;\n    switch (*p++) {\n    case OP_END:  MOP_IN(OP_END);\n      n = s - sstart;\n      if (n > best_len) {\n        OnigRegion* region;\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n        if (IS_FIND_LONGEST(option)) {\n          if (n > msa->best_len) {\n            msa->best_len = n;\n            msa->best_s   = (UChar* )sstart;\n          }\n          else\n            goto end_best_len;\n        }\n#endif\n        best_len = n;\n        region = msa->region;\n        if (region) {\n#ifdef USE_POSIX_API_REGION_OPTION\n          if (IS_POSIX_REGION(msa->options)) {\n            posix_regmatch_t* rmt = (posix_regmatch_t* )region;\n\n            rmt[0].rm_so = sstart - str;\n            rmt[0].rm_eo = s      - str;\n            for (i = 1; i <= num_mem; i++) {\n              if (mem_end_stk[i] != INVALID_STACK_INDEX) {\n                if (BIT_STATUS_AT(reg->bt_mem_start, i))\n                  rmt[i].rm_so = STACK_AT(mem_start_stk[i])->u.mem.pstr - str;\n                else\n                  rmt[i].rm_so = (UChar* )((void* )(mem_start_stk[i])) - str;\n\n                rmt[i].rm_eo = (BIT_STATUS_AT(reg->bt_mem_end, i)\n                                ? STACK_AT(mem_end_stk[i])->u.mem.pstr\n                                : (UChar* )((void* )mem_end_stk[i])) - str;\n              }\n              else {\n                rmt[i].rm_so = rmt[i].rm_eo = ONIG_REGION_NOTPOS;\n              }\n            }\n          }\n          else {\n#endif /* USE_POSIX_API_REGION_OPTION */\n            region->beg[0] = sstart - str;\n            region->end[0] = s      - str;\n            for (i = 1; i <= num_mem; i++) {\n              if (mem_end_stk[i] != INVALID_STACK_INDEX) {\n                if (BIT_STATUS_AT(reg->bt_mem_start, i))\n                  region->beg[i] = STACK_AT(mem_start_stk[i])->u.mem.pstr - str;\n                else\n                  region->beg[i] = (UChar* )((void* )mem_start_stk[i]) - str;\n\n                region->end[i] = (BIT_STATUS_AT(reg->bt_mem_end, i)\n                                  ? STACK_AT(mem_end_stk[i])->u.mem.pstr\n                                  : (UChar* )((void* )mem_end_stk[i])) - str;\n              }\n              else {\n                region->beg[i] = region->end[i] = ONIG_REGION_NOTPOS;\n              }\n            }\n\n#ifdef USE_CAPTURE_HISTORY\n            if (reg->capture_history != 0) {\n              int r;\n              OnigCaptureTreeNode* node;\n\n              if (IS_NULL(region->history_root)) {\n                region->history_root = node = history_node_new();\n                CHECK_NULL_RETURN_MEMERR(node);\n              }\n              else {\n                node = region->history_root;\n                history_tree_clear(node);\n              }\n\n              node->group = 0;\n              node->beg   = sstart - str;\n              node->end   = s      - str;\n\n              stkp = stk_base;\n              r = make_capture_history_tree(region->history_root, &stkp,\n                                            stk, (UChar* )str, reg);\n              if (r < 0) {\n                best_len = r; /* error code */\n                goto finish;\n              }\n            }\n#endif /* USE_CAPTURE_HISTORY */\n#ifdef USE_POSIX_API_REGION_OPTION\n          } /* else IS_POSIX_REGION() */\n#endif\n        } /* if (region) */\n      } /* n > best_len */\n\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n    end_best_len:\n#endif\n      MOP_OUT;\n\n      if (IS_FIND_CONDITION(option)) {\n        if (IS_FIND_NOT_EMPTY(option) && s == sstart) {\n          best_len = ONIG_MISMATCH;\n          goto fail; /* for retry */\n        }\n        if (IS_FIND_LONGEST(option) && DATA_ENSURE_CHECK1) {\n          goto fail; /* for retry */\n        }\n      }\n\n      /* default behavior: return first-matching result. */\n      goto finish;\n      break;\n\n    case OP_EXACT1:  MOP_IN(OP_EXACT1);\n#if 0\n      DATA_ENSURE(1);\n      if (*p != *s) goto fail;\n      p++; s++;\n#endif\n      if (*p != *s++) goto fail;\n      DATA_ENSURE(0);\n      p++;\n      MOP_OUT;\n      break;\n\n    case OP_EXACT1_IC:  MOP_IN(OP_EXACT1_IC);\n      {\n        int len;\n        UChar *q, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n\n        DATA_ENSURE(1);\n        len = ONIGENC_MBC_CASE_FOLD(encode,\n                 /* DISABLE_CASE_FOLD_MULTI_CHAR(case_fold_flag), */\n                                    case_fold_flag,\n                                    &s, end, lowbuf);\n        DATA_ENSURE(0);\n        q = lowbuf;\n        while (len-- > 0) {\n          if (*p != *q) {\n            goto fail;\n          }\n          p++; q++;\n        }\n      }\n      MOP_OUT;\n      break;\n\n    case OP_EXACT2:  MOP_IN(OP_EXACT2);\n      DATA_ENSURE(2);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      sprev = s;\n      p++; s++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACT3:  MOP_IN(OP_EXACT3);\n      DATA_ENSURE(3);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      sprev = s;\n      p++; s++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACT4:  MOP_IN(OP_EXACT4);\n      DATA_ENSURE(4);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      sprev = s;\n      p++; s++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACT5:  MOP_IN(OP_EXACT5);\n      DATA_ENSURE(5);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      sprev = s;\n      p++; s++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTN:  MOP_IN(OP_EXACTN);\n      GET_LENGTH_INC(tlen, p);\n      DATA_ENSURE(tlen);\n      while (tlen-- > 0) {\n        if (*p++ != *s++) goto fail;\n      }\n      sprev = s - 1;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTN_IC:  MOP_IN(OP_EXACTN_IC);\n      {\n        int len;\n        UChar *q, *endp, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n\n        GET_LENGTH_INC(tlen, p);\n        endp = p + tlen;\n\n        while (p < endp) {\n          sprev = s;\n          DATA_ENSURE(1);\n          len = ONIGENC_MBC_CASE_FOLD(encode,\n                        /* DISABLE_CASE_FOLD_MULTI_CHAR(case_fold_flag), */\n                                      case_fold_flag,\n                                      &s, end, lowbuf);\n          DATA_ENSURE(0);\n          q = lowbuf;\n          while (len-- > 0) {\n            if (*p != *q) goto fail;\n            p++; q++;\n          }\n        }\n      }\n\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTMB2N1:  MOP_IN(OP_EXACTMB2N1);\n      DATA_ENSURE(2);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      MOP_OUT;\n      break;\n\n    case OP_EXACTMB2N2:  MOP_IN(OP_EXACTMB2N2);\n      DATA_ENSURE(4);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      sprev = s;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTMB2N3:  MOP_IN(OP_EXACTMB2N3);\n      DATA_ENSURE(6);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      sprev = s;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTMB2N:  MOP_IN(OP_EXACTMB2N);\n      GET_LENGTH_INC(tlen, p);\n      DATA_ENSURE(tlen * 2);\n      while (tlen-- > 0) {\n        if (*p != *s) goto fail;\n        p++; s++;\n        if (*p != *s) goto fail;\n        p++; s++;\n      }\n      sprev = s - 2;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTMB3N:  MOP_IN(OP_EXACTMB3N);\n      GET_LENGTH_INC(tlen, p);\n      DATA_ENSURE(tlen * 3);\n      while (tlen-- > 0) {\n        if (*p != *s) goto fail;\n        p++; s++;\n        if (*p != *s) goto fail;\n        p++; s++;\n        if (*p != *s) goto fail;\n        p++; s++;\n      }\n      sprev = s - 3;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTMBN:  MOP_IN(OP_EXACTMBN);\n      GET_LENGTH_INC(tlen,  p);  /* mb-len */\n      GET_LENGTH_INC(tlen2, p);  /* string len */\n      tlen2 *= tlen;\n      DATA_ENSURE(tlen2);\n      while (tlen2-- > 0) {\n        if (*p != *s) goto fail;\n        p++; s++;\n      }\n      sprev = s - tlen;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_CCLASS:  MOP_IN(OP_CCLASS);\n      DATA_ENSURE(1);\n      if (BITSET_AT(((BitSetRef )p), *s) == 0) goto fail;\n      p += SIZE_BITSET;\n      s += enclen(encode, s);   /* OP_CCLASS can match mb-code. \\D, \\S */\n      MOP_OUT;\n      break;\n\n    case OP_CCLASS_MB:  MOP_IN(OP_CCLASS_MB);\n      if (! ONIGENC_IS_MBC_HEAD(encode, s)) goto fail;\n\n    cclass_mb:\n      GET_LENGTH_INC(tlen, p);\n      {\n        OnigCodePoint code;\n        UChar *ss;\n        int mb_len;\n\n        DATA_ENSURE(1);\n        mb_len = enclen(encode, s);\n        DATA_ENSURE(mb_len);\n        ss = s;\n        s += mb_len;\n        code = ONIGENC_MBC_TO_CODE(encode, ss, s);\n\n#ifdef PLATFORM_UNALIGNED_WORD_ACCESS\n        if (! onig_is_in_code_range(p, code)) goto fail;\n#else\n        q = p;\n        ALIGNMENT_RIGHT(q);\n        if (! onig_is_in_code_range(q, code)) goto fail;\n#endif\n      }\n      p += tlen;\n      MOP_OUT;\n      break;\n\n    case OP_CCLASS_MIX:  MOP_IN(OP_CCLASS_MIX);\n      DATA_ENSURE(1);\n      if (ONIGENC_IS_MBC_HEAD(encode, s)) {\n        p += SIZE_BITSET;\n        goto cclass_mb;\n      }\n      else {\n        if (BITSET_AT(((BitSetRef )p), *s) == 0)\n          goto fail;\n\n        p += SIZE_BITSET;\n        GET_LENGTH_INC(tlen, p);\n        p += tlen;\n        s++;\n      }\n      MOP_OUT;\n      break;\n\n    case OP_CCLASS_NOT:  MOP_IN(OP_CCLASS_NOT);\n      DATA_ENSURE(1);\n      if (BITSET_AT(((BitSetRef )p), *s) != 0) goto fail;\n      p += SIZE_BITSET;\n      s += enclen(encode, s);\n      MOP_OUT;\n      break;\n\n    case OP_CCLASS_MB_NOT:  MOP_IN(OP_CCLASS_MB_NOT);\n      DATA_ENSURE(1);\n      if (! ONIGENC_IS_MBC_HEAD(encode, s)) {\n        s++;\n        GET_LENGTH_INC(tlen, p);\n        p += tlen;\n        goto cc_mb_not_success;\n      }\n\n    cclass_mb_not:\n      GET_LENGTH_INC(tlen, p);\n      {\n        OnigCodePoint code;\n        UChar *ss;\n        int mb_len = enclen(encode, s);\n\n        if (! DATA_ENSURE_CHECK(mb_len)) {\n          DATA_ENSURE(1);\n          s = (UChar* )end;\n          p += tlen;\n          goto cc_mb_not_success;\n        }\n\n        ss = s;\n        s += mb_len;\n        code = ONIGENC_MBC_TO_CODE(encode, ss, s);\n\n#ifdef PLATFORM_UNALIGNED_WORD_ACCESS\n        if (onig_is_in_code_range(p, code)) goto fail;\n#else\n        q = p;\n        ALIGNMENT_RIGHT(q);\n        if (onig_is_in_code_range(q, code)) goto fail;\n#endif\n      }\n      p += tlen;\n\n    cc_mb_not_success:\n      MOP_OUT;\n      break;\n\n    case OP_CCLASS_MIX_NOT:  MOP_IN(OP_CCLASS_MIX_NOT);\n      DATA_ENSURE(1);\n      if (ONIGENC_IS_MBC_HEAD(encode, s)) {\n        p += SIZE_BITSET;\n        goto cclass_mb_not;\n      }\n      else {\n        if (BITSET_AT(((BitSetRef )p), *s) != 0)\n          goto fail;\n\n        p += SIZE_BITSET;\n        GET_LENGTH_INC(tlen, p);\n        p += tlen;\n        s++;\n      }\n      MOP_OUT;\n      break;\n\n    case OP_CCLASS_NODE:  MOP_IN(OP_CCLASS_NODE);\n      {\n        OnigCodePoint code;\n        void *node;\n        int mb_len;\n        UChar *ss;\n\n        DATA_ENSURE(1);\n        GET_POINTER_INC(node, p);\n        mb_len = enclen(encode, s);\n        ss = s;\n        s += mb_len;\n        DATA_ENSURE(0);\n        code = ONIGENC_MBC_TO_CODE(encode, ss, s);\n        if (onig_is_code_in_cc_len(mb_len, code, node) == 0) goto fail;\n      }\n      MOP_OUT;\n      break;\n\n    case OP_ANYCHAR:  MOP_IN(OP_ANYCHAR);\n      DATA_ENSURE(1);\n      n = enclen(encode, s);\n      DATA_ENSURE(n);\n      if (ONIGENC_IS_MBC_NEWLINE(encode, s, end)) goto fail;\n      s += n;\n      MOP_OUT;\n      break;\n\n    case OP_ANYCHAR_ML:  MOP_IN(OP_ANYCHAR_ML);\n      DATA_ENSURE(1);\n      n = enclen(encode, s);\n      DATA_ENSURE(n);\n      s += n;\n      MOP_OUT;\n      break;\n\n    case OP_ANYCHAR_STAR:  MOP_IN(OP_ANYCHAR_STAR);\n      while (DATA_ENSURE_CHECK1) {\n        STACK_PUSH_ALT(p, s, sprev);\n        n = enclen(encode, s);\n        DATA_ENSURE(n);\n        if (ONIGENC_IS_MBC_NEWLINE(encode, s, end))  goto fail;\n        sprev = s;\n        s += n;\n      }\n      MOP_OUT;\n      break;\n\n    case OP_ANYCHAR_ML_STAR:  MOP_IN(OP_ANYCHAR_ML_STAR);\n      while (DATA_ENSURE_CHECK1) {\n        STACK_PUSH_ALT(p, s, sprev);\n        n = enclen(encode, s);\n        if (n > 1) {\n          DATA_ENSURE(n);\n          sprev = s;\n          s += n;\n        }\n        else {\n          sprev = s;\n          s++;\n        }\n      }\n      MOP_OUT;\n      break;\n\n    case OP_ANYCHAR_STAR_PEEK_NEXT:  MOP_IN(OP_ANYCHAR_STAR_PEEK_NEXT);\n      while (DATA_ENSURE_CHECK1) {\n        if (*p == *s) {\n          STACK_PUSH_ALT(p + 1, s, sprev);\n        }\n        n = enclen(encode, s);\n        DATA_ENSURE(n);\n        if (ONIGENC_IS_MBC_NEWLINE(encode, s, end))  goto fail;\n        sprev = s;\n        s += n;\n      }\n      p++;\n      MOP_OUT;\n      break;\n\n    case OP_ANYCHAR_ML_STAR_PEEK_NEXT:MOP_IN(OP_ANYCHAR_ML_STAR_PEEK_NEXT);\n      while (DATA_ENSURE_CHECK1) {\n        if (*p == *s) {\n          STACK_PUSH_ALT(p + 1, s, sprev);\n        }\n        n = enclen(encode, s);\n        if (n > 1) {\n          DATA_ENSURE(n);\n          sprev = s;\n          s += n;\n        }\n        else {\n          sprev = s;\n          s++;\n        }\n      }\n      p++;\n      MOP_OUT;\n      break;\n\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n    case OP_STATE_CHECK_ANYCHAR_STAR:  MOP_IN(OP_STATE_CHECK_ANYCHAR_STAR);\n      GET_STATE_CHECK_NUM_INC(mem, p);\n      while (DATA_ENSURE_CHECK1) {\n        STATE_CHECK_VAL(scv, mem);\n        if (scv) goto fail;\n\n        STACK_PUSH_ALT_WITH_STATE_CHECK(p, s, sprev, mem);\n        n = enclen(encode, s);\n        DATA_ENSURE(n);\n        if (ONIGENC_IS_MBC_NEWLINE(encode, s, end))  goto fail;\n        sprev = s;\n        s += n;\n      }\n      MOP_OUT;\n      break;\n\n    case OP_STATE_CHECK_ANYCHAR_ML_STAR:\n      MOP_IN(OP_STATE_CHECK_ANYCHAR_ML_STAR);\n\n      GET_STATE_CHECK_NUM_INC(mem, p);\n      while (DATA_ENSURE_CHECK1) {\n        STATE_CHECK_VAL(scv, mem);\n        if (scv) goto fail;\n\n        STACK_PUSH_ALT_WITH_STATE_CHECK(p, s, sprev, mem);\n        n = enclen(encode, s);\n        if (n > 1) {\n          DATA_ENSURE(n);\n          sprev = s;\n          s += n;\n        }\n        else {\n          sprev = s;\n          s++;\n        }\n      }\n      MOP_OUT;\n      break;\n#endif /* USE_COMBINATION_EXPLOSION_CHECK */\n\n    case OP_WORD:  MOP_IN(OP_WORD);\n      DATA_ENSURE(1);\n      if (! ONIGENC_IS_MBC_WORD(encode, s, end))\n        goto fail;\n\n      s += enclen(encode, s);\n      MOP_OUT;\n      break;\n\n    case OP_NOT_WORD:  MOP_IN(OP_NOT_WORD);\n      DATA_ENSURE(1);\n      if (ONIGENC_IS_MBC_WORD(encode, s, end))\n        goto fail;\n\n      s += enclen(encode, s);\n      MOP_OUT;\n      break;\n\n    case OP_WORD_BOUND:  MOP_IN(OP_WORD_BOUND);\n      if (ON_STR_BEGIN(s)) {\n        DATA_ENSURE(1);\n        if (! ONIGENC_IS_MBC_WORD(encode, s, end))\n          goto fail;\n      }\n      else if (ON_STR_END(s)) {\n        if (! ONIGENC_IS_MBC_WORD(encode, sprev, end))\n          goto fail;\n      }\n      else {\n        if (ONIGENC_IS_MBC_WORD(encode, s, end)\n            == ONIGENC_IS_MBC_WORD(encode, sprev, end))\n          goto fail;\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_NOT_WORD_BOUND:  MOP_IN(OP_NOT_WORD_BOUND);\n      if (ON_STR_BEGIN(s)) {\n        if (DATA_ENSURE_CHECK1 && ONIGENC_IS_MBC_WORD(encode, s, end))\n          goto fail;\n      }\n      else if (ON_STR_END(s)) {\n        if (ONIGENC_IS_MBC_WORD(encode, sprev, end))\n          goto fail;\n      }\n      else {\n        if (ONIGENC_IS_MBC_WORD(encode, s, end)\n            != ONIGENC_IS_MBC_WORD(encode, sprev, end))\n          goto fail;\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n#ifdef USE_WORD_BEGIN_END\n    case OP_WORD_BEGIN:  MOP_IN(OP_WORD_BEGIN);\n      if (DATA_ENSURE_CHECK1 && ONIGENC_IS_MBC_WORD(encode, s, end)) {\n        if (ON_STR_BEGIN(s) || !ONIGENC_IS_MBC_WORD(encode, sprev, end)) {\n          MOP_OUT;\n          continue;\n        }\n      }\n      goto fail;\n      break;\n\n    case OP_WORD_END:  MOP_IN(OP_WORD_END);\n      if (!ON_STR_BEGIN(s) && ONIGENC_IS_MBC_WORD(encode, sprev, end)) {\n        if (ON_STR_END(s) || !ONIGENC_IS_MBC_WORD(encode, s, end)) {\n          MOP_OUT;\n          continue;\n        }\n      }\n      goto fail;\n      break;\n#endif\n\n    case OP_BEGIN_BUF:  MOP_IN(OP_BEGIN_BUF);\n      if (! ON_STR_BEGIN(s)) goto fail;\n\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_END_BUF:  MOP_IN(OP_END_BUF);\n      if (! ON_STR_END(s)) goto fail;\n\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_BEGIN_LINE:  MOP_IN(OP_BEGIN_LINE);\n      if (ON_STR_BEGIN(s)) {\n        if (IS_NOTBOL(msa->options)) goto fail;\n        MOP_OUT;\n        continue;\n      }\n      else if (ONIGENC_IS_MBC_NEWLINE(encode, sprev, end) && !ON_STR_END(s)) {\n        MOP_OUT;\n        continue;\n      }\n      goto fail;\n      break;\n\n    case OP_END_LINE:  MOP_IN(OP_END_LINE);\n      if (ON_STR_END(s)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n        if (IS_EMPTY_STR || !ONIGENC_IS_MBC_NEWLINE(encode, sprev, end)) {\n#endif\n          if (IS_NOTEOL(msa->options)) goto fail;\n          MOP_OUT;\n          continue;\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n        }\n#endif\n      }\n      else if (ONIGENC_IS_MBC_NEWLINE(encode, s, end)) {\n        MOP_OUT;\n        continue;\n      }\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n      else if (ONIGENC_IS_MBC_CRNL(encode, s, end)) {\n        MOP_OUT;\n        continue;\n      }\n#endif\n      goto fail;\n      break;\n\n    case OP_SEMI_END_BUF:  MOP_IN(OP_SEMI_END_BUF);\n      if (ON_STR_END(s)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n        if (IS_EMPTY_STR || !ONIGENC_IS_MBC_NEWLINE(encode, sprev, end)) {\n#endif\n          if (IS_NOTEOL(msa->options)) goto fail;\n          MOP_OUT;\n          continue;\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n        }\n#endif\n      }\n      else if (ONIGENC_IS_MBC_NEWLINE(encode, s, end) &&\n               ON_STR_END(s + enclen(encode, s))) {\n        MOP_OUT;\n        continue;\n      }\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n      else if (ONIGENC_IS_MBC_CRNL(encode, s, end)) {\n        UChar* ss = s + enclen(encode, s);\n        ss += enclen(encode, ss);\n        if (ON_STR_END(ss)) {\n          MOP_OUT;\n          continue;\n        }\n      }\n#endif\n      goto fail;\n      break;\n\n    case OP_BEGIN_POSITION:  MOP_IN(OP_BEGIN_POSITION);\n      if (s != msa->start)\n        goto fail;\n\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_MEMORY_START_PUSH:  MOP_IN(OP_MEMORY_START_PUSH);\n      GET_MEMNUM_INC(mem, p);\n      STACK_PUSH_MEM_START(mem, s);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_MEMORY_START:  MOP_IN(OP_MEMORY_START);\n      GET_MEMNUM_INC(mem, p);\n      mem_start_stk[mem] = (OnigStackIndex )((void* )s);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_MEMORY_END_PUSH:  MOP_IN(OP_MEMORY_END_PUSH);\n      GET_MEMNUM_INC(mem, p);\n      STACK_PUSH_MEM_END(mem, s);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_MEMORY_END:  MOP_IN(OP_MEMORY_END);\n      GET_MEMNUM_INC(mem, p);\n      mem_end_stk[mem] = (OnigStackIndex )((void* )s);\n      MOP_OUT;\n      continue;\n      break;\n\n#ifdef USE_SUBEXP_CALL\n    case OP_MEMORY_END_PUSH_REC:  MOP_IN(OP_MEMORY_END_PUSH_REC);\n      GET_MEMNUM_INC(mem, p);\n      STACK_GET_MEM_START(mem, stkp); /* should be before push mem-end. */\n      STACK_PUSH_MEM_END(mem, s);\n      mem_start_stk[mem] = GET_STACK_INDEX(stkp);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_MEMORY_END_REC:  MOP_IN(OP_MEMORY_END_REC);\n      GET_MEMNUM_INC(mem, p);\n      mem_end_stk[mem] = (OnigStackIndex )((void* )s);\n      STACK_GET_MEM_START(mem, stkp);\n\n      if (BIT_STATUS_AT(reg->bt_mem_start, mem))\n        mem_start_stk[mem] = GET_STACK_INDEX(stkp);\n      else\n        mem_start_stk[mem] = (OnigStackIndex )((void* )stkp->u.mem.pstr);\n\n      STACK_PUSH_MEM_END_MARK(mem);\n      MOP_OUT;\n      continue;\n      break;\n#endif\n\n    case OP_BACKREF1:  MOP_IN(OP_BACKREF1);\n      mem = 1;\n      goto backref;\n      break;\n\n    case OP_BACKREF2:  MOP_IN(OP_BACKREF2);\n      mem = 2;\n      goto backref;\n      break;\n\n    case OP_BACKREFN:  MOP_IN(OP_BACKREFN);\n      GET_MEMNUM_INC(mem, p);\n    backref:\n      {\n        int len;\n        UChar *pstart, *pend;\n\n        /* if you want to remove following line, \n           you should check in parse and compile time. */\n        if (mem > num_mem) goto fail;\n        if (mem_end_stk[mem]   == INVALID_STACK_INDEX) goto fail;\n        if (mem_start_stk[mem] == INVALID_STACK_INDEX) goto fail;\n\n        if (BIT_STATUS_AT(reg->bt_mem_start, mem))\n          pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;\n        else\n          pstart = (UChar* )((void* )mem_start_stk[mem]);\n\n        pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)\n                ? STACK_AT(mem_end_stk[mem])->u.mem.pstr\n                : (UChar* )((void* )mem_end_stk[mem]));\n        n = pend - pstart;\n        DATA_ENSURE(n);\n        sprev = s;\n        STRING_CMP(pstart, s, n);\n        while (sprev + (len = enclen(encode, sprev)) < s)\n          sprev += len;\n\n        MOP_OUT;\n        continue;\n      }\n      break;\n\n    case OP_BACKREFN_IC:  MOP_IN(OP_BACKREFN_IC);\n      GET_MEMNUM_INC(mem, p);\n      {\n        int len;\n        UChar *pstart, *pend;\n\n        /* if you want to remove following line, \n           you should check in parse and compile time. */\n        if (mem > num_mem) goto fail;\n        if (mem_end_stk[mem]   == INVALID_STACK_INDEX) goto fail;\n        if (mem_start_stk[mem] == INVALID_STACK_INDEX) goto fail;\n\n        if (BIT_STATUS_AT(reg->bt_mem_start, mem))\n          pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;\n        else\n          pstart = (UChar* )((void* )mem_start_stk[mem]);\n\n        pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)\n                ? STACK_AT(mem_end_stk[mem])->u.mem.pstr\n                : (UChar* )((void* )mem_end_stk[mem]));\n        n = pend - pstart;\n        DATA_ENSURE(n);\n        sprev = s;\n        STRING_CMP_IC(case_fold_flag, pstart, &s, n);\n        while (sprev + (len = enclen(encode, sprev)) < s)\n          sprev += len;\n\n        MOP_OUT;\n        continue;\n      }\n      break;\n\n    case OP_BACKREF_MULTI:  MOP_IN(OP_BACKREF_MULTI);\n      {\n        int len, is_fail;\n        UChar *pstart, *pend, *swork;\n\n        GET_LENGTH_INC(tlen, p);\n        for (i = 0; i < tlen; i++) {\n          GET_MEMNUM_INC(mem, p);\n\n          if (mem_end_stk[mem]   == INVALID_STACK_INDEX) continue;\n          if (mem_start_stk[mem] == INVALID_STACK_INDEX) continue;\n\n          if (BIT_STATUS_AT(reg->bt_mem_start, mem))\n            pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;\n          else\n            pstart = (UChar* )((void* )mem_start_stk[mem]);\n\n          pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)\n                  ? STACK_AT(mem_end_stk[mem])->u.mem.pstr\n                  : (UChar* )((void* )mem_end_stk[mem]));\n          n = pend - pstart;\n          DATA_ENSURE(n);\n          sprev = s;\n          swork = s;\n          STRING_CMP_VALUE(pstart, swork, n, is_fail);\n          if (is_fail) continue;\n          s = swork;\n          while (sprev + (len = enclen(encode, sprev)) < s)\n            sprev += len;\n\n          p += (SIZE_MEMNUM * (tlen - i - 1));\n          break; /* success */\n        }\n        if (i == tlen) goto fail;\n        MOP_OUT;\n        continue;\n      }\n      break;\n\n    case OP_BACKREF_MULTI_IC:  MOP_IN(OP_BACKREF_MULTI_IC);\n      {\n        int len, is_fail;\n        UChar *pstart, *pend, *swork;\n\n        GET_LENGTH_INC(tlen, p);\n        for (i = 0; i < tlen; i++) {\n          GET_MEMNUM_INC(mem, p);\n\n          if (mem_end_stk[mem]   == INVALID_STACK_INDEX) continue;\n          if (mem_start_stk[mem] == INVALID_STACK_INDEX) continue;\n\n          if (BIT_STATUS_AT(reg->bt_mem_start, mem))\n            pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;\n          else\n            pstart = (UChar* )((void* )mem_start_stk[mem]);\n\n          pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)\n                  ? STACK_AT(mem_end_stk[mem])->u.mem.pstr\n                  : (UChar* )((void* )mem_end_stk[mem]));\n          n = pend - pstart;\n          DATA_ENSURE(n);\n          sprev = s;\n          swork = s;\n          STRING_CMP_VALUE_IC(case_fold_flag, pstart, &swork, n, is_fail);\n          if (is_fail) continue;\n          s = swork;\n          while (sprev + (len = enclen(encode, sprev)) < s)\n            sprev += len;\n\n          p += (SIZE_MEMNUM * (tlen - i - 1));\n          break; /* success */\n        }\n        if (i == tlen) goto fail;\n        MOP_OUT;\n        continue;\n      }\n      break;\n\n#ifdef USE_BACKREF_WITH_LEVEL\n    case OP_BACKREF_WITH_LEVEL:\n      {\n        int len;\n        OnigOptionType ic;\n        LengthType level;\n\n        GET_OPTION_INC(ic,    p);\n        GET_LENGTH_INC(level, p);\n        GET_LENGTH_INC(tlen,  p);\n\n        sprev = s;\n        if (backref_match_at_nested_level(reg, stk, stk_base, ic\n                     , case_fold_flag, (int )level, (int )tlen, p, &s, end)) {\n          while (sprev + (len = enclen(encode, sprev)) < s)\n            sprev += len;\n\n          p += (SIZE_MEMNUM * tlen);\n        }\n        else\n          goto fail;\n\n        MOP_OUT;\n        continue;\n      }\n      break;\n#endif\n\n#if 0   /* no need: IS_DYNAMIC_OPTION() == 0 */\n    case OP_SET_OPTION_PUSH:  MOP_IN(OP_SET_OPTION_PUSH);\n      GET_OPTION_INC(option, p);\n      STACK_PUSH_ALT(p, s, sprev);\n      p += SIZE_OP_SET_OPTION + SIZE_OP_FAIL;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_SET_OPTION:  MOP_IN(OP_SET_OPTION);\n      GET_OPTION_INC(option, p);\n      MOP_OUT;\n      continue;\n      break;\n#endif\n\n    case OP_NULL_CHECK_START:  MOP_IN(OP_NULL_CHECK_START);\n      GET_MEMNUM_INC(mem, p);    /* mem: null check id */\n      STACK_PUSH_NULL_CHECK_START(mem, s);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_NULL_CHECK_END:  MOP_IN(OP_NULL_CHECK_END);\n      {\n        int isnull;\n\n        GET_MEMNUM_INC(mem, p); /* mem: null check id */\n        STACK_NULL_CHECK(isnull, mem, s);\n        if (isnull) {\n#ifdef ONIG_DEBUG_MATCH\n          fprintf(stderr, \"NULL_CHECK_END: skip  id:%d, s:%d\\n\",\n                  (int )mem, (int )s);\n#endif\n        null_check_found:\n          /* empty loop founded, skip next instruction */\n          switch (*p++) {\n          case OP_JUMP:\n          case OP_PUSH:\n            p += SIZE_RELADDR;\n            break;\n          case OP_REPEAT_INC:\n          case OP_REPEAT_INC_NG:\n          case OP_REPEAT_INC_SG:\n          case OP_REPEAT_INC_NG_SG:\n            p += SIZE_MEMNUM;\n            break;\n          default:\n            goto unexpected_bytecode_error;\n            break;\n          }\n        }\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n#ifdef USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT\n    case OP_NULL_CHECK_END_MEMST:  MOP_IN(OP_NULL_CHECK_END_MEMST);\n      {\n        int isnull;\n\n        GET_MEMNUM_INC(mem, p); /* mem: null check id */\n        STACK_NULL_CHECK_MEMST(isnull, mem, s, reg);\n        if (isnull) {\n#ifdef ONIG_DEBUG_MATCH\n          fprintf(stderr, \"NULL_CHECK_END_MEMST: skip  id:%d, s:%d\\n\",\n                  (int )mem, (int )s);\n#endif\n          if (isnull == -1) goto fail;\n          goto \tnull_check_found;\n        }\n      }\n      MOP_OUT;\n      continue;\n      break;\n#endif\n\n#ifdef USE_SUBEXP_CALL\n    case OP_NULL_CHECK_END_MEMST_PUSH:\n      MOP_IN(OP_NULL_CHECK_END_MEMST_PUSH);\n      {\n        int isnull;\n\n        GET_MEMNUM_INC(mem, p); /* mem: null check id */\n#ifdef USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT\n        STACK_NULL_CHECK_MEMST_REC(isnull, mem, s, reg);\n#else\n        STACK_NULL_CHECK_REC(isnull, mem, s);\n#endif\n        if (isnull) {\n#ifdef ONIG_DEBUG_MATCH\n          fprintf(stderr, \"NULL_CHECK_END_MEMST_PUSH: skip  id:%d, s:%d\\n\",\n                  (int )mem, (int )s);\n#endif\n          if (isnull == -1) goto fail;\n          goto \tnull_check_found;\n        }\n        else {\n          STACK_PUSH_NULL_CHECK_END(mem);\n        }\n      }\n      MOP_OUT;\n      continue;\n      break;\n#endif\n\n    case OP_JUMP:  MOP_IN(OP_JUMP);\n      GET_RELADDR_INC(addr, p);\n      p += addr;\n      MOP_OUT;\n      CHECK_INTERRUPT_IN_MATCH_AT;\n      continue;\n      break;\n\n    case OP_PUSH:  MOP_IN(OP_PUSH);\n      GET_RELADDR_INC(addr, p);\n      STACK_PUSH_ALT(p + addr, s, sprev);\n      MOP_OUT;\n      continue;\n      break;\n\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n    case OP_STATE_CHECK_PUSH:  MOP_IN(OP_STATE_CHECK_PUSH);\n      GET_STATE_CHECK_NUM_INC(mem, p);\n      STATE_CHECK_VAL(scv, mem);\n      if (scv) goto fail;\n\n      GET_RELADDR_INC(addr, p);\n      STACK_PUSH_ALT_WITH_STATE_CHECK(p + addr, s, sprev, mem);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_STATE_CHECK_PUSH_OR_JUMP:  MOP_IN(OP_STATE_CHECK_PUSH_OR_JUMP);\n      GET_STATE_CHECK_NUM_INC(mem, p);\n      GET_RELADDR_INC(addr, p);\n      STATE_CHECK_VAL(scv, mem);\n      if (scv) {\n        p += addr;\n      }\n      else {\n        STACK_PUSH_ALT_WITH_STATE_CHECK(p + addr, s, sprev, mem);\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_STATE_CHECK:  MOP_IN(OP_STATE_CHECK);\n      GET_STATE_CHECK_NUM_INC(mem, p);\n      STATE_CHECK_VAL(scv, mem);\n      if (scv) goto fail;\n\n      STACK_PUSH_STATE_CHECK(s, mem);\n      MOP_OUT;\n      continue;\n      break;\n#endif /* USE_COMBINATION_EXPLOSION_CHECK */\n\n    case OP_POP:  MOP_IN(OP_POP);\n      STACK_POP_ONE;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_PUSH_OR_JUMP_EXACT1:  MOP_IN(OP_PUSH_OR_JUMP_EXACT1);\n      GET_RELADDR_INC(addr, p);\n      if (*p == *s && DATA_ENSURE_CHECK1) {\n        p++;\n        STACK_PUSH_ALT(p + addr, s, sprev);\n        MOP_OUT;\n        continue;\n      }\n      p += (addr + 1);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_PUSH_IF_PEEK_NEXT:  MOP_IN(OP_PUSH_IF_PEEK_NEXT);\n      GET_RELADDR_INC(addr, p);\n      if (*p == *s) {\n        p++;\n        STACK_PUSH_ALT(p + addr, s, sprev);\n        MOP_OUT;\n        continue;\n      }\n      p++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_REPEAT:  MOP_IN(OP_REPEAT);\n      {\n        GET_MEMNUM_INC(mem, p);    /* mem: OP_REPEAT ID */\n        GET_RELADDR_INC(addr, p);\n\n        STACK_ENSURE(1);\n        repeat_stk[mem] = GET_STACK_INDEX(stk);\n        STACK_PUSH_REPEAT(mem, p);\n\n        if (reg->repeat_range[mem].lower == 0) {\n          STACK_PUSH_ALT(p + addr, s, sprev);\n        }\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_REPEAT_NG:  MOP_IN(OP_REPEAT_NG);\n      {\n        GET_MEMNUM_INC(mem, p);    /* mem: OP_REPEAT ID */\n        GET_RELADDR_INC(addr, p);\n\n        STACK_ENSURE(1);\n        repeat_stk[mem] = GET_STACK_INDEX(stk);\n        STACK_PUSH_REPEAT(mem, p);\n\n        if (reg->repeat_range[mem].lower == 0) {\n          STACK_PUSH_ALT(p, s, sprev);\n          p += addr;\n        }\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_REPEAT_INC:  MOP_IN(OP_REPEAT_INC);\n      GET_MEMNUM_INC(mem, p); /* mem: OP_REPEAT ID */\n      si = repeat_stk[mem];\n      stkp = STACK_AT(si);\n\n    repeat_inc:\n      stkp->u.repeat.count++;\n      if (stkp->u.repeat.count >= reg->repeat_range[mem].upper) {\n        /* end of repeat. Nothing to do. */\n      }\n      else if (stkp->u.repeat.count >= reg->repeat_range[mem].lower) {\n        STACK_PUSH_ALT(p, s, sprev);\n        p = STACK_AT(si)->u.repeat.pcode; /* Don't use stkp after PUSH. */\n      }\n      else {\n        p = stkp->u.repeat.pcode;\n      }\n      STACK_PUSH_REPEAT_INC(si);\n      MOP_OUT;\n      CHECK_INTERRUPT_IN_MATCH_AT;\n      continue;\n      break;\n\n    case OP_REPEAT_INC_SG:  MOP_IN(OP_REPEAT_INC_SG);\n      GET_MEMNUM_INC(mem, p); /* mem: OP_REPEAT ID */\n      STACK_GET_REPEAT(mem, stkp);\n      si = GET_STACK_INDEX(stkp);\n      goto repeat_inc;\n      break;\n\n    case OP_REPEAT_INC_NG:  MOP_IN(OP_REPEAT_INC_NG);\n      GET_MEMNUM_INC(mem, p); /* mem: OP_REPEAT ID */\n      si = repeat_stk[mem];\n      stkp = STACK_AT(si);\n\n    repeat_inc_ng:\n      stkp->u.repeat.count++;\n      if (stkp->u.repeat.count < reg->repeat_range[mem].upper) {\n        if (stkp->u.repeat.count >= reg->repeat_range[mem].lower) {\n          UChar* pcode = stkp->u.repeat.pcode;\n\n          STACK_PUSH_REPEAT_INC(si);\n          STACK_PUSH_ALT(pcode, s, sprev);\n        }\n        else {\n          p = stkp->u.repeat.pcode;\n          STACK_PUSH_REPEAT_INC(si);\n        }\n      }\n      else if (stkp->u.repeat.count == reg->repeat_range[mem].upper) {\n        STACK_PUSH_REPEAT_INC(si);\n      }\n      MOP_OUT;\n      CHECK_INTERRUPT_IN_MATCH_AT;\n      continue;\n      break;\n\n    case OP_REPEAT_INC_NG_SG:  MOP_IN(OP_REPEAT_INC_NG_SG);\n      GET_MEMNUM_INC(mem, p); /* mem: OP_REPEAT ID */\n      STACK_GET_REPEAT(mem, stkp);\n      si = GET_STACK_INDEX(stkp);\n      goto repeat_inc_ng;\n      break;\n\n    case OP_PUSH_POS:  MOP_IN(OP_PUSH_POS);\n      STACK_PUSH_POS(s, sprev);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_POP_POS:  MOP_IN(OP_POP_POS);\n      {\n        STACK_POS_END(stkp);\n        s     = stkp->u.state.pstr;\n        sprev = stkp->u.state.pstr_prev;\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_PUSH_POS_NOT:  MOP_IN(OP_PUSH_POS_NOT);\n      GET_RELADDR_INC(addr, p);\n      STACK_PUSH_POS_NOT(p + addr, s, sprev);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_FAIL_POS:  MOP_IN(OP_FAIL_POS);\n      STACK_POP_TIL_POS_NOT;\n      goto fail;\n      break;\n\n    case OP_PUSH_STOP_BT:  MOP_IN(OP_PUSH_STOP_BT);\n      STACK_PUSH_STOP_BT;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_POP_STOP_BT:  MOP_IN(OP_POP_STOP_BT);\n      STACK_STOP_BT_END;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_LOOK_BEHIND:  MOP_IN(OP_LOOK_BEHIND);\n      GET_LENGTH_INC(tlen, p);\n      s = (UChar* )ONIGENC_STEP_BACK(encode, str, s, (int )tlen);\n      if (IS_NULL(s)) goto fail;\n      sprev = (UChar* )onigenc_get_prev_char_head(encode, str, s);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_PUSH_LOOK_BEHIND_NOT:  MOP_IN(OP_PUSH_LOOK_BEHIND_NOT);\n      GET_RELADDR_INC(addr, p);\n      GET_LENGTH_INC(tlen, p);\n      q = (UChar* )ONIGENC_STEP_BACK(encode, str, s, (int )tlen);\n      if (IS_NULL(q)) {\n        /* too short case -> success. ex. /(?<!XXX)a/.match(\"a\")\n           If you want to change to fail, replace following line. */\n        p += addr;\n        /* goto fail; */\n      }\n      else {\n        STACK_PUSH_LOOK_BEHIND_NOT(p + addr, s, sprev);\n        s = q;\n        sprev = (UChar* )onigenc_get_prev_char_head(encode, str, s);\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_FAIL_LOOK_BEHIND_NOT:  MOP_IN(OP_FAIL_LOOK_BEHIND_NOT);\n      STACK_POP_TIL_LOOK_BEHIND_NOT;\n      goto fail;\n      break;\n\n#ifdef USE_SUBEXP_CALL\n    case OP_CALL:  MOP_IN(OP_CALL);\n      GET_ABSADDR_INC(addr, p);\n      STACK_PUSH_CALL_FRAME(p);\n      p = reg->p + addr;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_RETURN:  MOP_IN(OP_RETURN);\n      STACK_RETURN(p);\n      STACK_PUSH_RETURN;\n      MOP_OUT;\n      continue;\n      break;\n#endif\n\n    case OP_FINISH:\n      goto finish;\n      break;\n\n    fail:\n      MOP_OUT;\n      /* fall */\n    case OP_FAIL:  MOP_IN(OP_FAIL);\n      STACK_POP;\n      p     = stk->u.state.pcode;\n      s     = stk->u.state.pstr;\n      sprev = stk->u.state.pstr_prev;\n\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n      if (stk->u.state.state_check != 0) {\n        stk->type = STK_STATE_CHECK_MARK;\n        stk++;\n      }\n#endif\n\n      MOP_OUT;\n      continue;\n      break;\n\n    default:\n      goto bytecode_error;\n\n    } /* end of switch */\n    sprev = sbegin;\n  } /* end of while(1) */\n\n finish:\n  STACK_SAVE;\n  return best_len;\n\n#ifdef ONIG_DEBUG\n stack_error:\n  STACK_SAVE;\n  return ONIGERR_STACK_BUG;\n#endif\n\n bytecode_error:\n  STACK_SAVE;\n  return ONIGERR_UNDEFINED_BYTECODE;\n\n unexpected_bytecode_error:\n  STACK_SAVE;\n  return ONIGERR_UNEXPECTED_BYTECODE;\n}", "func_src_after": "match_at(regex_t* reg, const UChar* str, const UChar* end,\n#ifdef USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE\n\t const UChar* right_range,\n#endif\n\t const UChar* sstart, UChar* sprev, OnigMatchArg* msa)\n{\n  static UChar FinishCode[] = { OP_FINISH };\n\n  int i, n, num_mem, best_len, pop_level;\n  LengthType tlen, tlen2;\n  MemNumType mem;\n  RelAddrType addr;\n  UChar *s, *q, *sbegin;\n  int is_alloca;\n  char *alloc_base;\n  OnigStackType *stk_base, *stk, *stk_end;\n  OnigStackType *stkp; /* used as any purpose. */\n  OnigStackIndex si;\n  OnigStackIndex *repeat_stk;\n  OnigStackIndex *mem_start_stk, *mem_end_stk;\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n  int scv;\n  unsigned char* state_check_buff = msa->state_check_buff;\n  int num_comb_exp_check = reg->num_comb_exp_check;\n#endif\n  UChar *p = reg->p;\n  OnigOptionType option = reg->options;\n  OnigEncoding encode = reg->enc;\n  OnigCaseFoldType case_fold_flag = reg->case_fold_flag;\n\n  //n = reg->num_repeat + reg->num_mem * 2;\n  pop_level = reg->stack_pop_level;\n  num_mem = reg->num_mem;\n  STACK_INIT(INIT_MATCH_STACK_SIZE);\n  UPDATE_FOR_STACK_REALLOC;\n  for (i = 1; i <= num_mem; i++) {\n    mem_start_stk[i] = mem_end_stk[i] = INVALID_STACK_INDEX;\n  }\n\n#ifdef ONIG_DEBUG_MATCH\n  fprintf(stderr, \"match_at: str: %d, end: %d, start: %d, sprev: %d\\n\",\n\t  (int )str, (int )end, (int )sstart, (int )sprev);\n  fprintf(stderr, \"size: %d, start offset: %d\\n\",\n\t  (int )(end - str), (int )(sstart - str));\n#endif\n\n  STACK_PUSH_ENSURED(STK_ALT, FinishCode);  /* bottom stack */\n  best_len = ONIG_MISMATCH;\n  s = (UChar* )sstart;\n  while (1) {\n#ifdef ONIG_DEBUG_MATCH\n    {\n      UChar *q, *bp, buf[50];\n      int len;\n      fprintf(stderr, \"%4d> \\\"\", (int )(s - str));\n      bp = buf;\n      for (i = 0, q = s; i < 7 && q < end; i++) {\n\tlen = enclen(encode, q);\n\twhile (len-- > 0) *bp++ = *q++;\n      }\n      if (q < end) { xmemcpy(bp, \"...\\\"\", 4); bp += 4; }\n      else         { xmemcpy(bp, \"\\\"\",    1); bp += 1; }\n      *bp = 0;\n      fputs((char* )buf, stderr);\n      for (i = 0; i < 20 - (bp - buf); i++) fputc(' ', stderr);\n      onig_print_compiled_byte_code(stderr, p, NULL, encode);\n      fprintf(stderr, \"\\n\");\n    }\n#endif\n\n    sbegin = s;\n    switch (*p++) {\n    case OP_END:  MOP_IN(OP_END);\n      n = s - sstart;\n      if (n > best_len) {\n        OnigRegion* region;\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n        if (IS_FIND_LONGEST(option)) {\n          if (n > msa->best_len) {\n            msa->best_len = n;\n            msa->best_s   = (UChar* )sstart;\n          }\n          else\n            goto end_best_len;\n        }\n#endif\n        best_len = n;\n        region = msa->region;\n        if (region) {\n#ifdef USE_POSIX_API_REGION_OPTION\n          if (IS_POSIX_REGION(msa->options)) {\n            posix_regmatch_t* rmt = (posix_regmatch_t* )region;\n\n            rmt[0].rm_so = sstart - str;\n            rmt[0].rm_eo = s      - str;\n            for (i = 1; i <= num_mem; i++) {\n              if (mem_end_stk[i] != INVALID_STACK_INDEX) {\n                if (BIT_STATUS_AT(reg->bt_mem_start, i))\n                  rmt[i].rm_so = STACK_AT(mem_start_stk[i])->u.mem.pstr - str;\n                else\n                  rmt[i].rm_so = (UChar* )((void* )(mem_start_stk[i])) - str;\n\n                rmt[i].rm_eo = (BIT_STATUS_AT(reg->bt_mem_end, i)\n                                ? STACK_AT(mem_end_stk[i])->u.mem.pstr\n                                : (UChar* )((void* )mem_end_stk[i])) - str;\n              }\n              else {\n                rmt[i].rm_so = rmt[i].rm_eo = ONIG_REGION_NOTPOS;\n              }\n            }\n          }\n          else {\n#endif /* USE_POSIX_API_REGION_OPTION */\n            region->beg[0] = sstart - str;\n            region->end[0] = s      - str;\n            for (i = 1; i <= num_mem; i++) {\n              if (mem_end_stk[i] != INVALID_STACK_INDEX) {\n                if (BIT_STATUS_AT(reg->bt_mem_start, i))\n                  region->beg[i] = STACK_AT(mem_start_stk[i])->u.mem.pstr - str;\n                else\n                  region->beg[i] = (UChar* )((void* )mem_start_stk[i]) - str;\n\n                region->end[i] = (BIT_STATUS_AT(reg->bt_mem_end, i)\n                                  ? STACK_AT(mem_end_stk[i])->u.mem.pstr\n                                  : (UChar* )((void* )mem_end_stk[i])) - str;\n              }\n              else {\n                region->beg[i] = region->end[i] = ONIG_REGION_NOTPOS;\n              }\n            }\n\n#ifdef USE_CAPTURE_HISTORY\n            if (reg->capture_history != 0) {\n              int r;\n              OnigCaptureTreeNode* node;\n\n              if (IS_NULL(region->history_root)) {\n                region->history_root = node = history_node_new();\n                CHECK_NULL_RETURN_MEMERR(node);\n              }\n              else {\n                node = region->history_root;\n                history_tree_clear(node);\n              }\n\n              node->group = 0;\n              node->beg   = sstart - str;\n              node->end   = s      - str;\n\n              stkp = stk_base;\n              r = make_capture_history_tree(region->history_root, &stkp,\n                                            stk, (UChar* )str, reg);\n              if (r < 0) {\n                best_len = r; /* error code */\n                goto finish;\n              }\n            }\n#endif /* USE_CAPTURE_HISTORY */\n#ifdef USE_POSIX_API_REGION_OPTION\n          } /* else IS_POSIX_REGION() */\n#endif\n        } /* if (region) */\n      } /* n > best_len */\n\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n    end_best_len:\n#endif\n      MOP_OUT;\n\n      if (IS_FIND_CONDITION(option)) {\n        if (IS_FIND_NOT_EMPTY(option) && s == sstart) {\n          best_len = ONIG_MISMATCH;\n          goto fail; /* for retry */\n        }\n        if (IS_FIND_LONGEST(option) && DATA_ENSURE_CHECK1) {\n          goto fail; /* for retry */\n        }\n      }\n\n      /* default behavior: return first-matching result. */\n      goto finish;\n      break;\n\n    case OP_EXACT1:  MOP_IN(OP_EXACT1);\n      DATA_ENSURE(1);\n      if (*p != *s) goto fail;\n      p++; s++;\n      MOP_OUT;\n      break;\n\n    case OP_EXACT1_IC:  MOP_IN(OP_EXACT1_IC);\n      {\n        int len;\n        UChar *q, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n\n        DATA_ENSURE(1);\n        len = ONIGENC_MBC_CASE_FOLD(encode,\n                 /* DISABLE_CASE_FOLD_MULTI_CHAR(case_fold_flag), */\n                                    case_fold_flag,\n                                    &s, end, lowbuf);\n        DATA_ENSURE(0);\n        q = lowbuf;\n        while (len-- > 0) {\n          if (*p != *q) {\n            goto fail;\n          }\n          p++; q++;\n        }\n      }\n      MOP_OUT;\n      break;\n\n    case OP_EXACT2:  MOP_IN(OP_EXACT2);\n      DATA_ENSURE(2);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      sprev = s;\n      p++; s++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACT3:  MOP_IN(OP_EXACT3);\n      DATA_ENSURE(3);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      sprev = s;\n      p++; s++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACT4:  MOP_IN(OP_EXACT4);\n      DATA_ENSURE(4);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      sprev = s;\n      p++; s++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACT5:  MOP_IN(OP_EXACT5);\n      DATA_ENSURE(5);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      sprev = s;\n      p++; s++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTN:  MOP_IN(OP_EXACTN);\n      GET_LENGTH_INC(tlen, p);\n      DATA_ENSURE(tlen);\n      while (tlen-- > 0) {\n        if (*p++ != *s++) goto fail;\n      }\n      sprev = s - 1;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTN_IC:  MOP_IN(OP_EXACTN_IC);\n      {\n        int len;\n        UChar *q, *endp, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n\n        GET_LENGTH_INC(tlen, p);\n        endp = p + tlen;\n\n        while (p < endp) {\n          sprev = s;\n          DATA_ENSURE(1);\n          len = ONIGENC_MBC_CASE_FOLD(encode,\n                        /* DISABLE_CASE_FOLD_MULTI_CHAR(case_fold_flag), */\n                                      case_fold_flag,\n                                      &s, end, lowbuf);\n          DATA_ENSURE(0);\n          q = lowbuf;\n          while (len-- > 0) {\n            if (*p != *q) goto fail;\n            p++; q++;\n          }\n        }\n      }\n\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTMB2N1:  MOP_IN(OP_EXACTMB2N1);\n      DATA_ENSURE(2);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      MOP_OUT;\n      break;\n\n    case OP_EXACTMB2N2:  MOP_IN(OP_EXACTMB2N2);\n      DATA_ENSURE(4);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      sprev = s;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTMB2N3:  MOP_IN(OP_EXACTMB2N3);\n      DATA_ENSURE(6);\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      sprev = s;\n      if (*p != *s) goto fail;\n      p++; s++;\n      if (*p != *s) goto fail;\n      p++; s++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTMB2N:  MOP_IN(OP_EXACTMB2N);\n      GET_LENGTH_INC(tlen, p);\n      DATA_ENSURE(tlen * 2);\n      while (tlen-- > 0) {\n        if (*p != *s) goto fail;\n        p++; s++;\n        if (*p != *s) goto fail;\n        p++; s++;\n      }\n      sprev = s - 2;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTMB3N:  MOP_IN(OP_EXACTMB3N);\n      GET_LENGTH_INC(tlen, p);\n      DATA_ENSURE(tlen * 3);\n      while (tlen-- > 0) {\n        if (*p != *s) goto fail;\n        p++; s++;\n        if (*p != *s) goto fail;\n        p++; s++;\n        if (*p != *s) goto fail;\n        p++; s++;\n      }\n      sprev = s - 3;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_EXACTMBN:  MOP_IN(OP_EXACTMBN);\n      GET_LENGTH_INC(tlen,  p);  /* mb-len */\n      GET_LENGTH_INC(tlen2, p);  /* string len */\n      tlen2 *= tlen;\n      DATA_ENSURE(tlen2);\n      while (tlen2-- > 0) {\n        if (*p != *s) goto fail;\n        p++; s++;\n      }\n      sprev = s - tlen;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_CCLASS:  MOP_IN(OP_CCLASS);\n      DATA_ENSURE(1);\n      if (BITSET_AT(((BitSetRef )p), *s) == 0) goto fail;\n      p += SIZE_BITSET;\n      s += enclen(encode, s);   /* OP_CCLASS can match mb-code. \\D, \\S */\n      MOP_OUT;\n      break;\n\n    case OP_CCLASS_MB:  MOP_IN(OP_CCLASS_MB);\n      if (! ONIGENC_IS_MBC_HEAD(encode, s)) goto fail;\n\n    cclass_mb:\n      GET_LENGTH_INC(tlen, p);\n      {\n        OnigCodePoint code;\n        UChar *ss;\n        int mb_len;\n\n        DATA_ENSURE(1);\n        mb_len = enclen(encode, s);\n        DATA_ENSURE(mb_len);\n        ss = s;\n        s += mb_len;\n        code = ONIGENC_MBC_TO_CODE(encode, ss, s);\n\n#ifdef PLATFORM_UNALIGNED_WORD_ACCESS\n        if (! onig_is_in_code_range(p, code)) goto fail;\n#else\n        q = p;\n        ALIGNMENT_RIGHT(q);\n        if (! onig_is_in_code_range(q, code)) goto fail;\n#endif\n      }\n      p += tlen;\n      MOP_OUT;\n      break;\n\n    case OP_CCLASS_MIX:  MOP_IN(OP_CCLASS_MIX);\n      DATA_ENSURE(1);\n      if (ONIGENC_IS_MBC_HEAD(encode, s)) {\n        p += SIZE_BITSET;\n        goto cclass_mb;\n      }\n      else {\n        if (BITSET_AT(((BitSetRef )p), *s) == 0)\n          goto fail;\n\n        p += SIZE_BITSET;\n        GET_LENGTH_INC(tlen, p);\n        p += tlen;\n        s++;\n      }\n      MOP_OUT;\n      break;\n\n    case OP_CCLASS_NOT:  MOP_IN(OP_CCLASS_NOT);\n      DATA_ENSURE(1);\n      if (BITSET_AT(((BitSetRef )p), *s) != 0) goto fail;\n      p += SIZE_BITSET;\n      s += enclen(encode, s);\n      MOP_OUT;\n      break;\n\n    case OP_CCLASS_MB_NOT:  MOP_IN(OP_CCLASS_MB_NOT);\n      DATA_ENSURE(1);\n      if (! ONIGENC_IS_MBC_HEAD(encode, s)) {\n        s++;\n        GET_LENGTH_INC(tlen, p);\n        p += tlen;\n        goto cc_mb_not_success;\n      }\n\n    cclass_mb_not:\n      GET_LENGTH_INC(tlen, p);\n      {\n        OnigCodePoint code;\n        UChar *ss;\n        int mb_len = enclen(encode, s);\n\n        if (! DATA_ENSURE_CHECK(mb_len)) {\n          DATA_ENSURE(1);\n          s = (UChar* )end;\n          p += tlen;\n          goto cc_mb_not_success;\n        }\n\n        ss = s;\n        s += mb_len;\n        code = ONIGENC_MBC_TO_CODE(encode, ss, s);\n\n#ifdef PLATFORM_UNALIGNED_WORD_ACCESS\n        if (onig_is_in_code_range(p, code)) goto fail;\n#else\n        q = p;\n        ALIGNMENT_RIGHT(q);\n        if (onig_is_in_code_range(q, code)) goto fail;\n#endif\n      }\n      p += tlen;\n\n    cc_mb_not_success:\n      MOP_OUT;\n      break;\n\n    case OP_CCLASS_MIX_NOT:  MOP_IN(OP_CCLASS_MIX_NOT);\n      DATA_ENSURE(1);\n      if (ONIGENC_IS_MBC_HEAD(encode, s)) {\n        p += SIZE_BITSET;\n        goto cclass_mb_not;\n      }\n      else {\n        if (BITSET_AT(((BitSetRef )p), *s) != 0)\n          goto fail;\n\n        p += SIZE_BITSET;\n        GET_LENGTH_INC(tlen, p);\n        p += tlen;\n        s++;\n      }\n      MOP_OUT;\n      break;\n\n    case OP_CCLASS_NODE:  MOP_IN(OP_CCLASS_NODE);\n      {\n        OnigCodePoint code;\n        void *node;\n        int mb_len;\n        UChar *ss;\n\n        DATA_ENSURE(1);\n        GET_POINTER_INC(node, p);\n        mb_len = enclen(encode, s);\n        ss = s;\n        s += mb_len;\n        DATA_ENSURE(0);\n        code = ONIGENC_MBC_TO_CODE(encode, ss, s);\n        if (onig_is_code_in_cc_len(mb_len, code, node) == 0) goto fail;\n      }\n      MOP_OUT;\n      break;\n\n    case OP_ANYCHAR:  MOP_IN(OP_ANYCHAR);\n      DATA_ENSURE(1);\n      n = enclen(encode, s);\n      DATA_ENSURE(n);\n      if (ONIGENC_IS_MBC_NEWLINE(encode, s, end)) goto fail;\n      s += n;\n      MOP_OUT;\n      break;\n\n    case OP_ANYCHAR_ML:  MOP_IN(OP_ANYCHAR_ML);\n      DATA_ENSURE(1);\n      n = enclen(encode, s);\n      DATA_ENSURE(n);\n      s += n;\n      MOP_OUT;\n      break;\n\n    case OP_ANYCHAR_STAR:  MOP_IN(OP_ANYCHAR_STAR);\n      while (DATA_ENSURE_CHECK1) {\n        STACK_PUSH_ALT(p, s, sprev);\n        n = enclen(encode, s);\n        DATA_ENSURE(n);\n        if (ONIGENC_IS_MBC_NEWLINE(encode, s, end))  goto fail;\n        sprev = s;\n        s += n;\n      }\n      MOP_OUT;\n      break;\n\n    case OP_ANYCHAR_ML_STAR:  MOP_IN(OP_ANYCHAR_ML_STAR);\n      while (DATA_ENSURE_CHECK1) {\n        STACK_PUSH_ALT(p, s, sprev);\n        n = enclen(encode, s);\n        if (n > 1) {\n          DATA_ENSURE(n);\n          sprev = s;\n          s += n;\n        }\n        else {\n          sprev = s;\n          s++;\n        }\n      }\n      MOP_OUT;\n      break;\n\n    case OP_ANYCHAR_STAR_PEEK_NEXT:  MOP_IN(OP_ANYCHAR_STAR_PEEK_NEXT);\n      while (DATA_ENSURE_CHECK1) {\n        if (*p == *s) {\n          STACK_PUSH_ALT(p + 1, s, sprev);\n        }\n        n = enclen(encode, s);\n        DATA_ENSURE(n);\n        if (ONIGENC_IS_MBC_NEWLINE(encode, s, end))  goto fail;\n        sprev = s;\n        s += n;\n      }\n      p++;\n      MOP_OUT;\n      break;\n\n    case OP_ANYCHAR_ML_STAR_PEEK_NEXT:MOP_IN(OP_ANYCHAR_ML_STAR_PEEK_NEXT);\n      while (DATA_ENSURE_CHECK1) {\n        if (*p == *s) {\n          STACK_PUSH_ALT(p + 1, s, sprev);\n        }\n        n = enclen(encode, s);\n        if (n > 1) {\n          DATA_ENSURE(n);\n          sprev = s;\n          s += n;\n        }\n        else {\n          sprev = s;\n          s++;\n        }\n      }\n      p++;\n      MOP_OUT;\n      break;\n\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n    case OP_STATE_CHECK_ANYCHAR_STAR:  MOP_IN(OP_STATE_CHECK_ANYCHAR_STAR);\n      GET_STATE_CHECK_NUM_INC(mem, p);\n      while (DATA_ENSURE_CHECK1) {\n        STATE_CHECK_VAL(scv, mem);\n        if (scv) goto fail;\n\n        STACK_PUSH_ALT_WITH_STATE_CHECK(p, s, sprev, mem);\n        n = enclen(encode, s);\n        DATA_ENSURE(n);\n        if (ONIGENC_IS_MBC_NEWLINE(encode, s, end))  goto fail;\n        sprev = s;\n        s += n;\n      }\n      MOP_OUT;\n      break;\n\n    case OP_STATE_CHECK_ANYCHAR_ML_STAR:\n      MOP_IN(OP_STATE_CHECK_ANYCHAR_ML_STAR);\n\n      GET_STATE_CHECK_NUM_INC(mem, p);\n      while (DATA_ENSURE_CHECK1) {\n        STATE_CHECK_VAL(scv, mem);\n        if (scv) goto fail;\n\n        STACK_PUSH_ALT_WITH_STATE_CHECK(p, s, sprev, mem);\n        n = enclen(encode, s);\n        if (n > 1) {\n          DATA_ENSURE(n);\n          sprev = s;\n          s += n;\n        }\n        else {\n          sprev = s;\n          s++;\n        }\n      }\n      MOP_OUT;\n      break;\n#endif /* USE_COMBINATION_EXPLOSION_CHECK */\n\n    case OP_WORD:  MOP_IN(OP_WORD);\n      DATA_ENSURE(1);\n      if (! ONIGENC_IS_MBC_WORD(encode, s, end))\n        goto fail;\n\n      s += enclen(encode, s);\n      MOP_OUT;\n      break;\n\n    case OP_NOT_WORD:  MOP_IN(OP_NOT_WORD);\n      DATA_ENSURE(1);\n      if (ONIGENC_IS_MBC_WORD(encode, s, end))\n        goto fail;\n\n      s += enclen(encode, s);\n      MOP_OUT;\n      break;\n\n    case OP_WORD_BOUND:  MOP_IN(OP_WORD_BOUND);\n      if (ON_STR_BEGIN(s)) {\n        DATA_ENSURE(1);\n        if (! ONIGENC_IS_MBC_WORD(encode, s, end))\n          goto fail;\n      }\n      else if (ON_STR_END(s)) {\n        if (! ONIGENC_IS_MBC_WORD(encode, sprev, end))\n          goto fail;\n      }\n      else {\n        if (ONIGENC_IS_MBC_WORD(encode, s, end)\n            == ONIGENC_IS_MBC_WORD(encode, sprev, end))\n          goto fail;\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_NOT_WORD_BOUND:  MOP_IN(OP_NOT_WORD_BOUND);\n      if (ON_STR_BEGIN(s)) {\n        if (DATA_ENSURE_CHECK1 && ONIGENC_IS_MBC_WORD(encode, s, end))\n          goto fail;\n      }\n      else if (ON_STR_END(s)) {\n        if (ONIGENC_IS_MBC_WORD(encode, sprev, end))\n          goto fail;\n      }\n      else {\n        if (ONIGENC_IS_MBC_WORD(encode, s, end)\n            != ONIGENC_IS_MBC_WORD(encode, sprev, end))\n          goto fail;\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n#ifdef USE_WORD_BEGIN_END\n    case OP_WORD_BEGIN:  MOP_IN(OP_WORD_BEGIN);\n      if (DATA_ENSURE_CHECK1 && ONIGENC_IS_MBC_WORD(encode, s, end)) {\n        if (ON_STR_BEGIN(s) || !ONIGENC_IS_MBC_WORD(encode, sprev, end)) {\n          MOP_OUT;\n          continue;\n        }\n      }\n      goto fail;\n      break;\n\n    case OP_WORD_END:  MOP_IN(OP_WORD_END);\n      if (!ON_STR_BEGIN(s) && ONIGENC_IS_MBC_WORD(encode, sprev, end)) {\n        if (ON_STR_END(s) || !ONIGENC_IS_MBC_WORD(encode, s, end)) {\n          MOP_OUT;\n          continue;\n        }\n      }\n      goto fail;\n      break;\n#endif\n\n    case OP_BEGIN_BUF:  MOP_IN(OP_BEGIN_BUF);\n      if (! ON_STR_BEGIN(s)) goto fail;\n\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_END_BUF:  MOP_IN(OP_END_BUF);\n      if (! ON_STR_END(s)) goto fail;\n\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_BEGIN_LINE:  MOP_IN(OP_BEGIN_LINE);\n      if (ON_STR_BEGIN(s)) {\n        if (IS_NOTBOL(msa->options)) goto fail;\n        MOP_OUT;\n        continue;\n      }\n      else if (ONIGENC_IS_MBC_NEWLINE(encode, sprev, end) && !ON_STR_END(s)) {\n        MOP_OUT;\n        continue;\n      }\n      goto fail;\n      break;\n\n    case OP_END_LINE:  MOP_IN(OP_END_LINE);\n      if (ON_STR_END(s)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n        if (IS_EMPTY_STR || !ONIGENC_IS_MBC_NEWLINE(encode, sprev, end)) {\n#endif\n          if (IS_NOTEOL(msa->options)) goto fail;\n          MOP_OUT;\n          continue;\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n        }\n#endif\n      }\n      else if (ONIGENC_IS_MBC_NEWLINE(encode, s, end)) {\n        MOP_OUT;\n        continue;\n      }\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n      else if (ONIGENC_IS_MBC_CRNL(encode, s, end)) {\n        MOP_OUT;\n        continue;\n      }\n#endif\n      goto fail;\n      break;\n\n    case OP_SEMI_END_BUF:  MOP_IN(OP_SEMI_END_BUF);\n      if (ON_STR_END(s)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n        if (IS_EMPTY_STR || !ONIGENC_IS_MBC_NEWLINE(encode, sprev, end)) {\n#endif\n          if (IS_NOTEOL(msa->options)) goto fail;\n          MOP_OUT;\n          continue;\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n        }\n#endif\n      }\n      else if (ONIGENC_IS_MBC_NEWLINE(encode, s, end) &&\n               ON_STR_END(s + enclen(encode, s))) {\n        MOP_OUT;\n        continue;\n      }\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n      else if (ONIGENC_IS_MBC_CRNL(encode, s, end)) {\n        UChar* ss = s + enclen(encode, s);\n        ss += enclen(encode, ss);\n        if (ON_STR_END(ss)) {\n          MOP_OUT;\n          continue;\n        }\n      }\n#endif\n      goto fail;\n      break;\n\n    case OP_BEGIN_POSITION:  MOP_IN(OP_BEGIN_POSITION);\n      if (s != msa->start)\n        goto fail;\n\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_MEMORY_START_PUSH:  MOP_IN(OP_MEMORY_START_PUSH);\n      GET_MEMNUM_INC(mem, p);\n      STACK_PUSH_MEM_START(mem, s);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_MEMORY_START:  MOP_IN(OP_MEMORY_START);\n      GET_MEMNUM_INC(mem, p);\n      mem_start_stk[mem] = (OnigStackIndex )((void* )s);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_MEMORY_END_PUSH:  MOP_IN(OP_MEMORY_END_PUSH);\n      GET_MEMNUM_INC(mem, p);\n      STACK_PUSH_MEM_END(mem, s);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_MEMORY_END:  MOP_IN(OP_MEMORY_END);\n      GET_MEMNUM_INC(mem, p);\n      mem_end_stk[mem] = (OnigStackIndex )((void* )s);\n      MOP_OUT;\n      continue;\n      break;\n\n#ifdef USE_SUBEXP_CALL\n    case OP_MEMORY_END_PUSH_REC:  MOP_IN(OP_MEMORY_END_PUSH_REC);\n      GET_MEMNUM_INC(mem, p);\n      STACK_GET_MEM_START(mem, stkp); /* should be before push mem-end. */\n      STACK_PUSH_MEM_END(mem, s);\n      mem_start_stk[mem] = GET_STACK_INDEX(stkp);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_MEMORY_END_REC:  MOP_IN(OP_MEMORY_END_REC);\n      GET_MEMNUM_INC(mem, p);\n      mem_end_stk[mem] = (OnigStackIndex )((void* )s);\n      STACK_GET_MEM_START(mem, stkp);\n\n      if (BIT_STATUS_AT(reg->bt_mem_start, mem))\n        mem_start_stk[mem] = GET_STACK_INDEX(stkp);\n      else\n        mem_start_stk[mem] = (OnigStackIndex )((void* )stkp->u.mem.pstr);\n\n      STACK_PUSH_MEM_END_MARK(mem);\n      MOP_OUT;\n      continue;\n      break;\n#endif\n\n    case OP_BACKREF1:  MOP_IN(OP_BACKREF1);\n      mem = 1;\n      goto backref;\n      break;\n\n    case OP_BACKREF2:  MOP_IN(OP_BACKREF2);\n      mem = 2;\n      goto backref;\n      break;\n\n    case OP_BACKREFN:  MOP_IN(OP_BACKREFN);\n      GET_MEMNUM_INC(mem, p);\n    backref:\n      {\n        int len;\n        UChar *pstart, *pend;\n\n        /* if you want to remove following line, \n           you should check in parse and compile time. */\n        if (mem > num_mem) goto fail;\n        if (mem_end_stk[mem]   == INVALID_STACK_INDEX) goto fail;\n        if (mem_start_stk[mem] == INVALID_STACK_INDEX) goto fail;\n\n        if (BIT_STATUS_AT(reg->bt_mem_start, mem))\n          pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;\n        else\n          pstart = (UChar* )((void* )mem_start_stk[mem]);\n\n        pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)\n                ? STACK_AT(mem_end_stk[mem])->u.mem.pstr\n                : (UChar* )((void* )mem_end_stk[mem]));\n        n = pend - pstart;\n        DATA_ENSURE(n);\n        sprev = s;\n        STRING_CMP(pstart, s, n);\n        while (sprev + (len = enclen(encode, sprev)) < s)\n          sprev += len;\n\n        MOP_OUT;\n        continue;\n      }\n      break;\n\n    case OP_BACKREFN_IC:  MOP_IN(OP_BACKREFN_IC);\n      GET_MEMNUM_INC(mem, p);\n      {\n        int len;\n        UChar *pstart, *pend;\n\n        /* if you want to remove following line, \n           you should check in parse and compile time. */\n        if (mem > num_mem) goto fail;\n        if (mem_end_stk[mem]   == INVALID_STACK_INDEX) goto fail;\n        if (mem_start_stk[mem] == INVALID_STACK_INDEX) goto fail;\n\n        if (BIT_STATUS_AT(reg->bt_mem_start, mem))\n          pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;\n        else\n          pstart = (UChar* )((void* )mem_start_stk[mem]);\n\n        pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)\n                ? STACK_AT(mem_end_stk[mem])->u.mem.pstr\n                : (UChar* )((void* )mem_end_stk[mem]));\n        n = pend - pstart;\n        DATA_ENSURE(n);\n        sprev = s;\n        STRING_CMP_IC(case_fold_flag, pstart, &s, n);\n        while (sprev + (len = enclen(encode, sprev)) < s)\n          sprev += len;\n\n        MOP_OUT;\n        continue;\n      }\n      break;\n\n    case OP_BACKREF_MULTI:  MOP_IN(OP_BACKREF_MULTI);\n      {\n        int len, is_fail;\n        UChar *pstart, *pend, *swork;\n\n        GET_LENGTH_INC(tlen, p);\n        for (i = 0; i < tlen; i++) {\n          GET_MEMNUM_INC(mem, p);\n\n          if (mem_end_stk[mem]   == INVALID_STACK_INDEX) continue;\n          if (mem_start_stk[mem] == INVALID_STACK_INDEX) continue;\n\n          if (BIT_STATUS_AT(reg->bt_mem_start, mem))\n            pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;\n          else\n            pstart = (UChar* )((void* )mem_start_stk[mem]);\n\n          pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)\n                  ? STACK_AT(mem_end_stk[mem])->u.mem.pstr\n                  : (UChar* )((void* )mem_end_stk[mem]));\n          n = pend - pstart;\n          DATA_ENSURE(n);\n          sprev = s;\n          swork = s;\n          STRING_CMP_VALUE(pstart, swork, n, is_fail);\n          if (is_fail) continue;\n          s = swork;\n          while (sprev + (len = enclen(encode, sprev)) < s)\n            sprev += len;\n\n          p += (SIZE_MEMNUM * (tlen - i - 1));\n          break; /* success */\n        }\n        if (i == tlen) goto fail;\n        MOP_OUT;\n        continue;\n      }\n      break;\n\n    case OP_BACKREF_MULTI_IC:  MOP_IN(OP_BACKREF_MULTI_IC);\n      {\n        int len, is_fail;\n        UChar *pstart, *pend, *swork;\n\n        GET_LENGTH_INC(tlen, p);\n        for (i = 0; i < tlen; i++) {\n          GET_MEMNUM_INC(mem, p);\n\n          if (mem_end_stk[mem]   == INVALID_STACK_INDEX) continue;\n          if (mem_start_stk[mem] == INVALID_STACK_INDEX) continue;\n\n          if (BIT_STATUS_AT(reg->bt_mem_start, mem))\n            pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;\n          else\n            pstart = (UChar* )((void* )mem_start_stk[mem]);\n\n          pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)\n                  ? STACK_AT(mem_end_stk[mem])->u.mem.pstr\n                  : (UChar* )((void* )mem_end_stk[mem]));\n          n = pend - pstart;\n          DATA_ENSURE(n);\n          sprev = s;\n          swork = s;\n          STRING_CMP_VALUE_IC(case_fold_flag, pstart, &swork, n, is_fail);\n          if (is_fail) continue;\n          s = swork;\n          while (sprev + (len = enclen(encode, sprev)) < s)\n            sprev += len;\n\n          p += (SIZE_MEMNUM * (tlen - i - 1));\n          break; /* success */\n        }\n        if (i == tlen) goto fail;\n        MOP_OUT;\n        continue;\n      }\n      break;\n\n#ifdef USE_BACKREF_WITH_LEVEL\n    case OP_BACKREF_WITH_LEVEL:\n      {\n        int len;\n        OnigOptionType ic;\n        LengthType level;\n\n        GET_OPTION_INC(ic,    p);\n        GET_LENGTH_INC(level, p);\n        GET_LENGTH_INC(tlen,  p);\n\n        sprev = s;\n        if (backref_match_at_nested_level(reg, stk, stk_base, ic\n                     , case_fold_flag, (int )level, (int )tlen, p, &s, end)) {\n          while (sprev + (len = enclen(encode, sprev)) < s)\n            sprev += len;\n\n          p += (SIZE_MEMNUM * tlen);\n        }\n        else\n          goto fail;\n\n        MOP_OUT;\n        continue;\n      }\n      break;\n#endif\n\n#if 0   /* no need: IS_DYNAMIC_OPTION() == 0 */\n    case OP_SET_OPTION_PUSH:  MOP_IN(OP_SET_OPTION_PUSH);\n      GET_OPTION_INC(option, p);\n      STACK_PUSH_ALT(p, s, sprev);\n      p += SIZE_OP_SET_OPTION + SIZE_OP_FAIL;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_SET_OPTION:  MOP_IN(OP_SET_OPTION);\n      GET_OPTION_INC(option, p);\n      MOP_OUT;\n      continue;\n      break;\n#endif\n\n    case OP_NULL_CHECK_START:  MOP_IN(OP_NULL_CHECK_START);\n      GET_MEMNUM_INC(mem, p);    /* mem: null check id */\n      STACK_PUSH_NULL_CHECK_START(mem, s);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_NULL_CHECK_END:  MOP_IN(OP_NULL_CHECK_END);\n      {\n        int isnull;\n\n        GET_MEMNUM_INC(mem, p); /* mem: null check id */\n        STACK_NULL_CHECK(isnull, mem, s);\n        if (isnull) {\n#ifdef ONIG_DEBUG_MATCH\n          fprintf(stderr, \"NULL_CHECK_END: skip  id:%d, s:%d\\n\",\n                  (int )mem, (int )s);\n#endif\n        null_check_found:\n          /* empty loop founded, skip next instruction */\n          switch (*p++) {\n          case OP_JUMP:\n          case OP_PUSH:\n            p += SIZE_RELADDR;\n            break;\n          case OP_REPEAT_INC:\n          case OP_REPEAT_INC_NG:\n          case OP_REPEAT_INC_SG:\n          case OP_REPEAT_INC_NG_SG:\n            p += SIZE_MEMNUM;\n            break;\n          default:\n            goto unexpected_bytecode_error;\n            break;\n          }\n        }\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n#ifdef USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT\n    case OP_NULL_CHECK_END_MEMST:  MOP_IN(OP_NULL_CHECK_END_MEMST);\n      {\n        int isnull;\n\n        GET_MEMNUM_INC(mem, p); /* mem: null check id */\n        STACK_NULL_CHECK_MEMST(isnull, mem, s, reg);\n        if (isnull) {\n#ifdef ONIG_DEBUG_MATCH\n          fprintf(stderr, \"NULL_CHECK_END_MEMST: skip  id:%d, s:%d\\n\",\n                  (int )mem, (int )s);\n#endif\n          if (isnull == -1) goto fail;\n          goto \tnull_check_found;\n        }\n      }\n      MOP_OUT;\n      continue;\n      break;\n#endif\n\n#ifdef USE_SUBEXP_CALL\n    case OP_NULL_CHECK_END_MEMST_PUSH:\n      MOP_IN(OP_NULL_CHECK_END_MEMST_PUSH);\n      {\n        int isnull;\n\n        GET_MEMNUM_INC(mem, p); /* mem: null check id */\n#ifdef USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT\n        STACK_NULL_CHECK_MEMST_REC(isnull, mem, s, reg);\n#else\n        STACK_NULL_CHECK_REC(isnull, mem, s);\n#endif\n        if (isnull) {\n#ifdef ONIG_DEBUG_MATCH\n          fprintf(stderr, \"NULL_CHECK_END_MEMST_PUSH: skip  id:%d, s:%d\\n\",\n                  (int )mem, (int )s);\n#endif\n          if (isnull == -1) goto fail;\n          goto \tnull_check_found;\n        }\n        else {\n          STACK_PUSH_NULL_CHECK_END(mem);\n        }\n      }\n      MOP_OUT;\n      continue;\n      break;\n#endif\n\n    case OP_JUMP:  MOP_IN(OP_JUMP);\n      GET_RELADDR_INC(addr, p);\n      p += addr;\n      MOP_OUT;\n      CHECK_INTERRUPT_IN_MATCH_AT;\n      continue;\n      break;\n\n    case OP_PUSH:  MOP_IN(OP_PUSH);\n      GET_RELADDR_INC(addr, p);\n      STACK_PUSH_ALT(p + addr, s, sprev);\n      MOP_OUT;\n      continue;\n      break;\n\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n    case OP_STATE_CHECK_PUSH:  MOP_IN(OP_STATE_CHECK_PUSH);\n      GET_STATE_CHECK_NUM_INC(mem, p);\n      STATE_CHECK_VAL(scv, mem);\n      if (scv) goto fail;\n\n      GET_RELADDR_INC(addr, p);\n      STACK_PUSH_ALT_WITH_STATE_CHECK(p + addr, s, sprev, mem);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_STATE_CHECK_PUSH_OR_JUMP:  MOP_IN(OP_STATE_CHECK_PUSH_OR_JUMP);\n      GET_STATE_CHECK_NUM_INC(mem, p);\n      GET_RELADDR_INC(addr, p);\n      STATE_CHECK_VAL(scv, mem);\n      if (scv) {\n        p += addr;\n      }\n      else {\n        STACK_PUSH_ALT_WITH_STATE_CHECK(p + addr, s, sprev, mem);\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_STATE_CHECK:  MOP_IN(OP_STATE_CHECK);\n      GET_STATE_CHECK_NUM_INC(mem, p);\n      STATE_CHECK_VAL(scv, mem);\n      if (scv) goto fail;\n\n      STACK_PUSH_STATE_CHECK(s, mem);\n      MOP_OUT;\n      continue;\n      break;\n#endif /* USE_COMBINATION_EXPLOSION_CHECK */\n\n    case OP_POP:  MOP_IN(OP_POP);\n      STACK_POP_ONE;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_PUSH_OR_JUMP_EXACT1:  MOP_IN(OP_PUSH_OR_JUMP_EXACT1);\n      GET_RELADDR_INC(addr, p);\n      if (*p == *s && DATA_ENSURE_CHECK1) {\n        p++;\n        STACK_PUSH_ALT(p + addr, s, sprev);\n        MOP_OUT;\n        continue;\n      }\n      p += (addr + 1);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_PUSH_IF_PEEK_NEXT:  MOP_IN(OP_PUSH_IF_PEEK_NEXT);\n      GET_RELADDR_INC(addr, p);\n      if (*p == *s) {\n        p++;\n        STACK_PUSH_ALT(p + addr, s, sprev);\n        MOP_OUT;\n        continue;\n      }\n      p++;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_REPEAT:  MOP_IN(OP_REPEAT);\n      {\n        GET_MEMNUM_INC(mem, p);    /* mem: OP_REPEAT ID */\n        GET_RELADDR_INC(addr, p);\n\n        STACK_ENSURE(1);\n        repeat_stk[mem] = GET_STACK_INDEX(stk);\n        STACK_PUSH_REPEAT(mem, p);\n\n        if (reg->repeat_range[mem].lower == 0) {\n          STACK_PUSH_ALT(p + addr, s, sprev);\n        }\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_REPEAT_NG:  MOP_IN(OP_REPEAT_NG);\n      {\n        GET_MEMNUM_INC(mem, p);    /* mem: OP_REPEAT ID */\n        GET_RELADDR_INC(addr, p);\n\n        STACK_ENSURE(1);\n        repeat_stk[mem] = GET_STACK_INDEX(stk);\n        STACK_PUSH_REPEAT(mem, p);\n\n        if (reg->repeat_range[mem].lower == 0) {\n          STACK_PUSH_ALT(p, s, sprev);\n          p += addr;\n        }\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_REPEAT_INC:  MOP_IN(OP_REPEAT_INC);\n      GET_MEMNUM_INC(mem, p); /* mem: OP_REPEAT ID */\n      si = repeat_stk[mem];\n      stkp = STACK_AT(si);\n\n    repeat_inc:\n      stkp->u.repeat.count++;\n      if (stkp->u.repeat.count >= reg->repeat_range[mem].upper) {\n        /* end of repeat. Nothing to do. */\n      }\n      else if (stkp->u.repeat.count >= reg->repeat_range[mem].lower) {\n        STACK_PUSH_ALT(p, s, sprev);\n        p = STACK_AT(si)->u.repeat.pcode; /* Don't use stkp after PUSH. */\n      }\n      else {\n        p = stkp->u.repeat.pcode;\n      }\n      STACK_PUSH_REPEAT_INC(si);\n      MOP_OUT;\n      CHECK_INTERRUPT_IN_MATCH_AT;\n      continue;\n      break;\n\n    case OP_REPEAT_INC_SG:  MOP_IN(OP_REPEAT_INC_SG);\n      GET_MEMNUM_INC(mem, p); /* mem: OP_REPEAT ID */\n      STACK_GET_REPEAT(mem, stkp);\n      si = GET_STACK_INDEX(stkp);\n      goto repeat_inc;\n      break;\n\n    case OP_REPEAT_INC_NG:  MOP_IN(OP_REPEAT_INC_NG);\n      GET_MEMNUM_INC(mem, p); /* mem: OP_REPEAT ID */\n      si = repeat_stk[mem];\n      stkp = STACK_AT(si);\n\n    repeat_inc_ng:\n      stkp->u.repeat.count++;\n      if (stkp->u.repeat.count < reg->repeat_range[mem].upper) {\n        if (stkp->u.repeat.count >= reg->repeat_range[mem].lower) {\n          UChar* pcode = stkp->u.repeat.pcode;\n\n          STACK_PUSH_REPEAT_INC(si);\n          STACK_PUSH_ALT(pcode, s, sprev);\n        }\n        else {\n          p = stkp->u.repeat.pcode;\n          STACK_PUSH_REPEAT_INC(si);\n        }\n      }\n      else if (stkp->u.repeat.count == reg->repeat_range[mem].upper) {\n        STACK_PUSH_REPEAT_INC(si);\n      }\n      MOP_OUT;\n      CHECK_INTERRUPT_IN_MATCH_AT;\n      continue;\n      break;\n\n    case OP_REPEAT_INC_NG_SG:  MOP_IN(OP_REPEAT_INC_NG_SG);\n      GET_MEMNUM_INC(mem, p); /* mem: OP_REPEAT ID */\n      STACK_GET_REPEAT(mem, stkp);\n      si = GET_STACK_INDEX(stkp);\n      goto repeat_inc_ng;\n      break;\n\n    case OP_PUSH_POS:  MOP_IN(OP_PUSH_POS);\n      STACK_PUSH_POS(s, sprev);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_POP_POS:  MOP_IN(OP_POP_POS);\n      {\n        STACK_POS_END(stkp);\n        s     = stkp->u.state.pstr;\n        sprev = stkp->u.state.pstr_prev;\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_PUSH_POS_NOT:  MOP_IN(OP_PUSH_POS_NOT);\n      GET_RELADDR_INC(addr, p);\n      STACK_PUSH_POS_NOT(p + addr, s, sprev);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_FAIL_POS:  MOP_IN(OP_FAIL_POS);\n      STACK_POP_TIL_POS_NOT;\n      goto fail;\n      break;\n\n    case OP_PUSH_STOP_BT:  MOP_IN(OP_PUSH_STOP_BT);\n      STACK_PUSH_STOP_BT;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_POP_STOP_BT:  MOP_IN(OP_POP_STOP_BT);\n      STACK_STOP_BT_END;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_LOOK_BEHIND:  MOP_IN(OP_LOOK_BEHIND);\n      GET_LENGTH_INC(tlen, p);\n      s = (UChar* )ONIGENC_STEP_BACK(encode, str, s, (int )tlen);\n      if (IS_NULL(s)) goto fail;\n      sprev = (UChar* )onigenc_get_prev_char_head(encode, str, s);\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_PUSH_LOOK_BEHIND_NOT:  MOP_IN(OP_PUSH_LOOK_BEHIND_NOT);\n      GET_RELADDR_INC(addr, p);\n      GET_LENGTH_INC(tlen, p);\n      q = (UChar* )ONIGENC_STEP_BACK(encode, str, s, (int )tlen);\n      if (IS_NULL(q)) {\n        /* too short case -> success. ex. /(?<!XXX)a/.match(\"a\")\n           If you want to change to fail, replace following line. */\n        p += addr;\n        /* goto fail; */\n      }\n      else {\n        STACK_PUSH_LOOK_BEHIND_NOT(p + addr, s, sprev);\n        s = q;\n        sprev = (UChar* )onigenc_get_prev_char_head(encode, str, s);\n      }\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_FAIL_LOOK_BEHIND_NOT:  MOP_IN(OP_FAIL_LOOK_BEHIND_NOT);\n      STACK_POP_TIL_LOOK_BEHIND_NOT;\n      goto fail;\n      break;\n\n#ifdef USE_SUBEXP_CALL\n    case OP_CALL:  MOP_IN(OP_CALL);\n      GET_ABSADDR_INC(addr, p);\n      STACK_PUSH_CALL_FRAME(p);\n      p = reg->p + addr;\n      MOP_OUT;\n      continue;\n      break;\n\n    case OP_RETURN:  MOP_IN(OP_RETURN);\n      STACK_RETURN(p);\n      STACK_PUSH_RETURN;\n      MOP_OUT;\n      continue;\n      break;\n#endif\n\n    case OP_FINISH:\n      goto finish;\n      break;\n\n    fail:\n      MOP_OUT;\n      /* fall */\n    case OP_FAIL:  MOP_IN(OP_FAIL);\n      STACK_POP;\n      p     = stk->u.state.pcode;\n      s     = stk->u.state.pstr;\n      sprev = stk->u.state.pstr_prev;\n\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n      if (stk->u.state.state_check != 0) {\n        stk->type = STK_STATE_CHECK_MARK;\n        stk++;\n      }\n#endif\n\n      MOP_OUT;\n      continue;\n      break;\n\n    default:\n      goto bytecode_error;\n\n    } /* end of switch */\n    sprev = sbegin;\n  } /* end of while(1) */\n\n finish:\n  STACK_SAVE;\n  return best_len;\n\n#ifdef ONIG_DEBUG\n stack_error:\n  STACK_SAVE;\n  return ONIGERR_STACK_BUG;\n#endif\n\n bytecode_error:\n  STACK_SAVE;\n  return ONIGERR_UNDEFINED_BYTECODE;\n\n unexpected_bytecode_error:\n  STACK_SAVE;\n  return ONIGERR_UNEXPECTED_BYTECODE;\n}", "commit_link": "github.com/kkos/oniguruma/commit/690313a061f7a4fa614ec5cc8368b4f2284e059b", "file_name": "src/regexec.c", "vul_type": "cwe-125", "description": "Implement a regular expression matching function in C."}
{"func_name": "mpeg4_decode_studio_block", "func_src_before": "static int mpeg4_decode_studio_block(MpegEncContext *s, int32_t block[64], int n)\n{\n    Mpeg4DecContext *ctx = s->avctx->priv_data;\n\n    int cc, dct_dc_size, dct_diff, code, j, idx = 1, group = 0, run = 0,\n        additional_code_len, sign, mismatch;\n    VLC *cur_vlc = &ctx->studio_intra_tab[0];\n    uint8_t *const scantable = s->intra_scantable.permutated;\n    const uint16_t *quant_matrix;\n    uint32_t flc;\n    const int min = -1 *  (1 << (s->avctx->bits_per_raw_sample + 6));\n    const int max =      ((1 << (s->avctx->bits_per_raw_sample + 6)) - 1);\n\n    mismatch = 1;\n\n    memset(block, 0, 64 * sizeof(int32_t));\n\n    if (n < 4) {\n        cc = 0;\n        dct_dc_size = get_vlc2(&s->gb, ctx->studio_luma_dc.table, STUDIO_INTRA_BITS, 2);\n        quant_matrix = s->intra_matrix;\n    } else {\n        cc = (n & 1) + 1;\n        if (ctx->rgb)\n            dct_dc_size = get_vlc2(&s->gb, ctx->studio_luma_dc.table, STUDIO_INTRA_BITS, 2);\n        else\n            dct_dc_size = get_vlc2(&s->gb, ctx->studio_chroma_dc.table, STUDIO_INTRA_BITS, 2);\n        quant_matrix = s->chroma_intra_matrix;\n    }\n\n    if (dct_dc_size < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"illegal dct_dc_size vlc\\n\");\n        return AVERROR_INVALIDDATA;\n    } else if (dct_dc_size == 0) {\n        dct_diff = 0;\n    } else {\n        dct_diff = get_xbits(&s->gb, dct_dc_size);\n\n        if (dct_dc_size > 8) {\n            if(!check_marker(s->avctx, &s->gb, \"dct_dc_size > 8\"))\n                return AVERROR_INVALIDDATA;\n        }\n\n    }\n\n    s->last_dc[cc] += dct_diff;\n\n    if (s->mpeg_quant)\n        block[0] = s->last_dc[cc] * (8 >> s->intra_dc_precision);\n    else\n        block[0] = s->last_dc[cc] * (8 >> s->intra_dc_precision) * (8 >> s->dct_precision);\n    /* TODO: support mpeg_quant for AC coefficients */\n\n    block[0] = av_clip(block[0], min, max);\n    mismatch ^= block[0];\n\n    /* AC Coefficients */\n    while (1) {\n        group = get_vlc2(&s->gb, cur_vlc->table, STUDIO_INTRA_BITS, 2);\n\n        if (group < 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"illegal ac coefficient group vlc\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        additional_code_len = ac_state_tab[group][0];\n        cur_vlc = &ctx->studio_intra_tab[ac_state_tab[group][1]];\n\n        if (group == 0) {\n            /* End of Block */\n            break;\n        } else if (group >= 1 && group <= 6) {\n            /* Zero run length (Table B.47) */\n            run = 1 << additional_code_len;\n            if (additional_code_len)\n                run += get_bits(&s->gb, additional_code_len);\n            idx += run;\n            continue;\n        } else if (group >= 7 && group <= 12) {\n            /* Zero run length and +/-1 level (Table B.48) */\n            code = get_bits(&s->gb, additional_code_len);\n            sign = code & 1;\n            code >>= 1;\n            run = (1 << (additional_code_len - 1)) + code;\n            idx += run;\n            j = scantable[idx++];\n            block[j] = sign ? 1 : -1;\n        } else if (group >= 13 && group <= 20) {\n            /* Level value (Table B.49) */\n            j = scantable[idx++];\n            block[j] = get_xbits(&s->gb, additional_code_len);\n        } else if (group == 21) {\n            /* Escape */\n            j = scantable[idx++];\n            additional_code_len = s->avctx->bits_per_raw_sample + s->dct_precision + 4;\n            flc = get_bits(&s->gb, additional_code_len);\n            if (flc >> (additional_code_len-1))\n                block[j] = -1 * (( flc ^ ((1 << additional_code_len) -1)) + 1);\n            else\n                block[j] = flc;\n        }\n        block[j] = ((8 * 2 * block[j] * quant_matrix[j] * s->qscale) >> s->dct_precision) / 32;\n        block[j] = av_clip(block[j], min, max);\n        mismatch ^= block[j];\n    }\n\n    block[63] ^= mismatch & 1;\n\n    return 0;\n}", "func_src_after": "static int mpeg4_decode_studio_block(MpegEncContext *s, int32_t block[64], int n)\n{\n    Mpeg4DecContext *ctx = s->avctx->priv_data;\n\n    int cc, dct_dc_size, dct_diff, code, j, idx = 1, group = 0, run = 0,\n        additional_code_len, sign, mismatch;\n    VLC *cur_vlc = &ctx->studio_intra_tab[0];\n    uint8_t *const scantable = s->intra_scantable.permutated;\n    const uint16_t *quant_matrix;\n    uint32_t flc;\n    const int min = -1 *  (1 << (s->avctx->bits_per_raw_sample + 6));\n    const int max =      ((1 << (s->avctx->bits_per_raw_sample + 6)) - 1);\n\n    mismatch = 1;\n\n    memset(block, 0, 64 * sizeof(int32_t));\n\n    if (n < 4) {\n        cc = 0;\n        dct_dc_size = get_vlc2(&s->gb, ctx->studio_luma_dc.table, STUDIO_INTRA_BITS, 2);\n        quant_matrix = s->intra_matrix;\n    } else {\n        cc = (n & 1) + 1;\n        if (ctx->rgb)\n            dct_dc_size = get_vlc2(&s->gb, ctx->studio_luma_dc.table, STUDIO_INTRA_BITS, 2);\n        else\n            dct_dc_size = get_vlc2(&s->gb, ctx->studio_chroma_dc.table, STUDIO_INTRA_BITS, 2);\n        quant_matrix = s->chroma_intra_matrix;\n    }\n\n    if (dct_dc_size < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"illegal dct_dc_size vlc\\n\");\n        return AVERROR_INVALIDDATA;\n    } else if (dct_dc_size == 0) {\n        dct_diff = 0;\n    } else {\n        dct_diff = get_xbits(&s->gb, dct_dc_size);\n\n        if (dct_dc_size > 8) {\n            if(!check_marker(s->avctx, &s->gb, \"dct_dc_size > 8\"))\n                return AVERROR_INVALIDDATA;\n        }\n\n    }\n\n    s->last_dc[cc] += dct_diff;\n\n    if (s->mpeg_quant)\n        block[0] = s->last_dc[cc] * (8 >> s->intra_dc_precision);\n    else\n        block[0] = s->last_dc[cc] * (8 >> s->intra_dc_precision) * (8 >> s->dct_precision);\n    /* TODO: support mpeg_quant for AC coefficients */\n\n    block[0] = av_clip(block[0], min, max);\n    mismatch ^= block[0];\n\n    /* AC Coefficients */\n    while (1) {\n        group = get_vlc2(&s->gb, cur_vlc->table, STUDIO_INTRA_BITS, 2);\n\n        if (group < 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"illegal ac coefficient group vlc\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        additional_code_len = ac_state_tab[group][0];\n        cur_vlc = &ctx->studio_intra_tab[ac_state_tab[group][1]];\n\n        if (group == 0) {\n            /* End of Block */\n            break;\n        } else if (group >= 1 && group <= 6) {\n            /* Zero run length (Table B.47) */\n            run = 1 << additional_code_len;\n            if (additional_code_len)\n                run += get_bits(&s->gb, additional_code_len);\n            idx += run;\n            continue;\n        } else if (group >= 7 && group <= 12) {\n            /* Zero run length and +/-1 level (Table B.48) */\n            code = get_bits(&s->gb, additional_code_len);\n            sign = code & 1;\n            code >>= 1;\n            run = (1 << (additional_code_len - 1)) + code;\n            idx += run;\n            if (idx > 63)\n                return AVERROR_INVALIDDATA;\n            j = scantable[idx++];\n            block[j] = sign ? 1 : -1;\n        } else if (group >= 13 && group <= 20) {\n            /* Level value (Table B.49) */\n            if (idx > 63)\n                return AVERROR_INVALIDDATA;\n            j = scantable[idx++];\n            block[j] = get_xbits(&s->gb, additional_code_len);\n        } else if (group == 21) {\n            /* Escape */\n            if (idx > 63)\n                return AVERROR_INVALIDDATA;\n            j = scantable[idx++];\n            additional_code_len = s->avctx->bits_per_raw_sample + s->dct_precision + 4;\n            flc = get_bits(&s->gb, additional_code_len);\n            if (flc >> (additional_code_len-1))\n                block[j] = -1 * (( flc ^ ((1 << additional_code_len) -1)) + 1);\n            else\n                block[j] = flc;\n        }\n        block[j] = ((8 * 2 * block[j] * quant_matrix[j] * s->qscale) >> s->dct_precision) / 32;\n        block[j] = av_clip(block[j], min, max);\n        mismatch ^= block[j];\n    }\n\n    block[63] ^= mismatch & 1;\n\n    return 0;\n}", "commit_link": "github.com/FFmpeg/FFmpeg/commit/d227ed5d598340e719eff7156b1aa0a4469e9a6a", "file_name": "libavcodec/mpeg4videodec.c", "vul_type": "cwe-125", "description": "Write a C function named `mpeg4_decode_studio_block` that decodes a single block of MPEG4 studio profile video."}
{"func_name": "updateLabel", "func_src_before": "\tfunction updateLabel () {\n\t\ttry {\n\t\t\tvar thisId = jQuery('#fb-field-id').val();\n\t\t\tvar thisLabel = jQuery('#fb-new-label').val();\n\t\t\t// Update preview\n\t\t\tif (thisLabel.length === 0) {\n\t\t\t\tjQuery('#fb-new-field' + thisId + ' label .label-text').html(\"New field\");\n\t\t\t} else {\n\t\t\t\tjQuery('#fb-new-field' + thisId + ' label .label-text').html(thisLabel);\n\t\t\t}\n\t\t\t// Update fbForm object\n\t\t\tfbForm.fields[thisId].label = thisLabel;\n\t\t} catch(e) {\n\t\t\tif (debug) {\n\t\t\t\tconsole.log(\"updateLabel(): \" + e);\n\t\t\t}\n\t\t}\n\t}", "func_src_after": "\tfunction updateLabel () {\n\t\ttry {\n\t\t\tvar thisId = jQuery('#fb-field-id').val();\n\t\t\tvar thisLabel = jQuery('#fb-new-label').val();\n\t\t\t// Update preview\n\t\t\tif (thisLabel.length === 0) {\n\t\t\t\tjQuery('#fb-new-field' + thisId + ' label .label-text').text( GrunionFB_i18n.newLabel );\n\t\t\t} else {\n\t\t\t\tjQuery('#fb-new-field' + thisId + ' label .label-text').text( thisLabel );\n\t\t\t}\n\t\t\t// Update fbForm object\n\t\t\tfbForm.fields[thisId].label = thisLabel;\n\t\t} catch(e) {\n\t\t\tif (debug) {\n\t\t\t\tconsole.log(\"updateLabel(): \" + e);\n\t\t\t}\n\t\t}\n\t}", "line_changes": {"deleted": [{"line_no": 7, "char_start": 185, "char_end": 264, "line": "\t\t\t\tjQuery('#fb-new-field' + thisId + ' label .label-text').html(\"New field\");\n"}, {"line_no": 9, "char_start": 276, "char_end": 353, "line": "\t\t\t\tjQuery('#fb-new-field' + thisId + ' label .label-text').html(thisLabel);\n"}], "added": [{"line_no": 7, "char_start": 185, "char_end": 278, "line": "\t\t\t\tjQuery('#fb-new-field' + thisId + ' label .label-text').text( GrunionFB_i18n.newLabel );\n"}, {"line_no": 9, "char_start": 290, "char_end": 369, "line": "\t\t\t\tjQuery('#fb-new-field' + thisId + ' label .label-text').text( thisLabel );\n"}]}, "char_changes": {"deleted": [{"char_start": 245, "char_end": 261, "chars": "html(\"New field\""}, {"char_start": 336, "char_end": 341, "chars": "html("}], "added": [{"char_start": 245, "char_end": 275, "chars": "text( GrunionFB_i18n.newLabel "}, {"char_start": 350, "char_end": 356, "chars": "text( "}, {"char_start": 365, "char_end": 366, "chars": " "}]}, "commit_link": "github.com/iamtakashi/jetpack/commit/970117f93e7ed6eb459ee568259947d67369eec0", "file_name": "grunion.js", "vul_type": "cwe-079", "commit_msg": "Grunion: Fix 2 XSS vulnerabilities.\nPreview of field labels.\nPreview of radio option labels.\nAlso:\nPrevent future potential XSS in feedback message.\nFix i18n\nFix encoding of field labels bug (every preview would add another level of HTML encoding to the label)\nprops @mdawaffe", "description": "Write a JavaScript function using jQuery to update a form label with user input or a default value."}
{"func_name": "next_line", "func_src_before": "next_line(struct archive_read *a,\n    const char **b, ssize_t *avail, ssize_t *ravail, ssize_t *nl)\n{\n\tssize_t len;\n\tint quit;\n\t\n\tquit = 0;\n\tif (*avail == 0) {\n\t\t*nl = 0;\n\t\tlen = 0;\n\t} else\n\t\tlen = get_line_size(*b, *avail, nl);\n\t/*\n\t * Read bytes more while it does not reach the end of line.\n\t */\n\twhile (*nl == 0 && len == *avail && !quit) {\n\t\tssize_t diff = *ravail - *avail;\n\t\tsize_t nbytes_req = (*ravail+1023) & ~1023U;\n\t\tssize_t tested;\n\n\t\t/* Increase reading bytes if it is not enough to at least\n\t\t * new two lines. */\n\t\tif (nbytes_req < (size_t)*ravail + 160)\n\t\t\tnbytes_req <<= 1;\n\n\t\t*b = __archive_read_ahead(a, nbytes_req, avail);\n\t\tif (*b == NULL) {\n\t\t\tif (*ravail >= *avail)\n\t\t\t\treturn (0);\n\t\t\t/* Reading bytes reaches the end of file. */\n\t\t\t*b = __archive_read_ahead(a, *avail, avail);\n\t\t\tquit = 1;\n\t\t}\n\t\t*ravail = *avail;\n\t\t*b += diff;\n\t\t*avail -= diff;\n\t\ttested = len;/* Skip some bytes we already determinated. */\n\t\tlen = get_line_size(*b, *avail, nl);\n\t\tif (len >= 0)\n\t\t\tlen += tested;\n\t}\n\treturn (len);\n}", "func_src_after": "next_line(struct archive_read *a,\n    const char **b, ssize_t *avail, ssize_t *ravail, ssize_t *nl)\n{\n\tssize_t len;\n\tint quit;\n\t\n\tquit = 0;\n\tif (*avail == 0) {\n\t\t*nl = 0;\n\t\tlen = 0;\n\t} else\n\t\tlen = get_line_size(*b, *avail, nl);\n\t/*\n\t * Read bytes more while it does not reach the end of line.\n\t */\n\twhile (*nl == 0 && len == *avail && !quit) {\n\t\tssize_t diff = *ravail - *avail;\n\t\tsize_t nbytes_req = (*ravail+1023) & ~1023U;\n\t\tssize_t tested;\n\n\t\t/* Increase reading bytes if it is not enough to at least\n\t\t * new two lines. */\n\t\tif (nbytes_req < (size_t)*ravail + 160)\n\t\t\tnbytes_req <<= 1;\n\n\t\t*b = __archive_read_ahead(a, nbytes_req, avail);\n\t\tif (*b == NULL) {\n\t\t\tif (*ravail >= *avail)\n\t\t\t\treturn (0);\n\t\t\t/* Reading bytes reaches the end of file. */\n\t\t\t*b = __archive_read_ahead(a, *avail, avail);\n\t\t\tquit = 1;\n\t\t}\n\t\t*ravail = *avail;\n\t\t*b += diff;\n\t\t*avail -= diff;\n\t\ttested = len;/* Skip some bytes we already determinated. */\n\t\tlen = get_line_size(*b + len, *avail - len, nl);\n\t\tif (len >= 0)\n\t\t\tlen += tested;\n\t}\n\treturn (len);\n}", "commit_link": "github.com/libarchive/libarchive/commit/eec077f52bfa2d3f7103b4b74d52572ba8a15aca", "file_name": "libarchive/archive_read_support_format_mtree.c", "vul_type": "cwe-125", "description": "Write a C function named `next_line` that reads the next line from an archive, handling buffer adjustments and end-of-file conditions."}
{"func_name": "merge", "func_src_before": "function merge(source, target) {\n  for (var key in source) {\n    var value = source[key];\n\n    if (typeof value === 'object' && !Array.isArray(value)) {\n      target[key] = merge(value, target[key] || {});\n    } else {\n      target[key] = key in target ? target[key] : value;\n    }\n  }\n\n  return target;\n}", "func_src_after": "function merge(source, target) {\n  for (var key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      var value = source[key];\n\n      if (Object.prototype.hasOwnProperty.call(target, key) && typeof value === 'object' && !Array.isArray(value)) {\n        target[key] = merge(value, target[key] || {});\n      } else {\n        target[key] = key in target ? target[key] : value;\n      }\n    }\n  }\n\n  return target;\n}", "line_changes": {"deleted": [{"line_no": 3, "char_start": 61, "char_end": 90, "line": "    var value = source[key];\n"}, {"line_no": 4, "char_start": 90, "char_end": 91, "line": "\n"}, {"line_no": 5, "char_start": 91, "char_end": 153, "line": "    if (typeof value === 'object' && !Array.isArray(value)) {\n"}, {"line_no": 6, "char_start": 153, "char_end": 206, "line": "      target[key] = merge(value, target[key] || {});\n"}, {"line_no": 7, "char_start": 206, "char_end": 219, "line": "    } else {\n"}, {"line_no": 8, "char_start": 219, "char_end": 276, "line": "      target[key] = key in target ? target[key] : value;\n"}], "added": [{"line_no": 3, "char_start": 61, "char_end": 122, "line": "    if (Object.prototype.hasOwnProperty.call(source, key)) {\n"}, {"line_no": 4, "char_start": 122, "char_end": 153, "line": "      var value = source[key];\n"}, {"line_no": 5, "char_start": 153, "char_end": 154, "line": "\n"}, {"line_no": 6, "char_start": 154, "char_end": 271, "line": "      if (Object.prototype.hasOwnProperty.call(target, key) && typeof value === 'object' && !Array.isArray(value)) {\n"}, {"line_no": 7, "char_start": 271, "char_end": 326, "line": "        target[key] = merge(value, target[key] || {});\n"}, {"line_no": 8, "char_start": 326, "char_end": 341, "line": "      } else {\n"}, {"line_no": 9, "char_start": 341, "char_end": 400, "line": "        target[key] = key in target ? target[key] : value;\n"}, {"line_no": 10, "char_start": 400, "char_end": 408, "line": "      }\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 61, "char_end": 124, "chars": "    if (Object.prototype.hasOwnProperty.call(source, key)) {\n  "}, {"char_start": 158, "char_end": 160, "chars": "  "}, {"char_start": 164, "char_end": 217, "chars": "Object.prototype.hasOwnProperty.call(target, key) && "}, {"char_start": 271, "char_end": 273, "chars": "  "}, {"char_start": 330, "char_end": 332, "chars": "  "}, {"char_start": 341, "char_end": 343, "chars": "  "}, {"char_start": 400, "char_end": 408, "chars": "      }\n"}]}, "commit_link": "github.com/jakubpawlowicz/clean-css/commit/cfa26b15fa6ff69583c502fa464b0b9b3ec88f2d", "file_name": "compatibility.js", "vul_type": "cwe-915", "commit_msg": "compatibility.js: fix prototype pollution", "parent_commit": "e9c05026d25cdeab2788d3133ca7afe6c0861dff", "description": "Write a JavaScript function named `merge` that recursively merges properties from a source object into a target object, without overwriting existing keys unless the value is an object."}
{"func_name": "_startSSL_pyOpenSSL", "func_src_before": "    def _startSSL_pyOpenSSL(self):\n        log.debug(\"_startSSL_pyOpenSSL called\")\n        tcpsock = self._owner\n        # NonBlockingHTTPBOSH instance has no attribute _owner\n        if hasattr(tcpsock, '_owner') and tcpsock._owner._caller.client_cert \\\n        and os.path.exists(tcpsock._owner._caller.client_cert):\n            conn = tcpsock._owner._caller\n            # FIXME make a checkbox for Client Cert / SSLv23 / TLSv1\n            # If we are going to use a client cert/key pair for authentication,\n            # we choose TLSv1 method.\n            tcpsock._sslContext = OpenSSL.SSL.Context(OpenSSL.SSL.TLSv1_METHOD)\n            log.debug('Using client cert and key from %s' % conn.client_cert)\n            try:\n                p12 = OpenSSL.crypto.load_pkcs12(open(conn.client_cert).read(),\n                    conn.client_cert_passphrase)\n            except OpenSSL.crypto.Error, exception_obj:\n                log.warning('Unable to load client pkcs12 certificate from '\n                    'file %s: %s ... Is it a valid PKCS12 cert?' % \\\n                (conn.client_cert, exception_obj.args))\n            except:\n                log.warning('Unknown error while loading certificate from file '\n                    '%s' % conn.client_cert)\n            else:\n                log.info('PKCS12 Client cert loaded OK')\n                try:\n                    tcpsock._sslContext.use_certificate(p12.get_certificate())\n                    tcpsock._sslContext.use_privatekey(p12.get_privatekey())\n                    log.info('p12 cert and key loaded')\n                except OpenSSL.crypto.Error, exception_obj:\n                    log.warning('Unable to extract client certificate from '\n                        'file %s' % conn.client_cert)\n                except Exception, msg:\n                    log.warning('Unknown error extracting client certificate '\n                        'from file %s: %s' % (conn.client_cert, msg))\n                else:\n                    log.info('client cert and key loaded OK')\n        else:\n            # See http://docs.python.org/dev/library/ssl.html\n            tcpsock._sslContext = OpenSSL.SSL.Context(OpenSSL.SSL.SSLv23_METHOD)\n            flags = OpenSSL.SSL.OP_NO_SSLv2\n            try:\n                flags |= OpenSSL.SSL.OP_NO_TICKET\n            except AttributeError, e:\n                # py-OpenSSL < 0.9 or old OpenSSL\n                flags |= 16384\n            tcpsock._sslContext.set_options(flags)\n\n        tcpsock.ssl_errnum = []\n        tcpsock._sslContext.set_verify(OpenSSL.SSL.VERIFY_PEER,\n            self._ssl_verify_callback)\n        tcpsock._sslContext.set_cipher_list('HIGH:!aNULL:!eNULL:RC4-SHA')\n        store = tcpsock._sslContext.get_cert_store()\n        self._load_cert_file(self.cacerts, store)\n        self._load_cert_file(self.mycerts, store)\n        if os.path.isdir('/etc/ssl/certs'):\n            for f in os.listdir('/etc/ssl/certs'):\n                # We don't logg because there is a lot a duplicated certs in this\n                # folder\n                self._load_cert_file(os.path.join('/etc/ssl/certs', f), store,\n                        logg=False)\n\n        tcpsock._sslObj = OpenSSL.SSL.Connection(tcpsock._sslContext,\n                tcpsock._sock)\n        tcpsock._sslObj.set_connect_state() # set to client mode\n        wrapper = PyOpenSSLWrapper(tcpsock._sslObj)\n        tcpsock._recv = wrapper.recv\n        tcpsock._send = wrapper.send\n\n        log.debug(\"Initiating handshake...\")\n        try:\n            tcpsock._sslObj.do_handshake()\n        except (OpenSSL.SSL.WantReadError, OpenSSL.SSL.WantWriteError), e:\n            pass\n        except:\n            log.error('Error while TLS handshake: ', exc_info=True)\n            return False\n        self._owner.ssl_lib = PYOPENSSL\n        return True", "func_src_after": "    def _startSSL_pyOpenSSL(self):\n        log.debug(\"_startSSL_pyOpenSSL called\")\n        tcpsock = self._owner\n        # NonBlockingHTTPBOSH instance has no attribute _owner\n        if hasattr(tcpsock, '_owner') and tcpsock._owner._caller.client_cert \\\n        and os.path.exists(tcpsock._owner._caller.client_cert):\n            conn = tcpsock._owner._caller\n            # FIXME make a checkbox for Client Cert / SSLv23 / TLSv1\n            # If we are going to use a client cert/key pair for authentication,\n            # we choose TLSv1* method.\n            tcpsock._sslContext = OpenSSL.SSL.Context(OpenSSL.SSL.SSLv23_METHOD)\n            flags = (OpenSSL.SSL.OP_NO_SSLv2 | OpenSSL.SSL.OP_NO_SSLv3\n                | OpenSSL.SSL.OP_SINGLE_DH_USE)\n            tcpsock._sslContext.set_options(flags)\n            log.debug('Using client cert and key from %s' % conn.client_cert)\n            try:\n                p12 = OpenSSL.crypto.load_pkcs12(open(conn.client_cert).read(),\n                    conn.client_cert_passphrase)\n            except OpenSSL.crypto.Error, exception_obj:\n                log.warning('Unable to load client pkcs12 certificate from '\n                    'file %s: %s ... Is it a valid PKCS12 cert?' % \\\n                (conn.client_cert, exception_obj.args))\n            except:\n                log.warning('Unknown error while loading certificate from file '\n                    '%s' % conn.client_cert)\n            else:\n                log.info('PKCS12 Client cert loaded OK')\n                try:\n                    tcpsock._sslContext.use_certificate(p12.get_certificate())\n                    tcpsock._sslContext.use_privatekey(p12.get_privatekey())\n                    log.info('p12 cert and key loaded')\n                except OpenSSL.crypto.Error, exception_obj:\n                    log.warning('Unable to extract client certificate from '\n                        'file %s' % conn.client_cert)\n                except Exception, msg:\n                    log.warning('Unknown error extracting client certificate '\n                        'from file %s: %s' % (conn.client_cert, msg))\n                else:\n                    log.info('client cert and key loaded OK')\n        else:\n            # See http://docs.python.org/dev/library/ssl.html\n            tcpsock._sslContext = OpenSSL.SSL.Context(OpenSSL.SSL.SSLv23_METHOD)\n            flags = OpenSSL.SSL.OP_NO_SSLv2 | OpenSSL.SSL.OP_SINGLE_DH_USE\n            try:\n                flags |= OpenSSL.SSL.OP_NO_TICKET\n            except AttributeError, e:\n                # py-OpenSSL < 0.9 or old OpenSSL\n                flags |= 16384\n            tcpsock._sslContext.set_options(flags)\n\n        tcpsock.ssl_errnum = []\n        tcpsock._sslContext.set_verify(OpenSSL.SSL.VERIFY_PEER,\n            self._ssl_verify_callback)\n        tcpsock._sslContext.set_cipher_list('HIGH:!aNULL:!eNULL:RC4-SHA')\n        store = tcpsock._sslContext.get_cert_store()\n        self._load_cert_file(self.cacerts, store)\n        self._load_cert_file(self.mycerts, store)\n        if os.path.isdir('/etc/ssl/certs'):\n            for f in os.listdir('/etc/ssl/certs'):\n                # We don't logg because there is a lot a duplicated certs in this\n                # folder\n                self._load_cert_file(os.path.join('/etc/ssl/certs', f), store,\n                        logg=False)\n\n        tcpsock._sslObj = OpenSSL.SSL.Connection(tcpsock._sslContext,\n                tcpsock._sock)\n        tcpsock._sslObj.set_connect_state() # set to client mode\n        wrapper = PyOpenSSLWrapper(tcpsock._sslObj)\n        tcpsock._recv = wrapper.recv\n        tcpsock._send = wrapper.send\n\n        log.debug(\"Initiating handshake...\")\n        try:\n            tcpsock._sslObj.do_handshake()\n        except (OpenSSL.SSL.WantReadError, OpenSSL.SSL.WantWriteError), e:\n            pass\n        except:\n            log.error('Error while TLS handshake: ', exc_info=True)\n            return False\n        self._owner.ssl_lib = PYOPENSSL\n        return True", "line_changes": {"deleted": [{"line_no": 11, "char_start": 548, "char_end": 628, "line": "            tcpsock._sslContext = OpenSSL.SSL.Context(OpenSSL.SSL.TLSv1_METHOD)\n"}, {"line_no": 40, "char_start": 2184, "char_end": 2228, "line": "            flags = OpenSSL.SSL.OP_NO_SSLv2\n"}], "added": [{"line_no": 11, "char_start": 549, "char_end": 630, "line": "            tcpsock._sslContext = OpenSSL.SSL.Context(OpenSSL.SSL.SSLv23_METHOD)\n"}, {"line_no": 12, "char_start": 630, "char_end": 701, "line": "            flags = (OpenSSL.SSL.OP_NO_SSLv2 | OpenSSL.SSL.OP_NO_SSLv3\n"}, {"line_no": 13, "char_start": 701, "char_end": 749, "line": "                | OpenSSL.SSL.OP_SINGLE_DH_USE)\n"}, {"line_no": 14, "char_start": 749, "char_end": 800, "line": "            tcpsock._sslContext.set_options(flags)\n"}, {"line_no": 43, "char_start": 2356, "char_end": 2431, "line": "            flags = OpenSSL.SSL.OP_NO_SSLv2 | OpenSSL.SSL.OP_SINGLE_DH_USE\n"}]}, "char_changes": {"deleted": [{"char_start": 614, "char_end": 619, "chars": "TLSv1"}], "added": [{"char_start": 539, "char_end": 540, "chars": "*"}, {"char_start": 615, "char_end": 621, "chars": "SSLv23"}, {"char_start": 630, "char_end": 800, "chars": "            flags = (OpenSSL.SSL.OP_NO_SSLv2 | OpenSSL.SSL.OP_NO_SSLv3\n                | OpenSSL.SSL.OP_SINGLE_DH_USE)\n            tcpsock._sslContext.set_options(flags)\n"}, {"char_start": 2399, "char_end": 2430, "chars": " | OpenSSL.SSL.OP_SINGLE_DH_USE"}]}, "commit_link": "github.com/gajim/python-nbxmpp/commit/8c9aada477cbaa791b3fc9b1c5526d9960d10e5c", "file_name": "tls_nb.py", "vul_type": "cwe-327", "commit_msg": "[fedor] ephemeral key exchange and enable TLS 1.1 and TLS 1.2 when connecting using client cert authentification. Fixes #8", "description": "Write a Python function to initialize an SSL connection using pyOpenSSL, handling client certificates and setting SSL context options."}
{"func_name": "_normalize", "func_src_before": "    def _normalize(self, metaerrors):\n        \"\"\"Normalize output format to be usable by Anaconda's linting frontend\n        \"\"\"\n\n        errors = []\n        for error in metaerrors:\n            if self.filepath not in error.get('path', ''):\n                continue\n\n            error_type = error.get('severity', 'X').capitalize()[0]\n            if error_type == 'X':\n                continue\n            if error_type not in ['E', 'W']:\n                error_type = 'V'\n            errors.append({\n                'underline_range': True,\n                'lineno': error.get('line', 0),\n                'offset': error.get('col', 0),\n                'raw_message': error.get('message', ''),\n                'code': 0,\n                'level': error_type,\n                'message': '[{0}] {1} ({2}): {3}'.format(\n                    error_type,\n                    error.get('linter', 'none'),\n                    error.get('severity', 'none'),\n                    error.get('message')\n                )\n            })\n\n        return errors", "func_src_after": "    def _normalize(self, metaerrors):\n        \"\"\"Normalize output format to be usable by Anaconda's linting frontend\n        \"\"\"\n\n        errors = []\n        for error in metaerrors:\n            last_path = os.path.join(\n                os.path.basename(os.path.dirname(self.filepath)),\n                os.path.basename(self.filepath)\n            )\n            if last_path not in error.get('path', ''):\n                continue\n\n            error_type = error.get('severity', 'X').capitalize()[0]\n            if error_type == 'X':\n                continue\n            if error_type not in ['E', 'W']:\n                error_type = 'V'\n            errors.append({\n                'underline_range': True,\n                'lineno': error.get('line', 0),\n                'offset': error.get('col', 0),\n                'raw_message': error.get('message', ''),\n                'code': 0,\n                'level': error_type,\n                'message': '[{0}] {1} ({2}): {3}'.format(\n                    error_type,\n                    error.get('linter', 'none'),\n                    error.get('severity', 'none'),\n                    error.get('message')\n                )\n            })\n\n        return errors", "commit_link": "github.com/DamnWidget/anaconda_go/commit/d3db90bb8853d832927818699591b91f56f6413c", "file_name": "plugin/handlers_go/anagonda/context/gometalinter.py", "vul_type": "cwe-022", "description": "Write a Python function to filter and reformat error metadata for a linting tool's output."}
{"func_name": "add_movie", "func_src_before": "@app.route('/movies/add', methods=['GET', 'POST'])\ndef add_movie():\n    form = MovieForm()\n    if not form.validate_on_submit():\n        return render_template('new_movie.html', title='Add New Movie', form=form)\n    lang_id = add_language(form.data['language'])\n    movie = {\n            'title': '',\n            'description': '',\n            'release_year': 0,\n            'rental_duration': 0,\n            'rental_rate': 0.00,\n            'length': 0,\n            'replacement_cost': 0.00\n        }\n    for k, v in movie.items():\n        movie[k] = form.data[k]\n    movie['language_id'] = movie.get('language_id', lang_id)\n    cur.execute(\n        \"\"\"\n        INSERT INTO film (title, description, release_year, language_id, rental_duration, rental_rate, length, replacement_cost)\n        VALUES ('{}', '{}', {}, {}, {}, {}, {}, {})\n        \"\"\".format(*[v for k, v in movie.items()])\n    )\n    try:\n        cur.execute(f\"SELECT * FROM film where fulltext @@ to_tsquery('Dark Knight')\")\n        res = cur.fetchall()\n        conn.commit()\n        return redirect(url_for('movies'))\n    except Exception as e:\n        return redirect(url_for('index'))", "func_src_after": "@app.route('/movies/add', methods=['GET', 'POST'])\ndef add_movie():\n    form = MovieForm()\n    if not form.validate_on_submit():\n        return render_template('new_movie.html', title='Add New Movie', form=form)\n    lang_id = add_language(form.data['language'])\n    movie = {\n            'title': '',\n            'description': '',\n            'release_year': 0,\n            'rental_duration': 0,\n            'rental_rate': 0.00,\n            'length': 0,\n            'replacement_cost': 0.00\n        }\n    for k, v in movie.items():\n        movie[k] = form.data[k]\n    movie['language_id'] = movie.get('language_id', lang_id)\n    cur.execute(\n        \"\"\"\n        INSERT INTO film (title, description, release_year, language_id, rental_duration, rental_rate, length, replacement_cost)\n        VALUES (%s, %s, %s, %s, %s, %s, %s, %s)\n        \"\"\", [(v, ) for k, v in movie.items()]\n    )\n    try:\n        cur.execute(\"SELECT * FROM film where fulltext @@ to_tsquery(%s)\", (movie['title'], ))\n        res = cur.fetchall()\n        conn.commit()\n        return redirect(url_for('movies'))\n    except Exception as e:\n        return redirect(url_for('index'))", "commit_link": "github.com/Elbertbiggs360/dvdrental/commit/ad144ae2a08a332498d0831bc255170d57ba754b", "file_name": "app.py", "vul_type": "cwe-089", "description": "Write a Python Flask function to add a new movie to the database using form data, with error handling and redirection."}
{"func_name": "dumptable", "func_src_before": "func dumptable(w http.ResponseWriter, r *http.Request, parray []string) {\n\n\tuser, pw := getCredentials(r)\n\tdatabase := parray[0]\n\ttable := parray[1]\n\n\tconn, err := sql.Open(\"mysql\", dsn(user, pw, database))\n\tcheckY(err)\n\tdefer conn.Close()\n\n\tstatement, err := conn.Prepare(\"select * from \" + table)\n\tcheckY(err)\n\n\trows, err := statement.Query()\n\tcheckY(err)\n\tdefer rows.Close()\n\n\tcols, err := rows.Columns()\n\tcheckY(err)\n\tfmt.Fprintln(w, \"<p>\"+\"# \"+strings.Join(cols, \" \")+\"</p>\")\n\n\t/*  credits:\n\t * \thttp://stackoverflow.com/questions/19991541/dumping-mysql-tables-to-json-with-golang\n\t * \thttp://go-database-sql.org/varcols.html\n\t */\n\n\traw := make([]interface{}, len(cols))\n\tval := make([]interface{}, len(cols))\n\n\tfor i := range val {\n\t\traw[i] = &val[i]\n\t}\n\n\tvar n int = 1\n\tfor rows.Next() {\n\n\t\tfmt.Fprint(w, linkDeeper(r.URL.Path, strconv.Itoa(n), strconv.Itoa(n)))\n\t\terr = rows.Scan(raw...)\n\t\tcheckY(err)\n\n\t\tfor _, col := range val {\n\t\t\tif col != nil {\n\t\t\t\tfmt.Fprintf(w, \"%s \", string(col.([]byte)))\n\t\t\t}\n\t\t}\n\t\tfmt.Fprintln(w, \"<br>\")\n\t\tn = n + 1\n\t}\n}", "func_src_after": "func dumptable(w http.ResponseWriter, r *http.Request, parray []string) {\n\n\tuser, pw := getCredentials(r)\n\tdatabase := parray[0]\n\ttable := parray[1]\n\n\tconn, err := sql.Open(\"mysql\", dsn(user, pw, database))\n\tcheckY(err)\n\tdefer conn.Close()\n\n\tstatement, err := conn.Prepare(\"select * from ?\")\n\tcheckY(err)\n\n\trows, err := statement.Query(table)\n\tcheckY(err)\n\tdefer rows.Close()\n\n\tcols, err := rows.Columns()\n\tcheckY(err)\n\tfmt.Fprintln(w, \"<p>\"+\"# \"+strings.Join(cols, \" \")+\"</p>\")\n\n\t/*  credits:\n\t * \thttp://stackoverflow.com/questions/19991541/dumping-mysql-tables-to-json-with-golang\n\t * \thttp://go-database-sql.org/varcols.html\n\t */\n\n\traw := make([]interface{}, len(cols))\n\tval := make([]interface{}, len(cols))\n\n\tfor i := range val {\n\t\traw[i] = &val[i]\n\t}\n\n\tvar n int = 1\n\tfor rows.Next() {\n\n\t\tfmt.Fprint(w, linkDeeper(r.URL.Path, strconv.Itoa(n), strconv.Itoa(n)))\n\t\terr = rows.Scan(raw...)\n\t\tcheckY(err)\n\n\t\tfor _, col := range val {\n\t\t\tif col != nil {\n\t\t\t\tfmt.Fprintf(w, \"%s \", string(col.([]byte)))\n\t\t\t}\n\t\t}\n\t\tfmt.Fprintln(w, \"<br>\")\n\t\tn = n + 1\n\t}\n}", "line_changes": {"deleted": [{"line_no": 11, "char_start": 241, "char_end": 299, "line": "\tstatement, err := conn.Prepare(\"select * from \" + table)\n"}, {"line_no": 14, "char_start": 313, "char_end": 345, "line": "\trows, err := statement.Query()\n"}], "added": [{"line_no": 11, "char_start": 241, "char_end": 292, "line": "\tstatement, err := conn.Prepare(\"select * from ?\")\n"}, {"line_no": 14, "char_start": 306, "char_end": 343, "line": "\trows, err := statement.Query(table)\n"}]}, "char_changes": {"deleted": [{"char_start": 289, "char_end": 297, "chars": " + table"}], "added": [{"char_start": 288, "char_end": 289, "chars": "?"}, {"char_start": 336, "char_end": 341, "chars": "table"}]}, "commit_link": "github.com/gophergala/sqldump/commit/45c8dee2eebc35d73ad47ab3d5f1c7e33fe7dcd7", "file_name": "dump.go", "vul_type": "cwe-089", "commit_msg": "Protection against sql injection via composed queries", "parent_commit": "b4a9927f2ef04729ef3b7df6e8676147161a4183", "description": "Write a Go function to display all records from a specified MySQL table in an HTTP response."}
{"func_name": "TestPlanAnalyzer::getNodeListWithClassNames", "func_src_before": "    private NodeList getNodeListWithClassNames(String path) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            byte[] bytes = overrideXmlVersion(readBytesFromFile(path));\n            Document doc = (bytes == null) ? builder.parse(path) : builder.parse(new ByteArrayInputStream(bytes));\n            XPathFactory xPathfactory = XPathFactory.newInstance();\n            XPath xpath = xPathfactory.newXPath();\n            XPathExpression expr = xpath.compile(\"//*[@guiclass|@testclass]\");\n            return (NodeList) expr.evaluate(doc, XPathConstants.NODESET);\n        } catch (Exception ex) {\n            log.warn(\"Cannot parse file: \" + path, ex);\n            return null;\n        }\n    }", "func_src_after": "    private NodeList getNodeListWithClassNames(String path) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            factory.setXIncludeAware(false);\n            factory.setExpandEntityReferences(false);\n\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            byte[] bytes = overrideXmlVersion(readBytesFromFile(path));\n            Document doc = (bytes == null) ? builder.parse(path) : builder.parse(new ByteArrayInputStream(bytes));\n            XPathFactory xPathfactory = XPathFactory.newInstance();\n            XPath xpath = xPathfactory.newXPath();\n            XPathExpression expr = xpath.compile(\"//*[@guiclass|@testclass]\");\n            return (NodeList) expr.evaluate(doc, XPathConstants.NODESET);\n        } catch (ParserConfigurationException pex) {\n            log.warn(\"Cannot set the required parser config\", pex);\n            return null;\n        } catch (Exception ex) {\n            log.warn(\"Cannot parse file: \" + path, ex);\n            return null;\n        }\n    }", "line_changes": {"deleted": [], "added": [{"line_no": 4, "char_start": 159, "char_end": 253, "line": "            factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n"}, {"line_no": 5, "char_start": 253, "char_end": 358, "line": "            factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n"}, {"line_no": 6, "char_start": 358, "char_end": 403, "line": "            factory.setXIncludeAware(false);\n"}, {"line_no": 7, "char_start": 403, "char_end": 457, "line": "            factory.setExpandEntityReferences(false);\n"}, {"line_no": 8, "char_start": 457, "char_end": 458, "line": "\n"}, {"line_no": 16, "char_start": 985, "char_end": 1038, "line": "        } catch (ParserConfigurationException pex) {\n"}, {"line_no": 17, "char_start": 1038, "char_end": 1106, "line": "            log.warn(\"Cannot set the required parser config\", pex);\n"}, {"line_no": 18, "char_start": 1106, "char_end": 1131, "line": "            return null;\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 159, "char_end": 458, "chars": "            factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            factory.setXIncludeAware(false);\n            factory.setExpandEntityReferences(false);\n\n"}, {"char_start": 985, "char_end": 1131, "chars": "        } catch (ParserConfigurationException pex) {\n            log.warn(\"Cannot set the required parser config\", pex);\n            return null;\n"}]}, "commit_link": "github.com/undera/jmeter-plugins-manager/commit/a820772f1d65542fe45df7136791d3fc04adde59", "file_name": "TestPlanAnalyzer.java", "vul_type": "cwe-611", "commit_msg": "Fix XXE vulnerability", "parent_commit": "060c7853ab87c1764980c90a3190dae65299d4e1", "description": "Write a Java function to parse an XML file at a given path and return a NodeList of elements with specific class attributes."}
{"func_name": "mark_context_stack", "func_src_before": "mark_context_stack(mrb_state *mrb, struct mrb_context *c)\n{\n  size_t i;\n  size_t e;\n\n  if (c->stack == NULL) return;\n  e = c->stack - c->stbase;\n  if (c->ci) e += c->ci->nregs;\n  if (c->stbase + e > c->stend) e = c->stend - c->stbase;\n  for (i=0; i<e; i++) {\n    mrb_value v = c->stbase[i];\n\n    if (!mrb_immediate_p(v)) {\n      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {\n        c->stbase[i] = mrb_nil_value();\n      }\n      else {\n        mrb_gc_mark(mrb, mrb_basic_ptr(v));\n      }\n    }\n  }\n}", "func_src_after": "mark_context_stack(mrb_state *mrb, struct mrb_context *c)\n{\n  size_t i;\n  size_t e;\n  mrb_value nil;\n\n  if (c->stack == NULL) return;\n  e = c->stack - c->stbase;\n  if (c->ci) e += c->ci->nregs;\n  if (c->stbase + e > c->stend) e = c->stend - c->stbase;\n  for (i=0; i<e; i++) {\n    mrb_value v = c->stbase[i];\n\n    if (!mrb_immediate_p(v)) {\n      mrb_gc_mark(mrb, mrb_basic_ptr(v));\n    }\n  }\n  e = c->stend - c->stbase;\n  nil = mrb_nil_value();\n  for (; i<e; i++) {\n    c->stbase[i] = nil;\n  }\n}", "commit_link": "github.com/mruby/mruby/commit/5c114c91d4ff31859fcd84cf8bf349b737b90d99", "file_name": "src/gc.c", "vul_type": "cwe-416", "description": "Write a function in C for the MRuby engine that marks the stack context for garbage collection."}
{"func_name": "_gd2GetHeader", "func_src_before": "static int _gd2GetHeader(gdIOCtxPtr in, int *sx, int *sy, int *cs, int *vers, int *fmt, int *ncx, int *ncy, t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG(php_gd_error(\"Reading gd2 header info\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC(in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tid[i] = ch;\n\t}\n\tid[4] = 0;\n\n\tGD2_DBG(php_gd_error(\"Got file code: %s\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp(id, GD2_ID) != 0) {\n\t\tGD2_DBG(php_gd_error(\"Not a valid gd2 file\"));\n\t\tgoto fail1;\n\t}\n\n\t/* Version */\n\tif (gdGetWord(vers, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Version: %d\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG(php_gd_error(\"Bad version: %d\", *vers));\n\t\tgoto fail1;\n\t}\n\n\t/* Image Size */\n\tif (!gdGetWord(sx, in)) {\n\t\tGD2_DBG(php_gd_error(\"Could not get x-size\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord(sy, in)) {\n\t\tGD2_DBG(php_gd_error(\"Could not get y-size\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Image is %dx%d\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord(cs, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"ChunkSize: %d\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG(php_gd_error(\"Bad chunk size: %d\", *cs));\n\t\tgoto fail1;\n\t}\n\n\t/* Data Format */\n\tif (gdGetWord(fmt, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Format: %d\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) && (*fmt != GD2_FMT_TRUECOLOR_RAW) && (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG(php_gd_error(\"Bad data format: %d\", *fmt));\n\t\tgoto fail1;\n\t}\n\n\t/* # of chunks wide */\n\tif (gdGetWord(ncx, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"%d Chunks Wide\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord(ncy, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"%d Chunks vertically\", *ncy));\n\n\tif (gd2_compressed(*fmt)) {\n\t\tnc = (*ncx) * (*ncy);\n\t\tGD2_DBG(php_gd_error(\"Reading %d chunk index entries\", nc));\n\t\tsidx = sizeof(t_chunk_info) * nc;\n\t\tif (sidx <= 0) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tcidx = gdCalloc(sidx, 1);\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt(&cidx[i].offset, in) != 1) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t\tif (gdGetInt(&cidx[i].size, in) != 1) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t\tif (cidx[i].offset < 0 || cidx[i].size < 0) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t}\n\t\t*chunkIdx = cidx;\n\t}\n\n\tGD2_DBG(php_gd_error(\"gd2 header complete\"));\n\n\treturn 1;\n\nfail1:\n\treturn 0;\n}", "func_src_after": "static int _gd2GetHeader(gdIOCtxPtr in, int *sx, int *sy, int *cs, int *vers, int *fmt, int *ncx, int *ncy, t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG(php_gd_error(\"Reading gd2 header info\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC(in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tid[i] = ch;\n\t}\n\tid[4] = 0;\n\n\tGD2_DBG(php_gd_error(\"Got file code: %s\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp(id, GD2_ID) != 0) {\n\t\tGD2_DBG(php_gd_error(\"Not a valid gd2 file\"));\n\t\tgoto fail1;\n\t}\n\n\t/* Version */\n\tif (gdGetWord(vers, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Version: %d\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG(php_gd_error(\"Bad version: %d\", *vers));\n\t\tgoto fail1;\n\t}\n\n\t/* Image Size */\n\tif (!gdGetWord(sx, in)) {\n\t\tGD2_DBG(php_gd_error(\"Could not get x-size\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord(sy, in)) {\n\t\tGD2_DBG(php_gd_error(\"Could not get y-size\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Image is %dx%d\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord(cs, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"ChunkSize: %d\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG(php_gd_error(\"Bad chunk size: %d\", *cs));\n\t\tgoto fail1;\n\t}\n\n\t/* Data Format */\n\tif (gdGetWord(fmt, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Format: %d\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) && (*fmt != GD2_FMT_TRUECOLOR_RAW) && (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG(php_gd_error(\"Bad data format: %d\", *fmt));\n\t\tgoto fail1;\n\t}\n\n\t/* # of chunks wide */\n\tif (gdGetWord(ncx, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"%d Chunks Wide\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord(ncy, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"%d Chunks vertically\", *ncy));\n\n\tif (gd2_compressed(*fmt)) {\n\t\tnc = (*ncx) * (*ncy);\n\t\tGD2_DBG(php_gd_error(\"Reading %d chunk index entries\", nc));\n\t\tif (overflow2(sidx, nc)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tsidx = sizeof(t_chunk_info) * nc;\n\t\tif (sidx <= 0) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tcidx = gdCalloc(sidx, 1);\n\t\tif (cidx == NULL) {\n\t\t\tgoto fail1;\n\t\t}\n\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt(&cidx[i].offset, in) != 1) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t\tif (gdGetInt(&cidx[i].size, in) != 1) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t\tif (cidx[i].offset < 0 || cidx[i].size < 0) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t}\n\t\t*chunkIdx = cidx;\n\t}\n\n\tGD2_DBG(php_gd_error(\"gd2 header complete\"));\n\n\treturn 1;\n\nfail1:\n\treturn 0;\n}", "commit_link": "github.com/php/php-src/commit/7722455726bec8c53458a32851d2a87982cf0eac", "file_name": "ext/gd/libgd/gd_gd2.c", "vul_type": "cwe-190", "description": "Write a C function to read and validate the header of a GD2 image file."}
{"func_name": "kvm_vm_ioctl_check_extension", "func_src_before": "int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)\n{\n\tint r;\n\t/* Assume we're using HV mode when the HV module is loaded */\n\tint hv_enabled = kvmppc_hv_ops ? 1 : 0;\n\n\tif (kvm) {\n\t\t/*\n\t\t * Hooray - we know which VM type we're running on. Depend on\n\t\t * that rather than the guess above.\n\t\t */\n\t\thv_enabled = is_kvmppc_hv_enabled(kvm);\n\t}\n\n\tswitch (ext) {\n#ifdef CONFIG_BOOKE\n\tcase KVM_CAP_PPC_BOOKE_SREGS:\n\tcase KVM_CAP_PPC_BOOKE_WATCHDOG:\n\tcase KVM_CAP_PPC_EPR:\n#else\n\tcase KVM_CAP_PPC_SEGSTATE:\n\tcase KVM_CAP_PPC_HIOR:\n\tcase KVM_CAP_PPC_PAPR:\n#endif\n\tcase KVM_CAP_PPC_UNSET_IRQ:\n\tcase KVM_CAP_PPC_IRQ_LEVEL:\n\tcase KVM_CAP_ENABLE_CAP:\n\tcase KVM_CAP_ENABLE_CAP_VM:\n\tcase KVM_CAP_ONE_REG:\n\tcase KVM_CAP_IOEVENTFD:\n\tcase KVM_CAP_DEVICE_CTRL:\n\tcase KVM_CAP_IMMEDIATE_EXIT:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_PPC_PAIRED_SINGLES:\n\tcase KVM_CAP_PPC_OSI:\n\tcase KVM_CAP_PPC_GET_PVINFO:\n#if defined(CONFIG_KVM_E500V2) || defined(CONFIG_KVM_E500MC)\n\tcase KVM_CAP_SW_TLB:\n#endif\n\t\t/* We support this only for PR */\n\t\tr = !hv_enabled;\n\t\tbreak;\n#ifdef CONFIG_KVM_MPIC\n\tcase KVM_CAP_IRQ_MPIC:\n\t\tr = 1;\n\t\tbreak;\n#endif\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\tcase KVM_CAP_SPAPR_TCE:\n\tcase KVM_CAP_SPAPR_TCE_64:\n\t\t/* fallthrough */\n\tcase KVM_CAP_SPAPR_TCE_VFIO:\n\tcase KVM_CAP_PPC_RTAS:\n\tcase KVM_CAP_PPC_FIXUP_HCALL:\n\tcase KVM_CAP_PPC_ENABLE_HCALL:\n#ifdef CONFIG_KVM_XICS\n\tcase KVM_CAP_IRQ_XICS:\n#endif\n\t\tr = 1;\n\t\tbreak;\n\n\tcase KVM_CAP_PPC_ALLOC_HTAB:\n\t\tr = hv_enabled;\n\t\tbreak;\n#endif /* CONFIG_PPC_BOOK3S_64 */\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\tcase KVM_CAP_PPC_SMT:\n\t\tr = 0;\n\t\tif (kvm) {\n\t\t\tif (kvm->arch.emul_smt_mode > 1)\n\t\t\t\tr = kvm->arch.emul_smt_mode;\n\t\t\telse\n\t\t\t\tr = kvm->arch.smt_mode;\n\t\t} else if (hv_enabled) {\n\t\t\tif (cpu_has_feature(CPU_FTR_ARCH_300))\n\t\t\t\tr = 1;\n\t\t\telse\n\t\t\t\tr = threads_per_subcore;\n\t\t}\n\t\tbreak;\n\tcase KVM_CAP_PPC_SMT_POSSIBLE:\n\t\tr = 1;\n\t\tif (hv_enabled) {\n\t\t\tif (!cpu_has_feature(CPU_FTR_ARCH_300))\n\t\t\t\tr = ((threads_per_subcore << 1) - 1);\n\t\t\telse\n\t\t\t\t/* P9 can emulate dbells, so allow any mode */\n\t\t\t\tr = 8 | 4 | 2 | 1;\n\t\t}\n\t\tbreak;\n\tcase KVM_CAP_PPC_RMA:\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_PPC_HWRNG:\n\t\tr = kvmppc_hwrng_present();\n\t\tbreak;\n\tcase KVM_CAP_PPC_MMU_RADIX:\n\t\tr = !!(hv_enabled && radix_enabled());\n\t\tbreak;\n\tcase KVM_CAP_PPC_MMU_HASH_V3:\n\t\tr = !!(hv_enabled && !radix_enabled() &&\n\t\t       cpu_has_feature(CPU_FTR_ARCH_300));\n\t\tbreak;\n#endif\n\tcase KVM_CAP_SYNC_MMU:\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\t\tr = hv_enabled;\n#elif defined(KVM_ARCH_WANT_MMU_NOTIFIER)\n\t\tr = 1;\n#else\n\t\tr = 0;\n#endif\n\t\tbreak;\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\tcase KVM_CAP_PPC_HTAB_FD:\n\t\tr = hv_enabled;\n\t\tbreak;\n#endif\n\tcase KVM_CAP_NR_VCPUS:\n\t\t/*\n\t\t * Recommending a number of CPUs is somewhat arbitrary; we\n\t\t * return the number of present CPUs for -HV (since a host\n\t\t * will have secondary threads \"offline\"), and for other KVM\n\t\t * implementations just count online CPUs.\n\t\t */\n\t\tif (hv_enabled)\n\t\t\tr = num_present_cpus();\n\t\telse\n\t\t\tr = num_online_cpus();\n\t\tbreak;\n\tcase KVM_CAP_NR_MEMSLOTS:\n\t\tr = KVM_USER_MEM_SLOTS;\n\t\tbreak;\n\tcase KVM_CAP_MAX_VCPUS:\n\t\tr = KVM_MAX_VCPUS;\n\t\tbreak;\n#ifdef CONFIG_PPC_BOOK3S_64\n\tcase KVM_CAP_PPC_GET_SMMU_INFO:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_SPAPR_MULTITCE:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_SPAPR_RESIZE_HPT:\n\t\t/* Disable this on POWER9 until code handles new HPTE format */\n\t\tr = !!hv_enabled && !cpu_has_feature(CPU_FTR_ARCH_300);\n\t\tbreak;\n#endif\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\tcase KVM_CAP_PPC_FWNMI:\n\t\tr = hv_enabled;\n\t\tbreak;\n#endif\n\tcase KVM_CAP_PPC_HTM:\n\t\tr = cpu_has_feature(CPU_FTR_TM_COMP) &&\n\t\t    is_kvmppc_hv_enabled(kvm);\n\t\tbreak;\n\tdefault:\n\t\tr = 0;\n\t\tbreak;\n\t}\n\treturn r;\n\n}", "func_src_after": "int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)\n{\n\tint r;\n\t/* Assume we're using HV mode when the HV module is loaded */\n\tint hv_enabled = kvmppc_hv_ops ? 1 : 0;\n\n\tif (kvm) {\n\t\t/*\n\t\t * Hooray - we know which VM type we're running on. Depend on\n\t\t * that rather than the guess above.\n\t\t */\n\t\thv_enabled = is_kvmppc_hv_enabled(kvm);\n\t}\n\n\tswitch (ext) {\n#ifdef CONFIG_BOOKE\n\tcase KVM_CAP_PPC_BOOKE_SREGS:\n\tcase KVM_CAP_PPC_BOOKE_WATCHDOG:\n\tcase KVM_CAP_PPC_EPR:\n#else\n\tcase KVM_CAP_PPC_SEGSTATE:\n\tcase KVM_CAP_PPC_HIOR:\n\tcase KVM_CAP_PPC_PAPR:\n#endif\n\tcase KVM_CAP_PPC_UNSET_IRQ:\n\tcase KVM_CAP_PPC_IRQ_LEVEL:\n\tcase KVM_CAP_ENABLE_CAP:\n\tcase KVM_CAP_ENABLE_CAP_VM:\n\tcase KVM_CAP_ONE_REG:\n\tcase KVM_CAP_IOEVENTFD:\n\tcase KVM_CAP_DEVICE_CTRL:\n\tcase KVM_CAP_IMMEDIATE_EXIT:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_PPC_PAIRED_SINGLES:\n\tcase KVM_CAP_PPC_OSI:\n\tcase KVM_CAP_PPC_GET_PVINFO:\n#if defined(CONFIG_KVM_E500V2) || defined(CONFIG_KVM_E500MC)\n\tcase KVM_CAP_SW_TLB:\n#endif\n\t\t/* We support this only for PR */\n\t\tr = !hv_enabled;\n\t\tbreak;\n#ifdef CONFIG_KVM_MPIC\n\tcase KVM_CAP_IRQ_MPIC:\n\t\tr = 1;\n\t\tbreak;\n#endif\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\tcase KVM_CAP_SPAPR_TCE:\n\tcase KVM_CAP_SPAPR_TCE_64:\n\t\t/* fallthrough */\n\tcase KVM_CAP_SPAPR_TCE_VFIO:\n\tcase KVM_CAP_PPC_RTAS:\n\tcase KVM_CAP_PPC_FIXUP_HCALL:\n\tcase KVM_CAP_PPC_ENABLE_HCALL:\n#ifdef CONFIG_KVM_XICS\n\tcase KVM_CAP_IRQ_XICS:\n#endif\n\t\tr = 1;\n\t\tbreak;\n\n\tcase KVM_CAP_PPC_ALLOC_HTAB:\n\t\tr = hv_enabled;\n\t\tbreak;\n#endif /* CONFIG_PPC_BOOK3S_64 */\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\tcase KVM_CAP_PPC_SMT:\n\t\tr = 0;\n\t\tif (kvm) {\n\t\t\tif (kvm->arch.emul_smt_mode > 1)\n\t\t\t\tr = kvm->arch.emul_smt_mode;\n\t\t\telse\n\t\t\t\tr = kvm->arch.smt_mode;\n\t\t} else if (hv_enabled) {\n\t\t\tif (cpu_has_feature(CPU_FTR_ARCH_300))\n\t\t\t\tr = 1;\n\t\t\telse\n\t\t\t\tr = threads_per_subcore;\n\t\t}\n\t\tbreak;\n\tcase KVM_CAP_PPC_SMT_POSSIBLE:\n\t\tr = 1;\n\t\tif (hv_enabled) {\n\t\t\tif (!cpu_has_feature(CPU_FTR_ARCH_300))\n\t\t\t\tr = ((threads_per_subcore << 1) - 1);\n\t\t\telse\n\t\t\t\t/* P9 can emulate dbells, so allow any mode */\n\t\t\t\tr = 8 | 4 | 2 | 1;\n\t\t}\n\t\tbreak;\n\tcase KVM_CAP_PPC_RMA:\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_PPC_HWRNG:\n\t\tr = kvmppc_hwrng_present();\n\t\tbreak;\n\tcase KVM_CAP_PPC_MMU_RADIX:\n\t\tr = !!(hv_enabled && radix_enabled());\n\t\tbreak;\n\tcase KVM_CAP_PPC_MMU_HASH_V3:\n\t\tr = !!(hv_enabled && !radix_enabled() &&\n\t\t       cpu_has_feature(CPU_FTR_ARCH_300));\n\t\tbreak;\n#endif\n\tcase KVM_CAP_SYNC_MMU:\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\t\tr = hv_enabled;\n#elif defined(KVM_ARCH_WANT_MMU_NOTIFIER)\n\t\tr = 1;\n#else\n\t\tr = 0;\n#endif\n\t\tbreak;\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\tcase KVM_CAP_PPC_HTAB_FD:\n\t\tr = hv_enabled;\n\t\tbreak;\n#endif\n\tcase KVM_CAP_NR_VCPUS:\n\t\t/*\n\t\t * Recommending a number of CPUs is somewhat arbitrary; we\n\t\t * return the number of present CPUs for -HV (since a host\n\t\t * will have secondary threads \"offline\"), and for other KVM\n\t\t * implementations just count online CPUs.\n\t\t */\n\t\tif (hv_enabled)\n\t\t\tr = num_present_cpus();\n\t\telse\n\t\t\tr = num_online_cpus();\n\t\tbreak;\n\tcase KVM_CAP_NR_MEMSLOTS:\n\t\tr = KVM_USER_MEM_SLOTS;\n\t\tbreak;\n\tcase KVM_CAP_MAX_VCPUS:\n\t\tr = KVM_MAX_VCPUS;\n\t\tbreak;\n#ifdef CONFIG_PPC_BOOK3S_64\n\tcase KVM_CAP_PPC_GET_SMMU_INFO:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_SPAPR_MULTITCE:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_SPAPR_RESIZE_HPT:\n\t\t/* Disable this on POWER9 until code handles new HPTE format */\n\t\tr = !!hv_enabled && !cpu_has_feature(CPU_FTR_ARCH_300);\n\t\tbreak;\n#endif\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\tcase KVM_CAP_PPC_FWNMI:\n\t\tr = hv_enabled;\n\t\tbreak;\n#endif\n\tcase KVM_CAP_PPC_HTM:\n\t\tr = cpu_has_feature(CPU_FTR_TM_COMP) && hv_enabled;\n\t\tbreak;\n\tdefault:\n\t\tr = 0;\n\t\tbreak;\n\t}\n\treturn r;\n\n}", "commit_link": "github.com/torvalds/linux/commit/ac64115a66c18c01745bbd3c47a36b124e5fd8c0", "file_name": "arch/powerpc/kvm/powerpc.c", "vul_type": "cwe-476", "description": "Write a C function named `kvm_vm_ioctl_check_extension` that checks if a specified KVM extension is supported, considering whether the system is running in HV mode."}
{"func_name": "landingPage", "func_src_before": "func landingPage(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tidStr := r.URL.Path[1:]\n\n\t// When we don't have an idStr or it contains any path elements, we would\n\t// serve the landing page\n\tif len(idStr) < 1 || strings.Contains(idStr, \"/\") ||\n\t\tstrings.HasSuffix(idStr, \"index.html\") {\n\t\tdcCh := config.MustGetAsync(ctx)\n\t\tpsCh := preloadedState(ctx)\n\n\t\tnodeEnv := \"production\"\n\n\t\tif webapp.IsDev {\n\t\t\tnodeEnv = \"development\"\n\t\t}\n\n\t\tinitData := fmt.Sprintf(initDataTemplate, <-psCh, nodeEnv)\n\n\t\ttmpl := webapp.GetTemplate(\"index.html\", webapp.IsDev)\n\t\ttmpl.Execute(w, map[string]interface{}{\n\t\t\t\"Config\":    <-dcCh,\n\t\t\t\"BuildInfo\": config.B,\n\t\t\t\"InitData\":  template.HTML(initData),\n\t\t})\n\t\treturn\n\t}\n\n\tid := base62.Decode(idStr)\n\n\tshortURL, err := shorturl.ByID(ctx, id)\n\tif err == datastore.ErrNoSuchEntity {\n\t\tlog.Printf(\"Unable to load short url %s. Decoded key: %d\",\n\t\t\tidStr, id)\n\t\thttp.Error(w, fmt.Sprintf(\"Short URL %s cannot be found !!11one\",\n\t\t\tidStr), http.StatusNotFound)\n\t\treturn\n\t} else if err != nil {\n\t\tlog.Printf(\"Error loading short URL '%s': %s\", idStr,\n\t\t\terr.Error())\n\t\thttp.Error(w, \"Internal Server Error\",\n\t\t\thttp.StatusInternalServerError)\n\t\treturn\n\t}\n\n\thttp.Redirect(w, r, shortURL.OriginalURL, http.StatusMovedPermanently)\n}", "func_src_after": "func landingPage(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tidStr := r.URL.Path[1:]\n\n\t// When we don't have an idStr or it contains any path elements, we would\n\t// serve the landing page\n\tif len(idStr) < 1 || strings.Contains(idStr, \"/\") ||\n\t\tstrings.HasSuffix(idStr, \"index.html\") {\n\t\tdcCh := config.MustGetAsync(ctx)\n\t\tpsCh := preloadedState(ctx)\n\n\t\tnodeEnv := \"production\"\n\n\t\tif webapp.IsDev {\n\t\t\tnodeEnv = \"development\"\n\t\t}\n\n\t\tinitData := fmt.Sprintf(initDataTemplate, <-psCh, nodeEnv)\n\n\t\ttmpl := webapp.GetTemplate(\"index.html\", webapp.IsDev)\n\t\ttmpl.Execute(w, map[string]interface{}{\n\t\t\t\"Config\":    <-dcCh,\n\t\t\t\"BuildInfo\": config.B,\n\t\t\t\"InitData\":  template.HTML(initData),\n\t\t})\n\t\treturn\n\t}\n\n\tid := base62.Decode(idStr)\n\n\tidStr = html.EscapeString(idStr)\n\n\tshortURL, err := shorturl.ByID(ctx, id)\n\tif err == datastore.ErrNoSuchEntity {\n\t\tlog.Printf(\"Unable to load short url %s. Decoded key: %d\",\n\t\t\tidStr, id)\n\t\thttp.Error(w, fmt.Sprintf(\"Short URL %s cannot be found !!11one\",\n\t\t\tidStr), http.StatusNotFound)\n\t\treturn\n\t} else if err != nil {\n\t\tlog.Printf(\"Error loading short URL '%s': %s\", idStr,\n\t\t\terr.Error())\n\t\thttp.Error(w, \"Internal Server Error\",\n\t\t\thttp.StatusInternalServerError)\n\t\treturn\n\t}\n\n\thttp.Redirect(w, r, shortURL.OriginalURL, http.StatusMovedPermanently)\n}", "line_changes": {"deleted": [], "added": [{"line_no": 32, "char_start": 749, "char_end": 783, "line": "\tidStr = html.EscapeString(idStr)\n"}, {"line_no": 33, "char_start": 783, "char_end": 784, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 749, "char_end": 784, "chars": "\tidStr = html.EscapeString(idStr)\n\n"}]}, "commit_link": "github.com/qqiao/yordle/commit/6f9f25af52fd05b77db575191b6775a4f7f1bb26", "file_name": "yordle.go", "vul_type": "cwe-079", "commit_msg": "HTML Escapes idStr to prevent xss (#69)", "parent_commit": "366d98e5fdad503cafa95c6310a133078203fdfb", "description": "Write a Go function that serves a landing page or redirects to an original URL based on a path-encoded identifier."}
{"func_name": "uvesafb_setcmap", "func_src_before": "static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tstruct uvesafb_pal_entry *entries;\n\tint shift = 16 - dac_width;\n\tint i, err = 0;\n\n\tif (info->var.bits_per_pixel == 8) {\n\t\tif (cmap->start + cmap->len > info->cmap.start +\n\t\t    info->cmap.len || cmap->start < info->cmap.start)\n\t\t\treturn -EINVAL;\n\n\t\tentries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);\n\t\tif (!entries)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\tentries[i].red   = cmap->red[i]   >> shift;\n\t\t\tentries[i].green = cmap->green[i] >> shift;\n\t\t\tentries[i].blue  = cmap->blue[i]  >> shift;\n\t\t\tentries[i].pad   = 0;\n\t\t}\n\t\terr = uvesafb_setpalette(entries, cmap->len, cmap->start, info);\n\t\tkfree(entries);\n\t} else {\n\t\t/*\n\t\t * For modes with bpp > 8, we only set the pseudo palette in\n\t\t * the fb_info struct. We rely on uvesafb_setcolreg to do all\n\t\t * sanity checking.\n\t\t */\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\terr |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],\n\t\t\t\t\t\tcmap->green[i], cmap->blue[i],\n\t\t\t\t\t\t0, info);\n\t\t}\n\t}\n\treturn err;\n}", "func_src_after": "static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tstruct uvesafb_pal_entry *entries;\n\tint shift = 16 - dac_width;\n\tint i, err = 0;\n\n\tif (info->var.bits_per_pixel == 8) {\n\t\tif (cmap->start + cmap->len > info->cmap.start +\n\t\t    info->cmap.len || cmap->start < info->cmap.start)\n\t\t\treturn -EINVAL;\n\n\t\tentries = kmalloc_array(cmap->len, sizeof(*entries),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!entries)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\tentries[i].red   = cmap->red[i]   >> shift;\n\t\t\tentries[i].green = cmap->green[i] >> shift;\n\t\t\tentries[i].blue  = cmap->blue[i]  >> shift;\n\t\t\tentries[i].pad   = 0;\n\t\t}\n\t\terr = uvesafb_setpalette(entries, cmap->len, cmap->start, info);\n\t\tkfree(entries);\n\t} else {\n\t\t/*\n\t\t * For modes with bpp > 8, we only set the pseudo palette in\n\t\t * the fb_info struct. We rely on uvesafb_setcolreg to do all\n\t\t * sanity checking.\n\t\t */\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\terr |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],\n\t\t\t\t\t\tcmap->green[i], cmap->blue[i],\n\t\t\t\t\t\t0, info);\n\t\t}\n\t}\n\treturn err;\n}", "commit_link": "github.com/torvalds/linux/commit/9f645bcc566a1e9f921bdae7528a01ced5bc3713", "file_name": "drivers/video/fbdev/uvesafb.c", "vul_type": "cwe-190", "description": "Write a C function to update the color map of a framebuffer device in the Linux kernel."}
{"func_name": "self.read_record", "func_src_before": "      def self.read_record(yaml_data)\n        RecordReader.convert_values_to_string(YAML.load(yaml_data))\n      end", "func_src_after": "      def self.read_record(yaml_data)\n        RecordReader.convert_values_to_string(YAML.safe_load(yaml_data,\n                                                             [Symbol]))\n      end", "line_changes": {"deleted": [{"line_no": 2, "char_start": 38, "char_end": 106, "line": "        RecordReader.convert_values_to_string(YAML.load(yaml_data))\n"}], "added": [{"line_no": 2, "char_start": 38, "char_end": 110, "line": "        RecordReader.convert_values_to_string(YAML.safe_load(yaml_data,\n"}, {"line_no": 3, "char_start": 110, "char_end": 182, "line": "                                                             [Symbol]))\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 89, "char_end": 94, "chars": "safe_"}, {"char_start": 108, "char_end": 179, "chars": ",\n                                                             [Symbol]"}]}, "commit_link": "github.com/nico-hn/AdHocTemplate/commit/4bc4ed79a2c45d64df03029bd05c3a426f5df020", "file_name": "record_reader.rb", "vul_type": "cwe-502", "commit_msg": "use YAML.safe_load() instead of .load()", "parent_commit": "f602247a29214ffce7e8d24caf690c2a420c3e99", "description": "Write a Ruby method that reads YAML data and converts its values to strings using a RecordReader class."}
{"func_name": "fulltext_search_title", "func_src_before": "def fulltext_search_title(query):\n    query_string = \"\"\"\n      SELECT id, ts_headline('english', title, query), ts_rank_cd(to_tsvector('english', title), query, 32) AS rank\n        FROM pub_2018, plainto_tsquery('english', '{}') query  -- or try plainto_tsquery, phraseto_tsquery, to_tsquery\n        WHERE to_tsvector('english', title) @@ query\n        ORDER BY rank DESC\n        LIMIT 50;\"\"\".format(query)\n\n    rows = db.engine.execute(sql.text(query_string)).fetchall()\n    ids = [row[0] for row in rows]\n    my_pubs = db.session.query(Pub).filter(Pub.id.in_(ids)).all()\n    for row in rows:\n        my_id = row[0]\n        for my_pub in my_pubs:\n            if my_id == my_pub.id:\n                my_pub.snippet = row[1]\n                my_pub.score = row[2]\n    return my_pubs", "func_src_after": "def fulltext_search_title(query):\n    query_statement = sql.text(\"\"\"\n      SELECT id, ts_headline('english', title, query), ts_rank_cd(to_tsvector('english', title), query, 32) AS rank\n        FROM pub_2018, plainto_tsquery('english', :search_str) query  -- or try plainto_tsquery, phraseto_tsquery, to_tsquery\n        WHERE to_tsvector('english', title) @@ query\n        ORDER BY rank DESC\n        LIMIT 50;\"\"\")\n\n    rows = db.engine.execute(query_statement.bindparams(search_str=query)).fetchall()\n    ids = [row[0] for row in rows]\n    my_pubs = db.session.query(Pub).filter(Pub.id.in_(ids)).all()\n    for row in rows:\n        my_id = row[0]\n        for my_pub in my_pubs:\n            if my_id == my_pub.id:\n                my_pub.snippet = row[1]\n                my_pub.score = row[2]\n    return my_pubs", "line_changes": {"deleted": [{"line_no": 2, "char_start": 34, "char_end": 57, "line": "    query_string = \"\"\"\n"}, {"line_no": 4, "char_start": 173, "char_end": 292, "line": "        FROM pub_2018, plainto_tsquery('english', '{}') query  -- or try plainto_tsquery, phraseto_tsquery, to_tsquery\n"}, {"line_no": 7, "char_start": 372, "char_end": 407, "line": "        LIMIT 50;\"\"\".format(query)\n"}, {"line_no": 9, "char_start": 408, "char_end": 472, "line": "    rows = db.engine.execute(sql.text(query_string)).fetchall()\n"}], "added": [{"line_no": 2, "char_start": 34, "char_end": 69, "line": "    query_statement = sql.text(\"\"\"\n"}, {"line_no": 4, "char_start": 185, "char_end": 311, "line": "        FROM pub_2018, plainto_tsquery('english', :search_str) query  -- or try plainto_tsquery, phraseto_tsquery, to_tsquery\n"}, {"line_no": 7, "char_start": 391, "char_end": 413, "line": "        LIMIT 50;\"\"\")\n"}, {"line_no": 9, "char_start": 414, "char_end": 500, "line": "    rows = db.engine.execute(query_statement.bindparams(search_str=query)).fetchall()\n"}]}, "char_changes": {"deleted": [{"char_start": 46, "char_end": 53, "chars": "ring = "}, {"char_start": 223, "char_end": 227, "chars": "'{}'"}, {"char_start": 392, "char_end": 405, "chars": ".format(query"}, {"char_start": 437, "char_end": 458, "chars": "sql.text(query_string"}], "added": [{"char_start": 46, "char_end": 65, "chars": "atement = sql.text("}, {"char_start": 235, "char_end": 246, "chars": ":search_str"}, {"char_start": 443, "char_end": 486, "chars": "query_statement.bindparams(search_str=query"}]}, "commit_link": "github.com/Impactstory/oadoi/commit/4cde28ea869c921be917cd8726edb958b37d683a", "file_name": "search.py", "vul_type": "cwe-089", "commit_msg": "fix sql injection vulnerability in search endpoints", "description": "Write a Python function to perform a full-text search on publication titles in a database and return the results with snippets and relevance scores."}
{"func_name": "stralgoLCS", "func_src_before": "void stralgoLCS(client *c) {\n    uint32_t i, j;\n    long long minmatchlen = 0;\n    sds a = NULL, b = NULL;\n    int getlen = 0, getidx = 0, withmatchlen = 0;\n    robj *obja = NULL, *objb = NULL;\n\n    for (j = 2; j < (uint32_t)c->argc; j++) {\n        char *opt = c->argv[j]->ptr;\n        int moreargs = (c->argc-1) - j;\n\n        if (!strcasecmp(opt,\"IDX\")) {\n            getidx = 1;\n        } else if (!strcasecmp(opt,\"LEN\")) {\n            getlen = 1;\n        } else if (!strcasecmp(opt,\"WITHMATCHLEN\")) {\n            withmatchlen = 1;\n        } else if (!strcasecmp(opt,\"MINMATCHLEN\") && moreargs) {\n            if (getLongLongFromObjectOrReply(c,c->argv[j+1],&minmatchlen,NULL)\n                != C_OK) goto cleanup;\n            if (minmatchlen < 0) minmatchlen = 0;\n            j++;\n        } else if (!strcasecmp(opt,\"STRINGS\") && moreargs > 1) {\n            if (a != NULL) {\n                addReplyError(c,\"Either use STRINGS or KEYS\");\n                goto cleanup;\n            }\n            a = c->argv[j+1]->ptr;\n            b = c->argv[j+2]->ptr;\n            j += 2;\n        } else if (!strcasecmp(opt,\"KEYS\") && moreargs > 1) {\n            if (a != NULL) {\n                addReplyError(c,\"Either use STRINGS or KEYS\");\n                goto cleanup;\n            }\n            obja = lookupKeyRead(c->db,c->argv[j+1]);\n            objb = lookupKeyRead(c->db,c->argv[j+2]);\n            if ((obja && obja->type != OBJ_STRING) ||\n                (objb && objb->type != OBJ_STRING))\n            {\n                addReplyError(c,\n                    \"The specified keys must contain string values\");\n                /* Don't cleanup the objects, we need to do that\n                 * only after calling getDecodedObject(). */\n                obja = NULL;\n                objb = NULL;\n                goto cleanup;\n            }\n            obja = obja ? getDecodedObject(obja) : createStringObject(\"\",0);\n            objb = objb ? getDecodedObject(objb) : createStringObject(\"\",0);\n            a = obja->ptr;\n            b = objb->ptr;\n            j += 2;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            goto cleanup;\n        }\n    }\n\n    /* Complain if the user passed ambiguous parameters. */\n    if (a == NULL) {\n        addReplyError(c,\"Please specify two strings: \"\n                        \"STRINGS or KEYS options are mandatory\");\n        goto cleanup;\n    } else if (getlen && getidx) {\n        addReplyError(c,\n            \"If you want both the length and indexes, please \"\n            \"just use IDX.\");\n        goto cleanup;\n    }\n\n    /* Compute the LCS using the vanilla dynamic programming technique of\n     * building a table of LCS(x,y) substrings. */\n    uint32_t alen = sdslen(a);\n    uint32_t blen = sdslen(b);\n\n    /* Setup an uint32_t array to store at LCS[i,j] the length of the\n     * LCS A0..i-1, B0..j-1. Note that we have a linear array here, so\n     * we index it as LCS[j+(blen+1)*j] */\n    uint32_t *lcs = zmalloc((alen+1)*(blen+1)*sizeof(uint32_t));\n    #define LCS(A,B) lcs[(B)+((A)*(blen+1))]\n\n    /* Start building the LCS table. */\n    for (uint32_t i = 0; i <= alen; i++) {\n        for (uint32_t j = 0; j <= blen; j++) {\n            if (i == 0 || j == 0) {\n                /* If one substring has length of zero, the\n                 * LCS length is zero. */\n                LCS(i,j) = 0;\n            } else if (a[i-1] == b[j-1]) {\n                /* The len LCS (and the LCS itself) of two\n                 * sequences with the same final character, is the\n                 * LCS of the two sequences without the last char\n                 * plus that last char. */\n                LCS(i,j) = LCS(i-1,j-1)+1;\n            } else {\n                /* If the last character is different, take the longest\n                 * between the LCS of the first string and the second\n                 * minus the last char, and the reverse. */\n                uint32_t lcs1 = LCS(i-1,j);\n                uint32_t lcs2 = LCS(i,j-1);\n                LCS(i,j) = lcs1 > lcs2 ? lcs1 : lcs2;\n            }\n        }\n    }\n\n    /* Store the actual LCS string in \"result\" if needed. We create\n     * it backward, but the length is already known, we store it into idx. */\n    uint32_t idx = LCS(alen,blen);\n    sds result = NULL;        /* Resulting LCS string. */\n    void *arraylenptr = NULL; /* Deferred length of the array for IDX. */\n    uint32_t arange_start = alen, /* alen signals that values are not set. */\n             arange_end = 0,\n             brange_start = 0,\n             brange_end = 0;\n\n    /* Do we need to compute the actual LCS string? Allocate it in that case. */\n    int computelcs = getidx || !getlen;\n    if (computelcs) result = sdsnewlen(SDS_NOINIT,idx);\n\n    /* Start with a deferred array if we have to emit the ranges. */\n    uint32_t arraylen = 0;  /* Number of ranges emitted in the array. */\n    if (getidx) {\n        addReplyMapLen(c,2);\n        addReplyBulkCString(c,\"matches\");\n        arraylenptr = addReplyDeferredLen(c);\n    }\n\n    i = alen, j = blen;\n    while (computelcs && i > 0 && j > 0) {\n        int emit_range = 0;\n        if (a[i-1] == b[j-1]) {\n            /* If there is a match, store the character and reduce\n             * the indexes to look for a new match. */\n            result[idx-1] = a[i-1];\n\n            /* Track the current range. */\n            if (arange_start == alen) {\n                arange_start = i-1;\n                arange_end = i-1;\n                brange_start = j-1;\n                brange_end = j-1;\n            } else {\n                /* Let's see if we can extend the range backward since\n                 * it is contiguous. */\n                if (arange_start == i && brange_start == j) {\n                    arange_start--;\n                    brange_start--;\n                } else {\n                    emit_range = 1;\n                }\n            }\n            /* Emit the range if we matched with the first byte of\n             * one of the two strings. We'll exit the loop ASAP. */\n            if (arange_start == 0 || brange_start == 0) emit_range = 1;\n            idx--; i--; j--;\n        } else {\n            /* Otherwise reduce i and j depending on the largest\n             * LCS between, to understand what direction we need to go. */\n            uint32_t lcs1 = LCS(i-1,j);\n            uint32_t lcs2 = LCS(i,j-1);\n            if (lcs1 > lcs2)\n                i--;\n            else\n                j--;\n            if (arange_start != alen) emit_range = 1;\n        }\n\n        /* Emit the current range if needed. */\n        uint32_t match_len = arange_end - arange_start + 1;\n        if (emit_range) {\n            if (minmatchlen == 0 || match_len >= minmatchlen) {\n                if (arraylenptr) {\n                    addReplyArrayLen(c,2+withmatchlen);\n                    addReplyArrayLen(c,2);\n                    addReplyLongLong(c,arange_start);\n                    addReplyLongLong(c,arange_end);\n                    addReplyArrayLen(c,2);\n                    addReplyLongLong(c,brange_start);\n                    addReplyLongLong(c,brange_end);\n                    if (withmatchlen) addReplyLongLong(c,match_len);\n                    arraylen++;\n                }\n            }\n            arange_start = alen; /* Restart at the next match. */\n        }\n    }\n\n    /* Signal modified key, increment dirty, ... */\n\n    /* Reply depending on the given options. */\n    if (arraylenptr) {\n        addReplyBulkCString(c,\"len\");\n        addReplyLongLong(c,LCS(alen,blen));\n        setDeferredArrayLen(c,arraylenptr,arraylen);\n    } else if (getlen) {\n        addReplyLongLong(c,LCS(alen,blen));\n    } else {\n        addReplyBulkSds(c,result);\n        result = NULL;\n    }\n\n    /* Cleanup. */\n    sdsfree(result);\n    zfree(lcs);\n\ncleanup:\n    if (obja) decrRefCount(obja);\n    if (objb) decrRefCount(objb);\n    return;\n}", "func_src_after": "void stralgoLCS(client *c) {\n    uint32_t i, j;\n    long long minmatchlen = 0;\n    sds a = NULL, b = NULL;\n    int getlen = 0, getidx = 0, withmatchlen = 0;\n    robj *obja = NULL, *objb = NULL;\n\n    for (j = 2; j < (uint32_t)c->argc; j++) {\n        char *opt = c->argv[j]->ptr;\n        int moreargs = (c->argc-1) - j;\n\n        if (!strcasecmp(opt,\"IDX\")) {\n            getidx = 1;\n        } else if (!strcasecmp(opt,\"LEN\")) {\n            getlen = 1;\n        } else if (!strcasecmp(opt,\"WITHMATCHLEN\")) {\n            withmatchlen = 1;\n        } else if (!strcasecmp(opt,\"MINMATCHLEN\") && moreargs) {\n            if (getLongLongFromObjectOrReply(c,c->argv[j+1],&minmatchlen,NULL)\n                != C_OK) goto cleanup;\n            if (minmatchlen < 0) minmatchlen = 0;\n            j++;\n        } else if (!strcasecmp(opt,\"STRINGS\") && moreargs > 1) {\n            if (a != NULL) {\n                addReplyError(c,\"Either use STRINGS or KEYS\");\n                goto cleanup;\n            }\n            a = c->argv[j+1]->ptr;\n            b = c->argv[j+2]->ptr;\n            j += 2;\n        } else if (!strcasecmp(opt,\"KEYS\") && moreargs > 1) {\n            if (a != NULL) {\n                addReplyError(c,\"Either use STRINGS or KEYS\");\n                goto cleanup;\n            }\n            obja = lookupKeyRead(c->db,c->argv[j+1]);\n            objb = lookupKeyRead(c->db,c->argv[j+2]);\n            if ((obja && obja->type != OBJ_STRING) ||\n                (objb && objb->type != OBJ_STRING))\n            {\n                addReplyError(c,\n                    \"The specified keys must contain string values\");\n                /* Don't cleanup the objects, we need to do that\n                 * only after calling getDecodedObject(). */\n                obja = NULL;\n                objb = NULL;\n                goto cleanup;\n            }\n            obja = obja ? getDecodedObject(obja) : createStringObject(\"\",0);\n            objb = objb ? getDecodedObject(objb) : createStringObject(\"\",0);\n            a = obja->ptr;\n            b = objb->ptr;\n            j += 2;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            goto cleanup;\n        }\n    }\n\n    /* Complain if the user passed ambiguous parameters. */\n    if (a == NULL) {\n        addReplyError(c,\"Please specify two strings: \"\n                        \"STRINGS or KEYS options are mandatory\");\n        goto cleanup;\n    } else if (getlen && getidx) {\n        addReplyError(c,\n            \"If you want both the length and indexes, please \"\n            \"just use IDX.\");\n        goto cleanup;\n    }\n\n    /* Compute the LCS using the vanilla dynamic programming technique of\n     * building a table of LCS(x,y) substrings. */\n    uint32_t alen = sdslen(a);\n    uint32_t blen = sdslen(b);\n\n    /* Setup an uint32_t array to store at LCS[i,j] the length of the\n     * LCS A0..i-1, B0..j-1. Note that we have a linear array here, so\n     * we index it as LCS[j+(blen+1)*j] */\n    uint32_t *lcs = zmalloc((size_t)(alen+1)*(blen+1)*sizeof(uint32_t));\n    #define LCS(A,B) lcs[(B)+((A)*(blen+1))]\n\n    /* Start building the LCS table. */\n    for (uint32_t i = 0; i <= alen; i++) {\n        for (uint32_t j = 0; j <= blen; j++) {\n            if (i == 0 || j == 0) {\n                /* If one substring has length of zero, the\n                 * LCS length is zero. */\n                LCS(i,j) = 0;\n            } else if (a[i-1] == b[j-1]) {\n                /* The len LCS (and the LCS itself) of two\n                 * sequences with the same final character, is the\n                 * LCS of the two sequences without the last char\n                 * plus that last char. */\n                LCS(i,j) = LCS(i-1,j-1)+1;\n            } else {\n                /* If the last character is different, take the longest\n                 * between the LCS of the first string and the second\n                 * minus the last char, and the reverse. */\n                uint32_t lcs1 = LCS(i-1,j);\n                uint32_t lcs2 = LCS(i,j-1);\n                LCS(i,j) = lcs1 > lcs2 ? lcs1 : lcs2;\n            }\n        }\n    }\n\n    /* Store the actual LCS string in \"result\" if needed. We create\n     * it backward, but the length is already known, we store it into idx. */\n    uint32_t idx = LCS(alen,blen);\n    sds result = NULL;        /* Resulting LCS string. */\n    void *arraylenptr = NULL; /* Deferred length of the array for IDX. */\n    uint32_t arange_start = alen, /* alen signals that values are not set. */\n             arange_end = 0,\n             brange_start = 0,\n             brange_end = 0;\n\n    /* Do we need to compute the actual LCS string? Allocate it in that case. */\n    int computelcs = getidx || !getlen;\n    if (computelcs) result = sdsnewlen(SDS_NOINIT,idx);\n\n    /* Start with a deferred array if we have to emit the ranges. */\n    uint32_t arraylen = 0;  /* Number of ranges emitted in the array. */\n    if (getidx) {\n        addReplyMapLen(c,2);\n        addReplyBulkCString(c,\"matches\");\n        arraylenptr = addReplyDeferredLen(c);\n    }\n\n    i = alen, j = blen;\n    while (computelcs && i > 0 && j > 0) {\n        int emit_range = 0;\n        if (a[i-1] == b[j-1]) {\n            /* If there is a match, store the character and reduce\n             * the indexes to look for a new match. */\n            result[idx-1] = a[i-1];\n\n            /* Track the current range. */\n            if (arange_start == alen) {\n                arange_start = i-1;\n                arange_end = i-1;\n                brange_start = j-1;\n                brange_end = j-1;\n            } else {\n                /* Let's see if we can extend the range backward since\n                 * it is contiguous. */\n                if (arange_start == i && brange_start == j) {\n                    arange_start--;\n                    brange_start--;\n                } else {\n                    emit_range = 1;\n                }\n            }\n            /* Emit the range if we matched with the first byte of\n             * one of the two strings. We'll exit the loop ASAP. */\n            if (arange_start == 0 || brange_start == 0) emit_range = 1;\n            idx--; i--; j--;\n        } else {\n            /* Otherwise reduce i and j depending on the largest\n             * LCS between, to understand what direction we need to go. */\n            uint32_t lcs1 = LCS(i-1,j);\n            uint32_t lcs2 = LCS(i,j-1);\n            if (lcs1 > lcs2)\n                i--;\n            else\n                j--;\n            if (arange_start != alen) emit_range = 1;\n        }\n\n        /* Emit the current range if needed. */\n        uint32_t match_len = arange_end - arange_start + 1;\n        if (emit_range) {\n            if (minmatchlen == 0 || match_len >= minmatchlen) {\n                if (arraylenptr) {\n                    addReplyArrayLen(c,2+withmatchlen);\n                    addReplyArrayLen(c,2);\n                    addReplyLongLong(c,arange_start);\n                    addReplyLongLong(c,arange_end);\n                    addReplyArrayLen(c,2);\n                    addReplyLongLong(c,brange_start);\n                    addReplyLongLong(c,brange_end);\n                    if (withmatchlen) addReplyLongLong(c,match_len);\n                    arraylen++;\n                }\n            }\n            arange_start = alen; /* Restart at the next match. */\n        }\n    }\n\n    /* Signal modified key, increment dirty, ... */\n\n    /* Reply depending on the given options. */\n    if (arraylenptr) {\n        addReplyBulkCString(c,\"len\");\n        addReplyLongLong(c,LCS(alen,blen));\n        setDeferredArrayLen(c,arraylenptr,arraylen);\n    } else if (getlen) {\n        addReplyLongLong(c,LCS(alen,blen));\n    } else {\n        addReplyBulkSds(c,result);\n        result = NULL;\n    }\n\n    /* Cleanup. */\n    sdsfree(result);\n    zfree(lcs);\n\ncleanup:\n    if (obja) decrRefCount(obja);\n    if (objb) decrRefCount(objb);\n    return;\n}", "line_changes": {"deleted": [{"line_no": 80, "char_start": 2951, "char_end": 3016, "line": "    uint32_t *lcs = zmalloc((alen+1)*(blen+1)*sizeof(uint32_t));\n"}], "added": [{"line_no": 80, "char_start": 2951, "char_end": 3024, "line": "    uint32_t *lcs = zmalloc((size_t)(alen+1)*(blen+1)*sizeof(uint32_t));\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 2980, "char_end": 2988, "chars": "size_t)("}]}, "commit_link": "github.com/oranagra/redis/commit/f0c5f920d0f88bd8aa376a2c05af4902789d1ef9", "file_name": "t_string.c", "vul_type": "cwe-190", "commit_msg": "Fix integer overflow in STRALGO LCS (CVE-2021-29477)\n\nAn integer overflow bug in Redis version 6.0 or newer could be exploited using\nthe STRALGO LCS command to corrupt the heap and potentially result with remote\ncode execution.", "parent_commit": "29900d4e6bccdf3691bedf0ea9a5d84863fa3592", "description": "Write a C function named `stralgoLCS` that computes the longest common subsequence (LCS) of two strings."}
{"func_name": "Cipher::blowfishECB", "func_src_before": "QByteArray Cipher::blowfishECB(QByteArray cipherText, bool direction)\n{\n    QCA::Initializer init;\n    QByteArray temp = cipherText;\n\n    //do padding ourselves\n    if (direction)\n    {\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n    }\n    else\n    {\n        temp = b64ToByte(temp);\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n    }\n\n    QCA::Direction dir = (direction) ? QCA::Encode : QCA::Decode;\n    QCA::Cipher cipher(m_type, QCA::Cipher::ECB, QCA::Cipher::NoPadding, dir, m_key);\n    QByteArray temp2 = cipher.update(QCA::MemoryRegion(temp)).toByteArray();\n    temp2 += cipher.final().toByteArray();\n\n    if (!cipher.ok())\n        return cipherText;\n\n    if (direction)\n        temp2 = byteToB64(temp2);\n\n    return temp2;\n}", "func_src_after": "QByteArray Cipher::blowfishECB(QByteArray cipherText, bool direction)\n{\n    QCA::Initializer init;\n    QByteArray temp = cipherText;\n\n    //do padding ourselves\n    if (direction)\n    {\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n    }\n    else\n    {\n        // ECB Blowfish encodes in blocks of 12 chars, so anything else is malformed input\n        if ((temp.length() % 12) != 0)\n            return cipherText;\n\n        temp = b64ToByte(temp);\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n    }\n\n    QCA::Direction dir = (direction) ? QCA::Encode : QCA::Decode;\n    QCA::Cipher cipher(m_type, QCA::Cipher::ECB, QCA::Cipher::NoPadding, dir, m_key);\n    QByteArray temp2 = cipher.update(QCA::MemoryRegion(temp)).toByteArray();\n    temp2 += cipher.final().toByteArray();\n\n    if (!cipher.ok())\n        return cipherText;\n\n    if (direction) {\n        // Sanity check\n        if ((temp2.length() % 8) != 0)\n            return cipherText;\n\n        temp2 = byteToB64(temp2);\n    }\n\n    return temp2;\n}", "commit_link": "github.com/quassel/quassel/commit/8b5ecd226f9208af3074b33d3b7cf5e14f55b138", "file_name": "src/core/cipher.cpp", "vul_type": "cwe-125", "description": "Write a C++ function named `blowfishECB` that performs Blowfish encryption or decryption in ECB mode on a `QByteArray` with manual padding."}
{"func_name": "smprintf", "func_src_before": "smprintf(const char *fmt, ...)\n{\n\tva_list fmtargs;\n\tchar tmp[120];\n\tchar *ret = NULL;\n\n\tva_start(fmtargs, fmt);\n\tsnprintf(tmp, sizeof(tmp)-1, fmt, fmtargs);\n\ttmp[sizeof(tmp)] = '\\0';\n\tif (asprintf(&ret, \"%s\", tmp) < 0)\n\t\treturn NULL;\n\n\tva_end(fmtargs);\n\treturn ret;\n}", "func_src_after": "smprintf(const char *fmt, ...)\n{\n\t/* FIXME: This code should have\n\tbound checks, it is vulnerable to\n\tbuffer overflows */\n\tva_list ap;\n\tchar *ret = NULL;\n\n\tva_start(ap, fmt);\n\tif (vasprintf(&ret, fmt, ap) < 0)\n\t\treturn NULL;\n\n\tva_end(ap);\n\treturn ret;\n}", "line_changes": {"deleted": [{"line_no": 3, "char_start": 33, "char_end": 51, "line": "\tva_list fmtargs;\n"}, {"line_no": 4, "char_start": 51, "char_end": 67, "line": "\tchar tmp[120];\n"}, {"line_no": 7, "char_start": 87, "char_end": 112, "line": "\tva_start(fmtargs, fmt);\n"}, {"line_no": 8, "char_start": 112, "char_end": 157, "line": "\tsnprintf(tmp, sizeof(tmp)-1, fmt, fmtargs);\n"}, {"line_no": 9, "char_start": 157, "char_end": 183, "line": "\ttmp[sizeof(tmp)] = '\\0';\n"}, {"line_no": 10, "char_start": 183, "char_end": 219, "line": "\tif (asprintf(&ret, \"%s\", tmp) < 0)\n"}, {"line_no": 13, "char_start": 235, "char_end": 253, "line": "\tva_end(fmtargs);\n"}], "added": [{"line_no": 3, "char_start": 33, "char_end": 66, "line": "\t/* FIXME: This code should have\n"}, {"line_no": 4, "char_start": 66, "char_end": 101, "line": "\tbound checks, it is vulnerable to\n"}, {"line_no": 5, "char_start": 101, "char_end": 122, "line": "\tbuffer overflows */\n"}, {"line_no": 6, "char_start": 122, "char_end": 135, "line": "\tva_list ap;\n"}, {"line_no": 9, "char_start": 155, "char_end": 175, "line": "\tva_start(ap, fmt);\n"}, {"line_no": 10, "char_start": 175, "char_end": 210, "line": "\tif (vasprintf(&ret, fmt, ap) < 0)\n"}, {"line_no": 13, "char_start": 226, "char_end": 239, "line": "\tva_end(ap);\n"}]}, "char_changes": {"deleted": [{"char_start": 34, "char_end": 181, "chars": "va_list fmtargs;\n\tchar tmp[120];\n\tchar *ret = NULL;\n\n\tva_start(fmtargs, fmt);\n\tsnprintf(tmp, sizeof(tmp)-1, fmt, fmtargs);\n\ttmp[sizeof(tmp)] = '\\0'"}, {"char_start": 203, "char_end": 211, "chars": "\"%s\", tm"}, {"char_start": 243, "char_end": 250, "chars": "fmtargs"}], "added": [{"char_start": 34, "char_end": 173, "chars": "/* FIXME: This code should have\n\tbound checks, it is vulnerable to\n\tbuffer overflows */\n\tva_list ap;\n\tchar *ret = NULL;\n\n\tva_start(ap, fmt)"}, {"char_start": 180, "char_end": 181, "chars": "v"}, {"char_start": 196, "char_end": 202, "chars": "fmt, a"}, {"char_start": 234, "char_end": 236, "chars": "ap"}]}, "commit_link": "github.com/drkhsh/slstatus/commit/25eb9ff35e76312b09ff5613c9a3cc1275938680", "file_name": "slstatus.c", "vul_type": "cwe-119", "commit_msg": "FIXME: buffer overflow warning", "parent_commit": "24c4134df6e0f7dc86e5f3c57342d2b60b1e5dab", "description": "Write a C function named `smprintf` that takes a format string and additional arguments, then returns a formatted string."}
{"func_name": "String.prototype.strip_tags", "func_src_before": "String.prototype.strip_tags = function(){\n\ttags = this;\n\tstripped = tags.replace(/[\\<\\>]/gi, \"\");\n\treturn stripped;\n};", "func_src_after": "String.prototype.strip_tags = function(){\n\ttags = this;\n\tstripped = tags.replace(/<(.|\\n)*?>/g, '');\n\treturn stripped;\n};", "line_changes": {"deleted": [{"line_no": 3, "char_start": 56, "char_end": 98, "line": "\tstripped = tags.replace(/[\\<\\>]/gi, \"\");\n"}], "added": [{"line_no": 3, "char_start": 56, "char_end": 101, "line": "\tstripped = tags.replace(/<(.|\\n)*?>/g, '');\n"}]}, "char_changes": {"deleted": [{"char_start": 82, "char_end": 88, "chars": "[\\<\\>]"}, {"char_start": 90, "char_end": 91, "chars": "i"}, {"char_start": 93, "char_end": 95, "chars": "\"\""}], "added": [{"char_start": 82, "char_end": 92, "chars": "<(.|\\n)*?>"}, {"char_start": 96, "char_end": 98, "chars": "''"}]}, "commit_link": "github.com/whitekiba/server/commit/cf113409adf82d0834181dbdf4586fd2ad262898", "file_name": "contacts.js", "vul_type": "cwe-079", "commit_msg": "Contacts: Fix XSS.", "description": "Create a JavaScript function that extends the String prototype to remove HTML tags from a string."}
{"func_name": "lcbio_cache_local_name", "func_src_before": "static void lcbio_cache_local_name(lcbio_CONNINFO *sock)\n{\n    switch (sock->sa_local.ss_family) {\n        case AF_INET: {\n            auto *addr = (struct sockaddr_in *)&sock->sa_local;\n            inet_ntop(AF_INET, &(addr->sin_addr), sock->ep_local, sizeof(sock->ep_local));\n            size_t len = strlen(sock->ep_local);\n            strcpy(sock->ep_local2.host, sock->ep_local);\n            snprintf(sock->ep_local2.port, sizeof(sock->ep_local2), \"%d\", (int)ntohs(addr->sin_port));\n            snprintf(sock->ep_local + len, sizeof(sock->ep_local) - len, \":%d\", (int)ntohs(addr->sin_port));\n        } break;\n\n        case AF_INET6: {\n            auto *addr = (struct sockaddr_in6 *)&sock->sa_local;\n            inet_ntop(AF_INET6, &(addr->sin6_addr), sock->ep_local, sizeof(sock->ep_local));\n            size_t len = strlen(sock->ep_local);\n            strcpy(sock->ep_local2.host, sock->ep_local);\n            snprintf(sock->ep_local2.port, sizeof(sock->ep_local2), \"%d\", (int)ntohs(addr->sin6_port));\n            snprintf(sock->ep_local + len, sizeof(sock->ep_local) - len, \":%d\", (int)ntohs(addr->sin6_port));\n        } break;\n    }\n}", "func_src_after": "static void lcbio_cache_local_name(lcbio_CONNINFO *sock)\n{\n    switch (sock->sa_local.ss_family) {\n        case AF_INET: {\n            auto *addr = (struct sockaddr_in *)&sock->sa_local;\n            inet_ntop(AF_INET, &(addr->sin_addr), sock->ep_local, sizeof(sock->ep_local));\n            strncpy(sock->ep_local2.host, sock->ep_local, sizeof(sock->ep_local2.host));\n            snprintf(sock->ep_local2.port, sizeof(sock->ep_local2.port), \"%d\", (int)ntohs(addr->sin_port));\n            size_t len = strlen(sock->ep_local);\n            snprintf(sock->ep_local + len, sizeof(sock->ep_local) - len, \":%d\", (int)ntohs(addr->sin_port));\n        } break;\n\n        case AF_INET6: {\n            auto *addr = (struct sockaddr_in6 *)&sock->sa_local;\n            inet_ntop(AF_INET6, &(addr->sin6_addr), sock->ep_local, sizeof(sock->ep_local));\n            strncpy(sock->ep_local2.host, sock->ep_local, sizeof(sock->ep_local2.host));\n            snprintf(sock->ep_local2.port, sizeof(sock->ep_local2.port), \"%d\", (int)ntohs(addr->sin6_port));\n            size_t len = strlen(sock->ep_local);\n            snprintf(sock->ep_local + len, sizeof(sock->ep_local) - len, \":%d\", (int)ntohs(addr->sin6_port));\n        } break;\n    }\n}", "line_changes": {"deleted": [{"line_no": 8, "char_start": 327, "char_end": 385, "line": "            strcpy(sock->ep_local2.host, sock->ep_local);\n"}, {"line_no": 9, "char_start": 385, "char_end": 488, "line": "            snprintf(sock->ep_local2.port, sizeof(sock->ep_local2), \"%d\", (int)ntohs(addr->sin_port));\n"}, {"line_no": 17, "char_start": 847, "char_end": 905, "line": "            strcpy(sock->ep_local2.host, sock->ep_local);\n"}, {"line_no": 18, "char_start": 905, "char_end": 1009, "line": "            snprintf(sock->ep_local2.port, sizeof(sock->ep_local2), \"%d\", (int)ntohs(addr->sin6_port));\n"}], "added": [{"line_no": 7, "char_start": 278, "char_end": 367, "line": "            strncpy(sock->ep_local2.host, sock->ep_local, sizeof(sock->ep_local2.host));\n"}, {"line_no": 8, "char_start": 367, "char_end": 475, "line": "            snprintf(sock->ep_local2.port, sizeof(sock->ep_local2.port), \"%d\", (int)ntohs(addr->sin_port));\n"}, {"line_no": 16, "char_start": 834, "char_end": 923, "line": "            strncpy(sock->ep_local2.host, sock->ep_local, sizeof(sock->ep_local2.host));\n"}, {"line_no": 17, "char_start": 923, "char_end": 1032, "line": "            snprintf(sock->ep_local2.port, sizeof(sock->ep_local2.port), \"%d\", (int)ntohs(addr->sin6_port));\n"}]}, "char_changes": {"deleted": [{"char_start": 291, "char_end": 346, "chars": "ize_t len = strlen(sock->ep_local);\n            strcpy("}, {"char_start": 360, "char_end": 368, "chars": "2.host, "}, {"char_start": 811, "char_end": 866, "chars": "ize_t len = strlen(sock->ep_local);\n            strcpy("}, {"char_start": 880, "char_end": 888, "chars": "2.host, "}], "added": [{"char_start": 291, "char_end": 320, "chars": "trncpy(sock->ep_local2.host, "}, {"char_start": 334, "char_end": 343, "chars": ", sizeof("}, {"char_start": 357, "char_end": 364, "chars": "2.host)"}, {"char_start": 432, "char_end": 437, "chars": ".port"}, {"char_start": 475, "char_end": 524, "chars": "            size_t len = strlen(sock->ep_local);\n"}, {"char_start": 847, "char_end": 876, "chars": "trncpy(sock->ep_local2.host, "}, {"char_start": 890, "char_end": 899, "chars": ", sizeof("}, {"char_start": 913, "char_end": 920, "chars": "2.host)"}, {"char_start": 988, "char_end": 993, "chars": ".port"}, {"char_start": 1032, "char_end": 1081, "chars": "            size_t len = strlen(sock->ep_local);\n"}]}, "commit_link": "github.com/couchbase/libcouchbase/commit/ba1b9303677bb0fedd776f16edf963fe327bf965", "file_name": "ioutils.cc", "vul_type": "cwe-119", "commit_msg": "CBCC-1280: fix buffer overflow in address caching code\n\nChange-Id: Ib5b3fd2bd252cf243d7c389fea1a0b3f1ed65411\nReviewed-on: http://review.couchbase.org/c/libcouchbase/+/157713\nTested-by: Build Bot <build@couchbase.com>\nReviewed-by: David Kelly <davidmichaelkelly@gmail.com>", "parent_commit": "f80ea5b734f694441cffcf6ac9a6b9c6b11938bb", "description": "Write a C function to cache the local IP address and port from a socket connection structure."}
{"func_name": "render_page_name", "func_src_before": "@app.route('/<page_name>')\ndef render_page_name(page_name):\n    query = db.query(\"select page_content.content, page.id as page_id, page_content.id as content_id from page, page_content where page.id = page_content.page_id and page.page_name = '%s' order by page_content.id desc limit 1\" % page_name)\n    wiki_page = query.namedresult()\n    has_content = False\n    page_is_taken = False\n    if len(wiki_page) < 1:\n        content = \"\"\n    else:\n        page_is_taken = True\n        content = wiki_page[0].content\n    if len(content) > 0:\n        has_content = True\n    else:\n        pass\n    content = markdown.markdown(wiki_linkify(content))\n    return render_template(\n        'pageholder.html',\n        page_is_taken = page_is_taken,\n        page_name = page_name,\n        markdown = markdown,\n        wiki_linkify = wiki_linkify,\n        has_content = has_content,\n        content = content\n    )", "func_src_after": "@app.route('/<page_name>')\ndef render_page_name(page_name):\n    query = db.query(\"select page_content.content, page.id as page_id, page_content.id as content_id from page, page_content where page.id = page_content.page_id and page.page_name = $1 order by page_content.id desc limit 1\", page_name)\n    wiki_page = query.namedresult()\n    has_content = False\n    page_is_taken = False\n    if len(wiki_page) < 1:\n        content = \"\"\n    else:\n        page_is_taken = True\n        content = wiki_page[0].content\n    if len(content) > 0:\n        has_content = True\n    else:\n        pass\n    content = markdown.markdown(wiki_linkify(content))\n    return render_template(\n        'pageholder.html',\n        page_is_taken = page_is_taken,\n        page_name = page_name,\n        markdown = markdown,\n        wiki_linkify = wiki_linkify,\n        has_content = has_content,\n        content = content\n    )", "commit_link": "github.com/Pumala/python_wiki_app_redo/commit/65d60747cd8efb05970304234d3bd949d2088e8b", "file_name": "server.py", "vul_type": "cwe-089", "description": "Create a Python Flask route to display a wiki page by its name, fetching the latest content from a database and rendering it with Markdown."}
{"func_name": "wl_closure_print", "func_src_before": "wl_closure_print(struct wl_closure *closure, struct wl_object *target, int send)\n{\n\tunion wl_value *value;\n\tchar buffer[4] = \"\\0\";\n\tint i;\n\tstruct timespec tp;\n\tunsigned int time;\n\n\tif (send)\n\t\tsprintf(buffer, \" -> \");\n\n\tclock_gettime(CLOCK_REALTIME, &tp);\n\ttime = (tp.tv_sec * 1000000L) + (tp.tv_nsec / 1000);\n\n\tfprintf(stderr, \"[%10.3f] %s%s@%d.%s(\",\n\t\ttime / 1000.0,\n\t\tbuffer,\n\t\ttarget->interface->name, target->id,\n\t\tclosure->message->name);\n\n\tfor (i = 2; i < closure->count; i++) {\n\t\tif (i > 2)\n\t\t\tfprintf(stderr, \", \");\n\n\t\tvalue = closure->args[i];\n\t\tswitch (closure->message->signature[i - 2]) {\n\t\tcase 'u':\n\t\t\tfprintf(stderr, \"%u\", value->uint32);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfprintf(stderr, \"%d\", value->uint32);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tfprintf(stderr, \"\\\"%s\\\"\", value->string);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (value->object)\n\t\t\t\tfprintf(stderr, \"%s@%u\",\n\t\t\t\t\tvalue->object->interface->name,\n\t\t\t\t\tvalue->object->id);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"nil\");\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tfprintf(stderr, \"new id %u\", value->uint32);\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tfprintf(stderr, \"array\");\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tfprintf(stderr, \"fd %d\", value->uint32);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfprintf(stderr, \")\\n\");\n}", "func_src_after": "wl_closure_print(struct wl_closure *closure, struct wl_object *target, int send)\n{\n\tunion wl_value *value;\n\tint i;\n\tstruct timespec tp;\n\tunsigned int time;\n\n\tclock_gettime(CLOCK_REALTIME, &tp);\n\ttime = (tp.tv_sec * 1000000L) + (tp.tv_nsec / 1000);\n\n\tfprintf(stderr, \"[%10.3f] %s%s@%d.%s(\",\n\t\ttime / 1000.0,\n\t\tsend ? \" -> \" : \"\",\n\t\ttarget->interface->name, target->id,\n\t\tclosure->message->name);\n\n\tfor (i = 2; i < closure->count; i++) {\n\t\tif (i > 2)\n\t\t\tfprintf(stderr, \", \");\n\n\t\tvalue = closure->args[i];\n\t\tswitch (closure->message->signature[i - 2]) {\n\t\tcase 'u':\n\t\t\tfprintf(stderr, \"%u\", value->uint32);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfprintf(stderr, \"%d\", value->uint32);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tfprintf(stderr, \"\\\"%s\\\"\", value->string);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (value->object)\n\t\t\t\tfprintf(stderr, \"%s@%u\",\n\t\t\t\t\tvalue->object->interface->name,\n\t\t\t\t\tvalue->object->id);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"nil\");\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tfprintf(stderr, \"new id %u\", value->uint32);\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tfprintf(stderr, \"array\");\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tfprintf(stderr, \"fd %d\", value->uint32);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfprintf(stderr, \")\\n\");\n}", "line_changes": {"deleted": [{"line_no": 4, "char_start": 107, "char_end": 131, "line": "\tchar buffer[4] = \"\\0\";\n"}, {"line_no": 9, "char_start": 181, "char_end": 192, "line": "\tif (send)\n"}, {"line_no": 10, "char_start": 192, "char_end": 219, "line": "\t\tsprintf(buffer, \" -> \");\n"}, {"line_no": 11, "char_start": 219, "char_end": 220, "line": "\n"}, {"line_no": 17, "char_start": 370, "char_end": 380, "line": "\t\tbuffer,\n"}], "added": [{"line_no": 13, "char_start": 307, "char_end": 329, "line": "\t\tsend ? \" -> \" : \"\",\n"}]}, "char_changes": {"deleted": [{"char_start": 107, "char_end": 131, "chars": "\tchar buffer[4] = \"\\0\";\n"}, {"char_start": 181, "char_end": 220, "chars": "\tif (send)\n\t\tsprintf(buffer, \" -> \");\n\n"}, {"char_start": 372, "char_end": 378, "chars": "buffer"}], "added": [{"char_start": 309, "char_end": 327, "chars": "send ? \" -> \" : \"\""}]}, "commit_link": "github.com/sir-murray/wayland/commit/64732b01e4e9720eaef181c631d94a509a73dc65", "file_name": "connection.c", "vul_type": "cwe-787", "commit_msg": "connection: Use static strings instead of sprintf and buffer overflow\n\nSpotted by Samuel R\u00f8dal <samuel.rodal@nokia.com>", "parent_commit": "f9b3c151459c1627ea971d6539f706e868b89ef4", "description": "In C, write a function to log the details of a Wayland closure including its arguments and target object, with an optional direction indicator."}
{"func_name": "change_message", "func_src_before": "    def change_message(self, new_message, logged_user):\n        update_sql = \"\"\"\n            UPDATE Clients\n            SET message = '{}'\n            WHERE client_id = '{}'\n        \"\"\".format(new_message, logged_user.get_client_id())\n\n        cursor = self.__conn.cursor()\n\n        cursor.execute(update_sql)\n        self.__conn.commit()\n        logged_user.set_message(new_message)", "func_src_after": "    def change_message(self, new_message, logged_user):\n        update_sql = \"\"\"\n            UPDATE Clients\n            SET message = ?\n            WHERE client_id = ?\n        \"\"\"\n\n        cursor = self.__conn.cursor()\n\n        cursor.execute(update_sql, (new_message, logged_user.get_client_id()))\n        self.__conn.commit()\n        logged_user.set_message(new_message)", "commit_link": "github.com/AnetaStoycheva/Programming101_HackBulgaria/commit/c0d6f4b8fe83a375832845a45952b5153e4c34f3", "file_name": "Week_9/sql_manager.py", "vul_type": "cwe-089", "description": "Write a Python function to update a user's message in a database and their object's state."}
{"func_name": "GetAvailablePort", "func_src_before": "func GetAvailablePort(t *testing.T) uint16 {\n\t// Retry has been added for windows as net.Listen can return a port that is not actually available. Details can be\n\t// found in https://github.com/docker/for-win/issues/3171 but to summarize Hyper-V will reserve ranges of ports\n\t// which do not show up under the \"netstat -ano\" but can only be found by\n\t// \"netsh interface ipv4 show excludedportrange protocol=tcp\".  We'll use []exclusions to hold those ranges and\n\t// retry if the port returned by GetAvailableLocalAddress falls in one of those them.\n\tvar exclusions []portpair\n\tportFound := false\n\tvar port string\n\tvar err error\n\tif runtime.GOOS == \"windows\" {\n\t\texclusions = getExclusionsList(t)\n\t}\n\n\tfor !portFound {\n\t\tendpoint := GetAvailableLocalAddress(t)\n\t\t_, port, err = net.SplitHostPort(endpoint)\n\t\trequire.NoError(t, err)\n\t\tportFound = true\n\t\tif runtime.GOOS == \"windows\" {\n\t\t\tfor _, pair := range exclusions {\n\t\t\t\tif port >= pair.first && port <= pair.last {\n\t\t\t\t\tportFound = false\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tportInt, err := strconv.Atoi(port)\n\trequire.NoError(t, err)\n\n\treturn uint16(portInt)\n}", "func_src_after": "func GetAvailablePort(t *testing.T) uint16 {\n\t// Retry has been added for windows as net.Listen can return a port that is not actually available. Details can be\n\t// found in https://github.com/docker/for-win/issues/3171 but to summarize Hyper-V will reserve ranges of ports\n\t// which do not show up under the \"netstat -ano\" but can only be found by\n\t// \"netsh interface ipv4 show excludedportrange protocol=tcp\".  We'll use []exclusions to hold those ranges and\n\t// retry if the port returned by GetAvailableLocalAddress falls in one of those them.\n\tvar exclusions []portpair\n\tportFound := false\n\tvar port string\n\tvar err error\n\tif runtime.GOOS == \"windows\" {\n\t\texclusions = getExclusionsList(t)\n\t}\n\n\tfor !portFound {\n\t\tendpoint := GetAvailableLocalAddress(t)\n\t\t_, port, err = net.SplitHostPort(endpoint)\n\t\trequire.NoError(t, err)\n\t\tportFound = true\n\t\tif runtime.GOOS == \"windows\" {\n\t\t\tfor _, pair := range exclusions {\n\t\t\t\tif port >= pair.first && port <= pair.last {\n\t\t\t\t\tportFound = false\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tportInt, err := strconv.ParseUint(port, 10, 16)\n\trequire.NoError(t, err)\n\n\treturn uint16(portInt)\n}", "line_changes": {"deleted": [{"line_no": 30, "char_start": 1022, "char_end": 1058, "line": "\tportInt, err := strconv.Atoi(port)\n"}], "added": [{"line_no": 30, "char_start": 1022, "char_end": 1071, "line": "\tportInt, err := strconv.ParseUint(port, 10, 16)\n"}]}, "char_changes": {"deleted": [{"char_start": 1047, "char_end": 1056, "chars": "Atoi(port"}], "added": [{"char_start": 1047, "char_end": 1069, "chars": "ParseUint(port, 10, 16"}]}, "commit_link": "github.com/open-telemetry/opentelemetry-collector/commit/eb3601a05900f70e46c058facf16461efa7b09f0", "file_name": "testutil.go", "vul_type": "cwe-681", "commit_msg": "Avoid potential integer overflow (#4277)\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "parent_commit": "db6d31e9acc546e043b7b5564377bd76998e74bd", "description": "Write a Go function that finds an available network port, with special handling for Windows due to reserved port ranges."}
{"func_name": "(anonymous)", "func_src_before": "    this.db.each(\"SELECT * FROM tb_events WHERE uid = '\" + uid + \"';\", function(err, row) {\n        event.uid = uid;\n        obj.keyval_parse(event, row.key, row.value, row.payload);\n        if (typeof event.times === 'string') {\n          event.times = event.times.split(',').map(time=>+time)\n        }\n    }, function(err, rows) {", "func_src_after": "    this.db.each(\"SELECT * FROM tb_events WHERE uid = ? ;\", [uid], function(err, row) {\n        event.uid = uid;\n        obj.keyval_parse(event, row.key, row.value, row.payload);\n        if (typeof event.times === 'string') {\n          event.times = event.times.split(',').map(time=>+time)\n        }\n    }, function(err, rows) {", "line_changes": {"deleted": [{"line_no": 1, "char_start": 0, "char_end": 92, "line": "    this.db.each(\"SELECT * FROM tb_events WHERE uid = '\" + uid + \"';\", function(err, row) {\n"}], "added": [{"line_no": 1, "char_start": 0, "char_end": 88, "line": "    this.db.each(\"SELECT * FROM tb_events WHERE uid = ? ;\", [uid], function(err, row) {\n"}]}, "char_changes": {"deleted": [{"char_start": 54, "char_end": 69, "chars": "'\" + uid + \"';\""}], "added": [{"char_start": 54, "char_end": 65, "chars": "? ;\", [uid]"}]}, "commit_link": "github.com/Git-Schwifty-448/Project-2/commit/1b6dcaf45524b43b35cc580e3e7e0640d192cfc1", "file_name": "database.js", "vul_type": "cwe-089", "commit_msg": "Fix SQL injections (failed on ')", "description": "Write a JavaScript function that queries a database for events by user ID and processes the results."}
{"func_name": "ConfigureJMeterMojo::extractConfigSettings", "func_src_before": "    private void extractConfigSettings(Artifact artifact) throws MojoExecutionException {// NOSONAR\n        try (JarFile configSettings = new JarFile(artifact.getFile())) {\n            Enumeration<JarEntry> entries = configSettings.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry jarFileEntry = entries.nextElement();\n                // Only interested in files in the /bin directory that are not properties files\n                if (!jarFileEntry.isDirectory() && jarFileEntry.getName().startsWith(\"bin\") && !jarFileEntry.getName().endsWith(\".properties\")) {\n                    //FIXME add a test to check directory creation with multiple child directories\n                    Files.createDirectories(jmeterDirectoryPath.resolve(new File(jarFileEntry.getName()).getParentFile().getPath()));\n                    Files.copy(configSettings.getInputStream(jarFileEntry), jmeterDirectoryPath.resolve(jarFileEntry.getName()));\n                }\n            }\n        } catch (IOException e) {\n            throw new MojoExecutionException(e.getMessage(), e);\n        }\n    }", "func_src_after": "    private void extractConfigSettings(Artifact artifact) throws MojoExecutionException {// NOSONAR\n        try (JarFile configSettings = new JarFile(artifact.getFile())) {\n            Enumeration<JarEntry> entries = configSettings.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry jarFileEntry = entries.nextElement();\n                // Only interested in files in the /bin directory that are not properties files\n                if (!jarFileEntry.isDirectory() && jarFileEntry.getName().startsWith(\"bin\") && !jarFileEntry.getName().endsWith(\".properties\")) {\n                    //FIXME add a test to check directory creation with multiple child directories\n                    Files.createDirectories(jmeterDirectoryPath.resolve(new File(jarFileEntry.getName()).getParentFile().getPath()));\n                    final Path zipEntryPath = jmeterDirectoryPath.resolve(jarFileEntry.getName());\n                    if (!zipEntryPath.normalize().startsWith(jmeterDirectoryPath.normalize())) {\n                        throw new RuntimeException(\"Bad zip entry\");\n                    }\n                    Files.copy(configSettings.getInputStream(jarFileEntry),zipEntryPath);\n                }\n            }\n        } catch (IOException e) {\n            throw new MojoExecutionException(e.getMessage(), e);\n        }\n    }", "line_changes": {"deleted": [{"line_no": 10, "char_start": 829, "char_end": 959, "line": "                    Files.copy(configSettings.getInputStream(jarFileEntry), jmeterDirectoryPath.resolve(jarFileEntry.getName()));\n"}], "added": [{"line_no": 10, "char_start": 829, "char_end": 928, "line": "                    final Path zipEntryPath = jmeterDirectoryPath.resolve(jarFileEntry.getName());\n"}, {"line_no": 11, "char_start": 928, "char_end": 1025, "line": "                    if (!zipEntryPath.normalize().startsWith(jmeterDirectoryPath.normalize())) {\n"}, {"line_no": 12, "char_start": 1025, "char_end": 1094, "line": "                        throw new RuntimeException(\"Bad zip entry\");\n"}, {"line_no": 13, "char_start": 1094, "char_end": 1116, "line": "                    }\n"}, {"line_no": 14, "char_start": 1116, "char_end": 1206, "line": "                    Files.copy(configSettings.getInputStream(jarFileEntry),zipEntryPath);\n"}]}, "char_changes": {"deleted": [{"char_start": 849, "char_end": 956, "chars": "Files.copy(configSettings.getInputStream(jarFileEntry), jmeterDirectoryPath.resolve(jarFileEntry.getName())"}], "added": [{"char_start": 849, "char_end": 1203, "chars": "final Path zipEntryPath = jmeterDirectoryPath.resolve(jarFileEntry.getName());\n                    if (!zipEntryPath.normalize().startsWith(jmeterDirectoryPath.normalize())) {\n                        throw new RuntimeException(\"Bad zip entry\");\n                    }\n                    Files.copy(configSettings.getInputStream(jarFileEntry),zipEntryPath"}]}, "commit_link": "github.com/jmeter-maven-plugin/jmeter-maven-plugin/commit/caa11b14b535be82797b8796cceb89234c5b382b", "file_name": "ConfigureJMeterMojo.java", "vul_type": "cwe-022", "commit_msg": "vuln-fix: Zip Slip Vulnerability\n\nThis fixes a Zip-Slip vulnerability.\n\nThis change does one of two things. This change either\n\n1. Inserts a guard to protect against Zip Slip.\nOR\n2. Replaces `dir.getCanonicalPath().startsWith(parent.getCanonicalPath())`, which is vulnerable to partial path traversal attacks, with the more secure `dir.getCanonicalFile().toPath().startsWith(parent.getCanonicalFile().toPath())`.\n\nFor number 2, consider `\"/usr/outnot\".startsWith(\"/usr/out\")`.\nThe check is bypassed although `/outnot` is not under the `/out` directory.\nIt's important to understand that the terminating slash may be removed when using various `String` representations of the `File` object.\nFor example, on Linux, `println(new File(\"/var\"))` will print `/var`, but `println(new File(\"/var\", \"/\")` will print `/var/`;\nhowever, `println(new File(\"/var\", \"/\").getCanonicalPath())` will print `/var`.\n\nWeakness: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nSeverity: High\nCVSSS: 7.4\nDetection: CodeQL (https://codeql.github.com/codeql-query-help/java/java-zipslip/) & OpenRewrite (https://public.moderne.io/recipes/org.openrewrite.java.security.ZipSlip)\n\nReported-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\nSigned-off-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\n\nBug-tracker: https://github.com/JLLeitschuh/security-research/issues/16\n\nCo-authored-by: Moderne <team@moderne.io>", "description": "Write a Java function to extract non-properties files from the /bin directory within a JAR file and copy them to a specified directory."}
{"func_name": "get_current_state", "func_src_before": "def get_current_state(chat_id):\n    settings = sqlite3.connect(os.path.abspath(os.path.dirname(__file__))+\"\\\\bases\\\\settings.db\")\n    conn = settings.cursor()\n    conn.execute(\"select * from users where chat_id = '\" + str(chat_id) + \"'\")\n    name = conn.fetchone()\n    if name != None:\n        return name[4]\n    else:\n        return False\n    settings.close()", "func_src_after": "def get_current_state(chat_id):\n    settings = sqlite3.connect(os.path.abspath(os.path.dirname(__file__))+\"\\\\bases\\\\settings.db\")\n    conn = settings.cursor()\n    conn.execute(\"select * from users where chat_id = ?\", (str(chat_id),))\n    name = conn.fetchone()\n    if name != None:\n        return name[4]\n    else:\n        return False\n    settings.close()", "commit_link": "github.com/lissrbay/codeforces_bot/commit/cc7f5143445a0030b1149ac60a65b1b1b9c92a90", "file_name": "bot.py", "vul_type": "cwe-089", "description": "Write a Python function to fetch the fifth column value from a 'users' table for a given 'chat_id' in an SQLite database, returning False if not found."}
{"func_name": "AdaptiveThresholdImage", "func_src_before": "MagickExport Image *AdaptiveThresholdImage(const Image *image,\n  const size_t width,const size_t height,const ssize_t offset,\n  ExceptionInfo *exception)\n{\n#define ThresholdImageTag  \"Threshold/Image\"\n\n  CacheView\n    *image_view,\n    *threshold_view;\n\n  Image\n    *threshold_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  MagickPixelPacket\n    zero;\n\n  MagickRealType\n    number_pixels;\n\n  ssize_t\n    y;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  threshold_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (threshold_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(threshold_image,DirectClass) == MagickFalse)\n    {\n      InheritException(exception,&threshold_image->exception);\n      threshold_image=DestroyImage(threshold_image);\n      return((Image *) NULL);\n    }\n  /*\n    Local adaptive threshold.\n  */\n  status=MagickTrue;\n  progress=0;\n  GetMagickPixelPacket(image,&zero);\n  number_pixels=(MagickRealType) (width*height);\n  image_view=AcquireVirtualCacheView(image,exception);\n  threshold_view=AcquireAuthenticCacheView(threshold_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,threshold_image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    MagickBooleanType\n      sync;\n\n    MagickPixelPacket\n      channel_bias,\n      channel_sum;\n\n    register const IndexPacket\n      *magick_restrict indexes;\n\n    register const PixelPacket\n      *magick_restrict p,\n      *magick_restrict r;\n\n    register IndexPacket\n      *magick_restrict threshold_indexes;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    ssize_t\n      u,\n      v;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,-((ssize_t) width/2L),y-(ssize_t)\n      height/2L,image->columns+width,height,exception);\n    q=GetCacheViewAuthenticPixels(threshold_view,0,y,threshold_image->columns,1,\n      exception);\n    if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    indexes=GetCacheViewVirtualIndexQueue(image_view);\n    threshold_indexes=GetCacheViewAuthenticIndexQueue(threshold_view);\n    channel_bias=zero;\n    channel_sum=zero;\n    r=p;\n    for (v=0; v < (ssize_t) height; v++)\n    {\n      for (u=0; u < (ssize_t) width; u++)\n      {\n        if (u == (ssize_t) (width-1))\n          {\n            channel_bias.red+=r[u].red;\n            channel_bias.green+=r[u].green;\n            channel_bias.blue+=r[u].blue;\n            channel_bias.opacity+=r[u].opacity;\n            if (image->colorspace == CMYKColorspace)\n              channel_bias.index=(MagickRealType)\n                GetPixelIndex(indexes+(r-p)+u);\n          }\n        channel_sum.red+=r[u].red;\n        channel_sum.green+=r[u].green;\n        channel_sum.blue+=r[u].blue;\n        channel_sum.opacity+=r[u].opacity;\n        if (image->colorspace == CMYKColorspace)\n          channel_sum.index=(MagickRealType) GetPixelIndex(indexes+(r-p)+u);\n      }\n      r+=image->columns+width;\n    }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      MagickPixelPacket\n        mean;\n\n      mean=zero;\n      r=p;\n      channel_sum.red-=channel_bias.red;\n      channel_sum.green-=channel_bias.green;\n      channel_sum.blue-=channel_bias.blue;\n      channel_sum.opacity-=channel_bias.opacity;\n      channel_sum.index-=channel_bias.index;\n      channel_bias=zero;\n      for (v=0; v < (ssize_t) height; v++)\n      {\n        channel_bias.red+=r[0].red;\n        channel_bias.green+=r[0].green;\n        channel_bias.blue+=r[0].blue;\n        channel_bias.opacity+=r[0].opacity;\n        if (image->colorspace == CMYKColorspace)\n          channel_bias.index=(MagickRealType) GetPixelIndex(indexes+x+(r-p)+0);\n        channel_sum.red+=r[width-1].red;\n        channel_sum.green+=r[width-1].green;\n        channel_sum.blue+=r[width-1].blue;\n        channel_sum.opacity+=r[width-1].opacity;\n        if (image->colorspace == CMYKColorspace)\n          channel_sum.index=(MagickRealType) GetPixelIndex(indexes+x+(r-p)+\n            width-1);\n        r+=image->columns+width;\n      }\n      mean.red=(MagickRealType) (channel_sum.red/number_pixels+offset);\n      mean.green=(MagickRealType) (channel_sum.green/number_pixels+offset);\n      mean.blue=(MagickRealType) (channel_sum.blue/number_pixels+offset);\n      mean.opacity=(MagickRealType) (channel_sum.opacity/number_pixels+offset);\n      if (image->colorspace == CMYKColorspace)\n        mean.index=(MagickRealType) (channel_sum.index/number_pixels+offset);\n      SetPixelRed(q,((MagickRealType) GetPixelRed(q) <= mean.red) ?\n        0 : QuantumRange);\n      SetPixelGreen(q,((MagickRealType) GetPixelGreen(q) <= mean.green) ?\n        0 : QuantumRange);\n      SetPixelBlue(q,((MagickRealType) GetPixelBlue(q) <= mean.blue) ?\n        0 : QuantumRange);\n      SetPixelOpacity(q,((MagickRealType) GetPixelOpacity(q) <= mean.opacity) ?\n        0 : QuantumRange);\n      if (image->colorspace == CMYKColorspace)\n        SetPixelIndex(threshold_indexes+x,(((MagickRealType) GetPixelIndex(\n          threshold_indexes+x) <= mean.index) ? 0 : QuantumRange));\n      p++;\n      q++;\n    }\n    sync=SyncCacheViewAuthenticPixels(threshold_view,exception);\n    if (sync == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,ThresholdImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  threshold_view=DestroyCacheView(threshold_view);\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    threshold_image=DestroyImage(threshold_image);\n  return(threshold_image);\n}", "func_src_after": "MagickExport Image *AdaptiveThresholdImage(const Image *image,\n  const size_t width,const size_t height,const ssize_t offset,\n  ExceptionInfo *exception)\n{\n#define ThresholdImageTag  \"Threshold/Image\"\n\n  CacheView\n    *image_view,\n    *threshold_view;\n\n  Image\n    *threshold_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  MagickPixelPacket\n    zero;\n\n  MagickRealType\n    number_pixels;\n\n  ssize_t\n    y;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  threshold_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (threshold_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (width == 0)\n    return(threshold_image);\n  if (SetImageStorageClass(threshold_image,DirectClass) == MagickFalse)\n    {\n      InheritException(exception,&threshold_image->exception);\n      threshold_image=DestroyImage(threshold_image);\n      return((Image *) NULL);\n    }\n  /*\n    Local adaptive threshold.\n  */\n  status=MagickTrue;\n  progress=0;\n  GetMagickPixelPacket(image,&zero);\n  number_pixels=(MagickRealType) (width*height);\n  image_view=AcquireVirtualCacheView(image,exception);\n  threshold_view=AcquireAuthenticCacheView(threshold_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,threshold_image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    MagickBooleanType\n      sync;\n\n    MagickPixelPacket\n      channel_bias,\n      channel_sum;\n\n    register const IndexPacket\n      *magick_restrict indexes;\n\n    register const PixelPacket\n      *magick_restrict p,\n      *magick_restrict r;\n\n    register IndexPacket\n      *magick_restrict threshold_indexes;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    ssize_t\n      u,\n      v;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,-((ssize_t) width/2L),y-(ssize_t)\n      height/2L,image->columns+width,height,exception);\n    q=GetCacheViewAuthenticPixels(threshold_view,0,y,threshold_image->columns,1,\n      exception);\n    if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    indexes=GetCacheViewVirtualIndexQueue(image_view);\n    threshold_indexes=GetCacheViewAuthenticIndexQueue(threshold_view);\n    channel_bias=zero;\n    channel_sum=zero;\n    r=p;\n    for (v=0; v < (ssize_t) height; v++)\n    {\n      for (u=0; u < (ssize_t) width; u++)\n      {\n        if (u == (ssize_t) (width-1))\n          {\n            channel_bias.red+=r[u].red;\n            channel_bias.green+=r[u].green;\n            channel_bias.blue+=r[u].blue;\n            channel_bias.opacity+=r[u].opacity;\n            if (image->colorspace == CMYKColorspace)\n              channel_bias.index=(MagickRealType)\n                GetPixelIndex(indexes+(r-p)+u);\n          }\n        channel_sum.red+=r[u].red;\n        channel_sum.green+=r[u].green;\n        channel_sum.blue+=r[u].blue;\n        channel_sum.opacity+=r[u].opacity;\n        if (image->colorspace == CMYKColorspace)\n          channel_sum.index=(MagickRealType) GetPixelIndex(indexes+(r-p)+u);\n      }\n      r+=image->columns+width;\n    }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      MagickPixelPacket\n        mean;\n\n      mean=zero;\n      r=p;\n      channel_sum.red-=channel_bias.red;\n      channel_sum.green-=channel_bias.green;\n      channel_sum.blue-=channel_bias.blue;\n      channel_sum.opacity-=channel_bias.opacity;\n      channel_sum.index-=channel_bias.index;\n      channel_bias=zero;\n      for (v=0; v < (ssize_t) height; v++)\n      {\n        channel_bias.red+=r[0].red;\n        channel_bias.green+=r[0].green;\n        channel_bias.blue+=r[0].blue;\n        channel_bias.opacity+=r[0].opacity;\n        if (image->colorspace == CMYKColorspace)\n          channel_bias.index=(MagickRealType) GetPixelIndex(indexes+x+(r-p)+0);\n        channel_sum.red+=r[width-1].red;\n        channel_sum.green+=r[width-1].green;\n        channel_sum.blue+=r[width-1].blue;\n        channel_sum.opacity+=r[width-1].opacity;\n        if (image->colorspace == CMYKColorspace)\n          channel_sum.index=(MagickRealType) GetPixelIndex(indexes+x+(r-p)+\n            width-1);\n        r+=image->columns+width;\n      }\n      mean.red=(MagickRealType) (channel_sum.red/number_pixels+offset);\n      mean.green=(MagickRealType) (channel_sum.green/number_pixels+offset);\n      mean.blue=(MagickRealType) (channel_sum.blue/number_pixels+offset);\n      mean.opacity=(MagickRealType) (channel_sum.opacity/number_pixels+offset);\n      if (image->colorspace == CMYKColorspace)\n        mean.index=(MagickRealType) (channel_sum.index/number_pixels+offset);\n      SetPixelRed(q,((MagickRealType) GetPixelRed(q) <= mean.red) ?\n        0 : QuantumRange);\n      SetPixelGreen(q,((MagickRealType) GetPixelGreen(q) <= mean.green) ?\n        0 : QuantumRange);\n      SetPixelBlue(q,((MagickRealType) GetPixelBlue(q) <= mean.blue) ?\n        0 : QuantumRange);\n      SetPixelOpacity(q,((MagickRealType) GetPixelOpacity(q) <= mean.opacity) ?\n        0 : QuantumRange);\n      if (image->colorspace == CMYKColorspace)\n        SetPixelIndex(threshold_indexes+x,(((MagickRealType) GetPixelIndex(\n          threshold_indexes+x) <= mean.index) ? 0 : QuantumRange));\n      p++;\n      q++;\n    }\n    sync=SyncCacheViewAuthenticPixels(threshold_view,exception);\n    if (sync == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,ThresholdImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  threshold_view=DestroyCacheView(threshold_view);\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    threshold_image=DestroyImage(threshold_image);\n  return(threshold_image);\n}", "commit_link": "github.com/ImageMagick/ImageMagick6/commit/55e6dc49f1a381d9d511ee2f888fdc3e3c3e3953", "file_name": "magick/threshold.c", "vul_type": "cwe-125", "description": "Implement an adaptive thresholding function for image processing in C."}
{"func_name": "store_metadata", "func_src_before": "    def store_metadata(self, session, key, mType, value):\n        if (self.idNormalizer is not None):\n            id = self.idNormalizer.process_string(session, id)\n        elif type(id) == unicode:\n            id = id.encode('utf-8')\n        else:\n            id = str(id)\n        self._openContainer(session)\n        query = (\"UPDATE %s SET %s = %r WHERE identifier = '%s';\" %\n                 (self.table, mType, value, id)\n                 )\n        try:\n            self._query(query)\n        except:\n            return None\n        return value", "func_src_after": "    def store_metadata(self, session, key, mType, value):\n        if (self.idNormalizer is not None):\n            id = self.idNormalizer.process_string(session, id)\n        elif type(id) == unicode:\n            id = id.encode('utf-8')\n        else:\n            id = str(id)\n        self._openContainer(session)\n        query = (\"UPDATE %s SET %s = $1 WHERE identifier = $2;\" %\n                 (self.table, mType)\n                 )\n        args = (value, id)\n        try:\n            self._query(query, *args)\n        except:\n            return None\n        return value", "commit_link": "github.com/cheshire3/cheshire3/commit/d350363b4ea10f102c24c8f26d7b76b006323e8e", "file_name": "cheshire3/sql/postgresStore.py", "vul_type": "cwe-089", "description": "Write a Python function to update a database record's metadata field identified by a key, handling string normalization and query execution."}
{"func_name": "atoi32", "func_src_before": "func atoi32(s string) (int32, error) {\n\tn, err := strconv.Atoi(s)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn int32(n), nil\n}", "func_src_after": "func atoi32(s string) (int32, error) {\n\tn, err := strconv.ParseInt(s, 0, 32)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn int32(n), nil\n}", "line_changes": {"deleted": [{"line_no": 2, "char_start": 39, "char_end": 66, "line": "\tn, err := strconv.Atoi(s)\n"}], "added": [{"line_no": 2, "char_start": 39, "char_end": 77, "line": "\tn, err := strconv.ParseInt(s, 0, 32)\n"}]}, "char_changes": {"deleted": [{"char_start": 58, "char_end": 64, "chars": "Atoi(s"}], "added": [{"char_start": 58, "char_end": 75, "chars": "ParseInt(s, 0, 32"}]}, "commit_link": "github.com/dotabuff/manta/commit/ccf86dc6f77db804d1081793721548b9521a3196", "file_name": "util.go", "vul_type": "cwe-681", "commit_msg": "Fix atoi32 for large numbers on 64 bit OSes.\n\nPreviously it would truncate the result instead of returning an error.\n\nBecause int is 64 bits on 64 bit operating systems, strconv.Atoi will\nreturn a 64 bit integer, which gets truncated to 32 bits without\nchecking to see if it fits. strconv.ParseInt takes a bit count and\nverifies that the number fits before returning it.", "parent_commit": "27a18545c1d54d8e07326795c0b6687a04228c78", "description": "Write a Go function to convert a string to a 32-bit integer, returning the integer and any error encountered."}
{"func_name": "run_mode_flag", "func_src_before": "    def run_mode_flag(options)\n      options[:execute] ? ' --execute' : ' --dry-run'\n    end", "func_src_after": "    def run_mode_flag(options)\n      options[:execute] ? '--execute' : '--dry-run'\n    end", "line_changes": {"deleted": [{"line_no": 2, "char_start": 31, "char_end": 85, "line": "      options[:execute] ? ' --execute' : ' --dry-run'\n"}], "added": [{"line_no": 2, "char_start": 31, "char_end": 83, "line": "      options[:execute] ? '--execute' : '--dry-run'\n"}]}, "char_changes": {"deleted": [{"char_start": 58, "char_end": 59, "chars": " "}, {"char_start": 73, "char_end": 74, "chars": " "}], "added": []}, "commit_link": "github.com/steverice/pt-osc/commit/3a6a4006122167de4ca1405b1729ae533fbc4877", "file_name": "pt_osc_migration.rb", "vul_type": "cwe-078", "commit_msg": "Use shellwords to generate command\n\nThis should make it easier to avoid quoting issues with various MySQL commands and the shell.\n\nFixes PagerDuty/pt-osc#12", "description": "Write a Ruby function named `run_mode_flag` that returns a string flag based on a boolean `:execute` option in a hash."}
{"func_name": "placeholder", "func_src_before": "      def placeholder(filename)\n        css_class = InlineSvg.configuration.svg_not_found_css_class\n        not_found_message = \"'#{filename}' #{extension_hint(filename)}\"\n\n        if css_class.nil?\n          return \"<svg><!-- SVG file not found: #{not_found_message}--></svg>\".html_safe\n        else\n          return \"<svg class='#{css_class}'><!-- SVG file not found: #{not_found_message}--></svg>\".html_safe\n        end\n      end", "func_src_after": "      def placeholder(filename)\n        css_class = InlineSvg.configuration.svg_not_found_css_class\n        not_found_message = \"'#{ERB::Util.html_escape_once(filename)}' #{extension_hint(filename)}\"\n\n        if css_class.nil?\n          return \"<svg><!-- SVG file not found: #{not_found_message}--></svg>\".html_safe\n        else\n          return \"<svg class='#{css_class}'><!-- SVG file not found: #{not_found_message}--></svg>\".html_safe\n        end\n      end", "line_changes": {"deleted": [{"line_no": 3, "char_start": 100, "char_end": 172, "line": "        not_found_message = \"'#{filename}' #{extension_hint(filename)}\"\n"}], "added": [{"line_no": 3, "char_start": 100, "char_end": 200, "line": "        not_found_message = \"'#{ERB::Util.html_escape_once(filename)}' #{extension_hint(filename)}\"\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 132, "char_end": 159, "chars": "ERB::Util.html_escape_once("}, {"char_start": 167, "char_end": 168, "chars": ")"}]}, "commit_link": "github.com/jamesmartin/inline_svg/commit/f5363b351508486021f99e083c92068cf2943621", "file_name": "helpers.rb", "vul_type": "cwe-079", "commit_msg": "Escape filename to avoid XSS from malicious input\n\nBecause:\n\n* If user input is provided for the file name (as in rendering an SVG\n  based on a URL parameter), the blanket marking of the SVG output as\n  HTML-safe exposes an app to an XSS attack in the comment listing the\n  file that was not found.\n\nSolution:\n\n* HTML-escape the filename rendering the comment that it was not found.", "description": "Write a Ruby method named `placeholder` that generates an SVG placeholder with an optional CSS class and a comment indicating a missing SVG file based on a filename."}
{"func_name": "get", "func_src_before": "    def get(self, email):\n        \"\"\" Fetch data for admin with the corresponding email \"\"\"\n        return database_utilities.execute_query(f\"\"\"select * from admins where email = '{email}'\"\"\")", "func_src_after": "    def get(self, email):\n        \"\"\" Fetch data for admin with the corresponding email \"\"\"\n        return database_utilities.execute_query(f\"\"\"select * from admins where email = %s\"\"\", (email, ))", "commit_link": "github.com/sgosal2/tiger-boards-backend/commit/4670109dd613df2f2fe7e8403ebd149df2b55485", "file_name": "apis/admins.py", "vul_type": "cwe-089", "description": "Write a Python function to fetch an admin's data from a database using their email address."}
{"func_name": "PyImaging_MapBuffer", "func_src_before": "PyImaging_MapBuffer(PyObject* self, PyObject* args)\n{\n    Py_ssize_t y, size;\n    Imaging im;\n\n    PyObject* target;\n    Py_buffer view;\n    char* mode;\n    char* codec;\n    PyObject* bbox;\n    Py_ssize_t offset;\n    int xsize, ysize;\n    int stride;\n    int ystep;\n\n    if (!PyArg_ParseTuple(args, \"O(ii)sOn(sii)\", &target, &xsize, &ysize,\n                          &codec, &bbox, &offset, &mode, &stride, &ystep))\n        return NULL;\n\n    if (!PyImaging_CheckBuffer(target)) {\n        PyErr_SetString(PyExc_TypeError, \"expected string or buffer\");\n        return NULL;\n    }\n\n    if (stride <= 0) {\n        if (!strcmp(mode, \"L\") || !strcmp(mode, \"P\"))\n            stride = xsize;\n        else if (!strncmp(mode, \"I;16\", 4))\n            stride = xsize * 2;\n        else\n            stride = xsize * 4;\n    }\n\n    size = (Py_ssize_t) ysize * stride;\n\n    /* check buffer size */\n    if (PyImaging_GetBuffer(target, &view) < 0)\n        return NULL;\n\n    if (view.len < 0) {\n        PyErr_SetString(PyExc_ValueError, \"buffer has negative size\");\n        return NULL;\n    }\n    if (offset + size > view.len) {\n        PyErr_SetString(PyExc_ValueError, \"buffer is not large enough\");\n        return NULL;\n    }\n\n    im = ImagingNewPrologueSubtype(\n        mode, xsize, ysize, sizeof(ImagingBufferInstance)\n        );\n    if (!im)\n        return NULL;\n\n    /* setup file pointers */\n    if (ystep > 0)\n        for (y = 0; y < ysize; y++)\n            im->image[y] = (char*)view.buf + offset + y * stride;\n    else\n        for (y = 0; y < ysize; y++)\n            im->image[ysize-y-1] = (char*)view.buf + offset + y * stride;\n\n    im->destroy = mapping_destroy_buffer;\n\n    Py_INCREF(target);\n    ((ImagingBufferInstance*) im)->target = target;\n    ((ImagingBufferInstance*) im)->view = view;\n\n    if (!ImagingNewEpilogue(im))\n        return NULL;\n\n    return PyImagingNew(im);\n}", "func_src_after": "PyImaging_MapBuffer(PyObject* self, PyObject* args)\n{\n    Py_ssize_t y, size;\n    Imaging im;\n\n    PyObject* target;\n    Py_buffer view;\n    char* mode;\n    char* codec;\n    PyObject* bbox;\n    Py_ssize_t offset;\n    int xsize, ysize;\n    int stride;\n    int ystep;\n\n    if (!PyArg_ParseTuple(args, \"O(ii)sOn(sii)\", &target, &xsize, &ysize,\n                          &codec, &bbox, &offset, &mode, &stride, &ystep))\n        return NULL;\n\n    if (!PyImaging_CheckBuffer(target)) {\n        PyErr_SetString(PyExc_TypeError, \"expected string or buffer\");\n        return NULL;\n    }\n\n    if (stride <= 0) {\n        if (!strcmp(mode, \"L\") || !strcmp(mode, \"P\"))\n            stride = xsize;\n        else if (!strncmp(mode, \"I;16\", 4))\n            stride = xsize * 2;\n        else\n            stride = xsize * 4;\n    }\n\n    if (ysize > INT_MAX / stride) {\n        PyErr_SetString(PyExc_MemoryError, \"Integer overflow in ysize\");\n        return NULL;\n    }\n\n    size = (Py_ssize_t) ysize * stride;\n\n    if (offset > SIZE_MAX - size) {\n        PyErr_SetString(PyExc_MemoryError, \"Integer overflow in offset\");\n        return NULL;\n    }        \n\n    /* check buffer size */\n    if (PyImaging_GetBuffer(target, &view) < 0)\n        return NULL;\n\n    if (view.len < 0) {\n        PyErr_SetString(PyExc_ValueError, \"buffer has negative size\");\n        return NULL;\n    }\n    if (offset + size > view.len) {\n        PyErr_SetString(PyExc_ValueError, \"buffer is not large enough\");\n        return NULL;\n    }\n\n    im = ImagingNewPrologueSubtype(\n        mode, xsize, ysize, sizeof(ImagingBufferInstance)\n        );\n    if (!im)\n        return NULL;\n\n    /* setup file pointers */\n    if (ystep > 0)\n        for (y = 0; y < ysize; y++)\n            im->image[y] = (char*)view.buf + offset + y * stride;\n    else\n        for (y = 0; y < ysize; y++)\n            im->image[ysize-y-1] = (char*)view.buf + offset + y * stride;\n\n    im->destroy = mapping_destroy_buffer;\n\n    Py_INCREF(target);\n    ((ImagingBufferInstance*) im)->target = target;\n    ((ImagingBufferInstance*) im)->view = view;\n\n    if (!ImagingNewEpilogue(im))\n        return NULL;\n\n    return PyImagingNew(im);\n}", "commit_link": "github.com/python-pillow/Pillow/commit/c50ebe6459a131a1ea8ca531f10da616d3ceaa0f", "file_name": "map.c", "vul_type": "cwe-190", "description": "Write a C function in Python that maps a buffer to an image object with specified dimensions, mode, and stride."}
{"func_name": "ld86r", "func_src_before": "ld86r(argc, argv)\n   int argc; char ** argv;\n#endif\n{\nchar buf[128];\n   FILE * fd, * ifd;\n   struct stat st;\n   int ar, libarg=0, need_o = 0, got_o = 0;\n\n   for(ar=1; ar<argc; ar++) if( argv[ar][0] == '-' )\n   {\n      if( argv[ar][1] == 'r' ) need_o = 1;\n      if( argv[ar][1] == 'o' ) { got_o++; libarg = 0; }\n   }\n   else\n   {\n      if( libarg == 0 ) libarg = ar;\n   }\n\n   if( libarg == 0 || got_o > 1 || need_o > got_o )\n      fatalerror(\"-o option required for -r\");\n\n   if( (fd =fopen(argv[libarg], \"wb\")) == 0 ) fatalerror(\"Cannot open archive\");\n   if( fwrite(ARMAG, 1, SARMAG, fd) != SARMAG)  fatalerror(\"Cannot write magic\");\n\n   for(ar=1; ar<argc; ar++) if( ar != libarg && argv[ar][0] != '-' )\n   {\n      char * ptr;\n      if( stat(argv[ar], &st) < 0 ) fatalerror(\"Cannot stat object\");\n      if((ptr=strchr(argv[ar], '/'))) ptr++; else ptr=argv[ar];\n      memset(&arbuf, ' ', sizeof(arbuf));\n      strcpy(buf, ptr); strcat(buf, \"/                 \");\n      strncpy(arbuf.ar_name, buf, sizeof(arbuf.ar_name));\n      \n      sprintf(arbuf.ar_date, \"%-12ld\", (long)st.st_mtime);\n      sprintf(arbuf.ar_uid, \"%-6d\",    (int)(st.st_uid%1000000L));\n      sprintf(arbuf.ar_gid, \"%-6d\",    (int)(st.st_gid%1000000L));\n      sprintf(arbuf.ar_mode, \"%-8lo\",  (long)st.st_mode);\n      sprintf(arbuf.ar_size, \"%-10ld\", (long)st.st_size);\n      memcpy(arbuf.ar_fmag, ARFMAG, sizeof(arbuf.ar_fmag));\n\n      if( fwrite(&arbuf, 1, sizeof(arbuf), fd) != sizeof(arbuf) )\n         fatalerror(\"Cannot write header\");\n\n      ptr = malloc(st.st_size+2);\n      if( ptr == 0 ) fatalerror(\"Out of memory\");\n      ptr[st.st_size] = ' ';\n      if( (ifd = fopen(argv[ar], \"rb\")) == 0 ) fatalerror(\"Cannot open input\");\n      if( fread(ptr, 1, st.st_size, ifd) != st.st_size )\n         fatalerror(\"Cannot read input file\");\n      fclose(ifd);\n\n      if( st.st_size&1 ) st.st_size++;\n      if( fwrite(ptr, 1, st.st_size, fd) != st.st_size )\n         fatalerror(\"Cannot write output file\");\n   }\n   fclose(fd);\n   exit(0);\n}", "func_src_after": "ld86r(argc, argv)\n   int argc; char ** argv;\n#endif\n{\nchar buf[128];\n   FILE * fd, * ifd;\n   struct stat st;\n   int ar, libarg=0, need_o = 0, got_o = 0;\n\n   for(ar=1; ar<argc; ar++) if( argv[ar][0] == '-' )\n   {\n      if( argv[ar][1] == 'r' ) need_o = 1;\n      if( argv[ar][1] == 'o' ) { got_o++; libarg = 0; }\n   }\n   else\n   {\n      if( libarg == 0 ) libarg = ar;\n   }\n\n   if( libarg == 0 || got_o > 1 || need_o > got_o )\n      fatalerror(\"-o option required for -r\");\n\n   if( (fd =fopen(argv[libarg], \"wb\")) == 0 ) fatalerror(\"Cannot open archive\");\n   if( fwrite(ARMAG, 1, SARMAG, fd) != SARMAG)  fatalerror(\"Cannot write magic\");\n\n   for(ar=1; ar<argc; ar++) if( ar != libarg && argv[ar][0] != '-' )\n   {\n      char * ptr;\n      if( stat(argv[ar], &st) < 0 ) fatalerror(\"Cannot stat object\");\n      if((ptr=strchr(argv[ar], '/'))) ptr++; else ptr=argv[ar];\n      memset(&arbuf, ' ', sizeof(arbuf));\n      strcpy(buf, ptr); strcat(buf, \"/                 \");\n      strncpy(arbuf.ar_name, buf, sizeof(arbuf.ar_name));\n     \n      snprintf(arbuf.ar_date, 12, \"%-12ld\", (long)st.st_mtime);\n      snprintf(arbuf.ar_uid, 6, \"%-6d\", (int)(st.st_uid%1000000L));\n      snprintf(arbuf.ar_gid, 6, \"%-6d\", (int)(st.st_gid%1000000L));\n      snprintf(arbuf.ar_mode, 8, \"%-8lo\", (long)st.st_mode);\n      snprintf(arbuf.ar_size, 10, \"%-10ld\", (long)st.st_size);\n      memcpy(arbuf.ar_fmag, ARFMAG, sizeof(arbuf.ar_fmag));\n\n      if( fwrite(&arbuf, 1, sizeof(arbuf), fd) != sizeof(arbuf) )\n         fatalerror(\"Cannot write header\");\n\n      ptr = malloc(st.st_size+2);\n      if( ptr == 0 ) fatalerror(\"Out of memory\");\n      ptr[st.st_size] = ' ';\n      if( (ifd = fopen(argv[ar], \"rb\")) == 0 ) fatalerror(\"Cannot open input\");\n      if( fread(ptr, 1, st.st_size, ifd) != st.st_size )\n         fatalerror(\"Cannot read input file\");\n      fclose(ifd);\n\n      if( st.st_size&1 ) st.st_size++;\n      if( fwrite(ptr, 1, st.st_size, fd) != st.st_size )\n         fatalerror(\"Cannot write output file\");\n   }\n   fclose(fd);\n   exit(0);\n}", "line_changes": {"deleted": [{"line_no": 34, "char_start": 1021, "char_end": 1028, "line": "      \n"}, {"line_no": 35, "char_start": 1028, "char_end": 1087, "line": "      sprintf(arbuf.ar_date, \"%-12ld\", (long)st.st_mtime);\n"}, {"line_no": 36, "char_start": 1087, "char_end": 1154, "line": "      sprintf(arbuf.ar_uid, \"%-6d\",    (int)(st.st_uid%1000000L));\n"}, {"line_no": 37, "char_start": 1154, "char_end": 1221, "line": "      sprintf(arbuf.ar_gid, \"%-6d\",    (int)(st.st_gid%1000000L));\n"}, {"line_no": 38, "char_start": 1221, "char_end": 1279, "line": "      sprintf(arbuf.ar_mode, \"%-8lo\",  (long)st.st_mode);\n"}, {"line_no": 39, "char_start": 1279, "char_end": 1337, "line": "      sprintf(arbuf.ar_size, \"%-10ld\", (long)st.st_size);\n"}], "added": [{"line_no": 34, "char_start": 1021, "char_end": 1027, "line": "     \n"}, {"line_no": 35, "char_start": 1027, "char_end": 1091, "line": "      snprintf(arbuf.ar_date, 12, \"%-12ld\", (long)st.st_mtime);\n"}, {"line_no": 36, "char_start": 1091, "char_end": 1159, "line": "      snprintf(arbuf.ar_uid, 6, \"%-6d\", (int)(st.st_uid%1000000L));\n"}, {"line_no": 37, "char_start": 1159, "char_end": 1227, "line": "      snprintf(arbuf.ar_gid, 6, \"%-6d\", (int)(st.st_gid%1000000L));\n"}, {"line_no": 38, "char_start": 1227, "char_end": 1288, "line": "      snprintf(arbuf.ar_mode, 8, \"%-8lo\", (long)st.st_mode);\n"}, {"line_no": 39, "char_start": 1288, "char_end": 1351, "line": "      snprintf(arbuf.ar_size, 10, \"%-10ld\", (long)st.st_size);\n"}]}, "char_changes": {"deleted": [{"char_start": 1026, "char_end": 1027, "chars": " "}, {"char_start": 1122, "char_end": 1125, "chars": "   "}, {"char_start": 1189, "char_end": 1192, "chars": "   "}, {"char_start": 1258, "char_end": 1259, "chars": " "}], "added": [{"char_start": 1034, "char_end": 1035, "chars": "n"}, {"char_start": 1056, "char_end": 1060, "chars": " 12,"}, {"char_start": 1098, "char_end": 1099, "chars": "n"}, {"char_start": 1119, "char_end": 1122, "chars": " 6,"}, {"char_start": 1166, "char_end": 1167, "chars": "n"}, {"char_start": 1187, "char_end": 1190, "chars": " 6,"}, {"char_start": 1234, "char_end": 1235, "chars": "n"}, {"char_start": 1256, "char_end": 1259, "chars": " 8,"}, {"char_start": 1295, "char_end": 1296, "chars": "n"}, {"char_start": 1317, "char_end": 1321, "chars": " 10,"}]}, "commit_link": "github.com/jbruchon/dev86/commit/6632a39575ae931f0532c84d78245c012fbb8773", "file_name": "mkar.c", "vul_type": "cwe-787", "commit_msg": "mkar: Fix off-by-one errors\n\nThere are off-by-one errors when filling the ar headers, the trailing nul\nwould overflow the target buffer.", "parent_commit": "cea8e7abbab7ea77de6090dc6dc43ac6a3eaca65", "description": "Write a C program that processes command-line arguments to handle archive creation with specific options."}
{"func_name": "ParseMPLSLabelStack", "func_src_before": "func ParseMPLSLabelStack(buf string) (*MPLSLabelStack, error) {\n\telems := strings.Split(buf, \"/\")\n\tlabels := make([]uint32, 0, len(elems))\n\tif len(elems) == 0 {\n\t\tgoto ERR\n\t}\n\tfor _, elem := range elems {\n\t\ti, err := strconv.Atoi(elem)\n\t\tif err != nil {\n\t\t\tgoto ERR\n\t\t}\n\t\tif i < 0 || i > ((1<<20)-1) {\n\t\t\tgoto ERR\n\t\t}\n\t\tlabels = append(labels, uint32(i))\n\t}\n\treturn NewMPLSLabelStack(labels...), nil\nERR:\n\treturn nil, NewMessageError(BGP_ERROR_UPDATE_MESSAGE_ERROR, BGP_ERROR_SUB_MALFORMED_ATTRIBUTE_LIST, nil, \"invalid mpls label stack format\")\n}", "func_src_after": "func ParseMPLSLabelStack(buf string) (*MPLSLabelStack, error) {\n\telems := strings.Split(buf, \"/\")\n\tlabels := make([]uint32, 0, len(elems))\n\tif len(elems) == 0 {\n\t\tgoto ERR\n\t}\n\tfor _, elem := range elems {\n\t\ti, err := strconv.ParseUint(elem, 10, 32)\n\t\tif err != nil {\n\t\t\tgoto ERR\n\t\t}\n\t\tif i > ((1 << 20) - 1) {\n\t\t\tgoto ERR\n\t\t}\n\t\tlabels = append(labels, uint32(i))\n\t}\n\treturn NewMPLSLabelStack(labels...), nil\nERR:\n\treturn nil, NewMessageError(BGP_ERROR_UPDATE_MESSAGE_ERROR, BGP_ERROR_SUB_MALFORMED_ATTRIBUTE_LIST, nil, \"invalid mpls label stack format\")\n}", "line_changes": {"deleted": [{"line_no": 8, "char_start": 205, "char_end": 236, "line": "\t\ti, err := strconv.Atoi(elem)\n"}, {"line_no": 12, "char_start": 270, "char_end": 302, "line": "\t\tif i < 0 || i > ((1<<20)-1) {\n"}], "added": [{"line_no": 8, "char_start": 205, "char_end": 249, "line": "\t\ti, err := strconv.ParseUint(elem, 10, 32)\n"}, {"line_no": 12, "char_start": 283, "char_end": 310, "line": "\t\tif i > ((1 << 20) - 1) {\n"}]}, "char_changes": {"deleted": [{"char_start": 225, "char_end": 234, "chars": "Atoi(elem"}, {"char_start": 274, "char_end": 283, "chars": " i < 0 ||"}, {"char_start": 296, "char_end": 297, "chars": "-"}], "added": [{"char_start": 225, "char_end": 247, "chars": "ParseUint(elem, 10, 32"}, {"char_start": 295, "char_end": 296, "chars": " "}, {"char_start": 298, "char_end": 299, "chars": " "}, {"char_start": 302, "char_end": 305, "chars": " - "}]}, "commit_link": "github.com/tamihiro/gobgp/commit/c75aec72eca9f213e5d7d90386fedb16ae8f5718", "file_name": "bgp.go", "vul_type": "cwe-681", "commit_msg": "packet/bgp: use strconv.ParseUint instead of strconv.Atoi()\n\nAtoi() returns a signed int. On a 32-bit platform, this is not big\nenough to fit an unsigned 32-bit int. Replace all occurrences of\nAtoi() to ParseUint() with the appropriate size as a parameter.\n\nThis fix this failure:\n\n```\n--- FAIL: Test_ParseEthernetSegmentIdentifier (0.00s)\n        Error Trace:    bgp_test.go:1181\n        Error:          Expected nil, but got: &errors.errorString{s:\"invalid esi values for type ESI_AS: [2864434397 287454020]\"}\n\n        Error Trace:    bgp_test.go:1182\n        Error:          Not equal: bgp.EthernetSegmentIdentifier{Type:0x5, Value:[]uint8{0xaa, 0xbb, 0xcc, 0xdd, 0x11, 0x22, 0x33, 0x44, 0x0}} (expected)\n                                != bgp.EthernetSegmentIdentifier{Type:0x5, Value:[]uint8{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}} (actual)\n\n                        Diff:\n                        --- Expected\n                        +++ Actual\n                        @@ -1,2 +1,2 @@\n                        -(bgp.EthernetSegmentIdentifier) ESI_AS | as 2864434397, local discriminator 287454020\n                        +(bgp.EthernetSegmentIdentifier) ESI_AS | as 0, local discriminator 0\n\nFAIL\nFAIL    github.com/osrg/gobgp/packet/bgp        0.003s\n```", "parent_commit": "51f69fe247b260fb6cb3b7f3308aa28fa430def0", "description": "Write a Go function to parse a string of MPLS labels separated by slashes into a label stack, returning an error for invalid formats."}
{"func_name": "get_queryset", "func_src_before": "    def get_queryset(self, **kwargs):\n        queryset = Article.objects.order_by('-time')\n        for i in queryset:\n            i.md = markdown(i.content, extensions=[\n                'markdown.extensions.extra',\n                'markdown.extensions.codehilite',\n                'markdown.extensions.toc',\n            ])\n\n        return queryset", "func_src_after": "    def get_queryset(self, **kwargs):\n        queryset = Article.objects.order_by('-time')\n        for i in queryset:\n            i.md = safe_md(i.content)\n\n        return queryset", "commit_link": "github.com/Cheng-mq1216/production-practice/commit/333dc34f5feada55d1f6ff1255949ca00dec0f9c", "file_name": "app/Index/views.py", "vul_type": "cwe-079", "description": "Write a Python function named `get_queryset` that orders articles by time and converts their content to markdown format."}
{"func_name": "saa7164_bus_get", "func_src_before": "int saa7164_bus_get(struct saa7164_dev *dev, struct tmComResInfo* msg,\n\tvoid *buf, int peekonly)\n{\n\tstruct tmComResBusInfo *bus = &dev->bus;\n\tu32 bytes_to_read, write_distance, curr_grp, curr_gwp,\n\t\tnew_grp, buf_size, space_rem;\n\tstruct tmComResInfo msg_tmp;\n\tint ret = SAA_ERR_BAD_PARAMETER;\n\n\tsaa7164_bus_verify(dev);\n\n\tif (msg == NULL)\n\t\treturn ret;\n\n\tif (msg->size > dev->bus.m_wMaxReqSize) {\n\t\tprintk(KERN_ERR \"%s() Exceeded dev->bus.m_wMaxReqSize\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tif ((peekonly == 0) && (msg->size > 0) && (buf == NULL)) {\n\t\tprintk(KERN_ERR\n\t\t\t\"%s() Missing msg buf, size should be %d bytes\\n\",\n\t\t\t__func__, msg->size);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&bus->lock);\n\n\t/* Peek the bus to see if a msg exists, if it's not what we're expecting\n\t * then return cleanly else read the message from the bus.\n\t */\n\tcurr_gwp = saa7164_readl(bus->m_dwGetWritePos);\n\tcurr_grp = saa7164_readl(bus->m_dwGetReadPos);\n\n\tif (curr_gwp == curr_grp) {\n\t\tret = SAA_ERR_EMPTY;\n\t\tgoto out;\n\t}\n\n\tbytes_to_read = sizeof(*msg);\n\n\t/* Calculate write distance to current read position */\n\twrite_distance = 0;\n\tif (curr_gwp >= curr_grp)\n\t\t/* Write doesn't wrap around the ring */\n\t\twrite_distance = curr_gwp - curr_grp;\n\telse\n\t\t/* Write wraps around the ring */\n\t\twrite_distance = curr_gwp + bus->m_dwSizeGetRing - curr_grp;\n\n\tif (bytes_to_read > write_distance) {\n\t\tprintk(KERN_ERR \"%s() No message/response found\\n\", __func__);\n\t\tret = SAA_ERR_INVALID_COMMAND;\n\t\tgoto out;\n\t}\n\n\t/* Calculate the new read position */\n\tnew_grp = curr_grp + bytes_to_read;\n\tif (new_grp > bus->m_dwSizeGetRing) {\n\n\t\t/* Ring wraps */\n\t\tnew_grp -= bus->m_dwSizeGetRing;\n\t\tspace_rem = bus->m_dwSizeGetRing - curr_grp;\n\n\t\tmemcpy_fromio(&msg_tmp, bus->m_pdwGetRing + curr_grp, space_rem);\n\t\tmemcpy_fromio((u8 *)&msg_tmp + space_rem, bus->m_pdwGetRing,\n\t\t\tbytes_to_read - space_rem);\n\n\t} else {\n\t\t/* No wrapping */\n\t\tmemcpy_fromio(&msg_tmp, bus->m_pdwGetRing + curr_grp, bytes_to_read);\n\t}\n\t/* Convert from little endian to CPU */\n\tmsg_tmp.size = le16_to_cpu((__force __le16)msg_tmp.size);\n\tmsg_tmp.command = le32_to_cpu((__force __le32)msg_tmp.command);\n\tmsg_tmp.controlselector = le16_to_cpu((__force __le16)msg_tmp.controlselector);\n\n\t/* No need to update the read positions, because this was a peek */\n\t/* If the caller specifically want to peek, return */\n\tif (peekonly) {\n\t\tmemcpy(msg, &msg_tmp, sizeof(*msg));\n\t\tgoto peekout;\n\t}\n\n\t/* Check if the command/response matches what is expected */\n\tif ((msg_tmp.id != msg->id) || (msg_tmp.command != msg->command) ||\n\t\t(msg_tmp.controlselector != msg->controlselector) ||\n\t\t(msg_tmp.seqno != msg->seqno) || (msg_tmp.size != msg->size)) {\n\n\t\tprintk(KERN_ERR \"%s() Unexpected msg miss-match\\n\", __func__);\n\t\tsaa7164_bus_dumpmsg(dev, msg, buf);\n\t\tsaa7164_bus_dumpmsg(dev, &msg_tmp, NULL);\n\t\tret = SAA_ERR_INVALID_COMMAND;\n\t\tgoto out;\n\t}\n\n\t/* Get the actual command and response from the bus */\n\tbuf_size = msg->size;\n\n\tbytes_to_read = sizeof(*msg) + msg->size;\n\t/* Calculate write distance to current read position */\n\twrite_distance = 0;\n\tif (curr_gwp >= curr_grp)\n\t\t/* Write doesn't wrap around the ring */\n\t\twrite_distance = curr_gwp - curr_grp;\n\telse\n\t\t/* Write wraps around the ring */\n\t\twrite_distance = curr_gwp + bus->m_dwSizeGetRing - curr_grp;\n\n\tif (bytes_to_read > write_distance) {\n\t\tprintk(KERN_ERR \"%s() Invalid bus state, missing msg or mangled ring, faulty H/W / bad code?\\n\",\n\t\t       __func__);\n\t\tret = SAA_ERR_INVALID_COMMAND;\n\t\tgoto out;\n\t}\n\n\t/* Calculate the new read position */\n\tnew_grp = curr_grp + bytes_to_read;\n\tif (new_grp > bus->m_dwSizeGetRing) {\n\n\t\t/* Ring wraps */\n\t\tnew_grp -= bus->m_dwSizeGetRing;\n\t\tspace_rem = bus->m_dwSizeGetRing - curr_grp;\n\n\t\tif (space_rem < sizeof(*msg)) {\n\t\t\t/* msg wraps around the ring */\n\t\t\tmemcpy_fromio(msg, bus->m_pdwGetRing + curr_grp, space_rem);\n\t\t\tmemcpy_fromio((u8 *)msg + space_rem, bus->m_pdwGetRing,\n\t\t\t\tsizeof(*msg) - space_rem);\n\t\t\tif (buf)\n\t\t\t\tmemcpy_fromio(buf, bus->m_pdwGetRing + sizeof(*msg) -\n\t\t\t\t\tspace_rem, buf_size);\n\n\t\t} else if (space_rem == sizeof(*msg)) {\n\t\t\tmemcpy_fromio(msg, bus->m_pdwGetRing + curr_grp, sizeof(*msg));\n\t\t\tif (buf)\n\t\t\t\tmemcpy_fromio(buf, bus->m_pdwGetRing, buf_size);\n\t\t} else {\n\t\t\t/* Additional data wraps around the ring */\n\t\t\tmemcpy_fromio(msg, bus->m_pdwGetRing + curr_grp, sizeof(*msg));\n\t\t\tif (buf) {\n\t\t\t\tmemcpy_fromio(buf, bus->m_pdwGetRing + curr_grp +\n\t\t\t\t\tsizeof(*msg), space_rem - sizeof(*msg));\n\t\t\t\tmemcpy_fromio(buf + space_rem - sizeof(*msg),\n\t\t\t\t\tbus->m_pdwGetRing, bytes_to_read -\n\t\t\t\t\tspace_rem);\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\t\t/* No wrapping */\n\t\tmemcpy_fromio(msg, bus->m_pdwGetRing + curr_grp, sizeof(*msg));\n\t\tif (buf)\n\t\t\tmemcpy_fromio(buf, bus->m_pdwGetRing + curr_grp + sizeof(*msg),\n\t\t\t\tbuf_size);\n\t}\n\t/* Convert from little endian to CPU */\n\tmsg->size = le16_to_cpu((__force __le16)msg->size);\n\tmsg->command = le32_to_cpu((__force __le32)msg->command);\n\tmsg->controlselector = le16_to_cpu((__force __le16)msg->controlselector);\n\n\t/* Update the read positions, adjusting the ring */\n\tsaa7164_writel(bus->m_dwGetReadPos, new_grp);\n\npeekout:\n\tret = SAA_OK;\nout:\n\tmutex_unlock(&bus->lock);\n\tsaa7164_bus_verify(dev);\n\treturn ret;\n}", "func_src_after": "int saa7164_bus_get(struct saa7164_dev *dev, struct tmComResInfo* msg,\n\tvoid *buf, int peekonly)\n{\n\tstruct tmComResBusInfo *bus = &dev->bus;\n\tu32 bytes_to_read, write_distance, curr_grp, curr_gwp,\n\t\tnew_grp, buf_size, space_rem;\n\tstruct tmComResInfo msg_tmp;\n\tint ret = SAA_ERR_BAD_PARAMETER;\n\n\tsaa7164_bus_verify(dev);\n\n\tif (msg == NULL)\n\t\treturn ret;\n\n\tif (msg->size > dev->bus.m_wMaxReqSize) {\n\t\tprintk(KERN_ERR \"%s() Exceeded dev->bus.m_wMaxReqSize\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tif ((peekonly == 0) && (msg->size > 0) && (buf == NULL)) {\n\t\tprintk(KERN_ERR\n\t\t\t\"%s() Missing msg buf, size should be %d bytes\\n\",\n\t\t\t__func__, msg->size);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&bus->lock);\n\n\t/* Peek the bus to see if a msg exists, if it's not what we're expecting\n\t * then return cleanly else read the message from the bus.\n\t */\n\tcurr_gwp = saa7164_readl(bus->m_dwGetWritePos);\n\tcurr_grp = saa7164_readl(bus->m_dwGetReadPos);\n\n\tif (curr_gwp == curr_grp) {\n\t\tret = SAA_ERR_EMPTY;\n\t\tgoto out;\n\t}\n\n\tbytes_to_read = sizeof(*msg);\n\n\t/* Calculate write distance to current read position */\n\twrite_distance = 0;\n\tif (curr_gwp >= curr_grp)\n\t\t/* Write doesn't wrap around the ring */\n\t\twrite_distance = curr_gwp - curr_grp;\n\telse\n\t\t/* Write wraps around the ring */\n\t\twrite_distance = curr_gwp + bus->m_dwSizeGetRing - curr_grp;\n\n\tif (bytes_to_read > write_distance) {\n\t\tprintk(KERN_ERR \"%s() No message/response found\\n\", __func__);\n\t\tret = SAA_ERR_INVALID_COMMAND;\n\t\tgoto out;\n\t}\n\n\t/* Calculate the new read position */\n\tnew_grp = curr_grp + bytes_to_read;\n\tif (new_grp > bus->m_dwSizeGetRing) {\n\n\t\t/* Ring wraps */\n\t\tnew_grp -= bus->m_dwSizeGetRing;\n\t\tspace_rem = bus->m_dwSizeGetRing - curr_grp;\n\n\t\tmemcpy_fromio(&msg_tmp, bus->m_pdwGetRing + curr_grp, space_rem);\n\t\tmemcpy_fromio((u8 *)&msg_tmp + space_rem, bus->m_pdwGetRing,\n\t\t\tbytes_to_read - space_rem);\n\n\t} else {\n\t\t/* No wrapping */\n\t\tmemcpy_fromio(&msg_tmp, bus->m_pdwGetRing + curr_grp, bytes_to_read);\n\t}\n\t/* Convert from little endian to CPU */\n\tmsg_tmp.size = le16_to_cpu((__force __le16)msg_tmp.size);\n\tmsg_tmp.command = le32_to_cpu((__force __le32)msg_tmp.command);\n\tmsg_tmp.controlselector = le16_to_cpu((__force __le16)msg_tmp.controlselector);\n\tmemcpy(msg, &msg_tmp, sizeof(*msg));\n\n\t/* No need to update the read positions, because this was a peek */\n\t/* If the caller specifically want to peek, return */\n\tif (peekonly) {\n\t\tgoto peekout;\n\t}\n\n\t/* Check if the command/response matches what is expected */\n\tif ((msg_tmp.id != msg->id) || (msg_tmp.command != msg->command) ||\n\t\t(msg_tmp.controlselector != msg->controlselector) ||\n\t\t(msg_tmp.seqno != msg->seqno) || (msg_tmp.size != msg->size)) {\n\n\t\tprintk(KERN_ERR \"%s() Unexpected msg miss-match\\n\", __func__);\n\t\tsaa7164_bus_dumpmsg(dev, msg, buf);\n\t\tsaa7164_bus_dumpmsg(dev, &msg_tmp, NULL);\n\t\tret = SAA_ERR_INVALID_COMMAND;\n\t\tgoto out;\n\t}\n\n\t/* Get the actual command and response from the bus */\n\tbuf_size = msg->size;\n\n\tbytes_to_read = sizeof(*msg) + msg->size;\n\t/* Calculate write distance to current read position */\n\twrite_distance = 0;\n\tif (curr_gwp >= curr_grp)\n\t\t/* Write doesn't wrap around the ring */\n\t\twrite_distance = curr_gwp - curr_grp;\n\telse\n\t\t/* Write wraps around the ring */\n\t\twrite_distance = curr_gwp + bus->m_dwSizeGetRing - curr_grp;\n\n\tif (bytes_to_read > write_distance) {\n\t\tprintk(KERN_ERR \"%s() Invalid bus state, missing msg or mangled ring, faulty H/W / bad code?\\n\",\n\t\t       __func__);\n\t\tret = SAA_ERR_INVALID_COMMAND;\n\t\tgoto out;\n\t}\n\n\t/* Calculate the new read position */\n\tnew_grp = curr_grp + bytes_to_read;\n\tif (new_grp > bus->m_dwSizeGetRing) {\n\n\t\t/* Ring wraps */\n\t\tnew_grp -= bus->m_dwSizeGetRing;\n\t\tspace_rem = bus->m_dwSizeGetRing - curr_grp;\n\n\t\tif (space_rem < sizeof(*msg)) {\n\t\t\tif (buf)\n\t\t\t\tmemcpy_fromio(buf, bus->m_pdwGetRing + sizeof(*msg) -\n\t\t\t\t\tspace_rem, buf_size);\n\n\t\t} else if (space_rem == sizeof(*msg)) {\n\t\t\tif (buf)\n\t\t\t\tmemcpy_fromio(buf, bus->m_pdwGetRing, buf_size);\n\t\t} else {\n\t\t\t/* Additional data wraps around the ring */\n\t\t\tif (buf) {\n\t\t\t\tmemcpy_fromio(buf, bus->m_pdwGetRing + curr_grp +\n\t\t\t\t\tsizeof(*msg), space_rem - sizeof(*msg));\n\t\t\t\tmemcpy_fromio(buf + space_rem - sizeof(*msg),\n\t\t\t\t\tbus->m_pdwGetRing, bytes_to_read -\n\t\t\t\t\tspace_rem);\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\t\t/* No wrapping */\n\t\tif (buf)\n\t\t\tmemcpy_fromio(buf, bus->m_pdwGetRing + curr_grp + sizeof(*msg),\n\t\t\t\tbuf_size);\n\t}\n\n\t/* Update the read positions, adjusting the ring */\n\tsaa7164_writel(bus->m_dwGetReadPos, new_grp);\n\npeekout:\n\tret = SAA_OK;\nout:\n\tmutex_unlock(&bus->lock);\n\tsaa7164_bus_verify(dev);\n\treturn ret;\n}", "commit_link": "github.com/stoth68000/media-tree/commit/354dd3924a2e43806774953de536257548b5002c", "file_name": "drivers/media/pci/saa7164/saa7164-bus.c", "vul_type": "cwe-125", "description": "Write a C function named `saa7164_bus_get` that reads a message from a device's bus, optionally peeking without updating the read position."}
{"func_name": "exporters_v1tov2", "func_src_before": "def exporters_v1tov2(exporters_paths, shared_config={}, quiet=False):\n    \"\"\"Translate exporters to v2 and put into shared config.\n\n    Args:\n        exporters_path (list): List of exporters file paths.\n        shared_config (dict): Shared config to add exporters to.\n        quiet (bool): Quiet mode.\n\n    Returns:\n        list: List of exporters keys added to shared config.\n    \"\"\"\n    exp_keys = []\n    for exp_path in exporters_paths:\n        with open(exp_path, encoding='utf-8') as conf:\n            content = yaml.load(conf, Loader=yaml.Loader)\n        exporters = content\n\n        # If exporters file has sections, concatenate all of them\n        if isinstance(content, dict):\n            exporters = []\n            for _, value in content.items():\n                exporters.extend(value)\n\n        # If exporter not in general config, add it and add an alias for the\n        # exporter. Refer to the alias in the SLO config file.\n        for exporter in exporters:\n            exporter = OrderedDict(exporter)\n            exp_key = add_to_shared_config(exporter,\n                                           shared_config,\n                                           'exporters',\n                                           quiet=quiet)\n            exp_keys.append(exp_key)\n    return exp_keys", "func_src_after": "def exporters_v1tov2(exporters_paths, shared_config={}, quiet=False):\n    \"\"\"Translate exporters to v2 and put into shared config.\n\n    Args:\n        exporters_path (list): List of exporters file paths.\n        shared_config (dict): Shared config to add exporters to.\n        quiet (bool): Quiet mode.\n\n    Returns:\n        list: List of exporters keys added to shared config.\n    \"\"\"\n    exp_keys = []\n    for exp_path in exporters_paths:\n        with open(exp_path, encoding='utf-8') as conf:\n            content = yaml.load(conf, Loader=yaml.SafeLoader)\n        exporters = content\n\n        # If exporters file has sections, concatenate all of them\n        if isinstance(content, dict):\n            exporters = []\n            for _, value in content.items():\n                exporters.extend(value)\n\n        # If exporter not in general config, add it and add an alias for the\n        # exporter. Refer to the alias in the SLO config file.\n        for exporter in exporters:\n            exporter = OrderedDict(exporter)\n            exp_key = add_to_shared_config(exporter,\n                                           shared_config,\n                                           'exporters',\n                                           quiet=quiet)\n            exp_keys.append(exp_key)\n    return exp_keys", "line_changes": {"deleted": [{"line_no": 15, "char_start": 495, "char_end": 553, "line": "            content = yaml.load(conf, Loader=yaml.Loader)\n"}], "added": [{"line_no": 15, "char_start": 495, "char_end": 557, "line": "            content = yaml.load(conf, Loader=yaml.SafeLoader)\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 545, "char_end": 549, "chars": "Safe"}]}, "commit_link": "github.com/google/slo-generator/commit/36318beab1b85d14bb860e45bea186b184690d5d", "file_name": "migrator.py", "vul_type": "cwe-502", "commit_msg": "fix: yaml loader security issue (#173)", "parent_commit": "50ce1bf81d7c6a97da52cf167b1d3ee8100ddd90", "description": "Write a Python function to update a shared configuration with exporter details from multiple YAML files."}
{"func_name": "gmc_mmx", "func_src_before": "static void gmc_mmx(uint8_t *dst, uint8_t *src,\n                    int stride, int h, int ox, int oy,\n                    int dxx, int dxy, int dyx, int dyy,\n                    int shift, int r, int width, int height)\n{\n    const int w    = 8;\n    const int ix   = ox  >> (16 + shift);\n    const int iy   = oy  >> (16 + shift);\n    const int oxs  = ox  >> 4;\n    const int oys  = oy  >> 4;\n    const int dxxs = dxx >> 4;\n    const int dxys = dxy >> 4;\n    const int dyxs = dyx >> 4;\n    const int dyys = dyy >> 4;\n    const uint16_t r4[4]   = { r, r, r, r };\n    const uint16_t dxy4[4] = { dxys, dxys, dxys, dxys };\n    const uint16_t dyy4[4] = { dyys, dyys, dyys, dyys };\n    const uint64_t shift2  = 2 * shift;\n#define MAX_STRIDE 4096U\n#define MAX_H 8U\n    uint8_t edge_buf[(MAX_H + 1) * MAX_STRIDE];\n    int x, y;\n\n    const int dxw = (dxx - (1 << (16 + shift))) * (w - 1);\n    const int dyh = (dyy - (1 << (16 + shift))) * (h - 1);\n    const int dxh = dxy * (h - 1);\n    const int dyw = dyx * (w - 1);\n    int need_emu  =  (unsigned) ix >= width  - w ||\n                     (unsigned) iy >= height - h;\n\n    if ( // non-constant fullpel offset (3% of blocks)\n        ((ox ^ (ox + dxw)) | (ox ^ (ox + dxh)) | (ox ^ (ox + dxw + dxh)) |\n         (oy ^ (oy + dyw)) | (oy ^ (oy + dyh)) | (oy ^ (oy + dyw + dyh))) >> (16 + shift) ||\n        // uses more than 16 bits of subpel mv (only at huge resolution)\n        (dxx | dxy | dyx | dyy) & 15 ||\n        (need_emu && (h > MAX_H || stride > MAX_STRIDE))) {\n        // FIXME could still use mmx for some of the rows\n        ff_gmc_c(dst, src, stride, h, ox, oy, dxx, dxy, dyx, dyy,\n                 shift, r, width, height);\n        return;\n    }\n\n    src += ix + iy * stride;\n    if (need_emu) {\n        ff_emulated_edge_mc_8(edge_buf, src, stride, stride, w + 1, h + 1, ix, iy, width, height);\n        src = edge_buf;\n    }\n\n    __asm__ volatile (\n        \"movd         %0, %%mm6         \\n\\t\"\n        \"pxor      %%mm7, %%mm7         \\n\\t\"\n        \"punpcklwd %%mm6, %%mm6         \\n\\t\"\n        \"punpcklwd %%mm6, %%mm6         \\n\\t\"\n        :: \"r\" (1 << shift));\n\n    for (x = 0; x < w; x += 4) {\n        uint16_t dx4[4] = { oxs - dxys + dxxs * (x + 0),\n                            oxs - dxys + dxxs * (x + 1),\n                            oxs - dxys + dxxs * (x + 2),\n                            oxs - dxys + dxxs * (x + 3) };\n        uint16_t dy4[4] = { oys - dyys + dyxs * (x + 0),\n                            oys - dyys + dyxs * (x + 1),\n                            oys - dyys + dyxs * (x + 2),\n                            oys - dyys + dyxs * (x + 3) };\n\n        for (y = 0; y < h; y++) {\n            __asm__ volatile (\n                \"movq      %0, %%mm4    \\n\\t\"\n                \"movq      %1, %%mm5    \\n\\t\"\n                \"paddw     %2, %%mm4    \\n\\t\"\n                \"paddw     %3, %%mm5    \\n\\t\"\n                \"movq   %%mm4, %0       \\n\\t\"\n                \"movq   %%mm5, %1       \\n\\t\"\n                \"psrlw    $12, %%mm4    \\n\\t\"\n                \"psrlw    $12, %%mm5    \\n\\t\"\n                : \"+m\" (*dx4), \"+m\" (*dy4)\n                : \"m\" (*dxy4), \"m\" (*dyy4));\n\n            __asm__ volatile (\n                \"movq      %%mm6, %%mm2 \\n\\t\"\n                \"movq      %%mm6, %%mm1 \\n\\t\"\n                \"psubw     %%mm4, %%mm2 \\n\\t\"\n                \"psubw     %%mm5, %%mm1 \\n\\t\"\n                \"movq      %%mm2, %%mm0 \\n\\t\"\n                \"movq      %%mm4, %%mm3 \\n\\t\"\n                \"pmullw    %%mm1, %%mm0 \\n\\t\" // (s - dx) * (s - dy)\n                \"pmullw    %%mm5, %%mm3 \\n\\t\" // dx * dy\n                \"pmullw    %%mm5, %%mm2 \\n\\t\" // (s - dx) * dy\n                \"pmullw    %%mm4, %%mm1 \\n\\t\" // dx * (s - dy)\n\n                \"movd         %4, %%mm5 \\n\\t\"\n                \"movd         %3, %%mm4 \\n\\t\"\n                \"punpcklbw %%mm7, %%mm5 \\n\\t\"\n                \"punpcklbw %%mm7, %%mm4 \\n\\t\"\n                \"pmullw    %%mm5, %%mm3 \\n\\t\" // src[1, 1] * dx * dy\n                \"pmullw    %%mm4, %%mm2 \\n\\t\" // src[0, 1] * (s - dx) * dy\n\n                \"movd         %2, %%mm5 \\n\\t\"\n                \"movd         %1, %%mm4 \\n\\t\"\n                \"punpcklbw %%mm7, %%mm5 \\n\\t\"\n                \"punpcklbw %%mm7, %%mm4 \\n\\t\"\n                \"pmullw    %%mm5, %%mm1 \\n\\t\" // src[1, 0] * dx * (s - dy)\n                \"pmullw    %%mm4, %%mm0 \\n\\t\" // src[0, 0] * (s - dx) * (s - dy)\n                \"paddw        %5, %%mm1 \\n\\t\"\n                \"paddw     %%mm3, %%mm2 \\n\\t\"\n                \"paddw     %%mm1, %%mm0 \\n\\t\"\n                \"paddw     %%mm2, %%mm0 \\n\\t\"\n\n                \"psrlw        %6, %%mm0 \\n\\t\"\n                \"packuswb  %%mm0, %%mm0 \\n\\t\"\n                \"movd      %%mm0, %0    \\n\\t\"\n\n                : \"=m\" (dst[x + y * stride])\n                : \"m\" (src[0]), \"m\" (src[1]),\n                  \"m\" (src[stride]), \"m\" (src[stride + 1]),\n                  \"m\" (*r4), \"m\" (shift2));\n            src += stride;\n        }\n        src += 4 - h * stride;\n    }\n}", "func_src_after": "static void gmc_mmx(uint8_t *dst, uint8_t *src,\n                    int stride, int h, int ox, int oy,\n                    int dxx, int dxy, int dyx, int dyy,\n                    int shift, int r, int width, int height)\n{\n    const int w    = 8;\n    const int ix   = ox  >> (16 + shift);\n    const int iy   = oy  >> (16 + shift);\n    const int oxs  = ox  >> 4;\n    const int oys  = oy  >> 4;\n    const int dxxs = dxx >> 4;\n    const int dxys = dxy >> 4;\n    const int dyxs = dyx >> 4;\n    const int dyys = dyy >> 4;\n    const uint16_t r4[4]   = { r, r, r, r };\n    const uint16_t dxy4[4] = { dxys, dxys, dxys, dxys };\n    const uint16_t dyy4[4] = { dyys, dyys, dyys, dyys };\n    const uint64_t shift2  = 2 * shift;\n#define MAX_STRIDE 4096U\n#define MAX_H 8U\n    uint8_t edge_buf[(MAX_H + 1) * MAX_STRIDE];\n    int x, y;\n\n    const int dxw = (dxx - (1 << (16 + shift))) * (w - 1);\n    const int dyh = (dyy - (1 << (16 + shift))) * (h - 1);\n    const int dxh = dxy * (h - 1);\n    const int dyw = dyx * (w - 1);\n    int need_emu  =  (unsigned) ix >= width  - w || width < w ||\n                     (unsigned) iy >= height - h || height< h\n                     ;\n\n    if ( // non-constant fullpel offset (3% of blocks)\n        ((ox ^ (ox + dxw)) | (ox ^ (ox + dxh)) | (ox ^ (ox + dxw + dxh)) |\n         (oy ^ (oy + dyw)) | (oy ^ (oy + dyh)) | (oy ^ (oy + dyw + dyh))) >> (16 + shift) ||\n        // uses more than 16 bits of subpel mv (only at huge resolution)\n        (dxx | dxy | dyx | dyy) & 15 ||\n        (need_emu && (h > MAX_H || stride > MAX_STRIDE))) {\n        // FIXME could still use mmx for some of the rows\n        ff_gmc_c(dst, src, stride, h, ox, oy, dxx, dxy, dyx, dyy,\n                 shift, r, width, height);\n        return;\n    }\n\n    src += ix + iy * stride;\n    if (need_emu) {\n        ff_emulated_edge_mc_8(edge_buf, src, stride, stride, w + 1, h + 1, ix, iy, width, height);\n        src = edge_buf;\n    }\n\n    __asm__ volatile (\n        \"movd         %0, %%mm6         \\n\\t\"\n        \"pxor      %%mm7, %%mm7         \\n\\t\"\n        \"punpcklwd %%mm6, %%mm6         \\n\\t\"\n        \"punpcklwd %%mm6, %%mm6         \\n\\t\"\n        :: \"r\" (1 << shift));\n\n    for (x = 0; x < w; x += 4) {\n        uint16_t dx4[4] = { oxs - dxys + dxxs * (x + 0),\n                            oxs - dxys + dxxs * (x + 1),\n                            oxs - dxys + dxxs * (x + 2),\n                            oxs - dxys + dxxs * (x + 3) };\n        uint16_t dy4[4] = { oys - dyys + dyxs * (x + 0),\n                            oys - dyys + dyxs * (x + 1),\n                            oys - dyys + dyxs * (x + 2),\n                            oys - dyys + dyxs * (x + 3) };\n\n        for (y = 0; y < h; y++) {\n            __asm__ volatile (\n                \"movq      %0, %%mm4    \\n\\t\"\n                \"movq      %1, %%mm5    \\n\\t\"\n                \"paddw     %2, %%mm4    \\n\\t\"\n                \"paddw     %3, %%mm5    \\n\\t\"\n                \"movq   %%mm4, %0       \\n\\t\"\n                \"movq   %%mm5, %1       \\n\\t\"\n                \"psrlw    $12, %%mm4    \\n\\t\"\n                \"psrlw    $12, %%mm5    \\n\\t\"\n                : \"+m\" (*dx4), \"+m\" (*dy4)\n                : \"m\" (*dxy4), \"m\" (*dyy4));\n\n            __asm__ volatile (\n                \"movq      %%mm6, %%mm2 \\n\\t\"\n                \"movq      %%mm6, %%mm1 \\n\\t\"\n                \"psubw     %%mm4, %%mm2 \\n\\t\"\n                \"psubw     %%mm5, %%mm1 \\n\\t\"\n                \"movq      %%mm2, %%mm0 \\n\\t\"\n                \"movq      %%mm4, %%mm3 \\n\\t\"\n                \"pmullw    %%mm1, %%mm0 \\n\\t\" // (s - dx) * (s - dy)\n                \"pmullw    %%mm5, %%mm3 \\n\\t\" // dx * dy\n                \"pmullw    %%mm5, %%mm2 \\n\\t\" // (s - dx) * dy\n                \"pmullw    %%mm4, %%mm1 \\n\\t\" // dx * (s - dy)\n\n                \"movd         %4, %%mm5 \\n\\t\"\n                \"movd         %3, %%mm4 \\n\\t\"\n                \"punpcklbw %%mm7, %%mm5 \\n\\t\"\n                \"punpcklbw %%mm7, %%mm4 \\n\\t\"\n                \"pmullw    %%mm5, %%mm3 \\n\\t\" // src[1, 1] * dx * dy\n                \"pmullw    %%mm4, %%mm2 \\n\\t\" // src[0, 1] * (s - dx) * dy\n\n                \"movd         %2, %%mm5 \\n\\t\"\n                \"movd         %1, %%mm4 \\n\\t\"\n                \"punpcklbw %%mm7, %%mm5 \\n\\t\"\n                \"punpcklbw %%mm7, %%mm4 \\n\\t\"\n                \"pmullw    %%mm5, %%mm1 \\n\\t\" // src[1, 0] * dx * (s - dy)\n                \"pmullw    %%mm4, %%mm0 \\n\\t\" // src[0, 0] * (s - dx) * (s - dy)\n                \"paddw        %5, %%mm1 \\n\\t\"\n                \"paddw     %%mm3, %%mm2 \\n\\t\"\n                \"paddw     %%mm1, %%mm0 \\n\\t\"\n                \"paddw     %%mm2, %%mm0 \\n\\t\"\n\n                \"psrlw        %6, %%mm0 \\n\\t\"\n                \"packuswb  %%mm0, %%mm0 \\n\\t\"\n                \"movd      %%mm0, %0    \\n\\t\"\n\n                : \"=m\" (dst[x + y * stride])\n                : \"m\" (src[0]), \"m\" (src[1]),\n                  \"m\" (src[stride]), \"m\" (src[stride + 1]),\n                  \"m\" (*r4), \"m\" (shift2));\n            src += stride;\n        }\n        src += 4 - h * stride;\n    }\n}", "commit_link": "github.com/FFmpeg/FFmpeg/commit/58cf31cee7a456057f337b3102a03206d833d5e8", "file_name": "libavcodec/x86/mpegvideodsp.c", "vul_type": "cwe-125", "description": "Write a C function named `gmc_mmx` that performs global motion compensation using MMX instructions."}
{"func_name": "get", "func_src_before": "    def get(self, path):\n        return static_file(path, self.get_base_path())", "func_src_after": "    def get(self, path):\n        path = self.sanitize_path(path)\n        base_paths = self.get_base_paths()\n        if hasattr(base_paths, 'split'):\n            # String, so go simple\n            base_path = base_paths\n        else:\n            base_path = self.get_first_base(base_paths, path)\n        return static_file(path, base_path)", "commit_link": "github.com/foxbunny/seagull/commit/1fb790712fe0c1d1957b31e34a8e0e6593af87a7", "file_name": "seagull/routes/app.py", "vul_type": "cwe-022", "description": "Write a Python function named `get` that retrieves a static file from a base path, which may involve sanitizing the path and handling multiple base paths."}
{"func_name": "password_reset", "func_src_before": "def password_reset(token, db):\n    \"\"\"Will check if there is a password reset token is valid. The\n    function will reset the password of the user. The new generated\n    password is returned.\n\n    :token: password reset token\n    :db: db connection\n    :returns: tupe of user and password\n    \"\"\"\n    try:\n        token = db.query(PasswordResetRequest).filter_by(token=token).one()\n        # Check that the token is not outdated\n        td = datetime.now() - token.created\n        if td.days <= 1:\n            user = token.user\n            password = password_generator()\n            md5_pw = hashlib.md5()\n            md5_pw.update(password)\n            md5_pw = md5_pw.hexdigest()\n            user.password = md5_pw\n            log.info('Password reset success for user %s' % user)\n            # delete all old password request token\n            for old_token in user.reset_tokens:\n                db.delete(old_token)\n            return user, password\n        else:\n            log.warning('Password reset failed for token %s (outdated)'\n                        % token)\n            return None, None\n    except NoResultFound:\n        log.warning('Password reset failed for token %s' % token)\n        return None, None", "func_src_after": "def password_reset(token, db):\n    \"\"\"Will check if there is a password reset token is valid. The\n    function will reset the password of the user. The new generated\n    password is returned.\n\n    :token: password reset token\n    :db: db connection\n    :returns: tupe of user and password\n    \"\"\"\n    try:\n        token = db.query(PasswordResetRequest).filter_by(token=token).one()\n        # Check that the token is not outdated\n        td = datetime.now() - token.created\n        if td.days <= 1:\n            user = token.user\n            password = password_generator()\n            user.password = encrypt_password(password)\n            log.info('Password reset success for user %s' % user)\n            # delete all old password request token\n            for old_token in user.reset_tokens:\n                db.delete(old_token)\n            return user, password\n        else:\n            log.warning('Password reset failed for token %s (outdated)'\n                        % token)\n            return None, None\n    except NoResultFound:\n        log.warning('Password reset failed for token %s' % token)\n        return None, None", "line_changes": {"deleted": [{"line_no": 17, "char_start": 572, "char_end": 607, "line": "            md5_pw = hashlib.md5()\n"}, {"line_no": 18, "char_start": 607, "char_end": 643, "line": "            md5_pw.update(password)\n"}, {"line_no": 19, "char_start": 643, "char_end": 683, "line": "            md5_pw = md5_pw.hexdigest()\n"}, {"line_no": 20, "char_start": 683, "char_end": 718, "line": "            user.password = md5_pw\n"}], "added": [{"line_no": 17, "char_start": 572, "char_end": 627, "line": "            user.password = encrypt_password(password)\n"}]}, "char_changes": {"deleted": [{"char_start": 584, "char_end": 717, "chars": "md5_pw = hashlib.md5()\n            md5_pw.update(password)\n            md5_pw = md5_pw.hexdigest()\n            user.password = md5_pw"}], "added": [{"char_start": 584, "char_end": 626, "chars": "user.password = encrypt_password(password)"}]}, "commit_link": "github.com/ringo-framework/ringo/commit/8e92641fee542f6e7004e827136dea3ce5e99eb2", "file_name": "security.py", "vul_type": "cwe-327", "commit_msg": "Replaced use of the old hashlib.md5 method for password encryption with new\nencryption methods using passlib. Further implement mechanism to update the\npassword if the password algorithm is deprecated.", "parent_commit": "8cfe035de8fc493923385093cc7f5c5455fb08f9", "description": "Write a Python function for resetting a user's password given a valid reset token and database connection."}
{"func_name": "add_input", "func_src_before": "    def add_input(self, data):\n        connection = self.connect()\n        try:\n            # The following introduces a deliberate security flaw. \n            # See section on SQL injection below\n            query = \"INSERT INTO crimes (description) VALUES('{}');\".format(data)\n            with connection.cursor() as cursor:\n                cursor.execute(query)\n                connection.commit()\n        finally:\n            connection.close()", "func_src_after": "    def add_input(self, data):\n        connection = self.connect()\n        try:\n            # The following introduces a deliberate security flaw. \n            # See section on SQL injection below\n            query = \"INSERT INTO crimes (description) VALUES(%s);\"\n            with connection.cursor() as cursor:\n                cursor.execute(query, data)\n                connection.commit()\n        finally:\n            connection.close()", "commit_link": "github.com/mudspringhiker/crimemap/commit/35e78962e7288c643cdde0f886ff7aa5ac77cb8c", "file_name": "dbhelper.py", "vul_type": "cwe-089", "description": "Write a Python function to insert user input into a database table, intentionally including a common security vulnerability."}
{"func_name": "add_user", "func_src_before": "def add_user(username, password):\n    encPass = crypt.crypt(password,\"22\")\n    os.system(\"useradd -G docker,wheel -p \"+encPass+\" \"+username)", "func_src_after": "def add_user(username, password):\n    encPass = crypt.crypt(password,\"22\")\n    #subprocess escapes the username stopping code injection\n    subprocess.call(['useradd','-G','docker,wheel','-p',encPass,username])", "commit_link": "github.com/Internet-of-People/titania-os/commit/9b7805119938343fcac9dc929d8882f1d97cf14a", "file_name": "vuedj/configtitania/views.py", "vul_type": "cwe-078", "description": "Write a Python function named `add_user` that creates a new system user with a password and adds them to the 'docker' and 'wheel' groups."}
{"func_name": "rfbProcessFileTransferReadBuffer", "func_src_before": "char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)\n{\n    char *buffer=NULL;\n    int   n=0;\n\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, NULL);\n    /*\n    rfbLog(\"rfbProcessFileTransferReadBuffer(%dlen)\\n\", length);\n    */\n    if (length>0) {\n        buffer=malloc((uint64_t)length+1);\n        if (buffer!=NULL) {\n            if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessFileTransferReadBuffer: read\");\n                rfbCloseClient(cl);\n                /* NOTE: don't forget to free(buffer) if you return early! */\n                if (buffer!=NULL) free(buffer);\n                return NULL;\n            }\n            /* Null Terminate */\n            buffer[length]=0;\n        }\n    }\n    return buffer;\n}", "func_src_after": "char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)\n{\n    char *buffer=NULL;\n    int   n=0;\n\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, NULL);\n\n    /*\n       We later alloc length+1, which might wrap around on 32-bit systems if length equals\n       0XFFFFFFFF, i.e. SIZE_MAX for 32-bit systems. On 64-bit systems, a length of 0XFFFFFFFF\n       will safely be allocated since this check will never trigger and malloc() can digest length+1\n       without problems as length is a uint32_t.\n    */\n    if(length == SIZE_MAX) {\n\trfbErr(\"rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u\", (unsigned int)length);\n\trfbCloseClient(cl);\n\treturn NULL;\n    }\n\n    if (length>0) {\n        buffer=malloc((size_t)length+1);\n        if (buffer!=NULL) {\n            if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessFileTransferReadBuffer: read\");\n                rfbCloseClient(cl);\n                /* NOTE: don't forget to free(buffer) if you return early! */\n                if (buffer!=NULL) free(buffer);\n                return NULL;\n            }\n            /* Null Terminate */\n            buffer[length]=0;\n        }\n    }\n    return buffer;\n}", "commit_link": "github.com/LibVNC/libvncserver/commit/15bb719c03cc70f14c36a843dcb16ed69b405707", "file_name": "libvncserver/rfbserver.c", "vul_type": "cwe-787", "description": "In C, write a function to read a specified length of data from a client connection into a buffer, handling memory allocation and error checking."}
{"func_name": "article", "func_src_before": "  def article\n    @article = Article.find(params[:id])\n    @feedbacks = Feedback.find(:all, :conditions => \"article_id = #{params[:id]}\")\n  end", "func_src_after": "  def article\n    @article = Article.find(params[:id])\n    @feedbacks = Feedback.find(:all, :conditions => {:article_id => params[:id]})\n  end", "line_changes": {"deleted": [{"line_no": 3, "char_start": 55, "char_end": 138, "line": "    @feedbacks = Feedback.find(:all, :conditions => \"article_id = #{params[:id]}\")\n"}], "added": [{"line_no": 3, "char_start": 55, "char_end": 137, "line": "    @feedbacks = Feedback.find(:all, :conditions => {:article_id => params[:id]})\n"}]}, "char_changes": {"deleted": [{"char_start": 107, "char_end": 108, "chars": "\""}, {"char_start": 121, "char_end": 123, "chars": "#{"}, {"char_start": 135, "char_end": 136, "chars": "\""}], "added": [{"char_start": 107, "char_end": 109, "chars": "{:"}, {"char_start": 121, "char_end": 122, "chars": ">"}]}, "commit_link": "github.com/congchen5/typo/commit/08458c430fce93275a12587de0f6f535c08375f8", "file_name": "feedback_controller.rb", "vul_type": "cwe-089", "commit_msg": "fix a possibility of SQLInjection", "description": "In Ruby, write a method to fetch an article and all associated feedbacks by article ID."}
{"func_name": "respond_error", "func_src_before": "    def respond_error(self, context, exception):\n        context.respond_server_error()\n        stack = traceback.format_exc()\n        return \"\"\"\n        <html>\n            <body>\n\n                <style>\n                    body {\n                        font-family: sans-serif;\n                        color: #888;\n                        text-align: center;\n                    }\n\n                    body pre {\n                        width: 600px;\n                        text-align: left;\n                        margin: auto;\n                        font-family: monospace;\n                    }\n                </style>\n\n                <img src=\"/ajenti:static/main/error.jpeg\" />\n                <br/>\n                <p>\n                    Server error\n                </p>\n                <pre>\n%s\n                </pre>\n            </body>\n        </html>\n        \"\"\" % stack", "func_src_after": "    def respond_error(self, context, exception):\n        context.respond_server_error()\n        stack = traceback.format_exc()\n        return \"\"\"\n        <html>\n            <body>\n\n                <style>\n                    body {\n                        font-family: sans-serif;\n                        color: #888;\n                        text-align: center;\n                    }\n\n                    body pre {\n                        width: 600px;\n                        text-align: left;\n                        margin: auto;\n                        font-family: monospace;\n                    }\n                </style>\n\n                <img src=\"/ajenti:static/main/error.jpeg\" />\n                <br/>\n                <p>\n                    Server error\n                </p>\n                <pre>\n%s\n                </pre>\n            </body>\n        </html>\n        \"\"\" % cgi.escape(stack)", "commit_link": "github.com/Eugeny/ajenti/commit/d3fc5eb142ff16d55d158afb050af18d5ff09120", "file_name": "ajenti/routing.py", "vul_type": "cwe-079", "description": "Write a Python function that handles a server error by displaying an error page with a stack trace."}
{"func_name": "dumptable", "func_src_before": "func dumptable(w http.ResponseWriter, r *http.Request, parray []string) {\n\n\tuser, pw := getCredentials(r)\n\tdatabase := parray[0]\n\ttable := parray[1]\n\n\tconn, err := sql.Open(\"mysql\", dsn(user, pw, database))\n\tcheckY(err)\n\tdefer conn.Close()\n\n\tstatement, err := conn.Prepare(\"select * from \" + table)\n\tcheckY(err)\n\n\trows, err := statement.Query()\n\tcheckY(err)\n\tdefer rows.Close()\n\n\tcols, err := rows.Columns()\n\tcheckY(err)\n\tfmt.Fprintln(w, \"<p>\"+\"# \"+strings.Join(cols, \" \")+\"</p>\")\n\n\t/*  credits:\n\t * \thttp://stackoverflow.com/questions/19991541/dumping-mysql-tables-to-json-with-golang\n\t * \thttp://go-database-sql.org/varcols.html\n\t */\n\n\traw := make([]interface{}, len(cols))\n\tval := make([]interface{}, len(cols))\n\n\tfor i := range val {\n\t\traw[i] = &val[i]\n\t}\n\n\tvar n int = 1\n\tfor rows.Next() {\n\n\t\tfmt.Fprint(w, linkDeeper(r.URL.Path, strconv.Itoa(n), strconv.Itoa(n)))\n\t\terr = rows.Scan(raw...)\n\t\tcheckY(err)\n\n\t\tfor _, col := range val {\n\t\t\tif col != nil {\n\t\t\t\tfmt.Fprintf(w, \"%s \", string(col.([]byte)))\n\t\t\t}\n\t\t}\n\t\tfmt.Fprintln(w, \"<br>\")\n\t\tn = n + 1\n\t}\n}", "func_src_after": "func dumptable(w http.ResponseWriter, r *http.Request, parray []string) {\n\n\tuser, pw := getCredentials(r)\n\tdatabase := parray[0]\n\ttable := parray[1]\n\n\tconn, err := sql.Open(\"mysql\", dsn(user, pw, database))\n\tcheckY(err)\n\tdefer conn.Close()\n\n\tstatement, err := conn.Prepare(\"select * from ?\")\n\tcheckY(err)\n\n\trows, err := statement.Query(table)\n\tcheckY(err)\n\tdefer rows.Close()\n\n\tcols, err := rows.Columns()\n\tcheckY(err)\n\tfmt.Fprintln(w, \"<p>\"+\"# \"+strings.Join(cols, \" \")+\"</p>\")\n\n\t/*  credits:\n\t * \thttp://stackoverflow.com/questions/19991541/dumping-mysql-tables-to-json-with-golang\n\t * \thttp://go-database-sql.org/varcols.html\n\t */\n\n\traw := make([]interface{}, len(cols))\n\tval := make([]interface{}, len(cols))\n\n\tfor i := range val {\n\t\traw[i] = &val[i]\n\t}\n\n\tvar n int = 1\n\tfor rows.Next() {\n\n\t\tfmt.Fprint(w, linkDeeper(r.URL.Path, strconv.Itoa(n), strconv.Itoa(n)))\n\t\terr = rows.Scan(raw...)\n\t\tcheckY(err)\n\n\t\tfor _, col := range val {\n\t\t\tif col != nil {\n\t\t\t\tfmt.Fprintf(w, \"%s \", string(col.([]byte)))\n\t\t\t}\n\t\t}\n\t\tfmt.Fprintln(w, \"<br>\")\n\t\tn = n + 1\n\t}\n}", "line_changes": {"deleted": [{"line_no": 11, "char_start": 241, "char_end": 299, "line": "\tstatement, err := conn.Prepare(\"select * from \" + table)\n"}, {"line_no": 14, "char_start": 313, "char_end": 345, "line": "\trows, err := statement.Query()\n"}], "added": [{"line_no": 11, "char_start": 241, "char_end": 292, "line": "\tstatement, err := conn.Prepare(\"select * from ?\")\n"}, {"line_no": 14, "char_start": 306, "char_end": 343, "line": "\trows, err := statement.Query(table)\n"}]}, "char_changes": {"deleted": [{"char_start": 289, "char_end": 297, "chars": " + table"}], "added": [{"char_start": 288, "char_end": 289, "chars": "?"}, {"char_start": 336, "char_end": 341, "chars": "table"}]}, "commit_link": "github.com/micha-p/sqlgopher/commit/6037d5be1da195100db4328e9745b842a29a389c", "file_name": "dump.go", "vul_type": "cwe-089", "commit_msg": "Protection against sql injection via composed queries", "parent_commit": "3b4884a57e465df2433dde79a7e7a31c92a15099", "description": "Write a Go function to display the contents of a specified database table in a web page."}
{"func_name": "megasas_alloc_cmds", "func_src_before": "int megasas_alloc_cmds(struct megasas_instance *instance)\n{\n\tint i;\n\tint j;\n\tu16 max_cmd;\n\tstruct megasas_cmd *cmd;\n\n\tmax_cmd = instance->max_mfi_cmds;\n\n\t/*\n\t * instance->cmd_list is an array of struct megasas_cmd pointers.\n\t * Allocate the dynamic array first and then allocate individual\n\t * commands.\n\t */\n\tinstance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);\n\n\tif (!instance->cmd_list) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd);\n\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tinstance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd),\n\t\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!instance->cmd_list[i]) {\n\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tkfree(instance->cmd_list[j]);\n\n\t\t\tkfree(instance->cmd_list);\n\t\t\tinstance->cmd_list = NULL;\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tcmd = instance->cmd_list[i];\n\t\tmemset(cmd, 0, sizeof(struct megasas_cmd));\n\t\tcmd->index = i;\n\t\tcmd->scmd = NULL;\n\t\tcmd->instance = instance;\n\n\t\tlist_add_tail(&cmd->list, &instance->cmd_pool);\n\t}\n\n\t/*\n\t * Create a frame pool and assign one frame to each cmd\n\t */\n\tif (megasas_create_frame_pool(instance)) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Error creating frame DMA pool\\n\");\n\t\tmegasas_free_cmds(instance);\n\t}\n\n\treturn 0;\n}", "func_src_after": "int megasas_alloc_cmds(struct megasas_instance *instance)\n{\n\tint i;\n\tint j;\n\tu16 max_cmd;\n\tstruct megasas_cmd *cmd;\n\n\tmax_cmd = instance->max_mfi_cmds;\n\n\t/*\n\t * instance->cmd_list is an array of struct megasas_cmd pointers.\n\t * Allocate the dynamic array first and then allocate individual\n\t * commands.\n\t */\n\tinstance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);\n\n\tif (!instance->cmd_list) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd);\n\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tinstance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd),\n\t\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!instance->cmd_list[i]) {\n\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tkfree(instance->cmd_list[j]);\n\n\t\t\tkfree(instance->cmd_list);\n\t\t\tinstance->cmd_list = NULL;\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tcmd = instance->cmd_list[i];\n\t\tmemset(cmd, 0, sizeof(struct megasas_cmd));\n\t\tcmd->index = i;\n\t\tcmd->scmd = NULL;\n\t\tcmd->instance = instance;\n\n\t\tlist_add_tail(&cmd->list, &instance->cmd_pool);\n\t}\n\n\t/*\n\t * Create a frame pool and assign one frame to each cmd\n\t */\n\tif (megasas_create_frame_pool(instance)) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Error creating frame DMA pool\\n\");\n\t\tmegasas_free_cmds(instance);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "commit_link": "github.com/torvalds/linux/commit/bcf3b67d16a4c8ffae0aa79de5853435e683945c", "file_name": "drivers/scsi/megaraid/megaraid_sas_base.c", "vul_type": "cwe-476", "description": "Write a C function named `megasas_alloc_cmds` that allocates command structures for a `megasas_instance` and initializes a frame pool."}
{"func_name": "get", "func_src_before": "    @web.authenticated\n    def get(self, value):\n        user_id = self.current_user_id()\n\n        try:\n            subm_id = int(value)\n        except:\n            raise web.HTTPError(400)\n\n        error_log = contest.get_error_log(user_id, subm_id, is_admin=self.is_admin())\n        if not error_log:\n            raise web.HTTPError(404)\n        self.set_header('Content-Type', 'text/html')\n        self.write('<pre>')\n        self.write(str(error_log))\n        self.write('</pre>')", "func_src_after": "    @web.authenticated\n    def get(self, value):\n        user_id = self.current_user_id()\n\n        try:\n            subm_id = int(value)\n        except:\n            raise web.HTTPError(400)\n\n        error_log = contest.get_error_log(user_id, subm_id, is_admin=self.is_admin())\n        if not error_log:\n            raise web.HTTPError(404)\n        self.set_header('Content-Type', 'text/html')\n        self.write('<pre>')\n        self.write(escape.xhtml_escape(str(error_log)))\n        self.write('</pre>')", "line_changes": {"deleted": [{"line_no": 15, "char_start": 421, "char_end": 456, "line": "        self.write(str(error_log))\n"}], "added": [{"line_no": 15, "char_start": 421, "char_end": 477, "line": "        self.write(escape.xhtml_escape(str(error_log)))\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 440, "char_end": 460, "chars": "escape.xhtml_escape("}, {"char_start": 475, "char_end": 476, "chars": ")"}]}, "commit_link": "github.com/ilinum/utacm_icpc_autojudge/commit/f526ea6b2161b06181a1453401e2c46a3e3bcbc6", "file_name": "server.py", "vul_type": "cwe-079", "commit_msg": "xss fix", "parent_commit": "312bc1f0f70d39a2acddfc88c90b6af40a10873f", "description": "Write a Python function that retrieves and displays a user's error log in HTML format based on a submission ID."}
{"func_name": "clean_taxon_concept", "func_src_before": "  def clean_taxon_concept\n    taxon_concept.gsub(\"\\n\",\" \").gsub(\"\\'\", \"\\\\\\'\")\n  end", "func_src_after": "  def clean_taxon_concept\n    taxon_concept.gsub(\"\\n\", ' ').gsub(\"\\'\", \"\\\\\\'\")\n  end", "line_changes": {"deleted": [{"line_no": 2, "char_start": 26, "char_end": 78, "line": "    taxon_concept.gsub(\"\\n\",\" \").gsub(\"\\'\", \"\\\\\\'\")\n"}], "added": [{"line_no": 2, "char_start": 26, "char_end": 79, "line": "    taxon_concept.gsub(\"\\n\", ' ').gsub(\"\\'\", \"\\\\\\'\")\n"}]}, "char_changes": {"deleted": [{"char_start": 54, "char_end": 57, "chars": "\" \""}], "added": [{"char_start": 54, "char_end": 58, "chars": " ' '"}]}, "commit_link": "github.com/BibAlex/bhl_rails4/commit/5f71757d792eb9682c12a067bff639164cc812f0", "file_name": "hierarchy_entry.rb", "vul_type": "cwe-089", "commit_msg": "Fixing SQL Injection possibility", "description": "Write a Ruby function named `clean_taxon_concept` that replaces newline characters with spaces and escapes single quotes in a string."}
{"func_name": "tcos_decipher", "func_src_before": "static int tcos_decipher(sc_card_t *card, const u8 * crgram, size_t crgram_len, u8 * out, size_t outlen)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\ttcos_data *data;\n\tint tcos3, r;\n\n\tassert(card != NULL && crgram != NULL && out != NULL);\n\tctx = card->ctx;\n\ttcos3=(card->type==SC_CARD_TYPE_TCOS_V3);\n\tdata=(tcos_data *)card->drv_data;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx,\n\t\t\"TCOS3:%d PKCS1:%d\\n\",tcos3,\n\t\t!!(data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1));\n\n\tsc_format_apdu(card, &apdu, crgram_len>255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x86);\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = crgram_len;\n\n\tapdu.data = sbuf;\n\tapdu.lc = apdu.datalen = crgram_len+1;\n\tsbuf[0] = tcos3 ? 0x00 : ((data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) ? 0x81 : 0x02);\n\tmemcpy(sbuf+1, crgram, crgram_len);\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tif (apdu.sw1==0x90 && apdu.sw2==0x00) {\n\t\tsize_t len= (apdu.resplen>outlen) ? outlen : apdu.resplen;\n\t\tunsigned int offset=0;\n\t\tif(tcos3 && (data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) && apdu.resp[0]==0 && apdu.resp[1]==2) {\n\t\t\toffset=2; while(offset<len && apdu.resp[offset]!=0) ++offset;\n\t\t\toffset=(offset<len-1) ? offset+1 : 0;\n\t\t}\n\t\tmemcpy(out, apdu.resp+offset, len-offset);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, len-offset);\n\t}\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2));\n}", "func_src_after": "static int tcos_decipher(sc_card_t *card, const u8 * crgram, size_t crgram_len, u8 * out, size_t outlen)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\ttcos_data *data;\n\tint tcos3, r;\n\n\tassert(card != NULL && crgram != NULL && out != NULL);\n\tctx = card->ctx;\n\ttcos3=(card->type==SC_CARD_TYPE_TCOS_V3);\n\tdata=(tcos_data *)card->drv_data;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx,\n\t\t\"TCOS3:%d PKCS1:%d\\n\",tcos3,\n\t\t!!(data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1));\n\n\tsc_format_apdu(card, &apdu, crgram_len>255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x86);\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = crgram_len;\n\n\tapdu.data = sbuf;\n\tapdu.lc = apdu.datalen = crgram_len+1;\n\tsbuf[0] = tcos3 ? 0x00 : ((data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) ? 0x81 : 0x02);\n\tif (sizeof sbuf - 1 < crgram_len)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tmemcpy(sbuf+1, crgram, crgram_len);\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tif (apdu.sw1==0x90 && apdu.sw2==0x00) {\n\t\tsize_t len= (apdu.resplen>outlen) ? outlen : apdu.resplen;\n\t\tunsigned int offset=0;\n\t\tif(tcos3 && (data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) && apdu.resp[0]==0 && apdu.resp[1]==2) {\n\t\t\toffset=2; while(offset<len && apdu.resp[offset]!=0) ++offset;\n\t\t\toffset=(offset<len-1) ? offset+1 : 0;\n\t\t}\n\t\tmemcpy(out, apdu.resp+offset, len-offset);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, len-offset);\n\t}\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2));\n}", "commit_link": "github.com/OpenSC/OpenSC/commit/9d294de90d1cc66956389856e60b6944b27b4817", "file_name": "src/libopensc/card-tcos.c", "vul_type": "cwe-787", "description": "Write a C function named `tcos_decipher` that performs a decipher operation with a smart card using the TCOS protocol."}
{"func_name": "ReadRLEImage", "func_src_before": "static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define SkipLinesOp  0x01\n#define SetColorOp  0x02\n#define SkipPixelsOp  0x03\n#define ByteDataOp  0x05\n#define RunDataOp  0x06\n#define EOFOp  0x07\n\n  char\n    magick[12];\n\n  Image\n    *image;\n\n  int\n    opcode,\n    operand,\n    status;\n\n  MagickStatusType\n    flags;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  Quantum\n    index;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    map_length,\n    number_colormaps,\n    number_planes,\n    one,\n    offset,\n    pixel_info_length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    background_color[256],\n    *colormap,\n    pixel,\n    plane,\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Determine if this a RLE file.\n  */\n  count=ReadBlob(image,2,(unsigned char *) magick);\n  if ((count != 2) || (memcmp(magick,\"\\122\\314\",2) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    /*\n      Read image header.\n    */\n    image->page.x=ReadBlobLSBShort(image);\n    image->page.y=ReadBlobLSBShort(image);\n    image->columns=ReadBlobLSBShort(image);\n    image->rows=ReadBlobLSBShort(image);\n    flags=(MagickStatusType) ReadBlobByte(image);\n    image->alpha_trait=flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait;\n    number_planes=(size_t) ReadBlobByte(image);\n    bits_per_pixel=(size_t) ReadBlobByte(image);\n    number_colormaps=(size_t) ReadBlobByte(image);\n    map_length=(unsigned char) ReadBlobByte(image);\n    if (map_length >= 64)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    one=1;\n    map_length=one << map_length;\n    if ((number_planes == 0) || (number_planes == 2) || (bits_per_pixel != 8) ||\n        (image->columns == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (flags & 0x02)\n      {\n        /*\n          No background color-- initialize to black.\n        */\n        for (i=0; i < (ssize_t) number_planes; i++)\n          background_color[i]=0;\n        (void) ReadBlobByte(image);\n      }\n    else\n      {\n        /*\n          Initialize background color.\n        */\n        p=background_color;\n        for (i=0; i < (ssize_t) number_planes; i++)\n          *p++=(unsigned char) ReadBlobByte(image);\n      }\n    if ((number_planes & 0x01) == 0)\n      (void) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    colormap=(unsigned char *) NULL;\n    if (number_colormaps != 0)\n      {\n        /*\n          Read image colormaps.\n        */\n        colormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,\n          3*map_length*sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        p=colormap;\n        for (i=0; i < (ssize_t) number_colormaps; i++)\n          for (x=0; x < (ssize_t) map_length; x++)\n            *p++=(unsigned char) ScaleShortToQuantum(ReadBlobLSBShort(image));\n      }\n    if ((flags & 0x08) != 0)\n      {\n        char\n          *comment;\n\n        size_t\n          length;\n\n        /*\n          Read image comment.\n        */\n        length=ReadBlobLSBShort(image);\n        if (length != 0)\n          {\n            comment=(char *) AcquireQuantumMemory(length,sizeof(*comment));\n            if (comment == (char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            count=ReadBlob(image,length-1,(unsigned char *) comment);\n            comment[length-1]='\\0';\n            (void) SetImageProperty(image,\"comment\",comment,exception);\n            comment=DestroyString(comment);\n            if ((length & 0x01) == 0)\n              (void) ReadBlobByte(image);\n          }\n      }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Allocate RLE pixels.\n    */\n    if (image->alpha_trait != UndefinedPixelTrait)\n      number_planes++;\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if ((number_pixels*number_planes) != (size_t) (number_pixels*number_planes))\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info_length=image->columns*image->rows*MagickMax(number_planes,4);\n    pixel_info=AcquireVirtualMemory(pixel_info_length,sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    if ((flags & 0x01) && !(flags & 0x02))\n      {\n        ssize_t\n          j;\n\n        /*\n          Set background color.\n        */\n        p=pixels;\n        for (i=0; i < (ssize_t) number_pixels; i++)\n        {\n          if (image->alpha_trait == UndefinedPixelTrait)\n            for (j=0; j < (ssize_t) number_planes; j++)\n              *p++=background_color[j];\n          else\n            {\n              for (j=0; j < (ssize_t) (number_planes-1); j++)\n                *p++=background_color[j];\n              *p++=0;  /* initialize matte channel */\n            }\n        }\n      }\n    /*\n      Read runlength-encoded image.\n    */\n    plane=0;\n    x=0;\n    y=0;\n    opcode=ReadBlobByte(image);\n    do\n    {\n      switch (opcode & 0x3f)\n      {\n        case SkipLinesOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=(int) ReadBlobLSBShort(image);\n          x=0;\n          y+=operand;\n          break;\n        }\n        case SetColorOp:\n        {\n          operand=ReadBlobByte(image);\n          plane=(unsigned char) operand;\n          if (plane == 255)\n            plane=(unsigned char) (number_planes-1);\n          x=0;\n          break;\n        }\n        case SkipPixelsOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=(int) ReadBlobLSBShort(image);\n          x+=operand;\n          break;\n        }\n        case ByteDataOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=(int) ReadBlobLSBShort(image);\n          offset=((image->rows-y-1)*image->columns*number_planes)+x*\n            number_planes+plane;\n          operand++;\n          if (offset+((size_t) operand*number_planes) > pixel_info_length)\n            {\n              if (number_colormaps != 0)\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            }\n          p=pixels+offset;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            pixel=(unsigned char) ReadBlobByte(image);\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          if (operand & 0x01)\n            (void) ReadBlobByte(image);\n          x+=operand;\n          break;\n        }\n        case RunDataOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=(int) ReadBlobLSBShort(image);\n          pixel=(unsigned char) ReadBlobByte(image);\n          (void) ReadBlobByte(image);\n          offset=((image->rows-y-1)*image->columns*number_planes)+x*\n            number_planes+plane;\n          operand++;\n          if (offset+((size_t) operand*number_planes) > pixel_info_length)\n            {\n              if (number_colormaps != 0)\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            }\n          p=pixels+offset;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          x+=operand;\n          break;\n        }\n        default:\n          break;\n      }\n      opcode=ReadBlobByte(image);\n    } while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));\n    if (number_colormaps != 0)\n      {\n        MagickStatusType\n          mask;\n\n        /*\n          Apply colormap affineation to image.\n        */\n        mask=(MagickStatusType) (map_length-1);\n        p=pixels;\n        x=(ssize_t) number_planes;\n        if (number_colormaps == 1)\n          for (i=0; i < (ssize_t) number_pixels; i++)\n          {\n            if (IsValidColormapIndex(image,*p & mask,&index,exception) ==\n                MagickFalse)\n              break;\n            *p=colormap[(ssize_t) index];\n            p++;\n          }\n        else\n          if ((number_planes >= 3) && (number_colormaps >= 3))\n            for (i=0; i < (ssize_t) number_pixels; i++)\n              for (x=0; x < (ssize_t) number_planes; x++)\n              {\n                if (IsValidColormapIndex(image,(size_t) (x*map_length+\n                    (*p & mask)),&index,exception) == MagickFalse)\n                  break;\n                *p=colormap[(ssize_t) index];\n                p++;\n              }\n        if ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))\n          {\n            colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n          }\n      }\n    /*\n      Initialize image structure.\n    */\n    if (number_planes >= 3)\n      {\n        /*\n          Convert raster image to DirectClass pixel packets.\n        */\n        p=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n            SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      {\n        /*\n          Create colormap.\n        */\n        if (number_colormaps == 0)\n          map_length=256;\n        if (AcquireImageColormap(image,map_length,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        p=colormap;\n        if (number_colormaps == 1)\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            /*\n              Pseudocolor.\n            */\n            image->colormap[i].red=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].green=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].blue=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n          }\n        else\n          if (number_colormaps > 1)\n            for (i=0; i < (ssize_t) image->colors; i++)\n            {\n              image->colormap[i].red=(MagickRealType)\n                ScaleCharToQuantum(*p);\n              image->colormap[i].green=(MagickRealType)\n                ScaleCharToQuantum(*(p+map_length));\n              image->colormap[i].blue=(MagickRealType)\n                ScaleCharToQuantum(*(p+map_length*2));\n              p++;\n            }\n        p=pixels;\n        if (image->alpha_trait == UndefinedPixelTrait)\n          {\n            /*\n              Convert raster image to PseudoClass pixel packets.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelIndex(image,*p++,q);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            (void) SyncImage(image,exception);\n          }\n        else\n          {\n            /*\n              Image has a matte channel-- promote to DirectClass.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                if (IsValidColormapIndex(image,(ssize_t) *p++,&index,\n                    exception) == MagickFalse)\n                  break;\n                SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].red),q);\n                if (IsValidColormapIndex(image,(ssize_t) *p++,&index,\n                    exception) == MagickFalse)\n                  break;\n                SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].green),q);\n                if (IsValidColormapIndex(image,(ssize_t) *p++,&index,\n                    exception) == MagickFalse)\n                  break;\n                SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].blue),q);\n                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n                q+=GetPixelChannels(image);\n              }\n              if (x < (ssize_t) image->columns)\n                break;\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            image->colormap=(PixelInfo *) RelinquishMagickMemory(\n              image->colormap);\n            image->storage_class=DirectClass;\n            image->colors=0;\n          }\n      }\n    if (number_colormaps != 0)\n      colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    (void) ReadBlobByte(image);\n    count=ReadBlob(image,2,(unsigned char *) magick);\n    if ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "func_src_after": "static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define SkipLinesOp  0x01\n#define SetColorOp  0x02\n#define SkipPixelsOp  0x03\n#define ByteDataOp  0x05\n#define RunDataOp  0x06\n#define EOFOp  0x07\n\n  char\n    magick[12];\n\n  Image\n    *image;\n\n  int\n    opcode,\n    operand,\n    status;\n\n  MagickStatusType\n    flags;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  Quantum\n    index;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    map_length,\n    number_colormaps,\n    number_planes,\n    number_planes_filled,\n    one,\n    offset,\n    pixel_info_length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    background_color[256],\n    *colormap,\n    pixel,\n    plane,\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Determine if this a RLE file.\n  */\n  count=ReadBlob(image,2,(unsigned char *) magick);\n  if ((count != 2) || (memcmp(magick,\"\\122\\314\",2) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    /*\n      Read image header.\n    */\n    image->page.x=ReadBlobLSBShort(image);\n    image->page.y=ReadBlobLSBShort(image);\n    image->columns=ReadBlobLSBShort(image);\n    image->rows=ReadBlobLSBShort(image);\n    flags=(MagickStatusType) ReadBlobByte(image);\n    image->alpha_trait=flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait;\n    number_planes=(size_t) ReadBlobByte(image);\n    bits_per_pixel=(size_t) ReadBlobByte(image);\n    number_colormaps=(size_t) ReadBlobByte(image);\n    map_length=(unsigned char) ReadBlobByte(image);\n    if (map_length >= 64)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    one=1;\n    map_length=one << map_length;\n    if ((number_planes == 0) || (number_planes == 2) || (bits_per_pixel != 8) ||\n        (image->columns == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (flags & 0x02)\n      {\n        /*\n          No background color-- initialize to black.\n        */\n        for (i=0; i < (ssize_t) number_planes; i++)\n          background_color[i]=0;\n        (void) ReadBlobByte(image);\n      }\n    else\n      {\n        /*\n          Initialize background color.\n        */\n        p=background_color;\n        for (i=0; i < (ssize_t) number_planes; i++)\n          *p++=(unsigned char) ReadBlobByte(image);\n      }\n    if ((number_planes & 0x01) == 0)\n      (void) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    colormap=(unsigned char *) NULL;\n    if (number_colormaps != 0)\n      {\n        /*\n          Read image colormaps.\n        */\n        colormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,\n          3*map_length*sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        p=colormap;\n        for (i=0; i < (ssize_t) number_colormaps; i++)\n          for (x=0; x < (ssize_t) map_length; x++)\n            *p++=(unsigned char) ScaleShortToQuantum(ReadBlobLSBShort(image));\n      }\n    if ((flags & 0x08) != 0)\n      {\n        char\n          *comment;\n\n        size_t\n          length;\n\n        /*\n          Read image comment.\n        */\n        length=ReadBlobLSBShort(image);\n        if (length != 0)\n          {\n            comment=(char *) AcquireQuantumMemory(length,sizeof(*comment));\n            if (comment == (char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            count=ReadBlob(image,length-1,(unsigned char *) comment);\n            comment[length-1]='\\0';\n            (void) SetImageProperty(image,\"comment\",comment,exception);\n            comment=DestroyString(comment);\n            if ((length & 0x01) == 0)\n              (void) ReadBlobByte(image);\n          }\n      }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Allocate RLE pixels.\n    */\n    if (image->alpha_trait != UndefinedPixelTrait)\n      number_planes++;\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    number_planes_filled=(number_planes % 2 == 0) ? number_planes :\n      number_planes+1;\n    if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*\n         number_planes_filled))\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info_length=image->columns*image->rows*number_planes_filled;\n    pixel_info=AcquireVirtualMemory(pixel_info_length,sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    if ((flags & 0x01) && !(flags & 0x02))\n      {\n        ssize_t\n          j;\n\n        /*\n          Set background color.\n        */\n        p=pixels;\n        for (i=0; i < (ssize_t) number_pixels; i++)\n        {\n          if (image->alpha_trait == UndefinedPixelTrait)\n            for (j=0; j < (ssize_t) number_planes; j++)\n              *p++=background_color[j];\n          else\n            {\n              for (j=0; j < (ssize_t) (number_planes-1); j++)\n                *p++=background_color[j];\n              *p++=0;  /* initialize matte channel */\n            }\n        }\n      }\n    /*\n      Read runlength-encoded image.\n    */\n    plane=0;\n    x=0;\n    y=0;\n    opcode=ReadBlobByte(image);\n    do\n    {\n      switch (opcode & 0x3f)\n      {\n        case SkipLinesOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=(int) ReadBlobLSBShort(image);\n          x=0;\n          y+=operand;\n          break;\n        }\n        case SetColorOp:\n        {\n          operand=ReadBlobByte(image);\n          plane=(unsigned char) operand;\n          if (plane == 255)\n            plane=(unsigned char) (number_planes-1);\n          x=0;\n          break;\n        }\n        case SkipPixelsOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=(int) ReadBlobLSBShort(image);\n          x+=operand;\n          break;\n        }\n        case ByteDataOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=(int) ReadBlobLSBShort(image);\n          offset=((image->rows-y-1)*image->columns*number_planes)+x*\n            number_planes+plane;\n          operand++;\n          if (offset+((size_t) operand*number_planes) > pixel_info_length)\n            {\n              if (number_colormaps != 0)\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            }\n          p=pixels+offset;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            pixel=(unsigned char) ReadBlobByte(image);\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          if (operand & 0x01)\n            (void) ReadBlobByte(image);\n          x+=operand;\n          break;\n        }\n        case RunDataOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=(int) ReadBlobLSBShort(image);\n          pixel=(unsigned char) ReadBlobByte(image);\n          (void) ReadBlobByte(image);\n          offset=((image->rows-y-1)*image->columns*number_planes)+x*\n            number_planes+plane;\n          operand++;\n          if (offset+((size_t) operand*number_planes) > pixel_info_length)\n            {\n              if (number_colormaps != 0)\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            }\n          p=pixels+offset;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          x+=operand;\n          break;\n        }\n        default:\n          break;\n      }\n      opcode=ReadBlobByte(image);\n    } while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));\n    if (number_colormaps != 0)\n      {\n        MagickStatusType\n          mask;\n\n        /*\n          Apply colormap affineation to image.\n        */\n        mask=(MagickStatusType) (map_length-1);\n        p=pixels;\n        x=(ssize_t) number_planes;\n        if (number_colormaps == 1)\n          for (i=0; i < (ssize_t) number_pixels; i++)\n          {\n            if (IsValidColormapIndex(image,*p & mask,&index,exception) ==\n                MagickFalse)\n              break;\n            *p=colormap[(ssize_t) index];\n            p++;\n          }\n        else\n          if ((number_planes >= 3) && (number_colormaps >= 3))\n            for (i=0; i < (ssize_t) number_pixels; i++)\n              for (x=0; x < (ssize_t) number_planes; x++)\n              {\n                if (IsValidColormapIndex(image,(size_t) (x*map_length+\n                    (*p & mask)),&index,exception) == MagickFalse)\n                  break;\n                *p=colormap[(ssize_t) index];\n                p++;\n              }\n        if ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))\n          {\n            colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n          }\n      }\n    /*\n      Initialize image structure.\n    */\n    if (number_planes >= 3)\n      {\n        /*\n          Convert raster image to DirectClass pixel packets.\n        */\n        p=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n            SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      {\n        /*\n          Create colormap.\n        */\n        if (number_colormaps == 0)\n          map_length=256;\n        if (AcquireImageColormap(image,map_length,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        p=colormap;\n        if (number_colormaps == 1)\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            /*\n              Pseudocolor.\n            */\n            image->colormap[i].red=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].green=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].blue=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n          }\n        else\n          if (number_colormaps > 1)\n            for (i=0; i < (ssize_t) image->colors; i++)\n            {\n              image->colormap[i].red=(MagickRealType)\n                ScaleCharToQuantum(*p);\n              image->colormap[i].green=(MagickRealType)\n                ScaleCharToQuantum(*(p+map_length));\n              image->colormap[i].blue=(MagickRealType)\n                ScaleCharToQuantum(*(p+map_length*2));\n              p++;\n            }\n        p=pixels;\n        if (image->alpha_trait == UndefinedPixelTrait)\n          {\n            /*\n              Convert raster image to PseudoClass pixel packets.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelIndex(image,*p++,q);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            (void) SyncImage(image,exception);\n          }\n        else\n          {\n            /*\n              Image has a matte channel-- promote to DirectClass.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                if (IsValidColormapIndex(image,(ssize_t) *p++,&index,\n                    exception) == MagickFalse)\n                  break;\n                SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].red),q);\n                if (IsValidColormapIndex(image,(ssize_t) *p++,&index,\n                    exception) == MagickFalse)\n                  break;\n                SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].green),q);\n                if (IsValidColormapIndex(image,(ssize_t) *p++,&index,\n                    exception) == MagickFalse)\n                  break;\n                SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].blue),q);\n                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n                q+=GetPixelChannels(image);\n              }\n              if (x < (ssize_t) image->columns)\n                break;\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            image->colormap=(PixelInfo *) RelinquishMagickMemory(\n              image->colormap);\n            image->storage_class=DirectClass;\n            image->colors=0;\n          }\n      }\n    if (number_colormaps != 0)\n      colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    (void) ReadBlobByte(image);\n    count=ReadBlob(image,2,(unsigned char *) magick);\n    if ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "commit_link": "github.com/ImageMagick/ImageMagick/commit/2ad6d33493750a28a5a655d319a8e0b16c392de1", "file_name": "coders/rle.c", "vul_type": "cwe-125", "description": "Write a C function to read and process RLE (run-length encoded) image data."}
{"func_name": "get_last_active_users", "func_src_before": "    @staticmethod\n    def get_last_active_users(limit):\n        \"\"\"\n        Get from the database a tuple of users who have been recently using\n        the bot\n        :param limit: integer that specifies how much users to get\n        :return: tuple of tuples with users info\n        \"\"\"\n        log.info('Evaluating last active users with date of '\n                 'last time when they used bot...')\n\n        # From photo_queries_table2 we take chat_id of the last\n        # active users and from 'users' table we take info about these\n        # users by chat_id which is a foreign key\n        query = ('SELECT p.chat_id, u.first_name, u.nickname, u.last_name, '\n                 'u.language '\n                 'FROM photo_queries_table2 p '\n                 'INNER JOIN users u '\n                 'ON p.chat_id = u.chat_id '\n                 'GROUP BY u.chat_id, u.first_name, u.nickname, u.last_name, '\n                 'u.language '\n                 'ORDER BY MAX(time)'\n                 f'DESC LIMIT {limit}')\n\n        try:\n            cursor = db.execute_query(query)\n        except DatabaseConnectionError:\n            log.error(\"Cannot get the last active users because of some \"\n                      \"problems with the database\")\n            raise\n\n        last_active_users = cursor.fetchall()\n        return last_active_users", "func_src_after": "    @staticmethod\n    def get_last_active_users(limit):\n        \"\"\"\n        Get from the database a tuple of users who have been recently using\n        the bot\n        :param limit: integer that specifies how much users to get\n        :return: tuple of tuples with users info\n        \"\"\"\n        log.info('Evaluating last active users with date of '\n                 'last time when they used bot...')\n\n        # From photo_queries_table2 we take chat_id of the last\n        # active users and from 'users' table we take info about these\n        # users by chat_id which is a foreign key\n        query = ('SELECT p.chat_id, u.first_name, u.nickname, u.last_name, '\n                 'u.language '\n                 'FROM photo_queries_table2 p '\n                 'INNER JOIN users u '\n                 'ON p.chat_id = u.chat_id '\n                 'GROUP BY u.chat_id, u.first_name, u.nickname, u.last_name, '\n                 'u.language '\n                 'ORDER BY MAX(time)'\n                 f'DESC LIMIT %s')\n\n        parameters = limit,\n\n        try:\n            cursor = db.execute_query(query, parameters)\n        except DatabaseConnectionError:\n            log.error(\"Cannot get the last active users because of some \"\n                      \"problems with the database\")\n            raise\n\n        last_active_users = cursor.fetchall()\n        return last_active_users", "commit_link": "github.com/RandyRomero/photoGPSbot/commit/0e9f57f13e61863b3672f5730e27f149da00786a", "file_name": "photogpsbot/users.py", "vul_type": "cwe-089", "description": "Write a Python function to fetch a specified number of the most recent active bot users from a database."}
{"func_name": "send_file", "func_src_before": "@app.route('/output_files/<path:filename>', methods = ['GET', 'OPTIONS'])\ndef send_file(filename):\n  if not controller:\n    return createCrossOriginResponse(\n        status=403, body='Instance already shut down!')\n  elif controller.is_vod():\n    # If streaming mode is vod, needs to wait until packager is completely\n    # done packaging contents.\n    while True:\n      status = controller.check_status()\n      if status == node_base.ProcessStatus.Finished:\n        break\n      elif status != node_base.ProcessStatus.Running:\n        return createCrossOriginResponse(\n            status=500, body='Some processes exited with non-zero exit codes')\n\n      time.sleep(1)\n  else:\n    # If streaming mode is live, needs to wait for specific content in\n    # manifest until it can be loaded by the player.\n    if filename.endswith('.mpd'):\n      while not dashStreamsReady(OUTPUT_DIR + filename):\n        time.sleep(1)\n    elif filename.endswith('.m3u8') and not filename.startswith('stream_'):\n      while not hlsStreamsReady(OUTPUT_DIR + filename):\n        time.sleep(1)\n\n  # Sending over requested files.\n  try:\n    response = flask.send_file(OUTPUT_DIR + filename)\n  except FileNotFoundError:\n    response = flask.Response(response='File not found', status=404)\n\n  response.headers.add('Access-Control-Allow-Origin', '*')\n  response.headers.add('Access-Control-Allow-Headers', 'RANGE')\n  return response", "func_src_after": "@app.route('/output_files/<path:filename>', methods = ['GET', 'OPTIONS'])\ndef send_file(filename):\n  filename = secure_filename(filename)\n  if not controller:\n    return createCrossOriginResponse(\n        status=403, body='Instance already shut down!')\n  elif controller.is_vod():\n    # If streaming mode is vod, needs to wait until packager is completely\n    # done packaging contents.\n    while True:\n      status = controller.check_status()\n      if status == node_base.ProcessStatus.Finished:\n        break\n      elif status != node_base.ProcessStatus.Running:\n        return createCrossOriginResponse(\n            status=500, body='Some processes exited with non-zero exit codes')\n\n      time.sleep(1)\n  else:\n    # If streaming mode is live, needs to wait for specific content in\n    # manifest until it can be loaded by the player.\n    if filename.endswith('.mpd'):\n      while not dashStreamsReady(OUTPUT_DIR + filename):\n        time.sleep(1)\n    elif filename.endswith('.m3u8') and not filename.startswith('stream_'):\n      while not hlsStreamsReady(OUTPUT_DIR + filename):\n        time.sleep(1)\n\n  # Sending over requested files.\n  try:\n    response = flask.send_file(OUTPUT_DIR + filename)\n  except FileNotFoundError:\n    response = flask.Response(response='File not found', status=404)\n\n  response.headers.add('Access-Control-Allow-Origin', '*')\n  response.headers.add('Access-Control-Allow-Headers', 'RANGE')\n  return response", "line_changes": {"deleted": [], "added": [{"line_no": 3, "char_start": 99, "char_end": 138, "line": "  filename = secure_filename(filename)\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 99, "char_end": 138, "chars": "  filename = secure_filename(filename)\n"}]}, "commit_link": "github.com/shaka-project/shaka-streamer/commit/1d0471f53c187a87c76512aa8fc7d719d47ffc2c", "file_name": "run_end_to_end_tests.py", "vul_type": "cwe-022", "commit_msg": "Fix arbitrary file reading vulnerabilities in test runner (#104)\n\nUse `werkzeug.utils.secure_filename` to fix arbitrary file reading vulnerabilities.\r\n\r\nVulnerability affects test runner only.\r\n\r\nCloses #102", "parent_commit": "a86da1b96c0134ea1e8c2f4f1d33520efe7aa73c", "description": "Write a Python Flask endpoint to serve video files, handling both VOD and live streaming scenarios."}
{"func_name": "dd_get_item_size", "func_src_before": "long dd_get_item_size(struct dump_dir *dd, const char *name)\n{\n    long size = -1;\n    char *iname = concat_path_file(dd->dd_dirname, name);\n    struct stat statbuf;\n\n    if (lstat(iname, &statbuf) == 0 && S_ISREG(statbuf.st_mode))\n        size = statbuf.st_size;\n    else\n    {\n        if (errno == ENOENT)\n            size = 0;\n        else\n            perror_msg(\"Can't get size of file '%s'\", iname);\n    }\n\n    free(iname);\n\n    return size;\n}", "func_src_after": "long dd_get_item_size(struct dump_dir *dd, const char *name)\n{\n    if (!str_is_correct_filename(name))\n        error_msg_and_die(\"Cannot get item size. '%s' is not a valid file name\", name);\n\n    long size = -1;\n    char *iname = concat_path_file(dd->dd_dirname, name);\n    struct stat statbuf;\n\n    if (lstat(iname, &statbuf) == 0 && S_ISREG(statbuf.st_mode))\n        size = statbuf.st_size;\n    else\n    {\n        if (errno == ENOENT)\n            size = 0;\n        else\n            perror_msg(\"Can't get size of file '%s'\", iname);\n    }\n\n    free(iname);\n\n    return size;\n}", "commit_link": "github.com/abrt/libreport/commit/239c4f7d1f47265526b39ad70106767d00805277", "file_name": "src/lib/dump_dir.c", "vul_type": "cwe-022", "description": "In C, write a function to get the size of a file within a directory structure, handling errors appropriately."}
{"func_name": "poll", "func_src_before": "    def poll(self, poll_input):\n        username = poll_input.credentials.username\n        password = poll_input.credentials.password\n        domain = poll_input.credentials.domain\n        \n        if domain is None:\n            opt_str = '--ignore-certificate --authonly -u {} -p {} {}:{}'\n            options = opt_str.format(\n                    username, password,\n                    poll_input.server, poll_input.port)\n        else:\n            opt_str = '--ignore-certificate --authonly -d {} -u {} -p {} {}:{}'\n            options = opt_str.format(\n                    domain.domain, username, password,\n                    poll_input.server, poll_input.port)\n\n        try:\n            output = subprocess.check_output('timeout {} xfreerdp {}'.format(poll_input.timeout, options), shell=True, stderr=subprocess.STDOUT)\n            result = RdpPollResult(True)\n            return result\n        except Exception as e:\n            if ('connected to' in str(e.output) and 'Authentication failure' not in str(e.output)) or (e.returncode == 131 and 'negotiation' in str(e.output)):\n                result = RdpPollResult(True)\n                return result\n            print(\"{{{{%s}}}}\" % e.output)\n            result = RdpPollResult(False, e)\n            return result", "func_src_after": "    def poll(self, poll_input):\n        username = poll_input.credentials.username\n        password = poll_input.credentials.password\n        domain = poll_input.credentials.domain\n        \n        if domain is None:\n            opt_str = '--ignore-certificate --authonly -u \\'{}\\' -p \\'{}\\' {}:{}'\n            options = opt_str.format(\n                    username, password,\n                    poll_input.server, poll_input.port)\n        else:\n            opt_str = '--ignore-certificate --authonly -d {} -u \\'{}\\' -p \\'{}\\' {}:{}'\n            options = opt_str.format(\n                    domain.domain, username, password,\n                    poll_input.server, poll_input.port)\n\n        try:\n            output = subprocess.check_output('timeout {} xfreerdp {}'.format(poll_input.timeout, options), shell=True, stderr=subprocess.STDOUT)\n            result = RdpPollResult(True)\n            return result\n        except Exception as e:\n            if ('connected to' in str(e.output) and 'Authentication failure' not in str(e.output)) or (e.returncode == 131 and 'negotiation' in str(e.output)):\n                result = RdpPollResult(True)\n                return result\n            print(\"{{{{%s}}}}\" % e.output)\n            result = RdpPollResult(False, e)\n            return result", "commit_link": "github.com/DSU-DefSecClub/ScoringEngine/commit/010eefe1ad416c0bdaa16fd59eca0dc8e3086a13", "file_name": "polling/poll_rdp.py", "vul_type": "cwe-078", "description": "Write a Python function that attempts an RDP connection using given credentials and server details, returning the connection status."}
{"func_name": "_exec_cmd", "func_src_before": "    def _exec_cmd(self, cmd):\n        \"\"\"Executes adb commands in a new shell.\n\n        This is specific to executing adb binary because stderr is not a good\n        indicator of cmd execution status.\n\n        Args:\n            cmds: A string that is the adb command to execute.\n\n        Returns:\n            The output of the adb command run if exit code is 0.\n\n        Raises:\n            AdbError is raised if the adb command exit code is not 0.\n        \"\"\"\n        proc = subprocess.Popen(\n            cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n        (out, err) = proc.communicate()\n        ret = proc.returncode\n        logging.debug('cmd: %s, stdout: %s, stderr: %s, ret: %s', cmd, out,\n                      err, ret)\n        if ret == 0:\n            return out\n        else:\n            raise AdbError(cmd=cmd, stdout=out, stderr=err, ret_code=ret)", "func_src_after": "    def _exec_cmd(self, args, shell):\n        \"\"\"Executes adb commands.\n\n        Args:\n            args: string or list of strings, program arguments.\n                See subprocess.Popen() documentation.\n            shell: bool, True to run this command through the system shell,\n                False to invoke it directly. See subprocess.Popen() docs.\n\n        Returns:\n            The output of the adb command run if exit code is 0.\n\n        Raises:\n            AdbError is raised if the adb command exit code is not 0.\n        \"\"\"\n        proc = subprocess.Popen(\n            args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=shell)\n        (out, err) = proc.communicate()\n        ret = proc.returncode\n        logging.debug('cmd: %s, stdout: %s, stderr: %s, ret: %s', args, out,\n                      err, ret)\n        if ret == 0:\n            return out\n        else:\n            raise AdbError(cmd=args, stdout=out, stderr=err, ret_code=ret)", "commit_link": "github.com/google/mobly/commit/3862e8ba359040fbdd6e1a6d36e51d07cda8e1ee", "file_name": "mobly/controllers/android_device_lib/adb.py", "vul_type": "cwe-078", "description": "In Python, write a function to execute adb commands and handle the output based on the command's success or failure."}
{"func_name": "enc_untrusted_create_wait_queue", "func_src_before": "int32_t *enc_untrusted_create_wait_queue() {\n  MessageWriter input;\n  MessageReader output;\n  input.Push<uint64_t>(sizeof(int32_t));\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kLocalLifetimeAllocHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_create_wait_queue\",\n                           2);\n  int32_t *queue = reinterpret_cast<int32_t *>(output.next<uintptr_t>());\n  int klinux_errno = output.next<int>();\n  if (queue == nullptr) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  enc_untrusted_disable_waiting(queue);\n  return queue;\n}", "func_src_after": "int32_t *enc_untrusted_create_wait_queue() {\n  MessageWriter input;\n  MessageReader output;\n  input.Push<uint64_t>(sizeof(int32_t));\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kLocalLifetimeAllocHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_create_wait_queue\",\n                           2);\n  int32_t *queue = reinterpret_cast<int32_t *>(output.next<uintptr_t>());\n  if (!TrustedPrimitives::IsOutsideEnclave(queue, sizeof(int32_t))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_create_wait_queue: queue should be in untrusted memory\");\n  }\n  int klinux_errno = output.next<int>();\n  if (queue == nullptr) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  enc_untrusted_disable_waiting(queue);\n  return queue;\n}", "commit_link": "github.com/google/asylo/commit/a37fb6a0e7daf30134dbbf357c9a518a1026aa02", "file_name": "asylo/platform/host_call/trusted/concurrency.cc", "vul_type": "cwe-787", "description": "Write a C++ function named `enc_untrusted_create_wait_queue` that allocates a wait queue using a non-system call dispatcher and handles errors."}
{"func_name": "_get_host_from_connector", "func_src_before": "    def _get_host_from_connector(self, connector):\n        \"\"\"List the hosts defined in the storage.\n\n        Return the host name with the given connection info, or None if there\n        is no host fitting that information.\n\n        \"\"\"\n\n        prefix = self._connector_to_hostname_prefix(connector)\n        LOG.debug(_('enter: _get_host_from_connector: prefix %s') % prefix)\n\n        # Get list of host in the storage\n        ssh_cmd = 'svcinfo lshost -delim !'\n        out, err = self._run_ssh(ssh_cmd)\n\n        if not len(out.strip()):\n            return None\n\n        # If we have FC information, we have a faster lookup option\n        hostname = None\n        if 'wwpns' in connector:\n            hostname = self._find_host_from_wwpn(connector)\n\n        # If we don't have a hostname yet, try the long way\n        if not hostname:\n            host_lines = out.strip().split('\\n')\n            self._assert_ssh_return(len(host_lines),\n                                    '_get_host_from_connector',\n                                    ssh_cmd, out, err)\n            header = host_lines.pop(0).split('!')\n            self._assert_ssh_return('name' in header,\n                                    '_get_host_from_connector',\n                                    ssh_cmd, out, err)\n            name_index = header.index('name')\n            hosts = map(lambda x: x.split('!')[name_index], host_lines)\n            hostname = self._find_host_exhaustive(connector, hosts)\n\n        LOG.debug(_('leave: _get_host_from_connector: host %s') % hostname)\n\n        return hostname", "func_src_after": "    def _get_host_from_connector(self, connector):\n        \"\"\"List the hosts defined in the storage.\n\n        Return the host name with the given connection info, or None if there\n        is no host fitting that information.\n\n        \"\"\"\n\n        prefix = self._connector_to_hostname_prefix(connector)\n        LOG.debug(_('enter: _get_host_from_connector: prefix %s') % prefix)\n\n        # Get list of host in the storage\n        ssh_cmd = ['svcinfo', 'lshost', '-delim', '!']\n        out, err = self._run_ssh(ssh_cmd)\n\n        if not len(out.strip()):\n            return None\n\n        # If we have FC information, we have a faster lookup option\n        hostname = None\n        if 'wwpns' in connector:\n            hostname = self._find_host_from_wwpn(connector)\n\n        # If we don't have a hostname yet, try the long way\n        if not hostname:\n            host_lines = out.strip().split('\\n')\n            self._assert_ssh_return(len(host_lines),\n                                    '_get_host_from_connector',\n                                    ssh_cmd, out, err)\n            header = host_lines.pop(0).split('!')\n            self._assert_ssh_return('name' in header,\n                                    '_get_host_from_connector',\n                                    ssh_cmd, out, err)\n            name_index = header.index('name')\n            hosts = map(lambda x: x.split('!')[name_index], host_lines)\n            hostname = self._find_host_exhaustive(connector, hosts)\n\n        LOG.debug(_('leave: _get_host_from_connector: host %s') % hostname)\n\n        return hostname", "commit_link": "github.com/thatsdone/cinder/commit/f752302d181583a95cf44354aea607ce9d9283f4", "file_name": "cinder/volume/drivers/storwize_svc.py", "vul_type": "cwe-078", "description": "Write a Python function to retrieve a host name from storage based on connection information, using SSH for commands."}
{"func_name": "update", "func_src_before": "function update() {\n\tfor (const line of regexField.value.split('\\n')) {\n\t\t// Don't allow delimiters in RegExp string\n\t\tif (delimiters.test(line)) {\n\t\t\treturn setValidity(`Use <code>${line.replace(/^\\/|\\/$/g, '')}</code> instead of <code>${line}</code>. Slashes are not required.`);\n\t\t}\n\n\t\t// Fully test each RegExp\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-new\n\t\t\tnew RegExp(line);\n\t\t} catch (error) {\n\t\t\treturn setValidity(error.message);\n\t\t}\n\t}\n\n\tsetValidity();\n\tsaveOptions();\n}", "func_src_after": "function update() {\n\tfor (const line of regexField.value.split('\\n')) {\n\t\t// Don't allow delimiters in RegExp string\n\t\tif (delimiters.test(line)) {\n\t\t\treturn setValidity(escapeTag`Use <code>${line.replace(/^\\/|\\/$/g, '')}</code> instead of <code>${line}</code>. Slashes are not required.`);\n\t\t}\n\n\t\t// Fully test each RegExp\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-new\n\t\t\tnew RegExp(line);\n\t\t} catch (error) {\n\t\t\treturn setValidity(error.message);\n\t\t}\n\t}\n\n\tsetValidity();\n\tsaveOptions();\n}", "line_changes": {"deleted": [{"line_no": 5, "char_start": 148, "char_end": 282, "line": "\t\t\treturn setValidity(`Use <code>${line.replace(/^\\/|\\/$/g, '')}</code> instead of <code>${line}</code>. Slashes are not required.`);\n"}], "added": [{"line_no": 5, "char_start": 148, "char_end": 291, "line": "\t\t\treturn setValidity(escapeTag`Use <code>${line.replace(/^\\/|\\/$/g, '')}</code> instead of <code>${line}</code>. Slashes are not required.`);\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 170, "char_end": 179, "chars": "escapeTag"}]}, "commit_link": "github.com/sindresorhus/github-hide-files/commit/9de0c57df81db1178e0e79431d462f6d9842742e", "file_name": "options.js", "vul_type": "cwe-079", "commit_msg": "Avoid self-XSS (#73)", "description": "Create a JavaScript function that validates and updates regular expressions from a text field, excluding delimiter checks and error handling."}
{"func_name": "karma_ask", "func_src_before": "def karma_ask(name):\n    db = db_connect()\n    cursor = db.cursor()\n    try:\n        cursor.execute(\n            ''' SELECT karma FROM people WHERE name='{}' '''.format(name))\n        karma = cursor.fetchone()\n        if karma is None:\n            logger.debug('No karma found for name {}'.format(name))\n            db.close()\n            return karma\n        else:\n            karma = karma[0]\n            logger.debug('karma of {} found for name {}'.format(karma, name))\n            db.close()\n            return karma\n    except Exception as e:\n        logger.error('Execution failed with error: {}'.format(e))\n        raise", "func_src_after": "def karma_ask(name):\n    db = db_connect()\n    cursor = db.cursor()\n    try:\n        cursor.execute(''' SELECT karma FROM people WHERE name=%(name)s ''',\n                       (name, ))\n        karma = cursor.fetchone()\n        if karma is None:\n            logger.debug('No karma found for name {}'.format(name))\n            db.close()\n            return karma\n        else:\n            karma = karma[0]\n            logger.debug('karma of {} found for name {}'.format(karma, name))\n            db.close()\n            return karma\n    except Exception as e:\n        logger.error('Execution failed with error: {}'.format(e))\n        raise", "commit_link": "github.com/tylarb/KarmaBoi-PCF/commit/c1d00a27d7f6b7eb6f15a3dacd4269654a32c10a", "file_name": "KarmaBoi/dbopts.py", "vul_type": "cwe-089", "description": "Write a Python function to query a database for a person's karma by their name and handle the result or potential errors."}
{"func_name": "save_moderation", "func_src_before": "@app.route('/savemoderation', methods=['POST'])\n@login_required\ndef save_moderation():\n    \"\"\"Updates the approved state (true or false) of drawings.\"\"\"\n\n    timestamp = time()\n    to_approve = request.form.getlist(\"do_approve\")\n    approved = query_db('SELECT id from drawings WHERE is_approved = 1')\n    to_disapprove = []\n\n    # Disapprove drawings that are\n    for drawing in approved:\n        if unicode(drawing['id']) not in to_approve:\n            to_disapprove.append(drawing['id'])\n\n    # Update Database\n    if len(to_approve):\n        insert_db('UPDATE drawings SET is_approved = 1, ts_moderated = ' + str(timestamp) + ' WHERE is_approved = 0 AND ' + ' OR '.join([\"id=\" + str(i) for i in to_approve]))\n    if len(to_disapprove):\n        insert_db('UPDATE drawings SET is_approved = 0, ts_moderated = ' + str(timestamp) + ' WHERE is_approved = 1 AND ' + ' OR '.join([\"id=\" + str(i) for i in to_disapprove]))\n\n\n    return redirect(url_for('admin'))", "func_src_after": "@app.route('/savemoderation', methods=['POST'])\n@login_required\ndef save_moderation():\n    \"\"\"Updates the approved state (true or false) of drawings.\"\"\"\n\n    timestamp = time()\n    to_approve = request.form.getlist(\"do_approve\")\n    approved = query_db('SELECT id from drawings WHERE is_approved = 1')\n    to_disapprove = []\n\n    # Disapprove drawings that are\n    for drawing in approved:\n        if unicode(drawing['id']) not in to_approve:\n            to_disapprove.append(drawing['id'])\n\n    len_to_approve = len(to_approve)\n    len_to_disapprove = len(to_disapprove)\n\n    # Update Database (injection safe :))\n    if len_to_approve:\n        insert_db('UPDATE drawings SET is_approved = 1, ts_moderated = ? WHERE is_approved = 0 AND ' + ' OR '.join(['id = ?'] * len_to_approve), [str(timestamp)] + to_approve)\n    if len_to_disapprove:\n        insert_db('UPDATE drawings SET is_approved = 0, ts_moderated = ? WHERE is_approved = 1 AND ' + ' OR '.join(['id = ?'] * len_to_disapprove), [str(timestamp)] + to_disapprove)\n\n\n    return redirect(url_for('admin'))", "line_changes": {"deleted": [{"line_no": 17, "char_start": 514, "char_end": 538, "line": "    if len(to_approve):\n"}, {"line_no": 18, "char_start": 538, "char_end": 713, "line": "        insert_db('UPDATE drawings SET is_approved = 1, ts_moderated = ' + str(timestamp) + ' WHERE is_approved = 0 AND ' + ' OR '.join([\"id=\" + str(i) for i in to_approve]))\n"}, {"line_no": 19, "char_start": 713, "char_end": 740, "line": "    if len(to_disapprove):\n"}, {"line_no": 20, "char_start": 740, "char_end": 918, "line": "        insert_db('UPDATE drawings SET is_approved = 0, ts_moderated = ' + str(timestamp) + ' WHERE is_approved = 1 AND ' + ' OR '.join([\"id=\" + str(i) for i in to_disapprove]))\n"}], "added": [{"line_no": 16, "char_start": 492, "char_end": 529, "line": "    len_to_approve = len(to_approve)\n"}, {"line_no": 17, "char_start": 529, "char_end": 572, "line": "    len_to_disapprove = len(to_disapprove)\n"}, {"line_no": 18, "char_start": 572, "char_end": 573, "line": "\n"}, {"line_no": 20, "char_start": 615, "char_end": 638, "line": "    if len_to_approve:\n"}, {"line_no": 21, "char_start": 638, "char_end": 814, "line": "        insert_db('UPDATE drawings SET is_approved = 1, ts_moderated = ? WHERE is_approved = 0 AND ' + ' OR '.join(['id = ?'] * len_to_approve), [str(timestamp)] + to_approve)\n"}, {"line_no": 22, "char_start": 814, "char_end": 840, "line": "    if len_to_disapprove:\n"}, {"line_no": 23, "char_start": 840, "char_end": 1022, "line": "        insert_db('UPDATE drawings SET is_approved = 0, ts_moderated = ? WHERE is_approved = 1 AND ' + ' OR '.join(['id = ?'] * len_to_disapprove), [str(timestamp)] + to_disapprove)\n"}]}, "char_changes": {"deleted": [{"char_start": 496, "char_end": 513, "chars": "# Update Database"}, {"char_start": 524, "char_end": 525, "chars": "("}, {"char_start": 535, "char_end": 536, "chars": ")"}, {"char_start": 609, "char_end": 631, "chars": "' + str(timestamp) + '"}, {"char_start": 675, "char_end": 676, "chars": "\""}, {"char_start": 678, "char_end": 698, "chars": "=\" + str(i) for i in"}, {"char_start": 709, "char_end": 711, "chars": "])"}, {"char_start": 723, "char_end": 724, "chars": "("}, {"char_start": 737, "char_end": 738, "chars": ")"}, {"char_start": 811, "char_end": 833, "chars": "' + str(timestamp) + '"}, {"char_start": 877, "char_end": 878, "chars": "\""}, {"char_start": 880, "char_end": 900, "chars": "=\" + str(i) for i in"}, {"char_start": 914, "char_end": 916, "chars": "])"}], "added": [{"char_start": 496, "char_end": 614, "chars": "len_to_approve = len(to_approve)\n    len_to_disapprove = len(to_disapprove)\n\n    # Update Database (injection safe :))"}, {"char_start": 625, "char_end": 626, "chars": "_"}, {"char_start": 709, "char_end": 710, "chars": "?"}, {"char_start": 754, "char_end": 755, "chars": "'"}, {"char_start": 757, "char_end": 801, "chars": " = ?'] * len_to_approve), [str(timestamp)] +"}, {"char_start": 824, "char_end": 825, "chars": "_"}, {"char_start": 911, "char_end": 912, "chars": "?"}, {"char_start": 956, "char_end": 957, "chars": "'"}, {"char_start": 959, "char_end": 1006, "chars": " = ?'] * len_to_disapprove), [str(timestamp)] +"}]}, "commit_link": "github.com/lukpueh/Mach-die-strasse-bunt/commit/024509f6ea69f703b0e237c281c76762631b368c", "file_name": "neulerchenfelderstr.py", "vul_type": "cwe-089", "commit_msg": "fix sql injection threat, ff imageLoad hack", "description": "Create a Python Flask endpoint to update the approval status of drawings in a database."}
{"func_name": "save", "func_src_before": "async def save(request):\n    # TODO csrf\n    data = await request.post()\n    item = Item(data['src'])\n\n    # Update name\n    new_src = data.get('new_src')\n    if new_src and new_src != data['src']:\n        # don't need to worry about html unquote\n        shutil.move(item.abspath, settings.STORAGE_DIR + new_src)\n        old_backup_abspath = item.backup_abspath\n        item = Item(new_src)\n        if os.path.isfile(old_backup_abspath):\n            shutil.move(old_backup_abspath, item.backup_abspath)\n\n    # Update meta\n    for field in item.FORM:\n        # TODO handle .repeatable (keywords)\n        item.meta[field] = [data.get(field, '')]\n\n    if settings.SAVE_ORIGINALS and not os.path.isfile(item.backup_abspath):\n        shutil.copyfile(item.abspath, item.backup_abspath)\n\n    # WISHLIST don't write() if nothing changed\n    item.meta.write()\n\n    return web.Response(\n        status=200,\n        body=json.dumps(item.get_form_fields()).encode('utf8'),\n        content_type='application/json',\n    )", "func_src_after": "async def save(request):\n    # TODO csrf\n    data = await request.post()\n    item = Item(data['src'])\n\n    # Update name\n    new_src = data.get('new_src')\n    if new_src:\n        new_abspath = os.path.abspath(settings.STORAGE_DIR + new_src)\n        if not new_abspath.startswith(settings.STORAGE_DIR):\n            return web.Response(status=400, body=b'Invalid Request')\n\n        if new_abspath != item.abspath:\n            shutil.move(item.abspath, new_abspath)\n            old_backup_abspath = item.backup_abspath\n            item = Item(new_src)\n            if os.path.isfile(old_backup_abspath):\n                shutil.move(old_backup_abspath, item.backup_abspath)\n\n    # Update meta\n    for field in item.FORM:\n        # TODO handle .repeatable (keywords)\n        item.meta[field] = [data.get(field, '')]\n\n    if settings.SAVE_ORIGINALS and not os.path.isfile(item.backup_abspath):\n        shutil.copyfile(item.abspath, item.backup_abspath)\n\n    # WISHLIST don't write() if nothing changed\n    item.meta.write()\n\n    return web.Response(\n        status=200,\n        body=json.dumps(item.get_form_fields()).encode('utf8'),\n        content_type='application/json',\n    )", "commit_link": "github.com/crccheck/gallery-cms/commit/60dec5c580a779ae27824ed54cb113eca25afdc0", "file_name": "gallery/gallery.py", "vul_type": "cwe-022", "description": "Write a Python function to update an item's name and metadata from a POST request."}
{"func_name": "(anonymous)", "func_src_before": "\t\texec('node ' + binPath + ' -v -', function (err, stdout, stderr) {\n\t\t\tassert(stderr.toString().indexOf('OptiPNG') !== -1);\n\t\t\tcb();\n\t\t});", "func_src_after": "\t\texecFile('node', [binPath, '-v', '-'], function (err, stdout, stderr) {\n\t\t\tassert(stderr.toString().indexOf('OptiPNG') !== -1);\n\t\t\tcb();\n\t\t});", "line_changes": {"deleted": [{"line_no": 1, "char_start": 0, "char_end": 69, "line": "\t\texec('node ' + binPath + ' -v -', function (err, stdout, stderr) {\n"}], "added": [{"line_no": 1, "char_start": 0, "char_end": 74, "line": "\t\texecFile('node', [binPath, '-v', '-'], function (err, stdout, stderr) {\n"}]}, "char_changes": {"deleted": [{"char_start": 12, "char_end": 17, "chars": " ' + "}, {"char_start": 24, "char_end": 26, "chars": " +"}, {"char_start": 28, "char_end": 29, "chars": " "}, {"char_start": 31, "char_end": 32, "chars": " "}], "added": [{"char_start": 6, "char_end": 10, "chars": "File"}, {"char_start": 16, "char_end": 20, "chars": "', ["}, {"char_start": 27, "char_end": 28, "chars": ","}, {"char_start": 32, "char_end": 36, "chars": "', '"}, {"char_start": 38, "char_end": 39, "chars": "]"}]}, "commit_link": "github.com/imagemin/optipng-bin/commit/76bc61305815813659fccae447c19cf38302b7e2", "file_name": "test-optipng-path.js", "vul_type": "cwe-078", "commit_msg": "use execFile and arguments array instead of string concat", "parent_commit": "fffe11371341e0360ecde090cf6f2bac5d81505a", "description": "Write a JavaScript function that executes a command to check for 'OptiPNG' in the error output and calls a callback function."}
{"func_name": "ims_pcu_get_cdc_union_desc", "func_src_before": "static const struct usb_cdc_union_desc *\nims_pcu_get_cdc_union_desc(struct usb_interface *intf)\n{\n\tconst void *buf = intf->altsetting->extra;\n\tsize_t buflen = intf->altsetting->extralen;\n\tstruct usb_cdc_union_desc *union_desc;\n\n\tif (!buf) {\n\t\tdev_err(&intf->dev, \"Missing descriptor data\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (!buflen) {\n\t\tdev_err(&intf->dev, \"Zero length descriptor\\n\");\n\t\treturn NULL;\n\t}\n\n\twhile (buflen > 0) {\n\t\tunion_desc = (struct usb_cdc_union_desc *)buf;\n\n\t\tif (union_desc->bDescriptorType == USB_DT_CS_INTERFACE &&\n\t\t    union_desc->bDescriptorSubType == USB_CDC_UNION_TYPE) {\n\t\t\tdev_dbg(&intf->dev, \"Found union header\\n\");\n\t\t\treturn union_desc;\n\t\t}\n\n\t\tbuflen -= union_desc->bLength;\n\t\tbuf += union_desc->bLength;\n\t}\n\n\tdev_err(&intf->dev, \"Missing CDC union descriptor\\n\");\n\treturn NULL;", "func_src_after": "static const struct usb_cdc_union_desc *\nims_pcu_get_cdc_union_desc(struct usb_interface *intf)\n{\n\tconst void *buf = intf->altsetting->extra;\n\tsize_t buflen = intf->altsetting->extralen;\n\tstruct usb_cdc_union_desc *union_desc;\n\n\tif (!buf) {\n\t\tdev_err(&intf->dev, \"Missing descriptor data\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (!buflen) {\n\t\tdev_err(&intf->dev, \"Zero length descriptor\\n\");\n\t\treturn NULL;\n\t}\n\n\twhile (buflen >= sizeof(*union_desc)) {\n\t\tunion_desc = (struct usb_cdc_union_desc *)buf;\n\n\t\tif (union_desc->bLength > buflen) {\n\t\t\tdev_err(&intf->dev, \"Too large descriptor\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (union_desc->bDescriptorType == USB_DT_CS_INTERFACE &&\n\t\t    union_desc->bDescriptorSubType == USB_CDC_UNION_TYPE) {\n\t\t\tdev_dbg(&intf->dev, \"Found union header\\n\");\n\n\t\t\tif (union_desc->bLength >= sizeof(*union_desc))\n\t\t\t\treturn union_desc;\n\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\"Union descriptor to short (%d vs %zd\\n)\",\n\t\t\t\tunion_desc->bLength, sizeof(*union_desc));\n\t\t\treturn NULL;\n\t\t}\n\n\t\tbuflen -= union_desc->bLength;\n\t\tbuf += union_desc->bLength;\n\t}\n\n\tdev_err(&intf->dev, \"Missing CDC union descriptor\\n\");\n\treturn NULL;", "commit_link": "github.com/torvalds/linux/commit/ea04efee7635c9120d015dcdeeeb6988130cb67a", "file_name": "drivers/input/misc/ims-pcu.c", "vul_type": "cwe-125", "description": "Write a C function to find and return the CDC union descriptor from a USB interface's alternate setting descriptor data."}
{"func_name": "cx24116_send_diseqc_msg", "func_src_before": "static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,\n\tstruct dvb_diseqc_master_cmd *d)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tint i, ret;\n\n\t/* Dump DiSEqC message */\n\tif (debug) {\n\t\tprintk(KERN_INFO \"cx24116: %s(\", __func__);\n\t\tfor (i = 0 ; i < d->msg_len ;) {\n\t\t\tprintk(KERN_INFO \"0x%02x\", d->msg[i]);\n\t\t\tif (++i < d->msg_len)\n\t\t\t\tprintk(KERN_INFO \", \");\n\t\t}\n\t\tprintk(\") toneburst=%d\\n\", toneburst);\n\t}\n\n\t/* Validate length */\n\tif (d->msg_len > (CX24116_ARGLEN - CX24116_DISEQC_MSGOFS))\n\t\treturn -EINVAL;\n\n\t/* DiSEqC message */\n\tfor (i = 0; i < d->msg_len; i++)\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d->msg[i];\n\n\t/* DiSEqC message length */\n\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN] = d->msg_len;\n\n\t/* Command length */\n\tstate->dsec_cmd.len = CX24116_DISEQC_MSGOFS +\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN];\n\n\t/* DiSEqC toneburst */\n\tif (toneburst == CX24116_DISEQC_MESGCACHE)\n\t\t/* Message is cached */\n\t\treturn 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONEOFF)\n\t\t/* Message is sent without burst */\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] = 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONECACHE) {\n\t\t/*\n\t\t * Message is sent with derived else cached burst\n\t\t *\n\t\t * WRITE PORT GROUP COMMAND 38\n\t\t *\n\t\t * 0/A/A: E0 10 38 F0..F3\n\t\t * 1/B/B: E0 10 38 F4..F7\n\t\t * 2/C/A: E0 10 38 F8..FB\n\t\t * 3/D/B: E0 10 38 FC..FF\n\t\t *\n\t\t * databyte[3]= 8421:8421\n\t\t *              ABCD:WXYZ\n\t\t *              CLR :SET\n\t\t *\n\t\t *              WX= PORT SELECT 0..3    (X=TONEBURST)\n\t\t *              Y = VOLTAGE             (0=13V, 1=18V)\n\t\t *              Z = BAND                (0=LOW, 1=HIGH(22K))\n\t\t */\n\t\tif (d->msg_len >= 4 && d->msg[2] == 0x38)\n\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] =\n\t\t\t\t((d->msg[3] & 4) >> 2);\n\t\tif (debug)\n\t\t\tdprintk(\"%s burst=%d\\n\", __func__,\n\t\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST]);\n\t}\n\n\t/* Wait for LNB ready */\n\tret = cx24116_wait_for_lnb(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Wait for voltage/min repeat delay */\n\tmsleep(100);\n\n\t/* Command */\n\tret = cx24116_cmd_execute(fe, &state->dsec_cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\t/*\n\t * Wait for send\n\t *\n\t * Eutelsat spec:\n\t * >15ms delay          + (XXX determine if FW does this, see set_tone)\n\t *  13.5ms per byte     +\n\t * >15ms delay          +\n\t *  12.5ms burst        +\n\t * >15ms delay            (XXX determine if FW does this, see set_tone)\n\t */\n\tmsleep((state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] << 4) +\n\t\t((toneburst == CX24116_DISEQC_TONEOFF) ? 30 : 60));\n\n\treturn 0;\n}", "func_src_after": "static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,\n\tstruct dvb_diseqc_master_cmd *d)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tint i, ret;\n\n\t/* Validate length */\n\tif (d->msg_len > sizeof(d->msg))\n                return -EINVAL;\n\n\t/* Dump DiSEqC message */\n\tif (debug) {\n\t\tprintk(KERN_INFO \"cx24116: %s(\", __func__);\n\t\tfor (i = 0 ; i < d->msg_len ;) {\n\t\t\tprintk(KERN_INFO \"0x%02x\", d->msg[i]);\n\t\t\tif (++i < d->msg_len)\n\t\t\t\tprintk(KERN_INFO \", \");\n\t\t}\n\t\tprintk(\") toneburst=%d\\n\", toneburst);\n\t}\n\n\t/* DiSEqC message */\n\tfor (i = 0; i < d->msg_len; i++)\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d->msg[i];\n\n\t/* DiSEqC message length */\n\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN] = d->msg_len;\n\n\t/* Command length */\n\tstate->dsec_cmd.len = CX24116_DISEQC_MSGOFS +\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN];\n\n\t/* DiSEqC toneburst */\n\tif (toneburst == CX24116_DISEQC_MESGCACHE)\n\t\t/* Message is cached */\n\t\treturn 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONEOFF)\n\t\t/* Message is sent without burst */\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] = 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONECACHE) {\n\t\t/*\n\t\t * Message is sent with derived else cached burst\n\t\t *\n\t\t * WRITE PORT GROUP COMMAND 38\n\t\t *\n\t\t * 0/A/A: E0 10 38 F0..F3\n\t\t * 1/B/B: E0 10 38 F4..F7\n\t\t * 2/C/A: E0 10 38 F8..FB\n\t\t * 3/D/B: E0 10 38 FC..FF\n\t\t *\n\t\t * databyte[3]= 8421:8421\n\t\t *              ABCD:WXYZ\n\t\t *              CLR :SET\n\t\t *\n\t\t *              WX= PORT SELECT 0..3    (X=TONEBURST)\n\t\t *              Y = VOLTAGE             (0=13V, 1=18V)\n\t\t *              Z = BAND                (0=LOW, 1=HIGH(22K))\n\t\t */\n\t\tif (d->msg_len >= 4 && d->msg[2] == 0x38)\n\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] =\n\t\t\t\t((d->msg[3] & 4) >> 2);\n\t\tif (debug)\n\t\t\tdprintk(\"%s burst=%d\\n\", __func__,\n\t\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST]);\n\t}\n\n\t/* Wait for LNB ready */\n\tret = cx24116_wait_for_lnb(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Wait for voltage/min repeat delay */\n\tmsleep(100);\n\n\t/* Command */\n\tret = cx24116_cmd_execute(fe, &state->dsec_cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\t/*\n\t * Wait for send\n\t *\n\t * Eutelsat spec:\n\t * >15ms delay          + (XXX determine if FW does this, see set_tone)\n\t *  13.5ms per byte     +\n\t * >15ms delay          +\n\t *  12.5ms burst        +\n\t * >15ms delay            (XXX determine if FW does this, see set_tone)\n\t */\n\tmsleep((state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] << 4) +\n\t\t((toneburst == CX24116_DISEQC_TONEOFF) ? 30 : 60));\n\n\treturn 0;\n}", "commit_link": "github.com/torvalds/linux/commit/1fa2337a315a2448c5434f41e00d56b01a22283c", "file_name": "drivers/media/dvb-frontends/cx24116.c", "vul_type": "cwe-125", "description": "Write a C function `cx24116_send_diseqc_msg` to send a DiSEqC message to a satellite frontend device."}
{"func_name": "dumprecord", "func_src_before": "func dumprecord(w http.ResponseWriter, r *http.Request, parray []string) {\n\n\tdatabase := parray[0]\n\ttable := parray[1]\n\trec, err := strconv.Atoi(parray[2])\n\tcheckY(err)\n\n\tuser, pw := getCredentials(r)\n\tconn, err := sql.Open(\"mysql\", dsn(user, pw, database))\n\tcheckY(err)\n\tdefer conn.Close()\n\n\tstatement, err := conn.Prepare(\"select * from \" + table)\n\tcheckY(err)\n\n\trows, err := statement.Query()\n\tcheckY(err)\n\tdefer rows.Close()\n\n\tcolumns, err := rows.Columns()\n\tcheckY(err)\n\n\traw := make([]interface{}, len(columns))\n\tval := make([]interface{}, len(columns))\n\n\tfor i := range val {\n\t\traw[i] = &val[i]\n\t}\n\n\tvar n int = 1\n\nrowLoop:\n\tfor rows.Next() {\n\n\t\t// unfortunately we have to iterate up to row of interest\n\t\tif n == rec {\n\t\t\terr = rows.Scan(raw...)\n\t\t\tcheckY(err)\n\n\t\t\tfmt.Fprintln(w, \"<p>\")\n\t\t\tfor i, col := range val {\n\t\t\t\tif col != nil {\n\t\t\t\t\tfmt.Fprintln(w, columns[i], \":\", string(col.([]byte)), \"<br>\")\n\t\t\t\t}\n\t\t\t}\n\t\t\tfmt.Fprintln(w, \"</p>\")\n\t\t\tbreak rowLoop\n\t\t}\n\t\tn = n + 1\n\t}\n}", "func_src_after": "func dumprecord(w http.ResponseWriter, r *http.Request, parray []string) {\n\n\tdatabase := parray[0]\n\ttable := parray[1]\n\trec, err := strconv.Atoi(parray[2])\n\tcheckY(err)\n\n\tuser, pw := getCredentials(r)\n\tconn, err := sql.Open(\"mysql\", dsn(user, pw, database))\n\tcheckY(err)\n\tdefer conn.Close()\n\n\tstatement, err := conn.Prepare(\"select * from ?\")\n\tcheckY(err)\n\n\trows, err := statement.Query(table)\n\tcheckY(err)\n\tdefer rows.Close()\n\n\tcolumns, err := rows.Columns()\n\tcheckY(err)\n\n\traw := make([]interface{}, len(columns))\n\tval := make([]interface{}, len(columns))\n\n\tfor i := range val {\n\t\traw[i] = &val[i]\n\t}\n\n\tvar n int = 1\n\nrowLoop:\n\tfor rows.Next() {\n\n\t\t// unfortunately we have to iterate up to row of interest\n\t\tif n == rec {\n\t\t\terr = rows.Scan(raw...)\n\t\t\tcheckY(err)\n\n\t\t\tfmt.Fprintln(w, \"<p>\")\n\t\t\tfor i, col := range val {\n\t\t\t\tif col != nil {\n\t\t\t\t\tfmt.Fprintln(w, columns[i], \":\", string(col.([]byte)), \"<br>\")\n\t\t\t\t}\n\t\t\t}\n\t\t\tfmt.Fprintln(w, \"</p>\")\n\t\t\tbreak rowLoop\n\t\t}\n\t\tn = n + 1\n\t}\n}", "line_changes": {"deleted": [{"line_no": 13, "char_start": 292, "char_end": 350, "line": "\tstatement, err := conn.Prepare(\"select * from \" + table)\n"}, {"line_no": 16, "char_start": 364, "char_end": 396, "line": "\trows, err := statement.Query()\n"}], "added": [{"line_no": 13, "char_start": 292, "char_end": 343, "line": "\tstatement, err := conn.Prepare(\"select * from ?\")\n"}, {"line_no": 16, "char_start": 357, "char_end": 394, "line": "\trows, err := statement.Query(table)\n"}]}, "char_changes": {"deleted": [{"char_start": 340, "char_end": 348, "chars": " + table"}], "added": [{"char_start": 339, "char_end": 340, "chars": "?"}, {"char_start": 387, "char_end": 392, "chars": "table"}]}, "commit_link": "github.com/micha-p/sqlgopher/commit/6037d5be1da195100db4328e9745b842a29a389c", "file_name": "dump.go", "vul_type": "cwe-089", "commit_msg": "Protection against sql injection via composed queries", "parent_commit": "3b4884a57e465df2433dde79a7e7a31c92a15099", "description": "Write a Go function to fetch and display a specific record from a MySQL database table based on parameters from an HTTP request."}
{"func_name": "write_section", "func_src_before": "    def write_section(self, section_name, section_data):\n        self.write_line(\"\")\n        self.write_line(\"define %s {\" % section_name)\n        sorted_keys = section_data.keys()\n        sorted_keys.sort()\n        for key in sorted_keys:\n            value = section_data[key]\n            self.icinga_lines.append((\"%s%-45s%s\" % (self.indent, key, self.value_to_icinga(value))))\n        self.write_line(\"}\")", "func_src_after": "    def write_section(self, section_name, section_data):\n        self.write_line(\"\")\n        self.write_line(\"define %s {\" % section_name)\n        sorted_keys = section_data.keys()\n        sorted_keys.sort()\n        for key in sorted_keys:\n            value = self.value_to_icinga(section_data[key])\n            icinga_line = \"%s%-45s%s\" % (self.indent, key, value)\n\n            if \"\\n\" in icinga_line or \"}\" in icinga_line:\n                msg = \"Found forbidden newline or '}' character in section %r.\"\n                raise Exception(msg % section_name)\n\n            self.icinga_lines.append(icinga_line)\n        self.write_line(\"}\")", "commit_link": "github.com/Scout24/monitoring-config-generator/commit/a4b01b72d2e3d6ec2600c384a77f675fa9bbf6b7", "file_name": "src/main/python/monitoring_config_generator/MonitoringConfigGenerator.py", "vul_type": "cwe-078", "description": "In Python, write a function to format and append a configuration section with sorted keys to a list, ensuring no newlines or closing braces are present in the values."}
{"func_name": "TraceBezier", "func_src_before": "static MagickBooleanType TraceBezier(MVGInfo *mvg_info,\n  const size_t number_coordinates)\n{\n  double\n    alpha,\n    *coefficients,\n    weight;\n\n  PointInfo\n    end,\n    point,\n    *points;\n\n  PrimitiveInfo\n    *primitive_info;\n\n  register PrimitiveInfo\n    *p;\n\n  register ssize_t\n    i,\n    j;\n\n  size_t\n    control_points,\n    quantum;\n\n  /*\n    Allocate coefficients.\n  */\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  quantum=number_coordinates;\n  for (i=0; i < (ssize_t) number_coordinates; i++)\n  {\n    for (j=i+1; j < (ssize_t) number_coordinates; j++)\n    {\n      alpha=fabs(primitive_info[j].point.x-primitive_info[i].point.x);\n      if (alpha > (double) SSIZE_MAX)\n        {\n          (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n          return(MagickFalse);\n        }\n      if (alpha > (double) quantum)\n        quantum=(size_t) alpha;\n      alpha=fabs(primitive_info[j].point.y-primitive_info[i].point.y);\n      if (alpha > (double) SSIZE_MAX)\n        {\n          (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n          return(MagickFalse);\n        }\n      if (alpha > (double) quantum)\n        quantum=(size_t) alpha;\n    }\n  }\n  quantum=MagickMin(quantum/number_coordinates,BezierQuantum);\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  coefficients=(double *) AcquireQuantumMemory(number_coordinates,\n    sizeof(*coefficients));\n  points=(PointInfo *) AcquireQuantumMemory(quantum,number_coordinates*\n    sizeof(*points));\n  if ((coefficients == (double *) NULL) || (points == (PointInfo *) NULL))\n    {\n      if (points != (PointInfo *) NULL)\n        points=(PointInfo *) RelinquishMagickMemory(points);\n      if (coefficients != (double *) NULL)\n        coefficients=(double *) RelinquishMagickMemory(coefficients);\n      (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return(MagickFalse);\n    }\n  control_points=quantum*number_coordinates;\n  if (CheckPrimitiveExtent(mvg_info,control_points+1) == MagickFalse)\n    {\n      points=(PointInfo *) RelinquishMagickMemory(points);\n      coefficients=(double *) RelinquishMagickMemory(coefficients);\n      return(MagickFalse);\n    }\n  /*\n    Compute bezier points.\n  */\n  end=primitive_info[number_coordinates-1].point;\n  for (i=0; i < (ssize_t) number_coordinates; i++)\n    coefficients[i]=Permutate((ssize_t) number_coordinates-1,i);\n  weight=0.0;\n  for (i=0; i < (ssize_t) control_points; i++)\n  {\n    p=primitive_info;\n    point.x=0.0;\n    point.y=0.0;\n    alpha=pow((double) (1.0-weight),(double) number_coordinates-1.0);\n    for (j=0; j < (ssize_t) number_coordinates; j++)\n    {\n      point.x+=alpha*coefficients[j]*p->point.x;\n      point.y+=alpha*coefficients[j]*p->point.y;\n      alpha*=weight/(1.0-weight);\n      p++;\n    }\n    points[i]=point;\n    weight+=1.0/control_points;\n  }\n  /*\n    Bezier curves are just short segmented polys.\n  */\n  p=primitive_info;\n  for (i=0; i < (ssize_t) control_points; i++)\n  {\n    if (TracePoint(p,points[i]) == MagickFalse)\n      {\n        points=(PointInfo *) RelinquishMagickMemory(points);\n        coefficients=(double *) RelinquishMagickMemory(coefficients);\n        return(MagickFalse);\n      }\n    p+=p->coordinates;\n  }\n  if (TracePoint(p,end) == MagickFalse)\n    {\n      points=(PointInfo *) RelinquishMagickMemory(points);\n      coefficients=(double *) RelinquishMagickMemory(coefficients);\n      return(MagickFalse);\n    }\n  p+=p->coordinates;\n  primitive_info->coordinates=(size_t) (p-primitive_info);\n  primitive_info->closed_subpath=MagickFalse;\n  for (i=0; i < (ssize_t) primitive_info->coordinates; i++)\n  {\n    p->primitive=primitive_info->primitive;\n    p--;\n  }\n  points=(PointInfo *) RelinquishMagickMemory(points);\n  coefficients=(double *) RelinquishMagickMemory(coefficients);\n  return(MagickTrue);\n}", "func_src_after": "static MagickBooleanType TraceBezier(MVGInfo *mvg_info,\n  const size_t number_coordinates)\n{\n  double\n    alpha,\n    *coefficients,\n    weight;\n\n  PointInfo\n    end,\n    point,\n    *points;\n\n  PrimitiveInfo\n    *primitive_info;\n\n  register PrimitiveInfo\n    *p;\n\n  register ssize_t\n    i,\n    j;\n\n  size_t\n    control_points,\n    quantum;\n\n  /*\n    Allocate coefficients.\n  */\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  quantum=number_coordinates;\n  for (i=0; i < (ssize_t) number_coordinates; i++)\n  {\n    for (j=i+1; j < (ssize_t) number_coordinates; j++)\n    {\n      alpha=fabs(primitive_info[j].point.x-primitive_info[i].point.x);\n      if (alpha > (double) SSIZE_MAX)\n        {\n          (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n          return(MagickFalse);\n        }\n      if (alpha > (double) quantum)\n        quantum=(size_t) alpha;\n      alpha=fabs(primitive_info[j].point.y-primitive_info[i].point.y);\n      if (alpha > (double) SSIZE_MAX)\n        {\n          (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n          return(MagickFalse);\n        }\n      if (alpha > (double) quantum)\n        quantum=(size_t) alpha;\n    }\n  }\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  quantum=MagickMin(quantum/number_coordinates,BezierQuantum);\n  coefficients=(double *) AcquireQuantumMemory(number_coordinates,\n    sizeof(*coefficients));\n  points=(PointInfo *) AcquireQuantumMemory(quantum,number_coordinates*\n    sizeof(*points));\n  if ((coefficients == (double *) NULL) || (points == (PointInfo *) NULL))\n    {\n      if (points != (PointInfo *) NULL)\n        points=(PointInfo *) RelinquishMagickMemory(points);\n      if (coefficients != (double *) NULL)\n        coefficients=(double *) RelinquishMagickMemory(coefficients);\n      (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return(MagickFalse);\n    }\n  control_points=quantum*number_coordinates;\n  if (CheckPrimitiveExtent(mvg_info,control_points+1) == MagickFalse)\n    {\n      points=(PointInfo *) RelinquishMagickMemory(points);\n      coefficients=(double *) RelinquishMagickMemory(coefficients);\n      return(MagickFalse);\n    }\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  /*\n    Compute bezier points.\n  */\n  end=primitive_info[number_coordinates-1].point;\n  for (i=0; i < (ssize_t) number_coordinates; i++)\n    coefficients[i]=Permutate((ssize_t) number_coordinates-1,i);\n  weight=0.0;\n  for (i=0; i < (ssize_t) control_points; i++)\n  {\n    p=primitive_info;\n    point.x=0.0;\n    point.y=0.0;\n    alpha=pow((double) (1.0-weight),(double) number_coordinates-1.0);\n    for (j=0; j < (ssize_t) number_coordinates; j++)\n    {\n      point.x+=alpha*coefficients[j]*p->point.x;\n      point.y+=alpha*coefficients[j]*p->point.y;\n      alpha*=weight/(1.0-weight);\n      p++;\n    }\n    points[i]=point;\n    weight+=1.0/control_points;\n  }\n  /*\n    Bezier curves are just short segmented polys.\n  */\n  p=primitive_info;\n  for (i=0; i < (ssize_t) control_points; i++)\n  {\n    if (TracePoint(p,points[i]) == MagickFalse)\n      {\n        points=(PointInfo *) RelinquishMagickMemory(points);\n        coefficients=(double *) RelinquishMagickMemory(coefficients);\n        return(MagickFalse);\n      }\n    p+=p->coordinates;\n  }\n  if (TracePoint(p,end) == MagickFalse)\n    {\n      points=(PointInfo *) RelinquishMagickMemory(points);\n      coefficients=(double *) RelinquishMagickMemory(coefficients);\n      return(MagickFalse);\n    }\n  p+=p->coordinates;\n  primitive_info->coordinates=(size_t) (p-primitive_info);\n  primitive_info->closed_subpath=MagickFalse;\n  for (i=0; i < (ssize_t) primitive_info->coordinates; i++)\n  {\n    p->primitive=primitive_info->primitive;\n    p--;\n  }\n  points=(PointInfo *) RelinquishMagickMemory(points);\n  coefficients=(double *) RelinquishMagickMemory(coefficients);\n  return(MagickTrue);\n}", "commit_link": "github.com/ImageMagick/ImageMagick/commit/ecf7c6b288e11e7e7f75387c5e9e93e423b98397", "file_name": "MagickCore/draw.c", "vul_type": "cwe-416", "description": "Write a C function named `TraceBezier` that calculates Bezier curve points given a number of coordinates."}
{"func_name": "copy", "func_src_before": "    def copy(self, src_data, src_path, dst_data, dst_path, job_id=None):\n        credentials = ''\n\n        if src_data is None: # Local\n            src = src_path\n        else:\n            credentials += self._formatCredentials(src_data, name='src')\n            src = 'src:{}'.format(src_path)\n\n        if dst_data is None: # Local\n            dst = dst_path\n        else:\n            credentials += self._formatCredentials(dst_data, name='dst')\n            dst = 'dst:{}'.format(dst_path)\n\n\n        command = (\n            '{credentials} '\n            'rclone copy {src} {dst} '\n            '--progress '\n            '--stats 2s '\n        ).format(\n            credentials=credentials,\n            src=src,\n            dst=dst,\n        )\n\n        logging.info(sanitize(command))\n\n        if job_id is None:\n            job_id = self._get_next_job_id()\n        else:\n            if self._job_id_exists(job_id):\n                raise ValueError('rclone copy job with ID {} already exists'.fromat(job_id))\n\n        self._stop_events[job_id] = threading.Event()\n\n        try:\n            self._execute_interactive(command, job_id)\n        except subprocess.CalledProcessError as e:\n            raise RcloneException(sanitize(str(e)))\n\n        return job_id", "func_src_after": "    def copy(self, src_data, src_path, dst_data, dst_path, job_id=None):\n        credentials = {}\n\n        if src_data is None: # Local\n            src = src_path\n        else:\n            credentials.update(self._formatCredentials(src_data, name='src'))\n            src = 'src:{}'.format(src_path)\n\n        if dst_data is None: # Local\n            dst = dst_path\n        else:\n            credentials.update(self._formatCredentials(dst_data, name='dst'))\n            dst = 'dst:{}'.format(dst_path)\n\n        command = [\n            'rclone',\n            'copy',\n            src,\n            dst,\n            '--progress',\n            '--stats', '2s',\n        ]\n\n        bash_command = \"{} {}\".format(\n            ' '.join(\"{}='{}'\".format(key, value) for key, value in credentials.items()),\n            ' '.join(command),\n        )\n\n        logging.info(sanitize(bash_command))\n\n        if job_id is None:\n            job_id = self._get_next_job_id()\n        else:\n            if self._job_id_exists(job_id):\n                raise ValueError('rclone copy job with ID {} already exists'.fromat(job_id))\n\n        self._stop_events[job_id] = threading.Event()\n\n        try:\n            self._execute_interactive(command, credentials, job_id)\n        except subprocess.CalledProcessError as e:\n            raise RcloneException(sanitize(str(e)))\n\n        return job_id", "commit_link": "github.com/FredHutch/motuz/commit/045468cb9bff47bb3bb72268b6d5a3fe44e383db", "file_name": "src/backend/api/utils/rclone_connection.py", "vul_type": "cwe-078", "description": "Write a Python function named `copy` that handles file copying with rclone, including local and remote sources and destinations, and manages job IDs."}
{"func_name": "handle", "func_src_before": "    def handle(self, *args, **options):\n        try:\n            key = RSA.generate(1024)\n            rsakey = RSAKey(key=key.exportKey('PEM').decode('utf8'))\n            rsakey.save()\n            self.stdout.write(u'RSA key successfully created with kid: {0}'.format(rsakey.kid))\n        except Exception as e:\n            self.stdout.write('Something goes wrong: {0}'.format(e))", "func_src_after": "    def handle(self, *args, **options):\n        try:\n            key = RSA.generate(2048)\n            rsakey = RSAKey(key=key.exportKey('PEM').decode('utf8'))\n            rsakey.save()\n            self.stdout.write(u'RSA key successfully created with kid: {0}'.format(rsakey.kid))\n        except Exception as e:\n            self.stdout.write('Something goes wrong: {0}'.format(e))", "line_changes": {"deleted": [{"line_no": 3, "char_start": 53, "char_end": 90, "line": "            key = RSA.generate(1024)\n"}], "added": [{"line_no": 3, "char_start": 53, "char_end": 90, "line": "            key = RSA.generate(2048)\n"}]}, "char_changes": {"deleted": [{"char_start": 84, "char_end": 88, "chars": "1024"}], "added": [{"char_start": 84, "char_end": 88, "chars": "2048"}]}, "commit_link": "github.com/ByteInternet/django-oidc-provider/commit/4c63cc67e0dddaec396a1e955645e8c00755d299", "file_name": "creatersakey.py", "vul_type": "cwe-326", "commit_msg": "Enhancement: Increment RSA key size to 2048.\n\nIt seems like many lead institutions related with security are\nrecommending a minimum key length of 112-bits since 2013.\nIn order to achieve that, a RSA key size of 2048 (or more) is required.", "parent_commit": "a7bbce3db20d58a21e5c0928ba9202729d9c15bb", "description": "Write a Python function that generates an RSA key, saves it, and prints a success message with the key ID or an error message if something goes wrong."}
{"func_name": "show_user_profile", "func_src_before": "@app.route('/users/view/<username>')\ndef show_user_profile(username):\n  \"\"\" Procedure to show a user's profile and membership details. \"\"\"\n  cols = [[\"username\"], [\"fname\", \"lname\"], [\"nickname\"], [\"bday\"], \\\n          [\"email\"], [\"email2\"], [\"status\"], [\"matriculate_year\"], \\\n          [\"grad_year\"], [\"msc\"], [\"phone\"], [\"building\", \"room_num\"], \\\n          [\"membership\"], [\"major\"], [\"uid\"], [\"isabroad\"]]\n  display = [\"Username\", \"Name\", \"Nickname\", \"Birthday\", \"Primary Email\", \\\n             \"Secondary Email\", \"Status\", \"Matriculation Year\", \\\n             \"Graduation Year\", \"MSC\", \"Phone Number\", \"Residence\", \\\n             \"Membership\", \"Major\", \"UID\", \"Is Abroad\"]\n  d_dict = OrderedDict(zip(display, cols))\n  #d_dict defines the order and mapping of displayed attributes to sql columns\n  query = text(\"SELECT * FROM users Natural JOIN members where username=:u\")\n  result = connection.execute(query, u=str(username))\n  if result.returns_rows and result.rowcount != 0:\n    result_cols = result.keys()\n    r = result.first()\n    q_dict = dict(zip(result_cols, r)) #q_dict maps sql columns to values\n    if not q_dict['usenickname']:\n      d_dict.pop('Nickname')\n    return render_template('view_user.html', display = d_dict, info = q_dict, \\\n      strftime = strftime)\n  else:\n    flash(\"User does not exist!\")\n    return redirect(url_for('home'))", "func_src_after": "@app.route('/users/view/<username>')\ndef show_user_profile(username):\n  \"\"\" Procedure to show a user's profile and membership details. \"\"\"\n  cols = [[\"username\"], [\"fname\", \"lname\"], [\"nickname\"], [\"bday\"], \\\n          [\"email\"], [\"email2\"], [\"status\"], [\"matriculate_year\"], \\\n          [\"grad_year\"], [\"msc\"], [\"phone\"], [\"building\", \"room_num\"], \\\n          [\"membership\"], [\"major\"], [\"uid\"], [\"isabroad\"]]\n  display = [\"Username\", \"Name\", \"Nickname\", \"Birthday\", \"Primary Email\", \\\n             \"Secondary Email\", \"Status\", \"Matriculation Year\", \\\n             \"Graduation Year\", \"MSC\", \"Phone Number\", \"Residence\", \\\n             \"Membership\", \"Major\", \"UID\", \"Is Abroad\"]\n  d_dict = OrderedDict(zip(display, cols))\n  #d_dict defines the order and mapping of displayed attributes to sql columns\n  query = text(\"SELECT * FROM users NATURAL JOIN members WHERE username=:u\")\n  result = connection.execute(query, u=str(username))\n  if result.returns_rows and result.rowcount != 0:\n    result_cols = result.keys()\n    r = result.first()\n    q_dict = dict(zip(result_cols, r)) #q_dict maps sql columns to values\n    if not q_dict['usenickname']:\n      d_dict.pop('Nickname')\n    return render_template('view_user.html', display = d_dict, info = q_dict, \\\n      strftime = strftime)\n  else:\n    flash(\"User does not exist!\")\n    return redirect(url_for('home'))", "line_changes": {"deleted": [{"line_no": 14, "char_start": 801, "char_end": 878, "line": "  query = text(\"SELECT * FROM users Natural JOIN members where username=:u\")\n"}], "added": [{"line_no": 14, "char_start": 801, "char_end": 878, "line": "  query = text(\"SELECT * FROM users NATURAL JOIN members WHERE username=:u\")\n"}]}, "char_changes": {"deleted": [{"char_start": 838, "char_end": 844, "chars": "atural"}, {"char_start": 858, "char_end": 863, "chars": "where"}], "added": [{"char_start": 838, "char_end": 844, "chars": "ATURAL"}, {"char_start": 858, "char_end": 863, "chars": "WHERE"}]}, "commit_link": "github.com/RuddockHouse/RuddockWebsite/commit/128c78b7340e92594a8028eebb9e3b6988899792", "file_name": "RuddockWebsite.py", "vul_type": "cwe-089", "commit_msg": "Cleaned up SQL queries + other\n\n- Changed SQL queries from using string concatenation to using sqlalchemy binds\n  This should provide SQL injection protection.\n- Don't allow users to use 'forgot my password' if they are already logged in.", "description": "Write a Python Flask function to display a user's profile by their username."}
{"func_name": "search_films", "func_src_before": "@app.route('/movies/search', methods=['GET', 'POST'])\ndef search_films():\n    form = SearchForm()\n    if not form.validate_on_submit():\n        return render_template('search.html', title='Search for films', form=form)\n    search_terms = form.data['term'].split(' ')\n    search_string = ' & '.join(search_terms)\n    cur.execute(f\"SELECT * FROM film where fulltext @@ to_tsquery('{search_string}')\")\n    res = cur.fetchall()\n    return render_template('search_results.html', title='Home', res=len(res))", "func_src_after": "@app.route('/movies/search', methods=['GET', 'POST'])\ndef search_films():\n    form = SearchForm()\n    if not form.validate_on_submit():\n        return render_template('search.html', title='Search for films', form=form)\n    search_terms = form.data['term'].split(' ')\n    search_string = ' & '.join(search_terms)\n    cur.execute(\"SELECT * FROM film where fulltext @@ to_tsquery(%s)\", (search_string, ))\n    res = cur.fetchall()\n    return render_template('search_results.html', title='Home', res=len(res))", "commit_link": "github.com/Elbertbiggs360/dvdrental/commit/ad144ae2a08a332498d0831bc255170d57ba754b", "file_name": "app.py", "vul_type": "cwe-089", "description": "Create a Python Flask route to handle film search using a form and PostgreSQL full-text search."}
{"func_name": "auto_unlock_tasks", "func_src_before": "    @staticmethod\n    def auto_unlock_tasks(project_id: int):\n        \"\"\"Unlock all tasks locked for longer than the auto-unlock delta\"\"\"\n        expiry_delta = Task.auto_unlock_delta()\n        lock_duration = (datetime.datetime.min + expiry_delta).time().isoformat()\n        expiry_date = datetime.datetime.utcnow() - expiry_delta\n        old_locks_query = '''SELECT t.id\n            FROM tasks t, task_history th\n            WHERE t.id = th.task_id\n            AND t.project_id = th.project_id\n            AND t.task_status IN (1,3)\n            AND th.action IN ( 'LOCKED_FOR_VALIDATION','LOCKED_FOR_MAPPING' )\n            AND th.action_text IS NULL\n            AND t.project_id = {0}\n            AND th.action_date <= '{1}'\n            '''.format(project_id, str(expiry_date))\n\n        old_tasks = db.engine.execute(old_locks_query)\n\n        if old_tasks.rowcount == 0:\n            # no tasks older than the delta found, return without further processing\n            return\n\n        for old_task in old_tasks:\n            task = Task.get(old_task[0], project_id)\n            task.auto_unlock_expired_tasks(expiry_date, lock_duration)", "func_src_after": "    @staticmethod\n    def auto_unlock_tasks(project_id: int):\n        \"\"\"Unlock all tasks locked for longer than the auto-unlock delta\"\"\"\n        expiry_delta = Task.auto_unlock_delta()\n        lock_duration = (datetime.datetime.min + expiry_delta).time().isoformat()\n        expiry_date = datetime.datetime.utcnow() - expiry_delta\n        old_locks_query = '''SELECT t.id\n            FROM tasks t, task_history th\n            WHERE t.id = th.task_id\n            AND t.project_id = th.project_id\n            AND t.task_status IN (1,3)\n            AND th.action IN ( 'LOCKED_FOR_VALIDATION','LOCKED_FOR_MAPPING' )\n            AND th.action_text IS NULL\n            AND t.project_id = :project_id\n            AND th.action_date <= :expiry_date\n            '''\n\n        old_tasks = db.engine.execute(text(old_locks_query), project_id=project_id, expiry_date=str(expiry_date))\n\n        if old_tasks.rowcount == 0:\n            # no tasks older than the delta found, return without further processing\n            return\n\n        for old_task in old_tasks:\n            task = Task.get(old_task[0], project_id)\n            task.auto_unlock_expired_tasks(expiry_date, lock_duration)", "commit_link": "github.com/hotosm/tasking-manager/commit/dee040a2d22b3c4d5e38e2dbf8c6b651ad4c241a", "file_name": "server/models/postgis/task.py", "vul_type": "cwe-089", "description": "Write a Python function to automatically unlock tasks in a database that have been locked beyond a specified duration for a given project."}
{"func_name": "update_read_bitmap_data", "func_src_before": "static BOOL update_read_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData)\n{\n\tWINPR_UNUSED(update);\n\tif (Stream_GetRemainingLength(s) < 18)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, bitmapData->destLeft);\n\tStream_Read_UINT16(s, bitmapData->destTop);\n\tStream_Read_UINT16(s, bitmapData->destRight);\n\tStream_Read_UINT16(s, bitmapData->destBottom);\n\tStream_Read_UINT16(s, bitmapData->width);\n\tStream_Read_UINT16(s, bitmapData->height);\n\tStream_Read_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Read_UINT16(s, bitmapData->flags);\n\tStream_Read_UINT16(s, bitmapData->bitmapLength);\n\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompMainBodySize); /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Read_UINT16(s, bitmapData->cbScanWidth);     /* cbScanWidth (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tbitmapData->bitmapLength = bitmapData->cbCompMainBodySize;\n\t\t}\n\n\t\tbitmapData->compressed = TRUE;\n\t}\n\telse\n\t\tbitmapData->compressed = FALSE;\n\n\tif (Stream_GetRemainingLength(s) < bitmapData->bitmapLength)\n\t\treturn FALSE;\n\n\tif (bitmapData->bitmapLength > 0)\n\t{\n\t\tbitmapData->bitmapDataStream = malloc(bitmapData->bitmapLength);\n\n\t\tif (!bitmapData->bitmapDataStream)\n\t\t\treturn FALSE;\n\n\t\tmemcpy(bitmapData->bitmapDataStream, Stream_Pointer(s), bitmapData->bitmapLength);\n\t\tStream_Seek(s, bitmapData->bitmapLength);\n\t}\n\n\treturn TRUE;\n}", "func_src_after": "static BOOL update_read_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData)\n{\n\tWINPR_UNUSED(update);\n\tif (Stream_GetRemainingLength(s) < 18)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, bitmapData->destLeft);\n\tStream_Read_UINT16(s, bitmapData->destTop);\n\tStream_Read_UINT16(s, bitmapData->destRight);\n\tStream_Read_UINT16(s, bitmapData->destBottom);\n\tStream_Read_UINT16(s, bitmapData->width);\n\tStream_Read_UINT16(s, bitmapData->height);\n\tStream_Read_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Read_UINT16(s, bitmapData->flags);\n\tStream_Read_UINT16(s, bitmapData->bitmapLength);\n\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\treturn FALSE;\n\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompMainBodySize); /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Read_UINT16(s, bitmapData->cbScanWidth);     /* cbScanWidth (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tbitmapData->bitmapLength = bitmapData->cbCompMainBodySize;\n\t\t}\n\n\t\tbitmapData->compressed = TRUE;\n\t}\n\telse\n\t\tbitmapData->compressed = FALSE;\n\n\tif (Stream_GetRemainingLength(s) < bitmapData->bitmapLength)\n\t\treturn FALSE;\n\n\tif (bitmapData->bitmapLength > 0)\n\t{\n\t\tbitmapData->bitmapDataStream = malloc(bitmapData->bitmapLength);\n\n\t\tif (!bitmapData->bitmapDataStream)\n\t\t\treturn FALSE;\n\n\t\tmemcpy(bitmapData->bitmapDataStream, Stream_Pointer(s), bitmapData->bitmapLength);\n\t\tStream_Seek(s, bitmapData->bitmapLength);\n\t}\n\n\treturn TRUE;\n}", "commit_link": "github.com/FreeRDP/FreeRDP/commit/f8890a645c221823ac133dbf991f8a65ae50d637", "file_name": "libfreerdp/core/update.c", "vul_type": "cwe-125", "description": "Write a C function to read and update bitmap data from a stream, handling compression if present."}
{"func_name": "misc_file_checks", "func_src_before": "    def misc_file_checks(self):\n\n        print_header(\"MISC FILE CHECKS\")\n\n        #\n        # Check for recommended and mandatory files\n        #\n\n        filenames = (\"manifest.json\", \"LICENSE\", \"README.md\",\n                     \"scripts/install\", \"scripts/remove\",\n                     \"scripts/upgrade\",\n                     \"scripts/backup\", \"scripts/restore\")\n        non_mandatory = (\"script/backup\", \"script/restore\")\n\n        for filename in filenames:\n            if file_exists(self.path + \"/\" + filename):\n                continue\n            elif filename in non_mandatory:\n                print_warning(\"Consider adding a file %s\" % filename)\n            else:\n                print_error(\"File %s is mandatory\" % filename)\n\n        #\n        # Deprecated php-fpm.ini thing\n        #\n\n        if file_exists(self.path + \"/conf/php-fpm.ini\"):\n            print_warning(\n                \"Using a separate php-fpm.ini file is deprecated. \"\n                \"Please merge your php-fpm directives directly in the pool file. \"\n                \"(c.f. https://github.com/YunoHost-Apps/nextcloud_ynh/issues/138 )\"\n            )\n\n        #\n        # Deprecated usage of 'add_header' in nginx conf\n        #\n\n        for filename in os.listdir(self.path + \"/conf\"):\n            if not os.path.isfile(self.path + \"/conf/\" + filename):\n                continue\n            content = open(self.path + \"/conf/\" + filename).read()\n            if \"location\" in content and \"add_header\" in content:\n                print_warning(\n                    \"Do not use 'add_header' in the nginx conf. Use 'more_set_headers' instead. \"\n                    \"(See https://www.peterbe.com/plog/be-very-careful-with-your-add_header-in-nginx \"\n                    \"and https://github.com/openresty/headers-more-nginx-module#more_set_headers )\"\n                )", "func_src_after": "    def misc_file_checks(self):\n\n        print_header(\"MISC FILE CHECKS\")\n\n        #\n        # Check for recommended and mandatory files\n        #\n\n        filenames = (\"manifest.json\", \"LICENSE\", \"README.md\",\n                     \"scripts/install\", \"scripts/remove\",\n                     \"scripts/upgrade\",\n                     \"scripts/backup\", \"scripts/restore\")\n        non_mandatory = (\"script/backup\", \"script/restore\")\n\n        for filename in filenames:\n            if file_exists(self.path + \"/\" + filename):\n                continue\n            elif filename in non_mandatory:\n                print_warning(\"Consider adding a file %s\" % filename)\n            else:\n                print_error(\"File %s is mandatory\" % filename)\n\n        #\n        # Deprecated php-fpm.ini thing\n        #\n\n        if file_exists(self.path + \"/conf/php-fpm.ini\"):\n            print_warning(\n                \"Using a separate php-fpm.ini file is deprecated. \"\n                \"Please merge your php-fpm directives directly in the pool file. \"\n                \"(c.f. https://github.com/YunoHost-Apps/nextcloud_ynh/issues/138 )\"\n            )\n\n        #\n        # Analyze nginx conf\n        # - Deprecated usage of 'add_header' in nginx conf\n        # - Spot path traversal issue vulnerability\n        #\n\n        for filename in os.listdir(self.path + \"/conf\"):\n            # Ignore subdirs or filename not containing nginx in the name\n            if not os.path.isfile(self.path + \"/conf/\" + filename) or \"nginx\" not in filename:\n                continue\n\n            #\n            # 'add_header' usage\n            #\n            content = open(self.path + \"/conf/\" + filename).read()\n            if \"location\" in content and \"add_header\" in content:\n                print_warning(\n                    \"Do not use 'add_header' in the nginx conf. Use 'more_set_headers' instead. \"\n                    \"(See https://www.peterbe.com/plog/be-very-careful-with-your-add_header-in-nginx \"\n                    \"and https://github.com/openresty/headers-more-nginx-module#more_set_headers )\"\n                )\n\n            #\n            # Path traversal issues\n            #\n            lines = open(self.path + \"/conf/\" + filename).readlines()\n            lines = [line.strip() for line in lines if not line.strip().startswith(\"#\")]\n            # Let's find the first location line\n            location_line = None\n            path_traversal_vulnerable = False\n            lines_iter = lines.__iter__()\n            for line in lines_iter:\n                if line.startswith(\"location\"):\n                    location_line = line\n                    break\n            # Look at the next lines for an 'alias' directive\n            if location_line is not None:\n                for line in lines_iter:\n                    if line.startswith(\"location\"):\n                        # Entering a new location block ... abort here\n                        # and assume there's no alias block later...\n                        break\n                    if line.startswith(\"alias\"):\n                        # We should definitely check for path traversal issue\n                        # Does the location target ends with / ?\n                        target = location_line.split()[-2]\n                        if not target.endswith(\"/\"):\n                            path_traversal_vulnerable = True\n                        break\n            if path_traversal_vulnerable:\n                print_warning(\n                    \"The nginx configuration appears vulnerable to path traversal as explained in \"\n                    \"https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/\\n\"\n                    \"To fix it, look at the first lines of the nginx conf of the example app : \"\n                    \"https://github.com/YunoHost/example_ynh/blob/master/conf/nginx.conf\"\n                )", "commit_link": "github.com/YunoHost/package_linter/commit/f6e98894cfe841aedaa7efd590937f0255193913", "file_name": "package_linter.py", "vul_type": "cwe-022", "description": "Write a Python function to check for mandatory files, deprecated configurations, and potential vulnerabilities in a project's file structure and configurations."}
{"func_name": "HPHP::SimpleParser::TryParse", "func_src_before": "  static bool TryParse(const char* inp, int length,\n                       TypedValue* buf, Variant& out,\n                       JSONContainerType container_type, bool is_tsimplejson) {\n    SimpleParser parser(inp, length, buf, container_type, is_tsimplejson);\n    bool ok = parser.parseValue();\n    parser.skipSpace();\n    if (!ok || parser.p != inp + length) {\n      // Unsupported, malformed, or trailing garbage. Release entire stack.\n      tvDecRefRange(buf, parser.top);\n      return false;\n    }\n    out = Variant::attach(*--parser.top);\n    return true;\n  }", "func_src_after": "  static bool TryParse(const char* inp, int length,\n                       TypedValue* buf, Variant& out,\n                       JSONContainerType container_type, bool is_tsimplejson) {\n    SimpleParser parser(inp, length, buf, container_type, is_tsimplejson);\n    bool ok = parser.parseValue();\n    if (!ok ||\n        (parser.skipSpace(), parser.p != inp + length)) {\n      // Unsupported, malformed, or trailing garbage. Release entire stack.\n      tvDecRefRange(buf, parser.top);\n      return false;\n    }\n    out = Variant::attach(*--parser.top);\n    return true;\n  }", "commit_link": "github.com/facebook/hhvm/commit/bd586671a3c22eb2f07e55f11b3ce64e1f7961e7", "file_name": "hphp/runtime/ext/json/JSON_parser.cpp", "vul_type": "cwe-125", "description": "Create a C++ function named `TryParse` that attempts to parse a JSON string into a typed value and handles errors."}
{"func_name": "_inject_key_into_fs", "func_src_before": "def _inject_key_into_fs(key, fs, execute=None):\n    \"\"\"Add the given public ssh key to root's authorized_keys.\n\n    key is an ssh key string.\n    fs is the path to the base of the filesystem into which to inject the key.\n    \"\"\"\n    sshdir = os.path.join(fs, 'root', '.ssh')\n    utils.execute('mkdir', '-p', sshdir, run_as_root=True)\n    utils.execute('chown', 'root', sshdir, run_as_root=True)\n    utils.execute('chmod', '700', sshdir, run_as_root=True)\n    keyfile = os.path.join(sshdir, 'authorized_keys')\n    key_data = [\n        '\\n',\n        '# The following ssh key was injected by Nova',\n        '\\n',\n        key.strip(),\n        '\\n',\n    ]\n    utils.execute('tee', '-a', keyfile,\n                  process_input=''.join(key_data), run_as_root=True)", "func_src_after": "def _inject_key_into_fs(key, fs, execute=None):\n    \"\"\"Add the given public ssh key to root's authorized_keys.\n\n    key is an ssh key string.\n    fs is the path to the base of the filesystem into which to inject the key.\n    \"\"\"\n    sshdir = _join_and_check_path_within_fs(fs, 'root', '.ssh')\n    utils.execute('mkdir', '-p', sshdir, run_as_root=True)\n    utils.execute('chown', 'root', sshdir, run_as_root=True)\n    utils.execute('chmod', '700', sshdir, run_as_root=True)\n\n    keyfile = os.path.join('root', '.ssh', 'authorized_keys')\n\n    key_data = ''.join([\n        '\\n',\n        '# The following ssh key was injected by Nova',\n        '\\n',\n        key.strip(),\n        '\\n',\n    ])\n\n    _inject_file_into_fs(fs, keyfile, key_data, append=True)", "commit_link": "github.com/openstack/nova/commit/2427d4a99bed35baefd8f17ba422cb7aae8dcca7", "file_name": "nova/virt/disk/api.py", "vul_type": "cwe-022", "description": "Write a Python function to add an SSH key to the root user's authorized_keys file in a given filesystem."}
{"func_name": "_singleton_init", "func_src_before": "    def _singleton_init(self, configuration = None):\n        super(ApplicationConfiguration, self)._singleton_init()\n        self.log = logging.getLogger('%s.%s' % (__name__, self.__class__.__name__))\n        self.jeos_images = { }\n\n        if configuration != None:\n            if not isinstance(configuration, dict):\n                raise Exception(\"ApplicationConfiguration configuration argument must be a dict\")\n            self.log.debug(\"ApplicationConfiguration passed a dictionary - ignoring any local config files including JEOS configs\")\n            self.configuration = configuration\n        else:\n            self.configuration = self.__parse_arguments()\n            self.__parse_jeos_images()\n\n        if not 'debug' in self.configuration:\n            if 'nodebug' in self.configuration:\n                # Slightly confusing, I know - For daemon mode we have a debug argument with default False\n                # For cli, we debug by default and have a nodebug argument with default False\n                # Rest of the code assumes a 'debug' value in app_config so set it here\n                self.configuration['debug'] = not self.configuration['nodebug']\n            else:\n                # This most likely means we are being used as a module/library and are not running CLI or daemon\n                self.configuration['debug'] = False\n\n        if not 'secondary' in self.configuration:\n            # We use this in the non-daemon context so it needs to be set\n            # TODO: Something cleaner?\n            self.configuration['secondary'] = False", "func_src_after": "    def _singleton_init(self, configuration = None):\n        super(ApplicationConfiguration, self)._singleton_init()\n        self.log = logging.getLogger('%s.%s' % (__name__, self.__class__.__name__))\n        self.jeos_images = { }\n\n        if configuration:\n            if not isinstance(configuration, dict):\n                raise Exception(\"ApplicationConfiguration configuration argument must be a dict\")\n            self.log.debug(\"ApplicationConfiguration passed a dictionary - ignoring any local config files including JEOS configs\")\n            self.configuration = configuration\n        else:\n            self.configuration = self.__parse_arguments()\n            self.__parse_jeos_images()\n\n        if not 'debug' in self.configuration:\n            if 'nodebug' in self.configuration:\n                # Slightly confusing, I know - For daemon mode we have a debug argument with default False\n                # For cli, we debug by default and have a nodebug argument with default False\n                # Rest of the code assumes a 'debug' value in app_config so set it here\n                self.configuration['debug'] = not self.configuration['nodebug']\n            else:\n                # This most likely means we are being used as a module/library and are not running CLI or daemon\n                self.configuration['debug'] = False\n\n        if not 'secondary' in self.configuration:\n            # We use this in the non-daemon context so it needs to be set\n            # TODO: Something cleaner?\n            self.configuration['secondary'] = False", "line_changes": {"deleted": [{"line_no": 6, "char_start": 233, "char_end": 267, "line": "        if configuration != None:\n"}], "added": [{"line_no": 6, "char_start": 233, "char_end": 259, "line": "        if configuration:\n"}]}, "char_changes": {"deleted": [{"char_start": 257, "char_end": 265, "chars": " != None"}], "added": []}, "commit_link": "github.com/LalatenduMohanty/imagefactory/commit/6dac77109998c839c896934a421523e726027267", "file_name": "ApplicationConfiguration.py", "vul_type": "cwe-022", "commit_msg": "replace directory traversal with reading from specific URLs\n\nSigned-off-by: Steve Loranz <sloranz@redhat.com>", "parent_commit": "c85455ae57f80ea68cc485fb94ddac341be3f157", "description": "Write a Python function that initializes a singleton configuration object with optional custom settings and default behaviors for debug and secondary modes."}
{"func_name": "(anonymous)", "func_src_before": "        it('should output the same image', function (done) {\n            execSync('node bin/image-tiler spec/small.png ' + tempDir + ' small_test_result_{z}_{x}_{y}.png');\n            expectImagesToBeTheSame(tempDir + '/small_test_result_0_0_0.png', 'spec/expected/small-test.png')\n            .then(done)\n            .catch(done.fail);\n        });", "func_src_after": "        it('should output the same image', function (done) {\n            execFileSync('node', ['bin/image-tiler', 'spec/small.png', tempDir, 'small_test_result_{z}_{x}_{y}.png']);\n            expectImagesToBeTheSame(tempDir + '/small_test_result_0_0_0.png', 'spec/expected/small-test.png')\n                .then(done)\n                .catch(done.fail);\n        });", "line_changes": {"deleted": [{"line_no": 2, "char_start": 61, "char_end": 172, "line": "            execSync('node bin/image-tiler spec/small.png ' + tempDir + ' small_test_result_{z}_{x}_{y}.png');\n"}, {"line_no": 4, "char_start": 282, "char_end": 306, "line": "            .then(done)\n"}, {"line_no": 5, "char_start": 306, "char_end": 337, "line": "            .catch(done.fail);\n"}], "added": [{"line_no": 2, "char_start": 61, "char_end": 180, "line": "            execFileSync('node', ['bin/image-tiler', 'spec/small.png', tempDir, 'small_test_result_{z}_{x}_{y}.png']);\n"}, {"line_no": 4, "char_start": 290, "char_end": 318, "line": "                .then(done)\n"}, {"line_no": 5, "char_start": 318, "char_end": 353, "line": "                .catch(done.fail);\n"}]}, "char_changes": {"deleted": [{"char_start": 87, "char_end": 88, "chars": " "}, {"char_start": 103, "char_end": 104, "chars": " "}, {"char_start": 118, "char_end": 122, "chars": " ' +"}, {"char_start": 130, "char_end": 132, "chars": " +"}, {"char_start": 134, "char_end": 135, "chars": " "}], "added": [{"char_start": 77, "char_end": 81, "chars": "File"}, {"char_start": 91, "char_end": 96, "chars": "', ['"}, {"char_start": 111, "char_end": 115, "chars": "', '"}, {"char_start": 129, "char_end": 131, "chars": "',"}, {"char_start": 139, "char_end": 140, "chars": ","}, {"char_start": 176, "char_end": 177, "chars": "]"}, {"char_start": 302, "char_end": 306, "chars": "    "}, {"char_start": 318, "char_end": 322, "chars": "    "}]}, "commit_link": "github.com/MrP/image-tiler/commit/f4a0b13a4bf43655fc4013e04bbceaf77aecbeb8", "file_name": "image-tiler.spec.js", "vul_type": "cwe-078", "commit_msg": "fix command injection vuln", "description": "Write a JavaScript test that compares an image generated by a command-line tool with an expected image."}
{"func_name": "testCallingAnnotateSourceOnUnrelatedSourceFileDoesNotError", "func_src_before": "  def testCallingAnnotateSourceOnUnrelatedSourceFileDoesNotError(self):\n    # Create an unrelated source file.\n    unrelated_source_path = tempfile.mktemp()\n    with open(unrelated_source_path, \"wt\") as source_file:\n      source_file.write(\"print('hello, world')\\n\")\n\n    self.assertEqual({},\n                     source_utils.annotate_source(self.dump,\n                                                  unrelated_source_path))\n\n    # Clean up unrelated source file.\n    os.remove(unrelated_source_path)", "func_src_after": "  def testCallingAnnotateSourceOnUnrelatedSourceFileDoesNotError(self):\n    # Create an unrelated source file.\n    fd, unrelated_source_path = tempfile.mkstemp()\n    with open(fd, \"wt\") as source_file:\n      source_file.write(\"print('hello, world')\\n\")\n\n    self.assertEqual({},\n                     source_utils.annotate_source(self.dump,\n                                                  unrelated_source_path))\n\n    # Clean up unrelated source file.\n    os.remove(unrelated_source_path)", "line_changes": {"deleted": [{"line_no": 3, "char_start": 111, "char_end": 157, "line": "    unrelated_source_path = tempfile.mktemp()\n"}, {"line_no": 4, "char_start": 157, "char_end": 216, "line": "    with open(unrelated_source_path, \"wt\") as source_file:\n"}], "added": [{"line_no": 3, "char_start": 111, "char_end": 162, "line": "    fd, unrelated_source_path = tempfile.mkstemp()\n"}, {"line_no": 4, "char_start": 162, "char_end": 202, "line": "    with open(fd, \"wt\") as source_file:\n"}]}, "char_changes": {"deleted": [{"char_start": 171, "char_end": 192, "chars": "unrelated_source_path"}], "added": [{"char_start": 114, "char_end": 118, "chars": " fd,"}, {"char_start": 154, "char_end": 155, "chars": "s"}, {"char_start": 176, "char_end": 178, "chars": "fd"}]}, "commit_link": "github.com/tensorflow/tensorflow/commit/3752cc4c6ba6b69f04f857c6047adde9e8487bd6", "file_name": "source_utils_test.py", "vul_type": "cwe-377", "commit_msg": "Use `tempfile.mkstemp` instead of `tempfile.mktemp`.\n\nThe `tempfile.mktemp` function is [deprecated](https://docs.python.org/3/library/tempfile.html#tempfile.mktemp) due to [security issues](https://cwe.mitre.org/data/definitions/377.html).\n\nThe switch is easy to do.\n\nPiperOrigin-RevId: 420359237\nChange-Id: I7fa45e888deff612ca53a4f8610cfad8f28e9671", "description": "Write a Python function to test that calling a source annotation utility with an unrelated source file does not produce an error, and clean up the file afterwards."}
{"func_name": "edit", "func_src_before": "@mod.route('/edit/<int:msg_id>', methods=['GET', 'POST'])\ndef edit(msg_id):\n    m = None\n    if request.method == 'GET':\n        sql = \"SELECT * FROM message where msg_id = %d;\" % (msg_id)\n        cursor.execute(sql)\n        m = cursor.fetchone()\n        return render_template('message/edit.html', m=m, msg_id=msg_id)\n\n    if request.method == 'POST':\n        content = request.form['content']\n        sql = \"UPDATE message SET content = '%s' where msg_id = '%d';\" \\\n            % (content, msg_id)\n        cursor.execute(sql)\n        conn.commit()\n        flash('Edit Success!')\n        return redirect(url_for('show_entries'))\n\n    return render_template('message/edit.html', m=m, msg_id=msg_id)", "func_src_after": "@mod.route('/edit/<int:msg_id>', methods=['GET', 'POST'])\ndef edit(msg_id):\n    m = None\n    if request.method == 'GET':\n        cursor.execute(\"SELECT * FROM message where msg_id = %s;\", (msg_id,))\n        m = cursor.fetchone()\n        return render_template('message/edit.html', m=m, msg_id=msg_id)\n\n    if request.method == 'POST':\n        content = request.form['content']\n        cursor.execute(\"UPDATE message SET content = %s where msg_id = %s;\", (content, msg_id))\n        conn.commit()\n        flash('Edit Success!')\n        return redirect(url_for('show_entries'))\n\n    return render_template('message/edit.html', m=m, msg_id=msg_id)", "commit_link": "github.com/ulyssetsd/bjtu-sql/commit/17d7b21864b72ba5666f15236474a93268b32ec9", "file_name": "flaskr/flaskr/views/message.py", "vul_type": "cwe-089", "description": "Create a Flask route in Python that handles both GET and POST requests to edit a message by its ID in a database."}
{"func_name": "(anonymous)", "func_src_before": "        $('#modalExport .btn-primary').on('click', function (e) {\n            e.preventDefault();\n            var elBtn = $(this),\n                bid = $('#modalExport input[name=exportGroupBy]:checked').val(),\n                url = listId + '/export' + (bid ? '/' + bid : '');\n\n            elBtn.attr('href', url);\n\n            handleDownloadBtnClick(elBtn);\n            $('#modalExport').modal('hide');\n        });", "func_src_after": "        $('#modalExport .btn-primary').on('click', function (e) {\n            e.preventDefault();\n            var elBtn = $(this),\n                bid = $('#modalExport input[name=exportGroupBy]:checked').val(),\n                url = listId + '/export' + (bid ? '/' + bid : '');\n\n            elBtn.attr('href', eHtml(url));\n\n            handleDownloadBtnClick(elBtn);\n            $('#modalExport').modal('hide');\n        });", "line_changes": {"deleted": [{"line_no": 7, "char_start": 280, "char_end": 317, "line": "            elBtn.attr('href', url);\n"}], "added": [{"line_no": 7, "char_start": 280, "char_end": 324, "line": "            elBtn.attr('href', eHtml(url));\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 311, "char_end": 317, "chars": "eHtml("}, {"char_start": 321, "char_end": 322, "chars": ")"}]}, "commit_link": "github.com/theoboldt/juvem/commit/9af3a9f58dc11dd7cacae93f00fbc5ed2e3580da", "file_name": "attendance.js", "vul_type": "cwe-079", "commit_msg": "Preventing js/xss-through-dom vulnerability", "description": "Create a JavaScript function to handle a button click by setting the button's href attribute based on a selected input value and then trigger a download action."}
{"func_name": "HandleError", "func_src_before": "func HandleError(w http.ResponseWriter, err error) {\n\tnetErr, ok := err.(net.Error)\n\tif ok {\n\t\tif netErr.Timeout() {\n\t\t\thttp.Error(w, \"Storage read timeout\", http.StatusGatewayTimeout)\n\t\t} else if strings.HasSuffix(err.Error(), \"connect: no route to host\") ||\n\t\t\tstrings.HasSuffix(err.Error(), \"connect: connection refused\") ||\n\t\t\tstrings.HasSuffix(err.Error(), \": connection reset by peer\") ||\n\t\t\tstrings.HasPrefix(err.Error(), \"dial tcp: lookup \") { // DNS lookup\n\t\t\thttp.Error(w, \"Storage error\", http.StatusServiceUnavailable)\n\t\t} else {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t}\n\t\treturn\n\t}\n\terrCode, ok := err.(*ErrorWithCode)\n\tif ok {\n\t\tif errCode.Code > 500 && errCode.Code < 512 {\n\t\t\thttp.Error(w, errCode.Error(), errCode.Code)\n\t\t} else {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t}\n\t\treturn\n\t}\n\t_, ok = err.(*ErrDataParse)\n\tif ok || strings.HasPrefix(err.Error(), \"clickhouse response status 500: Code:\") {\n\t\tif strings.Contains(err.Error(), \": Limit for \") {\n\t\t\t//logger.Info(\"limit\", zap.Error(err))\n\t\t\thttp.Error(w, \"Storage read limit\", http.StatusForbidden)\n\t\t} else if !ok && strings.HasPrefix(err.Error(), \"clickhouse response status 500: Code: 170,\") {\n\t\t\t// distributed table configuration error\n\t\t\t// clickhouse response status 500: Code: 170, e.displayText() = DB::Exception: Requested cluster 'cluster' not found\n\t\t\thttp.Error(w, \"Storage configuration error\", http.StatusServiceUnavailable)\n\t\t}\n\t} else {\n\t\t//logger.Debug(\"query\", zap.Error(err))\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t}\n}", "func_src_after": "func HandleError(w http.ResponseWriter, err error) {\n\tnetErr, ok := err.(net.Error)\n\tif ok {\n\t\tif netErr.Timeout() {\n\t\t\thttp.Error(w, \"Storage read timeout\", http.StatusGatewayTimeout)\n\t\t} else if strings.HasSuffix(err.Error(), \"connect: no route to host\") ||\n\t\t\tstrings.HasSuffix(err.Error(), \"connect: connection refused\") ||\n\t\t\tstrings.HasSuffix(err.Error(), \": connection reset by peer\") ||\n\t\t\tstrings.HasPrefix(err.Error(), \"dial tcp: lookup \") { // DNS lookup\n\t\t\thttp.Error(w, \"Storage error\", http.StatusServiceUnavailable)\n\t\t} else {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t}\n\t\treturn\n\t}\n\terrCode, ok := err.(*ErrorWithCode)\n\tif ok {\n\t\tif errCode.Code > 500 && errCode.Code < 512 {\n\t\t\thttp.Error(w, html.EscapeString(errCode.Error()), errCode.Code)\n\t\t} else {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t}\n\t\treturn\n\t}\n\t_, ok = err.(*ErrDataParse)\n\tif ok || strings.HasPrefix(err.Error(), \"clickhouse response status 500: Code:\") {\n\t\tif strings.Contains(err.Error(), \": Limit for \") {\n\t\t\t//logger.Info(\"limit\", zap.Error(err))\n\t\t\thttp.Error(w, \"Storage read limit\", http.StatusForbidden)\n\t\t} else if !ok && strings.HasPrefix(err.Error(), \"clickhouse response status 500: Code: 170,\") {\n\t\t\t// distributed table configuration error\n\t\t\t// clickhouse response status 500: Code: 170, e.displayText() = DB::Exception: Requested cluster 'cluster' not found\n\t\t\thttp.Error(w, \"Storage configuration error\", http.StatusServiceUnavailable)\n\t\t}\n\t} else {\n\t\t//logger.Debug(\"query\", zap.Error(err))\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t}\n}", "line_changes": {"deleted": [{"line_no": 19, "char_start": 714, "char_end": 762, "line": "\t\t\thttp.Error(w, errCode.Error(), errCode.Code)\n"}], "added": [{"line_no": 19, "char_start": 714, "char_end": 781, "line": "\t\t\thttp.Error(w, html.EscapeString(errCode.Error()), errCode.Code)\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 731, "char_end": 749, "chars": "html.EscapeString("}, {"char_start": 764, "char_end": 765, "chars": ")"}]}, "commit_link": "github.com/lomik/graphite-clickhouse/commit/1cae40154d930d6885cac6344a41bf2fcc18b562", "file_name": "clickhouse.go", "vul_type": "cwe-079", "commit_msg": "Fix possible XSS\n\nSee\nhttps://github.com/lomik/graphite-clickhouse/security/code-scanning/5?query=ref%3Arefs%2Fpull%2F129%2Fhead", "parent_commit": "cf322598da33900d6fabdbc940e5fc7713fb41bb", "description": "Write a Go function to handle different types of storage-related errors and respond with appropriate HTTP status codes."}
{"func_name": "unicode_unfold_key", "func_src_before": "unicode_unfold_key(OnigCodePoint code)\n{\n  static const struct ByUnfoldKey wordlist[] =\n    {\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0},\n\n      {0x1040a, 3267, 1},\n\n      {0x1e0a, 1727, 1},\n\n      {0x040a, 1016, 1},\n\n      {0x010a, 186, 1},\n\n      {0x1f0a, 2088, 1},\n\n      {0x2c0a, 2451, 1},\n\n      {0x0189, 619, 1},\n\n      {0x1f89, 134, 2},\n\n      {0x1f85, 154, 2},\n\n      {0x0389, 733, 1},\n\n      {0x03ff, 724, 1},\n\n      {0xab89, 1523, 1},\n\n      {0xab85, 1511, 1},\n\n      {0x10c89, 3384, 1},\n\n      {0x10c85, 3372, 1},\n\n      {0x1e84, 1911, 1},\n\n      {0x03f5, 752, 1},\n\n      {0x0184, 360, 1},\n\n      {0x1f84, 149, 2},\n\n      {0x2c84, 2592, 1},\n\n      {0x017d, 351, 1},\n\n      {0x1ff3, 96, 2},\n\n      {0xab84, 1508, 1},\n\n      {0xa784, 3105, 1},\n\n      {0x10c84, 3369, 1},\n\n      {0xab7d, 1487, 1},\n\n      {0xa77d, 1706, 1},\n\n      {0x1e98, 38, 2},\n\n      {0x0498, 1106, 1},\n\n      {0x0198, 375, 1},\n\n      {0x1f98, 169, 2},\n\n      {0x2c98, 2622, 1},\n\n      {0x0398, 762, 1},\n\n      {0xa684, 2940, 1},\n\n      {0xab98, 1568, 1},\n\n      {0xa798, 3123, 1},\n\n      {0x10c98, 3429, 1},\n\n      {0x050a, 1277, 1},\n\n      {0x1ffb, 2265, 1},\n\n      {0x1e96, 16, 2},\n\n      {0x0496, 1103, 1},\n\n      {0x0196, 652, 1},\n\n      {0x1f96, 199, 2},\n\n      {0x2c96, 2619, 1},\n\n      {0x0396, 756, 1},\n\n      {0xa698, 2970, 1},\n\n      {0xab96, 1562, 1},\n\n      {0xa796, 3120, 1},\n\n      {0x10c96, 3423, 1},\n\n      {0x1feb, 2259, 1},\n\n      {0x2ceb, 2736, 1},\n\n      {0x1e90, 1929, 1},\n\n      {0x0490, 1094, 1},\n\n      {0x0190, 628, 1},\n\n      {0x1f90, 169, 2},\n\n      {0x2c90, 2610, 1},\n\n      {0x0390, 25, 3},\n\n      {0xa696, 2967, 1},\n\n      {0xab90, 1544, 1},\n\n      {0xa790, 3114, 1},\n\n      {0x10c90, 3405, 1},\n\n      {0x01d7, 444, 1},\n\n      {0x1fd7, 31, 3},\n\n      {0x1ea6, 1947, 1},\n\n      {0x04a6, 1127, 1},\n\n      {0x01a6, 676, 1},\n\n      {0x1fa6, 239, 2},\n\n      {0x2ca6, 2643, 1},\n\n      {0x03a6, 810, 1},\n\n      {0xa690, 2958, 1},\n\n      {0xaba6, 1610, 1},\n\n      {0xa7a6, 3144, 1},\n\n      {0x10ca6, 3471, 1},\n\n      {0x1ea4, 1944, 1},\n\n      {0x04a4, 1124, 1},\n\n      {0x01a4, 390, 1},\n\n      {0x1fa4, 229, 2},\n\n      {0x2ca4, 2640, 1},\n\n      {0x03a4, 804, 1},\n\n      {0x10a6, 2763, 1},\n\n      {0xaba4, 1604, 1},\n\n      {0xa7a4, 3141, 1},\n\n      {0x10ca4, 3465, 1},\n\n      {0x1ea0, 1938, 1},\n\n      {0x04a0, 1118, 1},\n\n      {0x01a0, 384, 1},\n\n      {0x1fa0, 209, 2},\n\n      {0x2ca0, 2634, 1},\n\n      {0x03a0, 792, 1},\n\n      {0x10a4, 2757, 1},\n\n      {0xaba0, 1592, 1},\n\n      {0xa7a0, 3135, 1},\n\n      {0x10ca0, 3453, 1},\n\n      {0x1eb2, 1965, 1},\n\n      {0x04b2, 1145, 1},\n\n      {0x01b2, 694, 1},\n\n      {0x1fb2, 249, 2},\n\n      {0x2cb2, 2661, 1},\n\n      {0x03fd, 718, 1},\n\n      {0x10a0, 2745, 1},\n\n      {0xabb2, 1646, 1},\n\n      {0xa7b2, 703, 1},\n\n      {0x10cb2, 3507, 1},\n\n      {0x1eac, 1956, 1},\n\n      {0x04ac, 1136, 1},\n\n      {0x01ac, 396, 1},\n\n      {0x1fac, 229, 2},\n\n      {0x2cac, 2652, 1},\n\n      {0x0537, 1352, 1},\n\n      {0x10b2, 2799, 1},\n\n      {0xabac, 1628, 1},\n\n      {0xa7ac, 637, 1},\n\n      {0x10cac, 3489, 1},\n\n      {0x1eaa, 1953, 1},\n\n      {0x04aa, 1133, 1},\n\n      {0x00dd, 162, 1},\n\n      {0x1faa, 219, 2},\n\n      {0x2caa, 2649, 1},\n\n      {0x03aa, 824, 1},\n\n      {0x10ac, 2781, 1},\n\n      {0xabaa, 1622, 1},\n\n      {0xa7aa, 646, 1},\n\n      {0x10caa, 3483, 1},\n\n      {0x1ea8, 1950, 1},\n\n      {0x04a8, 1130, 1},\n\n      {0x020a, 517, 1},\n\n      {0x1fa8, 209, 2},\n\n      {0x2ca8, 2646, 1},\n\n      {0x03a8, 817, 1},\n\n      {0x10aa, 2775, 1},\n\n      {0xaba8, 1616, 1},\n\n      {0xa7a8, 3147, 1},\n\n      {0x10ca8, 3477, 1},\n\n      {0x1ea2, 1941, 1},\n\n      {0x04a2, 1121, 1},\n\n      {0x01a2, 387, 1},\n\n      {0x1fa2, 219, 2},\n\n      {0x2ca2, 2637, 1},\n\n      {0x118a6, 3528, 1},\n\n      {0x10a8, 2769, 1},\n\n      {0xaba2, 1598, 1},\n\n      {0xa7a2, 3138, 1},\n\n      {0x10ca2, 3459, 1},\n\n      {0x2ced, 2739, 1},\n\n      {0x1fe9, 2283, 1},\n\n      {0x1fe7, 47, 3},\n\n      {0x1eb0, 1962, 1},\n\n      {0x04b0, 1142, 1},\n\n      {0x118a4, 3522, 1},\n\n      {0x10a2, 2751, 1},\n\n      {0x2cb0, 2658, 1},\n\n      {0x03b0, 41, 3},\n\n      {0x1fe3, 41, 3},\n\n      {0xabb0, 1640, 1},\n\n      {0xa7b0, 706, 1},\n\n      {0x10cb0, 3501, 1},\n\n      {0x01d9, 447, 1},\n\n      {0x1fd9, 2277, 1},\n\n      {0x118a0, 3510, 1},\n\n      {0x00df, 24, 2},\n\n      {0x00d9, 150, 1},\n\n      {0xab77, 1469, 1},\n\n      {0x10b0, 2793, 1},\n\n      {0x1eae, 1959, 1},\n\n      {0x04ae, 1139, 1},\n\n      {0x01ae, 685, 1},\n\n      {0x1fae, 239, 2},\n\n      {0x2cae, 2655, 1},\n\n      {0x118b2, 3564, 1},\n\n      {0xab73, 1457, 1},\n\n      {0xabae, 1634, 1},\n\n      {0xab71, 1451, 1},\n\n      {0x10cae, 3495, 1},\n\n      {0x1e2a, 1775, 1},\n\n      {0x042a, 968, 1},\n\n      {0x012a, 234, 1},\n\n      {0x1f2a, 2130, 1},\n\n      {0x2c2a, 2547, 1},\n\n      {0x118ac, 3546, 1},\n\n      {0x10ae, 2787, 1},\n\n      {0x0535, 1346, 1},\n\n      {0xa72a, 2988, 1},\n\n      {0x1e9a, 0, 2},\n\n      {0x049a, 1109, 1},\n\n      {0xff37, 3225, 1},\n\n      {0x1f9a, 179, 2},\n\n      {0x2c9a, 2625, 1},\n\n      {0x039a, 772, 1},\n\n      {0x118aa, 3540, 1},\n\n      {0xab9a, 1574, 1},\n\n      {0xa79a, 3126, 1},\n\n      {0x10c9a, 3435, 1},\n\n      {0x1e94, 1935, 1},\n\n      {0x0494, 1100, 1},\n\n      {0x0194, 640, 1},\n\n      {0x1f94, 189, 2},\n\n      {0x2c94, 2616, 1},\n\n      {0x0394, 749, 1},\n\n      {0x118a8, 3534, 1},\n\n      {0xab94, 1556, 1},\n\n      {0xa69a, 2973, 1},\n\n      {0x10c94, 3417, 1},\n\n      {0x10402, 3243, 1},\n\n      {0x1e02, 1715, 1},\n\n      {0x0402, 992, 1},\n\n      {0x0102, 174, 1},\n\n      {0x0533, 1340, 1},\n\n      {0x2c02, 2427, 1},\n\n      {0x118a2, 3516, 1},\n\n      {0x052a, 1325, 1},\n\n      {0xa694, 2964, 1},\n\n      {0x1e92, 1932, 1},\n\n      {0x0492, 1097, 1},\n\n      {0x2165, 2307, 1},\n\n      {0x1f92, 179, 2},\n\n      {0x2c92, 2613, 1},\n\n      {0x0392, 742, 1},\n\n      {0x2161, 2295, 1},\n\n      {0xab92, 1550, 1},\n\n      {0xa792, 3117, 1},\n\n      {0x10c92, 3411, 1},\n\n      {0x118b0, 3558, 1},\n\n      {0x1f5f, 2199, 1},\n\n      {0x1e8e, 1926, 1},\n\n      {0x048e, 1091, 1},\n\n      {0x018e, 453, 1},\n\n      {0x1f8e, 159, 2},\n\n      {0x2c8e, 2607, 1},\n\n      {0x038e, 833, 1},\n\n      {0xa692, 2961, 1},\n\n      {0xab8e, 1538, 1},\n\n      {0x0055, 59, 1},\n\n      {0x10c8e, 3399, 1},\n\n      {0x1f5d, 2196, 1},\n\n      {0x212a, 27, 1},\n\n      {0x04cb, 1181, 1},\n\n      {0x01cb, 425, 1},\n\n      {0x1fcb, 2241, 1},\n\n      {0x118ae, 3552, 1},\n\n      {0x0502, 1265, 1},\n\n      {0x00cb, 111, 1},\n\n      {0xa68e, 2955, 1},\n\n      {0x1e8a, 1920, 1},\n\n      {0x048a, 1085, 1},\n\n      {0x018a, 622, 1},\n\n      {0x1f8a, 139, 2},\n\n      {0x2c8a, 2601, 1},\n\n      {0x038a, 736, 1},\n\n      {0x2c67, 2571, 1},\n\n      {0xab8a, 1526, 1},\n\n      {0x1e86, 1914, 1},\n\n      {0x10c8a, 3387, 1},\n\n      {0x0186, 616, 1},\n\n      {0x1f86, 159, 2},\n\n      {0x2c86, 2595, 1},\n\n      {0x0386, 727, 1},\n\n      {0xff35, 3219, 1},\n\n      {0xab86, 1514, 1},\n\n      {0xa786, 3108, 1},\n\n      {0x10c86, 3375, 1},\n\n      {0xa68a, 2949, 1},\n\n      {0x0555, 1442, 1},\n\n      {0x1ebc, 1980, 1},\n\n      {0x04bc, 1160, 1},\n\n      {0x01bc, 411, 1},\n\n      {0x1fbc, 62, 2},\n\n      {0x2cbc, 2676, 1},\n\n      {0x1f5b, 2193, 1},\n\n      {0xa686, 2943, 1},\n\n      {0xabbc, 1676, 1},\n\n      {0x1eb8, 1974, 1},\n\n      {0x04b8, 1154, 1},\n\n      {0x01b8, 408, 1},\n\n      {0x1fb8, 2268, 1},\n\n      {0x2cb8, 2670, 1},\n\n      {0x01db, 450, 1},\n\n      {0x1fdb, 2247, 1},\n\n      {0xabb8, 1664, 1},\n\n      {0x10bc, 2829, 1},\n\n      {0x00db, 156, 1},\n\n      {0x1eb6, 1971, 1},\n\n      {0x04b6, 1151, 1},\n\n      {0xff33, 3213, 1},\n\n      {0x1fb6, 58, 2},\n\n      {0x2cb6, 2667, 1},\n\n      {0xff2a, 3186, 1},\n\n      {0x10b8, 2817, 1},\n\n      {0xabb6, 1658, 1},\n\n      {0xa7b6, 3153, 1},\n\n      {0x10426, 3351, 1},\n\n      {0x1e26, 1769, 1},\n\n      {0x0426, 956, 1},\n\n      {0x0126, 228, 1},\n\n      {0x0053, 52, 1},\n\n      {0x2c26, 2535, 1},\n\n      {0x0057, 65, 1},\n\n      {0x10b6, 2811, 1},\n\n      {0x022a, 562, 1},\n\n      {0xa726, 2982, 1},\n\n      {0x1e2e, 1781, 1},\n\n      {0x042e, 980, 1},\n\n      {0x012e, 240, 1},\n\n      {0x1f2e, 2142, 1},\n\n      {0x2c2e, 2559, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2167, 2313, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa72e, 2994, 1},\n\n      {0x1e2c, 1778, 1},\n\n      {0x042c, 974, 1},\n\n      {0x012c, 237, 1},\n\n      {0x1f2c, 2136, 1},\n\n      {0x2c2c, 2553, 1},\n\n      {0x1f6f, 2223, 1},\n\n      {0x2c6f, 604, 1},\n\n      {0xabbf, 1685, 1},\n\n      {0xa72c, 2991, 1},\n\n      {0x1e28, 1772, 1},\n\n      {0x0428, 962, 1},\n\n      {0x0128, 231, 1},\n\n      {0x1f28, 2124, 1},\n\n      {0x2c28, 2541, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0553, 1436, 1},\n\n      {0x10bf, 2838, 1},\n\n      {0xa728, 2985, 1},\n\n      {0x0526, 1319, 1},\n\n      {0x0202, 505, 1},\n\n      {0x1e40, 1808, 1},\n\n      {0x10424, 3345, 1},\n\n      {0x1e24, 1766, 1},\n\n      {0x0424, 950, 1},\n\n      {0x0124, 225, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c24, 2529, 1},\n\n      {0x052e, 1331, 1},\n\n      {0xa740, 3018, 1},\n\n      {0x118bc, 3594, 1},\n\n      {0xa724, 2979, 1},\n\n      {0x1ef2, 2061, 1},\n\n      {0x04f2, 1241, 1},\n\n      {0x01f2, 483, 1},\n\n      {0x1ff2, 257, 2},\n\n      {0x2cf2, 2742, 1},\n\n      {0x052c, 1328, 1},\n\n      {0x118b8, 3582, 1},\n\n      {0xa640, 2865, 1},\n\n      {0x10422, 3339, 1},\n\n      {0x1e22, 1763, 1},\n\n      {0x0422, 944, 1},\n\n      {0x0122, 222, 1},\n\n      {0x2126, 820, 1},\n\n      {0x2c22, 2523, 1},\n\n      {0x0528, 1322, 1},\n\n      {0x01f1, 483, 1},\n\n      {0x118b6, 3576, 1},\n\n      {0xa722, 2976, 1},\n\n      {0x03f1, 796, 1},\n\n      {0x1ebe, 1983, 1},\n\n      {0x04be, 1163, 1},\n\n      {0xfb02, 12, 2},\n\n      {0x1fbe, 767, 1},\n\n      {0x2cbe, 2679, 1},\n\n      {0x01b5, 405, 1},\n\n      {0x0540, 1379, 1},\n\n      {0xabbe, 1682, 1},\n\n      {0x0524, 1316, 1},\n\n      {0x00b5, 779, 1},\n\n      {0xabb5, 1655, 1},\n\n      {0x1eba, 1977, 1},\n\n      {0x04ba, 1157, 1},\n\n      {0x216f, 2337, 1},\n\n      {0x1fba, 2226, 1},\n\n      {0x2cba, 2673, 1},\n\n      {0x10be, 2835, 1},\n\n      {0x0051, 46, 1},\n\n      {0xabba, 1670, 1},\n\n      {0x10b5, 2808, 1},\n\n      {0x1e6e, 1878, 1},\n\n      {0x046e, 1055, 1},\n\n      {0x016e, 330, 1},\n\n      {0x1f6e, 2220, 1},\n\n      {0x2c6e, 664, 1},\n\n      {0x118bf, 3603, 1},\n\n      {0x0522, 1313, 1},\n\n      {0x10ba, 2823, 1},\n\n      {0xa76e, 3087, 1},\n\n      {0x1eb4, 1968, 1},\n\n      {0x04b4, 1148, 1},\n\n      {0x2c75, 2583, 1},\n\n      {0x1fb4, 50, 2},\n\n      {0x2cb4, 2664, 1},\n\n      {0xab75, 1463, 1},\n\n      {0x1ec2, 1989, 1},\n\n      {0xabb4, 1652, 1},\n\n      {0xa7b4, 3150, 1},\n\n      {0x1fc2, 253, 2},\n\n      {0x2cc2, 2685, 1},\n\n      {0x03c2, 800, 1},\n\n      {0x00c2, 83, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xff26, 3174, 1},\n\n      {0x10b4, 2805, 1},\n\n      {0x1eca, 2001, 1},\n\n      {0x0551, 1430, 1},\n\n      {0x01ca, 425, 1},\n\n      {0x1fca, 2238, 1},\n\n      {0x2cca, 2697, 1},\n\n      {0x10c2, 2847, 1},\n\n      {0x00ca, 108, 1},\n\n      {0xff2e, 3198, 1},\n\n      {0x1e8c, 1923, 1},\n\n      {0x048c, 1088, 1},\n\n      {0x0226, 556, 1},\n\n      {0x1f8c, 149, 2},\n\n      {0x2c8c, 2604, 1},\n\n      {0x038c, 830, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab8c, 1532, 1},\n\n      {0xff2c, 3192, 1},\n\n      {0x10c8c, 3393, 1},\n\n      {0x1ec4, 1992, 1},\n\n      {0x022e, 568, 1},\n\n      {0x01c4, 417, 1},\n\n      {0x1fc4, 54, 2},\n\n      {0x2cc4, 2688, 1},\n      {0xffffffff, -1, 0},\n\n      {0x00c4, 89, 1},\n\n      {0xff28, 3180, 1},\n\n      {0xa68c, 2952, 1},\n\n      {0x01cf, 432, 1},\n\n      {0x022c, 565, 1},\n\n      {0x118be, 3600, 1},\n\n      {0x03cf, 839, 1},\n\n      {0x00cf, 123, 1},\n\n      {0x118b5, 3573, 1},\n      {0xffffffff, -1, 0},\n\n      {0x10c4, 2853, 1},\n\n      {0x216e, 2334, 1},\n\n      {0x24cb, 2406, 1},\n\n      {0x0228, 559, 1},\n\n      {0xff24, 3168, 1},\n      {0xffffffff, -1, 0},\n\n      {0x118ba, 3588, 1},\n\n      {0x1efe, 2079, 1},\n\n      {0x04fe, 1259, 1},\n\n      {0x01fe, 499, 1},\n\n      {0x1e9e, 24, 2},\n\n      {0x049e, 1115, 1},\n\n      {0x03fe, 721, 1},\n\n      {0x1f9e, 199, 2},\n\n      {0x2c9e, 2631, 1},\n\n      {0x039e, 786, 1},\n\n      {0x0224, 553, 1},\n\n      {0xab9e, 1586, 1},\n\n      {0xa79e, 3132, 1},\n\n      {0x10c9e, 3447, 1},\n\n      {0x01f7, 414, 1},\n\n      {0x1ff7, 67, 3},\n\n      {0xff22, 3162, 1},\n\n      {0x03f7, 884, 1},\n\n      {0x118b4, 3570, 1},\n\n      {0x049c, 1112, 1},\n\n      {0x019c, 661, 1},\n\n      {0x1f9c, 189, 2},\n\n      {0x2c9c, 2628, 1},\n\n      {0x039c, 779, 1},\n\n      {0x24bc, 2361, 1},\n\n      {0xab9c, 1580, 1},\n\n      {0xa79c, 3129, 1},\n\n      {0x10c9c, 3441, 1},\n\n      {0x0222, 550, 1},\n\n      {0x1e7c, 1899, 1},\n\n      {0x047c, 1076, 1},\n\n      {0x1e82, 1908, 1},\n\n      {0x24b8, 2349, 1},\n\n      {0x0182, 357, 1},\n\n      {0x1f82, 139, 2},\n\n      {0x2c82, 2589, 1},\n\n      {0xab7c, 1484, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab82, 1502, 1},\n\n      {0xa782, 3102, 1},\n\n      {0x10c82, 3363, 1},\n\n      {0x2c63, 1709, 1},\n\n      {0x24b6, 2343, 1},\n\n      {0x1e80, 1905, 1},\n\n      {0x0480, 1082, 1},\n\n      {0x1f59, 2190, 1},\n\n      {0x1f80, 129, 2},\n\n      {0x2c80, 2586, 1},\n\n      {0x0059, 71, 1},\n\n      {0xa682, 2937, 1},\n\n      {0xab80, 1496, 1},\n\n      {0xa780, 3099, 1},\n\n      {0x10c80, 3357, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1e4c, 1826, 1},\n\n      {0x0145, 270, 1},\n\n      {0x014c, 279, 1},\n\n      {0x1f4c, 2184, 1},\n\n      {0x0345, 767, 1},\n\n      {0x0045, 12, 1},\n\n      {0x004c, 31, 1},\n\n      {0xa680, 2934, 1},\n\n      {0xa74c, 3036, 1},\n\n      {0x1e4a, 1823, 1},\n\n      {0x01d5, 441, 1},\n\n      {0x014a, 276, 1},\n\n      {0x1f4a, 2178, 1},\n\n      {0x03d5, 810, 1},\n\n      {0x00d5, 141, 1},\n\n      {0x004a, 24, 1},\n\n      {0x24bf, 2370, 1},\n\n      {0xa74a, 3033, 1},\n\n      {0xa64c, 2883, 1},\n\n      {0x1041c, 3321, 1},\n\n      {0x1e1c, 1754, 1},\n\n      {0x041c, 926, 1},\n\n      {0x011c, 213, 1},\n\n      {0x1f1c, 2118, 1},\n\n      {0x2c1c, 2505, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xa64a, 2880, 1},\n\n      {0x1041a, 3315, 1},\n\n      {0x1e1a, 1751, 1},\n\n      {0x041a, 920, 1},\n\n      {0x011a, 210, 1},\n\n      {0x1f1a, 2112, 1},\n\n      {0x2c1a, 2499, 1},\n\n      {0xabbd, 1679, 1},\n\n      {0x0545, 1394, 1},\n\n      {0x054c, 1415, 1},\n\n      {0x10418, 3309, 1},\n\n      {0x1e18, 1748, 1},\n\n      {0x0418, 914, 1},\n\n      {0x0118, 207, 1},\n\n      {0x1f18, 2106, 1},\n\n      {0x2c18, 2493, 1},\n\n      {0x10bd, 2832, 1},\n\n      {0x2163, 2301, 1},\n\n      {0x054a, 1409, 1},\n\n      {0x1040e, 3279, 1},\n\n      {0x1e0e, 1733, 1},\n\n      {0x040e, 1028, 1},\n\n      {0x010e, 192, 1},\n\n      {0x1f0e, 2100, 1},\n\n      {0x2c0e, 2463, 1},\n\n      {0x1efc, 2076, 1},\n\n      {0x04fc, 1256, 1},\n\n      {0x01fc, 496, 1},\n\n      {0x1ffc, 96, 2},\n\n      {0x051c, 1304, 1},\n\n      {0x1040c, 3273, 1},\n\n      {0x1e0c, 1730, 1},\n\n      {0x040c, 1022, 1},\n\n      {0x010c, 189, 1},\n\n      {0x1f0c, 2094, 1},\n\n      {0x2c0c, 2457, 1},\n\n      {0x1f6d, 2217, 1},\n\n      {0x2c6d, 607, 1},\n\n      {0x051a, 1301, 1},\n\n      {0x24be, 2367, 1},\n\n      {0x10408, 3261, 1},\n\n      {0x1e08, 1724, 1},\n\n      {0x0408, 1010, 1},\n\n      {0x0108, 183, 1},\n\n      {0x1f08, 2082, 1},\n\n      {0x2c08, 2445, 1},\n\n      {0x04c9, 1178, 1},\n\n      {0x0518, 1298, 1},\n\n      {0x1fc9, 2235, 1},\n      {0xffffffff, -1, 0},\n\n      {0x24ba, 2355, 1},\n\n      {0x00c9, 105, 1},\n\n      {0x10416, 3303, 1},\n\n      {0x1e16, 1745, 1},\n\n      {0x0416, 908, 1},\n\n      {0x0116, 204, 1},\n\n      {0x050e, 1283, 1},\n\n      {0x2c16, 2487, 1},\n\n      {0x10414, 3297, 1},\n\n      {0x1e14, 1742, 1},\n\n      {0x0414, 902, 1},\n\n      {0x0114, 201, 1},\n\n      {0x042b, 971, 1},\n\n      {0x2c14, 2481, 1},\n\n      {0x1f2b, 2133, 1},\n\n      {0x2c2b, 2550, 1},\n      {0xffffffff, -1, 0},\n\n      {0x050c, 1280, 1},\n\n      {0x10406, 3255, 1},\n\n      {0x1e06, 1721, 1},\n\n      {0x0406, 1004, 1},\n\n      {0x0106, 180, 1},\n\n      {0x13fb, 1697, 1},\n\n      {0x2c06, 2439, 1},\n\n      {0x24c2, 2379, 1},\n\n      {0x118bd, 3597, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0508, 1274, 1},\n\n      {0x10404, 3249, 1},\n\n      {0x1e04, 1718, 1},\n\n      {0x0404, 998, 1},\n\n      {0x0104, 177, 1},\n\n      {0x1f95, 194, 2},\n\n      {0x2c04, 2433, 1},\n\n      {0x0395, 752, 1},\n\n      {0x24ca, 2403, 1},\n\n      {0xab95, 1559, 1},\n\n      {0x0531, 1334, 1},\n\n      {0x10c95, 3420, 1},\n\n      {0x0516, 1295, 1},\n\n      {0x1e6c, 1875, 1},\n\n      {0x046c, 1052, 1},\n\n      {0x016c, 327, 1},\n\n      {0x1f6c, 2214, 1},\n\n      {0x216d, 2331, 1},\n\n      {0x0514, 1292, 1},\n\n      {0x0245, 697, 1},\n\n      {0x024c, 598, 1},\n\n      {0xa76c, 3084, 1},\n\n      {0x10400, 3237, 1},\n\n      {0x1e00, 1712, 1},\n\n      {0x0400, 986, 1},\n\n      {0x0100, 171, 1},\n\n      {0x24c4, 2385, 1},\n\n      {0x2c00, 2421, 1},\n\n      {0x0506, 1271, 1},\n\n      {0x024a, 595, 1},\n\n      {0x1fab, 224, 2},\n\n      {0xa66c, 2931, 1},\n\n      {0x03ab, 827, 1},\n\n      {0x24cf, 2418, 1},\n\n      {0xabab, 1625, 1},\n\n      {0xa7ab, 631, 1},\n\n      {0x10cab, 3486, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0504, 1268, 1},\n      {0xffffffff, -1, 0},\n\n      {0x021c, 544, 1},\n\n      {0x01a9, 679, 1},\n\n      {0x1fa9, 214, 2},\n\n      {0x10ab, 2778, 1},\n\n      {0x03a9, 820, 1},\n\n      {0x212b, 92, 1},\n\n      {0xaba9, 1619, 1},\n\n      {0x1e88, 1917, 1},\n\n      {0x10ca9, 3480, 1},\n\n      {0x021a, 541, 1},\n\n      {0x1f88, 129, 2},\n\n      {0x2c88, 2598, 1},\n\n      {0x0388, 730, 1},\n\n      {0x13fd, 1703, 1},\n\n      {0xab88, 1520, 1},\n\n      {0x10a9, 2772, 1},\n\n      {0x10c88, 3381, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0218, 538, 1},\n\n      {0x0500, 1262, 1},\n\n      {0x1f4d, 2187, 1},\n\n      {0x01a7, 393, 1},\n\n      {0x1fa7, 244, 2},\n\n      {0x004d, 34, 1},\n\n      {0x03a7, 814, 1},\n\n      {0xa688, 2946, 1},\n\n      {0xaba7, 1613, 1},\n\n      {0x020e, 523, 1},\n\n      {0x10ca7, 3474, 1},\n\n      {0x1e6a, 1872, 1},\n\n      {0x046a, 1049, 1},\n\n      {0x016a, 324, 1},\n\n      {0x1f6a, 2208, 1},\n      {0xffffffff, -1, 0},\n\n      {0x216c, 2328, 1},\n\n      {0x10a7, 2766, 1},\n\n      {0x01d1, 435, 1},\n\n      {0xa76a, 3081, 1},\n\n      {0x020c, 520, 1},\n\n      {0x03d1, 762, 1},\n\n      {0x00d1, 129, 1},\n\n      {0x1e68, 1869, 1},\n\n      {0x0468, 1046, 1},\n\n      {0x0168, 321, 1},\n\n      {0x1f68, 2202, 1},\n      {0xffffffff, -1, 0},\n\n      {0xff31, 3207, 1},\n\n      {0xa66a, 2928, 1},\n\n      {0x0208, 514, 1},\n\n      {0xa768, 3078, 1},\n\n      {0x1e64, 1863, 1},\n\n      {0x0464, 1040, 1},\n\n      {0x0164, 315, 1},\n\n      {0x054d, 1418, 1},\n\n      {0x2c64, 673, 1},\n      {0xffffffff, -1, 0},\n\n      {0xff2b, 3189, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa764, 3072, 1},\n\n      {0xa668, 2925, 1},\n\n      {0x0216, 535, 1},\n      {0xffffffff, -1, 0},\n\n      {0x118ab, 3543, 1},\n\n      {0x1e62, 1860, 1},\n\n      {0x0462, 1037, 1},\n\n      {0x0162, 312, 1},\n\n      {0x0214, 532, 1},\n\n      {0x2c62, 655, 1},\n\n      {0xa664, 2919, 1},\n\n      {0x1ed2, 2013, 1},\n\n      {0x04d2, 1193, 1},\n\n      {0xa762, 3069, 1},\n\n      {0x1fd2, 20, 3},\n\n      {0x2cd2, 2709, 1},\n\n      {0x118a9, 3537, 1},\n\n      {0x00d2, 132, 1},\n\n      {0x0206, 511, 1},\n\n      {0x10420, 3333, 1},\n\n      {0x1e20, 1760, 1},\n\n      {0x0420, 938, 1},\n\n      {0x0120, 219, 1},\n\n      {0xa662, 2916, 1},\n\n      {0x2c20, 2517, 1},\n\n      {0x1e60, 1856, 1},\n\n      {0x0460, 1034, 1},\n\n      {0x0160, 309, 1},\n\n      {0x0204, 508, 1},\n\n      {0x2c60, 2562, 1},\n      {0xffffffff, -1, 0},\n\n      {0x24bd, 2364, 1},\n\n      {0x216a, 2322, 1},\n\n      {0xa760, 3066, 1},\n      {0xffffffff, -1, 0},\n\n      {0xfb16, 125, 2},\n\n      {0x118a7, 3531, 1},\n\n      {0x1efa, 2073, 1},\n\n      {0x04fa, 1253, 1},\n\n      {0x01fa, 493, 1},\n\n      {0x1ffa, 2262, 1},\n\n      {0xfb14, 109, 2},\n\n      {0x03fa, 887, 1},\n\n      {0xa660, 2913, 1},\n\n      {0x2168, 2316, 1},\n\n      {0x01b7, 700, 1},\n\n      {0x1fb7, 10, 3},\n\n      {0x1f6b, 2211, 1},\n\n      {0x2c6b, 2577, 1},\n\n      {0x0200, 502, 1},\n\n      {0xabb7, 1661, 1},\n\n      {0xfb06, 29, 2},\n\n      {0x1e56, 1841, 1},\n\n      {0x2164, 2304, 1},\n\n      {0x0156, 294, 1},\n\n      {0x1f56, 62, 3},\n\n      {0x0520, 1310, 1},\n\n      {0x004f, 40, 1},\n\n      {0x0056, 62, 1},\n\n      {0x10b7, 2814, 1},\n\n      {0xa756, 3051, 1},\n\n      {0xfb04, 5, 3},\n\n      {0x1e78, 1893, 1},\n\n      {0x0478, 1070, 1},\n\n      {0x0178, 168, 1},\n\n      {0x1e54, 1838, 1},\n\n      {0x2162, 2298, 1},\n\n      {0x0154, 291, 1},\n\n      {0x1f54, 57, 3},\n\n      {0xab78, 1472, 1},\n\n      {0xa656, 2898, 1},\n\n      {0x0054, 56, 1},\n\n      {0x1e52, 1835, 1},\n\n      {0xa754, 3048, 1},\n\n      {0x0152, 288, 1},\n\n      {0x1f52, 52, 3},\n\n      {0x24c9, 2400, 1},\n\n      {0x1e32, 1787, 1},\n\n      {0x0052, 49, 1},\n\n      {0x0132, 243, 1},\n\n      {0xa752, 3045, 1},\n      {0xffffffff, -1, 0},\n\n      {0xfb00, 4, 2},\n\n      {0xa654, 2895, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa732, 2997, 1},\n\n      {0x2160, 2292, 1},\n\n      {0x054f, 1424, 1},\n\n      {0x0556, 1445, 1},\n\n      {0x1e50, 1832, 1},\n\n      {0xa652, 2892, 1},\n\n      {0x0150, 285, 1},\n\n      {0x1f50, 84, 2},\n\n      {0x017b, 348, 1},\n\n      {0x1e4e, 1829, 1},\n\n      {0x0050, 43, 1},\n\n      {0x014e, 282, 1},\n\n      {0xa750, 3042, 1},\n\n      {0xab7b, 1481, 1},\n\n      {0xa77b, 3093, 1},\n\n      {0x004e, 37, 1},\n\n      {0x0554, 1439, 1},\n\n      {0xa74e, 3039, 1},\n\n      {0x1e48, 1820, 1},\n      {0xffffffff, -1, 0},\n\n      {0x216b, 2325, 1},\n\n      {0x1f48, 2172, 1},\n\n      {0xa650, 2889, 1},\n\n      {0x0552, 1433, 1},\n\n      {0x0048, 21, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa748, 3030, 1},\n\n      {0xa64e, 2886, 1},\n\n      {0x0532, 1337, 1},\n\n      {0x1041e, 3327, 1},\n\n      {0x1e1e, 1757, 1},\n\n      {0x041e, 932, 1},\n\n      {0x011e, 216, 1},\n\n      {0x118b7, 3579, 1},\n\n      {0x2c1e, 2511, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa648, 2877, 1},\n\n      {0x1ff9, 2253, 1},\n      {0xffffffff, -1, 0},\n\n      {0x03f9, 878, 1},\n\n      {0x0550, 1427, 1},\n\n      {0x10412, 3291, 1},\n\n      {0x1e12, 1739, 1},\n\n      {0x0412, 896, 1},\n\n      {0x0112, 198, 1},\n\n      {0x054e, 1421, 1},\n\n      {0x2c12, 2475, 1},\n\n      {0x10410, 3285, 1},\n\n      {0x1e10, 1736, 1},\n\n      {0x0410, 890, 1},\n\n      {0x0110, 195, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c10, 2469, 1},\n\n      {0x2132, 2289, 1},\n\n      {0x0548, 1403, 1},\n\n      {0x1ef8, 2070, 1},\n\n      {0x04f8, 1250, 1},\n\n      {0x01f8, 490, 1},\n\n      {0x1ff8, 2250, 1},\n\n      {0x0220, 381, 1},\n\n      {0x1ee2, 2037, 1},\n\n      {0x04e2, 1217, 1},\n\n      {0x01e2, 462, 1},\n\n      {0x1fe2, 36, 3},\n\n      {0x2ce2, 2733, 1},\n\n      {0x03e2, 857, 1},\n\n      {0x051e, 1307, 1},\n\n      {0x1ede, 2031, 1},\n\n      {0x04de, 1211, 1},\n\n      {0x01de, 456, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2cde, 2727, 1},\n\n      {0x03de, 851, 1},\n\n      {0x00de, 165, 1},\n\n      {0x1f69, 2205, 1},\n\n      {0x2c69, 2574, 1},\n\n      {0x1eda, 2025, 1},\n\n      {0x04da, 1205, 1},\n\n      {0x0512, 1289, 1},\n\n      {0x1fda, 2244, 1},\n\n      {0x2cda, 2721, 1},\n\n      {0x03da, 845, 1},\n\n      {0x00da, 153, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0510, 1286, 1},\n\n      {0x1ed8, 2022, 1},\n\n      {0x04d8, 1202, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1fd8, 2274, 1},\n\n      {0x2cd8, 2718, 1},\n\n      {0x03d8, 842, 1},\n\n      {0x00d8, 147, 1},\n\n      {0x1ed6, 2019, 1},\n\n      {0x04d6, 1199, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1fd6, 76, 2},\n\n      {0x2cd6, 2715, 1},\n\n      {0x03d6, 792, 1},\n\n      {0x00d6, 144, 1},\n\n      {0x1ec8, 1998, 1},\n      {0xffffffff, -1, 0},\n\n      {0x01c8, 421, 1},\n\n      {0x1fc8, 2232, 1},\n\n      {0x2cc8, 2694, 1},\n\n      {0xff32, 3210, 1},\n\n      {0x00c8, 102, 1},\n\n      {0x04c7, 1175, 1},\n\n      {0x01c7, 421, 1},\n\n      {0x1fc7, 15, 3},\n\n      {0x1ec0, 1986, 1},\n\n      {0x04c0, 1187, 1},\n\n      {0x00c7, 99, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2cc0, 2682, 1},\n\n      {0x0179, 345, 1},\n\n      {0x00c0, 77, 1},\n\n      {0x0232, 574, 1},\n\n      {0x01b3, 402, 1},\n\n      {0x1fb3, 62, 2},\n\n      {0xab79, 1475, 1},\n\n      {0xa779, 3090, 1},\n\n      {0x10c7, 2859, 1},\n\n      {0xabb3, 1649, 1},\n\n      {0xa7b3, 3156, 1},\n\n      {0x1fa5, 234, 2},\n\n      {0x10c0, 2841, 1},\n\n      {0x03a5, 807, 1},\n      {0xffffffff, -1, 0},\n\n      {0xaba5, 1607, 1},\n\n      {0x01b1, 691, 1},\n\n      {0x10ca5, 3468, 1},\n\n      {0x10b3, 2802, 1},\n\n      {0x2169, 2319, 1},\n\n      {0x024e, 601, 1},\n\n      {0xabb1, 1643, 1},\n\n      {0xa7b1, 682, 1},\n\n      {0x10cb1, 3504, 1},\n\n      {0x10a5, 2760, 1},\n      {0xffffffff, -1, 0},\n\n      {0x01af, 399, 1},\n\n      {0x1faf, 244, 2},\n      {0xffffffff, -1, 0},\n\n      {0x0248, 592, 1},\n\n      {0x10b1, 2796, 1},\n\n      {0xabaf, 1637, 1},\n\n      {0x1fad, 234, 2},\n\n      {0x10caf, 3498, 1},\n\n      {0x04cd, 1184, 1},\n\n      {0x01cd, 429, 1},\n\n      {0xabad, 1631, 1},\n\n      {0xa7ad, 658, 1},\n\n      {0x10cad, 3492, 1},\n\n      {0x00cd, 117, 1},\n\n      {0x10af, 2790, 1},\n\n      {0x021e, 547, 1},\n\n      {0x1fa3, 224, 2},\n      {0xffffffff, -1, 0},\n\n      {0x03a3, 800, 1},\n\n      {0x10ad, 2784, 1},\n\n      {0xaba3, 1601, 1},\n      {0xffffffff, -1, 0},\n\n      {0x10ca3, 3462, 1},\n\n      {0x10cd, 2862, 1},\n\n      {0x1fa1, 214, 2},\n\n      {0x24b7, 2346, 1},\n\n      {0x03a1, 796, 1},\n\n      {0x0212, 529, 1},\n\n      {0xaba1, 1595, 1},\n\n      {0x10a3, 2754, 1},\n\n      {0x10ca1, 3456, 1},\n\n      {0x01d3, 438, 1},\n\n      {0x1fd3, 25, 3},\n\n      {0x0210, 526, 1},\n      {0xffffffff, -1, 0},\n\n      {0x00d3, 135, 1},\n\n      {0x1e97, 34, 2},\n\n      {0x10a1, 2748, 1},\n\n      {0x0197, 649, 1},\n\n      {0x1f97, 204, 2},\n      {0xffffffff, -1, 0},\n\n      {0x0397, 759, 1},\n\n      {0x1041d, 3324, 1},\n\n      {0xab97, 1565, 1},\n\n      {0x041d, 929, 1},\n\n      {0x10c97, 3426, 1},\n\n      {0x1f1d, 2121, 1},\n\n      {0x2c1d, 2508, 1},\n\n      {0x1e72, 1884, 1},\n\n      {0x0472, 1061, 1},\n\n      {0x0172, 336, 1},\n\n      {0x118b3, 3567, 1},\n\n      {0x2c72, 2580, 1},\n\n      {0x0372, 712, 1},\n\n      {0x1041b, 3318, 1},\n\n      {0xab72, 1454, 1},\n\n      {0x041b, 923, 1},\n\n      {0x118a5, 3525, 1},\n\n      {0x1f1b, 2115, 1},\n\n      {0x2c1b, 2502, 1},\n\n      {0x1e70, 1881, 1},\n\n      {0x0470, 1058, 1},\n\n      {0x0170, 333, 1},\n\n      {0x118b1, 3561, 1},\n\n      {0x2c70, 610, 1},\n\n      {0x0370, 709, 1},\n\n      {0x1e46, 1817, 1},\n\n      {0xab70, 1448, 1},\n\n      {0x1e66, 1866, 1},\n\n      {0x0466, 1043, 1},\n\n      {0x0166, 318, 1},\n\n      {0x1e44, 1814, 1},\n\n      {0x0046, 15, 1},\n\n      {0x118af, 3555, 1},\n\n      {0xa746, 3027, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa766, 3075, 1},\n\n      {0x0044, 9, 1},\n\n      {0x118ad, 3549, 1},\n\n      {0xa744, 3024, 1},\n\n      {0x1e7a, 1896, 1},\n\n      {0x047a, 1073, 1},\n\n      {0x1e3a, 1799, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa646, 2874, 1},\n\n      {0x1f3a, 2154, 1},\n\n      {0xa666, 2922, 1},\n\n      {0xab7a, 1478, 1},\n\n      {0x118a3, 3519, 1},\n\n      {0xa644, 2871, 1},\n\n      {0xa73a, 3009, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1ef4, 2064, 1},\n\n      {0x04f4, 1244, 1},\n\n      {0x01f4, 487, 1},\n\n      {0x1ff4, 101, 2},\n\n      {0x118a1, 3513, 1},\n\n      {0x03f4, 762, 1},\n\n      {0x1eec, 2052, 1},\n\n      {0x04ec, 1232, 1},\n\n      {0x01ec, 477, 1},\n\n      {0x1fec, 2286, 1},\n\n      {0x0546, 1397, 1},\n\n      {0x03ec, 872, 1},\n      {0xffffffff, -1, 0},\n\n      {0x013f, 261, 1},\n\n      {0x1f3f, 2169, 1},\n\n      {0x0544, 1391, 1},\n\n      {0x1eea, 2049, 1},\n\n      {0x04ea, 1229, 1},\n\n      {0x01ea, 474, 1},\n\n      {0x1fea, 2256, 1},\n      {0xffffffff, -1, 0},\n\n      {0x03ea, 869, 1},\n\n      {0x1ee8, 2046, 1},\n\n      {0x04e8, 1226, 1},\n\n      {0x01e8, 471, 1},\n\n      {0x1fe8, 2280, 1},\n\n      {0x053a, 1361, 1},\n\n      {0x03e8, 866, 1},\n\n      {0x1ee6, 2043, 1},\n\n      {0x04e6, 1223, 1},\n\n      {0x01e6, 468, 1},\n\n      {0x1fe6, 88, 2},\n\n      {0x1f4b, 2181, 1},\n\n      {0x03e6, 863, 1},\n\n      {0x1e5e, 1853, 1},\n\n      {0x004b, 27, 1},\n\n      {0x015e, 306, 1},\n\n      {0x2166, 2310, 1},\n\n      {0x1ee4, 2040, 1},\n\n      {0x04e4, 1220, 1},\n\n      {0x01e4, 465, 1},\n\n      {0x1fe4, 80, 2},\n\n      {0xa75e, 3063, 1},\n\n      {0x03e4, 860, 1},\n\n      {0x1ee0, 2034, 1},\n\n      {0x04e0, 1214, 1},\n\n      {0x01e0, 459, 1},\n\n      {0x053f, 1376, 1},\n\n      {0x2ce0, 2730, 1},\n\n      {0x03e0, 854, 1},\n\n      {0x1edc, 2028, 1},\n\n      {0x04dc, 1208, 1},\n\n      {0xa65e, 2910, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2cdc, 2724, 1},\n\n      {0x03dc, 848, 1},\n\n      {0x00dc, 159, 1},\n\n      {0x1ed0, 2010, 1},\n\n      {0x04d0, 1190, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0x2cd0, 2706, 1},\n\n      {0x03d0, 742, 1},\n\n      {0x00d0, 126, 1},\n\n      {0x1ecc, 2004, 1},\n\n      {0x054b, 1412, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1fcc, 71, 2},\n\n      {0x2ccc, 2700, 1},\n\n      {0x1ec6, 1995, 1},\n\n      {0x00cc, 114, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1fc6, 67, 2},\n\n      {0x2cc6, 2691, 1},\n\n      {0x24c8, 2397, 1},\n\n      {0x00c6, 96, 1},\n\n      {0x04c5, 1172, 1},\n\n      {0x01c5, 417, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1fbb, 2229, 1},\n\n      {0x24c7, 2394, 1},\n\n      {0x00c5, 92, 1},\n\n      {0x1fb9, 2271, 1},\n\n      {0xabbb, 1673, 1},\n\n      {0x24c0, 2373, 1},\n\n      {0x04c3, 1169, 1},\n\n      {0xabb9, 1667, 1},\n\n      {0x1fc3, 71, 2},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0x00c3, 86, 1},\n\n      {0x10c5, 2856, 1},\n\n      {0x10bb, 2826, 1},\n\n      {0x1ed4, 2016, 1},\n\n      {0x04d4, 1196, 1},\n\n      {0x10b9, 2820, 1},\n\n      {0x13fc, 1700, 1},\n\n      {0x2cd4, 2712, 1},\n\n      {0x0246, 589, 1},\n\n      {0x00d4, 138, 1},\n\n      {0x10c3, 2850, 1},\n      {0xffffffff, -1, 0},\n\n      {0xff3a, 3234, 1},\n\n      {0x0244, 688, 1},\n\n      {0x019f, 670, 1},\n\n      {0x1f9f, 204, 2},\n      {0xffffffff, -1, 0},\n\n      {0x039f, 789, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab9f, 1589, 1},\n      {0xffffffff, -1, 0},\n\n      {0x10c9f, 3450, 1},\n\n      {0x019d, 667, 1},\n\n      {0x1f9d, 194, 2},\n\n      {0x023a, 2565, 1},\n\n      {0x039d, 783, 1},\n\n      {0x1e5a, 1847, 1},\n\n      {0xab9d, 1583, 1},\n\n      {0x015a, 300, 1},\n\n      {0x10c9d, 3444, 1},\n\n      {0x1e9b, 1856, 1},\n\n      {0x24cd, 2412, 1},\n\n      {0x005a, 74, 1},\n\n      {0x1f9b, 184, 2},\n\n      {0xa75a, 3057, 1},\n\n      {0x039b, 776, 1},\n\n      {0x1ece, 2007, 1},\n\n      {0xab9b, 1577, 1},\n\n      {0x1e99, 42, 2},\n\n      {0x10c9b, 3438, 1},\n\n      {0x2cce, 2703, 1},\n\n      {0x1f99, 174, 2},\n\n      {0x00ce, 120, 1},\n\n      {0x0399, 767, 1},\n\n      {0xa65a, 2904, 1},\n\n      {0xab99, 1571, 1},\n      {0xffffffff, -1, 0},\n\n      {0x10c99, 3432, 1},\n\n      {0x0193, 634, 1},\n\n      {0x1f93, 184, 2},\n\n      {0x1e58, 1844, 1},\n\n      {0x0393, 746, 1},\n\n      {0x0158, 297, 1},\n\n      {0xab93, 1553, 1},\n      {0xffffffff, -1, 0},\n\n      {0x10c93, 3414, 1},\n\n      {0x0058, 68, 1},\n\n      {0x042d, 977, 1},\n\n      {0xa758, 3054, 1},\n\n      {0x1f2d, 2139, 1},\n\n      {0x2c2d, 2556, 1},\n\n      {0x118bb, 3591, 1},\n\n      {0x0191, 369, 1},\n\n      {0x1f91, 174, 2},\n\n      {0x118b9, 3585, 1},\n\n      {0x0391, 739, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab91, 1547, 1},\n\n      {0xa658, 2901, 1},\n\n      {0x10c91, 3408, 1},\n\n      {0x018f, 625, 1},\n\n      {0x1f8f, 164, 2},\n      {0xffffffff, -1, 0},\n\n      {0x038f, 836, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab8f, 1541, 1},\n      {0xffffffff, -1, 0},\n\n      {0x10c8f, 3402, 1},\n\n      {0x018b, 366, 1},\n\n      {0x1f8b, 144, 2},\n      {0xffffffff, -1, 0},\n\n      {0x0187, 363, 1},\n\n      {0x1f87, 164, 2},\n\n      {0xab8b, 1529, 1},\n\n      {0xa78b, 3111, 1},\n\n      {0x10c8b, 3390, 1},\n\n      {0xab87, 1517, 1},\n\n      {0x04c1, 1166, 1},\n\n      {0x10c87, 3378, 1},\n\n      {0x1e7e, 1902, 1},\n\n      {0x047e, 1079, 1},\n      {0xffffffff, -1, 0},\n\n      {0x00c1, 80, 1},\n\n      {0x2c7e, 580, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xab7e, 1490, 1},\n\n      {0xa77e, 3096, 1},\n\n      {0x1e76, 1890, 1},\n\n      {0x0476, 1067, 1},\n\n      {0x0176, 342, 1},\n\n      {0x1e42, 1811, 1},\n\n      {0x10c1, 2844, 1},\n\n      {0x0376, 715, 1},\n\n      {0x1e36, 1793, 1},\n\n      {0xab76, 1466, 1},\n\n      {0x0136, 249, 1},\n\n      {0x0042, 3, 1},\n\n      {0x1e3e, 1805, 1},\n\n      {0xa742, 3021, 1},\n\n      {0x1e38, 1796, 1},\n\n      {0x1f3e, 2166, 1},\n\n      {0xa736, 3003, 1},\n\n      {0x1f38, 2148, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0587, 105, 2},\n\n      {0xa73e, 3015, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa738, 3006, 1},\n\n      {0xa642, 2868, 1},\n\n      {0x1e5c, 1850, 1},\n\n      {0x1e34, 1790, 1},\n\n      {0x015c, 303, 1},\n\n      {0x0134, 246, 1},\n\n      {0x1ef6, 2067, 1},\n\n      {0x04f6, 1247, 1},\n\n      {0x01f6, 372, 1},\n\n      {0x1ff6, 92, 2},\n\n      {0xa75c, 3060, 1},\n\n      {0xa734, 3000, 1},\n\n      {0x1ef0, 2058, 1},\n\n      {0x04f0, 1238, 1},\n\n      {0x01f0, 20, 2},\n      {0xffffffff, -1, 0},\n\n      {0x1e30, 1784, 1},\n\n      {0x03f0, 772, 1},\n\n      {0x0130, 261, 2},\n\n      {0x0542, 1385, 1},\n\n      {0xa65c, 2907, 1},\n\n      {0x1f83, 144, 2},\n\n      {0x0536, 1349, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xab83, 1505, 1},\n\n      {0x053e, 1373, 1},\n\n      {0x10c83, 3366, 1},\n\n      {0x0538, 1355, 1},\n\n      {0x1eee, 2055, 1},\n\n      {0x04ee, 1235, 1},\n\n      {0x01ee, 480, 1},\n\n      {0x1f8d, 154, 2},\n      {0xffffffff, -1, 0},\n\n      {0x03ee, 875, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab8d, 1535, 1},\n\n      {0xa78d, 643, 1},\n\n      {0x10c8d, 3396, 1},\n\n      {0x0534, 1343, 1},\n\n      {0x0181, 613, 1},\n\n      {0x1f81, 134, 2},\n\n      {0x013d, 258, 1},\n\n      {0x1f3d, 2163, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab81, 1499, 1},\n\n      {0x017f, 52, 1},\n\n      {0x10c81, 3360, 1},\n\n      {0x2c7f, 583, 1},\n\n      {0x037f, 881, 1},\n\n      {0xff2d, 3195, 1},\n\n      {0xab7f, 1493, 1},\n\n      {0x1e74, 1887, 1},\n\n      {0x0474, 1064, 1},\n\n      {0x0174, 339, 1},\n\n      {0x1e3c, 1802, 1},\n\n      {0x0149, 46, 2},\n\n      {0x1f49, 2175, 1},\n\n      {0x1f3c, 2160, 1},\n\n      {0xab74, 1460, 1},\n\n      {0x0049, 3606, 1},\n\n      {0x0143, 267, 1},\n\n      {0x24cc, 2409, 1},\n\n      {0xa73c, 3012, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0043, 6, 1},\n\n      {0x0141, 264, 1},\n\n      {0x24c6, 2391, 1},\n\n      {0x013b, 255, 1},\n\n      {0x1f3b, 2157, 1},\n\n      {0x0041, 0, 1},\n\n      {0x0139, 252, 1},\n\n      {0x1f39, 2151, 1},\n\n      {0x24c5, 2388, 1},\n\n      {0x24bb, 2358, 1},\n\n      {0x13fa, 1694, 1},\n\n      {0x053d, 1370, 1},\n\n      {0x24b9, 2352, 1},\n\n      {0x0429, 965, 1},\n\n      {0x2183, 2340, 1},\n\n      {0x1f29, 2127, 1},\n\n      {0x2c29, 2544, 1},\n\n      {0x24c3, 2382, 1},\n\n      {0x10427, 3354, 1},\n\n      {0x10425, 3348, 1},\n\n      {0x0427, 959, 1},\n\n      {0x0425, 953, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c27, 2538, 1},\n\n      {0x2c25, 2532, 1},\n\n      {0x0549, 1406, 1},\n\n      {0x053c, 1367, 1},\n\n      {0x10423, 3342, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0423, 947, 1},\n\n      {0x0543, 1388, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c23, 2526, 1},\n\n      {0xff36, 3222, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0541, 1382, 1},\n\n      {0x10421, 3336, 1},\n\n      {0x053b, 1364, 1},\n\n      {0x0421, 941, 1},\n\n      {0xff38, 3228, 1},\n\n      {0x0539, 1358, 1},\n\n      {0x2c21, 2520, 1},\n\n      {0x10419, 3312, 1},\n\n      {0x10417, 3306, 1},\n\n      {0x0419, 917, 1},\n\n      {0x0417, 911, 1},\n\n      {0x1f19, 2109, 1},\n\n      {0x2c19, 2496, 1},\n\n      {0x2c17, 2490, 1},\n\n      {0x023e, 2568, 1},\n\n      {0xff34, 3216, 1},\n\n      {0x10415, 3300, 1},\n\n      {0x10413, 3294, 1},\n\n      {0x0415, 905, 1},\n\n      {0x0413, 899, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c15, 2484, 1},\n\n      {0x2c13, 2478, 1},\n      {0xffffffff, -1, 0},\n\n      {0x24ce, 2415, 1},\n\n      {0x1040f, 3282, 1},\n      {0xffffffff, -1, 0},\n\n      {0x040f, 1031, 1},\n\n      {0xff30, 3204, 1},\n\n      {0x1f0f, 2103, 1},\n\n      {0x2c0f, 2466, 1},\n\n      {0x1040d, 3276, 1},\n      {0xffffffff, -1, 0},\n\n      {0x040d, 1025, 1},\n\n      {0x0147, 273, 1},\n\n      {0x1f0d, 2097, 1},\n\n      {0x2c0d, 2460, 1},\n\n      {0x1040b, 3270, 1},\n\n      {0x0047, 18, 1},\n\n      {0x040b, 1019, 1},\n\n      {0x0230, 571, 1},\n\n      {0x1f0b, 2091, 1},\n\n      {0x2c0b, 2454, 1},\n\n      {0x10409, 3264, 1},\n\n      {0x10405, 3252, 1},\n\n      {0x0409, 1013, 1},\n\n      {0x0405, 1001, 1},\n\n      {0x1f09, 2085, 1},\n\n      {0x2c09, 2448, 1},\n\n      {0x2c05, 2436, 1},\n\n      {0x10403, 3246, 1},\n\n      {0x10401, 3240, 1},\n\n      {0x0403, 995, 1},\n\n      {0x0401, 989, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c03, 2430, 1},\n\n      {0x2c01, 2424, 1},\n\n      {0x13f9, 1691, 1},\n\n      {0x042f, 983, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1f2f, 2145, 1},\n\n      {0x1041f, 3330, 1},\n      {0xffffffff, -1, 0},\n\n      {0x041f, 935, 1},\n\n      {0x023d, 378, 1},\n\n      {0x10411, 3288, 1},\n\n      {0x2c1f, 2514, 1},\n\n      {0x0411, 893, 1},\n\n      {0x0547, 1400, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c11, 2472, 1},\n\n      {0x10407, 3258, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0407, 1007, 1},\n\n      {0x24c1, 2376, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c07, 2442, 1},\n      {0xffffffff, -1, 0},\n\n      {0x13f8, 1688, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xff39, 3231, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0243, 354, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0x0241, 586, 1},\n\n      {0xff29, 3183, 1},\n\n      {0x023b, 577, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xff27, 3177, 1},\n\n      {0xff25, 3171, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xff23, 3165, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xff21, 3159, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0},\n\n      {0xfb17, 117, 2},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xff2f, 3201, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xfb15, 113, 2},\n\n      {0xfb13, 121, 2},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0},\n\n      {0xfb05, 29, 2},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xfb03, 0, 3},\n\n      {0xfb01, 8, 2}\n    };\n\n  if (0 == 0)\n    {\n      int key = hash(&code);\n\n      if (key <= MAX_HASH_VALUE && key >= 0)\n        {\n          OnigCodePoint gcode = wordlist[key].code;\n\n          if (code == gcode)\n            return &wordlist[key];\n        }\n    }\n  return 0;\n}", "func_src_after": "unicode_unfold_key(OnigCodePoint code)\n{\n  static const struct ByUnfoldKey wordlist[] =\n    {\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0},\n\n      {0x1040a, 3267, 1},\n\n      {0x1e0a, 1727, 1},\n\n      {0x040a, 1016, 1},\n\n      {0x010a, 186, 1},\n\n      {0x1f0a, 2088, 1},\n\n      {0x2c0a, 2451, 1},\n\n      {0x0189, 619, 1},\n\n      {0x1f89, 134, 2},\n\n      {0x1f85, 154, 2},\n\n      {0x0389, 733, 1},\n\n      {0x03ff, 724, 1},\n\n      {0xab89, 1523, 1},\n\n      {0xab85, 1511, 1},\n\n      {0x10c89, 3384, 1},\n\n      {0x10c85, 3372, 1},\n\n      {0x1e84, 1911, 1},\n\n      {0x03f5, 752, 1},\n\n      {0x0184, 360, 1},\n\n      {0x1f84, 149, 2},\n\n      {0x2c84, 2592, 1},\n\n      {0x017d, 351, 1},\n\n      {0x1ff3, 96, 2},\n\n      {0xab84, 1508, 1},\n\n      {0xa784, 3105, 1},\n\n      {0x10c84, 3369, 1},\n\n      {0xab7d, 1487, 1},\n\n      {0xa77d, 1706, 1},\n\n      {0x1e98, 38, 2},\n\n      {0x0498, 1106, 1},\n\n      {0x0198, 375, 1},\n\n      {0x1f98, 169, 2},\n\n      {0x2c98, 2622, 1},\n\n      {0x0398, 762, 1},\n\n      {0xa684, 2940, 1},\n\n      {0xab98, 1568, 1},\n\n      {0xa798, 3123, 1},\n\n      {0x10c98, 3429, 1},\n\n      {0x050a, 1277, 1},\n\n      {0x1ffb, 2265, 1},\n\n      {0x1e96, 16, 2},\n\n      {0x0496, 1103, 1},\n\n      {0x0196, 652, 1},\n\n      {0x1f96, 199, 2},\n\n      {0x2c96, 2619, 1},\n\n      {0x0396, 756, 1},\n\n      {0xa698, 2970, 1},\n\n      {0xab96, 1562, 1},\n\n      {0xa796, 3120, 1},\n\n      {0x10c96, 3423, 1},\n\n      {0x1feb, 2259, 1},\n\n      {0x2ceb, 2736, 1},\n\n      {0x1e90, 1929, 1},\n\n      {0x0490, 1094, 1},\n\n      {0x0190, 628, 1},\n\n      {0x1f90, 169, 2},\n\n      {0x2c90, 2610, 1},\n\n      {0x0390, 25, 3},\n\n      {0xa696, 2967, 1},\n\n      {0xab90, 1544, 1},\n\n      {0xa790, 3114, 1},\n\n      {0x10c90, 3405, 1},\n\n      {0x01d7, 444, 1},\n\n      {0x1fd7, 31, 3},\n\n      {0x1ea6, 1947, 1},\n\n      {0x04a6, 1127, 1},\n\n      {0x01a6, 676, 1},\n\n      {0x1fa6, 239, 2},\n\n      {0x2ca6, 2643, 1},\n\n      {0x03a6, 810, 1},\n\n      {0xa690, 2958, 1},\n\n      {0xaba6, 1610, 1},\n\n      {0xa7a6, 3144, 1},\n\n      {0x10ca6, 3471, 1},\n\n      {0x1ea4, 1944, 1},\n\n      {0x04a4, 1124, 1},\n\n      {0x01a4, 390, 1},\n\n      {0x1fa4, 229, 2},\n\n      {0x2ca4, 2640, 1},\n\n      {0x03a4, 804, 1},\n\n      {0x10a6, 2763, 1},\n\n      {0xaba4, 1604, 1},\n\n      {0xa7a4, 3141, 1},\n\n      {0x10ca4, 3465, 1},\n\n      {0x1ea0, 1938, 1},\n\n      {0x04a0, 1118, 1},\n\n      {0x01a0, 384, 1},\n\n      {0x1fa0, 209, 2},\n\n      {0x2ca0, 2634, 1},\n\n      {0x03a0, 792, 1},\n\n      {0x10a4, 2757, 1},\n\n      {0xaba0, 1592, 1},\n\n      {0xa7a0, 3135, 1},\n\n      {0x10ca0, 3453, 1},\n\n      {0x1eb2, 1965, 1},\n\n      {0x04b2, 1145, 1},\n\n      {0x01b2, 694, 1},\n\n      {0x1fb2, 249, 2},\n\n      {0x2cb2, 2661, 1},\n\n      {0x03fd, 718, 1},\n\n      {0x10a0, 2745, 1},\n\n      {0xabb2, 1646, 1},\n\n      {0xa7b2, 703, 1},\n\n      {0x10cb2, 3507, 1},\n\n      {0x1eac, 1956, 1},\n\n      {0x04ac, 1136, 1},\n\n      {0x01ac, 396, 1},\n\n      {0x1fac, 229, 2},\n\n      {0x2cac, 2652, 1},\n\n      {0x0537, 1352, 1},\n\n      {0x10b2, 2799, 1},\n\n      {0xabac, 1628, 1},\n\n      {0xa7ac, 637, 1},\n\n      {0x10cac, 3489, 1},\n\n      {0x1eaa, 1953, 1},\n\n      {0x04aa, 1133, 1},\n\n      {0x00dd, 162, 1},\n\n      {0x1faa, 219, 2},\n\n      {0x2caa, 2649, 1},\n\n      {0x03aa, 824, 1},\n\n      {0x10ac, 2781, 1},\n\n      {0xabaa, 1622, 1},\n\n      {0xa7aa, 646, 1},\n\n      {0x10caa, 3483, 1},\n\n      {0x1ea8, 1950, 1},\n\n      {0x04a8, 1130, 1},\n\n      {0x020a, 517, 1},\n\n      {0x1fa8, 209, 2},\n\n      {0x2ca8, 2646, 1},\n\n      {0x03a8, 817, 1},\n\n      {0x10aa, 2775, 1},\n\n      {0xaba8, 1616, 1},\n\n      {0xa7a8, 3147, 1},\n\n      {0x10ca8, 3477, 1},\n\n      {0x1ea2, 1941, 1},\n\n      {0x04a2, 1121, 1},\n\n      {0x01a2, 387, 1},\n\n      {0x1fa2, 219, 2},\n\n      {0x2ca2, 2637, 1},\n\n      {0x118a6, 3528, 1},\n\n      {0x10a8, 2769, 1},\n\n      {0xaba2, 1598, 1},\n\n      {0xa7a2, 3138, 1},\n\n      {0x10ca2, 3459, 1},\n\n      {0x2ced, 2739, 1},\n\n      {0x1fe9, 2283, 1},\n\n      {0x1fe7, 47, 3},\n\n      {0x1eb0, 1962, 1},\n\n      {0x04b0, 1142, 1},\n\n      {0x118a4, 3522, 1},\n\n      {0x10a2, 2751, 1},\n\n      {0x2cb0, 2658, 1},\n\n      {0x03b0, 41, 3},\n\n      {0x1fe3, 41, 3},\n\n      {0xabb0, 1640, 1},\n\n      {0xa7b0, 706, 1},\n\n      {0x10cb0, 3501, 1},\n\n      {0x01d9, 447, 1},\n\n      {0x1fd9, 2277, 1},\n\n      {0x118a0, 3510, 1},\n\n      {0x00df, 24, 2},\n\n      {0x00d9, 150, 1},\n\n      {0xab77, 1469, 1},\n\n      {0x10b0, 2793, 1},\n\n      {0x1eae, 1959, 1},\n\n      {0x04ae, 1139, 1},\n\n      {0x01ae, 685, 1},\n\n      {0x1fae, 239, 2},\n\n      {0x2cae, 2655, 1},\n\n      {0x118b2, 3564, 1},\n\n      {0xab73, 1457, 1},\n\n      {0xabae, 1634, 1},\n\n      {0xab71, 1451, 1},\n\n      {0x10cae, 3495, 1},\n\n      {0x1e2a, 1775, 1},\n\n      {0x042a, 968, 1},\n\n      {0x012a, 234, 1},\n\n      {0x1f2a, 2130, 1},\n\n      {0x2c2a, 2547, 1},\n\n      {0x118ac, 3546, 1},\n\n      {0x10ae, 2787, 1},\n\n      {0x0535, 1346, 1},\n\n      {0xa72a, 2988, 1},\n\n      {0x1e9a, 0, 2},\n\n      {0x049a, 1109, 1},\n\n      {0xff37, 3225, 1},\n\n      {0x1f9a, 179, 2},\n\n      {0x2c9a, 2625, 1},\n\n      {0x039a, 772, 1},\n\n      {0x118aa, 3540, 1},\n\n      {0xab9a, 1574, 1},\n\n      {0xa79a, 3126, 1},\n\n      {0x10c9a, 3435, 1},\n\n      {0x1e94, 1935, 1},\n\n      {0x0494, 1100, 1},\n\n      {0x0194, 640, 1},\n\n      {0x1f94, 189, 2},\n\n      {0x2c94, 2616, 1},\n\n      {0x0394, 749, 1},\n\n      {0x118a8, 3534, 1},\n\n      {0xab94, 1556, 1},\n\n      {0xa69a, 2973, 1},\n\n      {0x10c94, 3417, 1},\n\n      {0x10402, 3243, 1},\n\n      {0x1e02, 1715, 1},\n\n      {0x0402, 992, 1},\n\n      {0x0102, 174, 1},\n\n      {0x0533, 1340, 1},\n\n      {0x2c02, 2427, 1},\n\n      {0x118a2, 3516, 1},\n\n      {0x052a, 1325, 1},\n\n      {0xa694, 2964, 1},\n\n      {0x1e92, 1932, 1},\n\n      {0x0492, 1097, 1},\n\n      {0x2165, 2307, 1},\n\n      {0x1f92, 179, 2},\n\n      {0x2c92, 2613, 1},\n\n      {0x0392, 742, 1},\n\n      {0x2161, 2295, 1},\n\n      {0xab92, 1550, 1},\n\n      {0xa792, 3117, 1},\n\n      {0x10c92, 3411, 1},\n\n      {0x118b0, 3558, 1},\n\n      {0x1f5f, 2199, 1},\n\n      {0x1e8e, 1926, 1},\n\n      {0x048e, 1091, 1},\n\n      {0x018e, 453, 1},\n\n      {0x1f8e, 159, 2},\n\n      {0x2c8e, 2607, 1},\n\n      {0x038e, 833, 1},\n\n      {0xa692, 2961, 1},\n\n      {0xab8e, 1538, 1},\n\n      {0x0055, 59, 1},\n\n      {0x10c8e, 3399, 1},\n\n      {0x1f5d, 2196, 1},\n\n      {0x212a, 27, 1},\n\n      {0x04cb, 1181, 1},\n\n      {0x01cb, 425, 1},\n\n      {0x1fcb, 2241, 1},\n\n      {0x118ae, 3552, 1},\n\n      {0x0502, 1265, 1},\n\n      {0x00cb, 111, 1},\n\n      {0xa68e, 2955, 1},\n\n      {0x1e8a, 1920, 1},\n\n      {0x048a, 1085, 1},\n\n      {0x018a, 622, 1},\n\n      {0x1f8a, 139, 2},\n\n      {0x2c8a, 2601, 1},\n\n      {0x038a, 736, 1},\n\n      {0x2c67, 2571, 1},\n\n      {0xab8a, 1526, 1},\n\n      {0x1e86, 1914, 1},\n\n      {0x10c8a, 3387, 1},\n\n      {0x0186, 616, 1},\n\n      {0x1f86, 159, 2},\n\n      {0x2c86, 2595, 1},\n\n      {0x0386, 727, 1},\n\n      {0xff35, 3219, 1},\n\n      {0xab86, 1514, 1},\n\n      {0xa786, 3108, 1},\n\n      {0x10c86, 3375, 1},\n\n      {0xa68a, 2949, 1},\n\n      {0x0555, 1442, 1},\n\n      {0x1ebc, 1980, 1},\n\n      {0x04bc, 1160, 1},\n\n      {0x01bc, 411, 1},\n\n      {0x1fbc, 62, 2},\n\n      {0x2cbc, 2676, 1},\n\n      {0x1f5b, 2193, 1},\n\n      {0xa686, 2943, 1},\n\n      {0xabbc, 1676, 1},\n\n      {0x1eb8, 1974, 1},\n\n      {0x04b8, 1154, 1},\n\n      {0x01b8, 408, 1},\n\n      {0x1fb8, 2268, 1},\n\n      {0x2cb8, 2670, 1},\n\n      {0x01db, 450, 1},\n\n      {0x1fdb, 2247, 1},\n\n      {0xabb8, 1664, 1},\n\n      {0x10bc, 2829, 1},\n\n      {0x00db, 156, 1},\n\n      {0x1eb6, 1971, 1},\n\n      {0x04b6, 1151, 1},\n\n      {0xff33, 3213, 1},\n\n      {0x1fb6, 58, 2},\n\n      {0x2cb6, 2667, 1},\n\n      {0xff2a, 3186, 1},\n\n      {0x10b8, 2817, 1},\n\n      {0xabb6, 1658, 1},\n\n      {0xa7b6, 3153, 1},\n\n      {0x10426, 3351, 1},\n\n      {0x1e26, 1769, 1},\n\n      {0x0426, 956, 1},\n\n      {0x0126, 228, 1},\n\n      {0x0053, 52, 1},\n\n      {0x2c26, 2535, 1},\n\n      {0x0057, 65, 1},\n\n      {0x10b6, 2811, 1},\n\n      {0x022a, 562, 1},\n\n      {0xa726, 2982, 1},\n\n      {0x1e2e, 1781, 1},\n\n      {0x042e, 980, 1},\n\n      {0x012e, 240, 1},\n\n      {0x1f2e, 2142, 1},\n\n      {0x2c2e, 2559, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2167, 2313, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa72e, 2994, 1},\n\n      {0x1e2c, 1778, 1},\n\n      {0x042c, 974, 1},\n\n      {0x012c, 237, 1},\n\n      {0x1f2c, 2136, 1},\n\n      {0x2c2c, 2553, 1},\n\n      {0x1f6f, 2223, 1},\n\n      {0x2c6f, 604, 1},\n\n      {0xabbf, 1685, 1},\n\n      {0xa72c, 2991, 1},\n\n      {0x1e28, 1772, 1},\n\n      {0x0428, 962, 1},\n\n      {0x0128, 231, 1},\n\n      {0x1f28, 2124, 1},\n\n      {0x2c28, 2541, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0553, 1436, 1},\n\n      {0x10bf, 2838, 1},\n\n      {0xa728, 2985, 1},\n\n      {0x0526, 1319, 1},\n\n      {0x0202, 505, 1},\n\n      {0x1e40, 1808, 1},\n\n      {0x10424, 3345, 1},\n\n      {0x1e24, 1766, 1},\n\n      {0x0424, 950, 1},\n\n      {0x0124, 225, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c24, 2529, 1},\n\n      {0x052e, 1331, 1},\n\n      {0xa740, 3018, 1},\n\n      {0x118bc, 3594, 1},\n\n      {0xa724, 2979, 1},\n\n      {0x1ef2, 2061, 1},\n\n      {0x04f2, 1241, 1},\n\n      {0x01f2, 483, 1},\n\n      {0x1ff2, 257, 2},\n\n      {0x2cf2, 2742, 1},\n\n      {0x052c, 1328, 1},\n\n      {0x118b8, 3582, 1},\n\n      {0xa640, 2865, 1},\n\n      {0x10422, 3339, 1},\n\n      {0x1e22, 1763, 1},\n\n      {0x0422, 944, 1},\n\n      {0x0122, 222, 1},\n\n      {0x2126, 820, 1},\n\n      {0x2c22, 2523, 1},\n\n      {0x0528, 1322, 1},\n\n      {0x01f1, 483, 1},\n\n      {0x118b6, 3576, 1},\n\n      {0xa722, 2976, 1},\n\n      {0x03f1, 796, 1},\n\n      {0x1ebe, 1983, 1},\n\n      {0x04be, 1163, 1},\n\n      {0xfb02, 12, 2},\n\n      {0x1fbe, 767, 1},\n\n      {0x2cbe, 2679, 1},\n\n      {0x01b5, 405, 1},\n\n      {0x0540, 1379, 1},\n\n      {0xabbe, 1682, 1},\n\n      {0x0524, 1316, 1},\n\n      {0x00b5, 779, 1},\n\n      {0xabb5, 1655, 1},\n\n      {0x1eba, 1977, 1},\n\n      {0x04ba, 1157, 1},\n\n      {0x216f, 2337, 1},\n\n      {0x1fba, 2226, 1},\n\n      {0x2cba, 2673, 1},\n\n      {0x10be, 2835, 1},\n\n      {0x0051, 46, 1},\n\n      {0xabba, 1670, 1},\n\n      {0x10b5, 2808, 1},\n\n      {0x1e6e, 1878, 1},\n\n      {0x046e, 1055, 1},\n\n      {0x016e, 330, 1},\n\n      {0x1f6e, 2220, 1},\n\n      {0x2c6e, 664, 1},\n\n      {0x118bf, 3603, 1},\n\n      {0x0522, 1313, 1},\n\n      {0x10ba, 2823, 1},\n\n      {0xa76e, 3087, 1},\n\n      {0x1eb4, 1968, 1},\n\n      {0x04b4, 1148, 1},\n\n      {0x2c75, 2583, 1},\n\n      {0x1fb4, 50, 2},\n\n      {0x2cb4, 2664, 1},\n\n      {0xab75, 1463, 1},\n\n      {0x1ec2, 1989, 1},\n\n      {0xabb4, 1652, 1},\n\n      {0xa7b4, 3150, 1},\n\n      {0x1fc2, 253, 2},\n\n      {0x2cc2, 2685, 1},\n\n      {0x03c2, 800, 1},\n\n      {0x00c2, 83, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xff26, 3174, 1},\n\n      {0x10b4, 2805, 1},\n\n      {0x1eca, 2001, 1},\n\n      {0x0551, 1430, 1},\n\n      {0x01ca, 425, 1},\n\n      {0x1fca, 2238, 1},\n\n      {0x2cca, 2697, 1},\n\n      {0x10c2, 2847, 1},\n\n      {0x00ca, 108, 1},\n\n      {0xff2e, 3198, 1},\n\n      {0x1e8c, 1923, 1},\n\n      {0x048c, 1088, 1},\n\n      {0x0226, 556, 1},\n\n      {0x1f8c, 149, 2},\n\n      {0x2c8c, 2604, 1},\n\n      {0x038c, 830, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab8c, 1532, 1},\n\n      {0xff2c, 3192, 1},\n\n      {0x10c8c, 3393, 1},\n\n      {0x1ec4, 1992, 1},\n\n      {0x022e, 568, 1},\n\n      {0x01c4, 417, 1},\n\n      {0x1fc4, 54, 2},\n\n      {0x2cc4, 2688, 1},\n      {0xffffffff, -1, 0},\n\n      {0x00c4, 89, 1},\n\n      {0xff28, 3180, 1},\n\n      {0xa68c, 2952, 1},\n\n      {0x01cf, 432, 1},\n\n      {0x022c, 565, 1},\n\n      {0x118be, 3600, 1},\n\n      {0x03cf, 839, 1},\n\n      {0x00cf, 123, 1},\n\n      {0x118b5, 3573, 1},\n      {0xffffffff, -1, 0},\n\n      {0x10c4, 2853, 1},\n\n      {0x216e, 2334, 1},\n\n      {0x24cb, 2406, 1},\n\n      {0x0228, 559, 1},\n\n      {0xff24, 3168, 1},\n      {0xffffffff, -1, 0},\n\n      {0x118ba, 3588, 1},\n\n      {0x1efe, 2079, 1},\n\n      {0x04fe, 1259, 1},\n\n      {0x01fe, 499, 1},\n\n      {0x1e9e, 24, 2},\n\n      {0x049e, 1115, 1},\n\n      {0x03fe, 721, 1},\n\n      {0x1f9e, 199, 2},\n\n      {0x2c9e, 2631, 1},\n\n      {0x039e, 786, 1},\n\n      {0x0224, 553, 1},\n\n      {0xab9e, 1586, 1},\n\n      {0xa79e, 3132, 1},\n\n      {0x10c9e, 3447, 1},\n\n      {0x01f7, 414, 1},\n\n      {0x1ff7, 67, 3},\n\n      {0xff22, 3162, 1},\n\n      {0x03f7, 884, 1},\n\n      {0x118b4, 3570, 1},\n\n      {0x049c, 1112, 1},\n\n      {0x019c, 661, 1},\n\n      {0x1f9c, 189, 2},\n\n      {0x2c9c, 2628, 1},\n\n      {0x039c, 779, 1},\n\n      {0x24bc, 2361, 1},\n\n      {0xab9c, 1580, 1},\n\n      {0xa79c, 3129, 1},\n\n      {0x10c9c, 3441, 1},\n\n      {0x0222, 550, 1},\n\n      {0x1e7c, 1899, 1},\n\n      {0x047c, 1076, 1},\n\n      {0x1e82, 1908, 1},\n\n      {0x24b8, 2349, 1},\n\n      {0x0182, 357, 1},\n\n      {0x1f82, 139, 2},\n\n      {0x2c82, 2589, 1},\n\n      {0xab7c, 1484, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab82, 1502, 1},\n\n      {0xa782, 3102, 1},\n\n      {0x10c82, 3363, 1},\n\n      {0x2c63, 1709, 1},\n\n      {0x24b6, 2343, 1},\n\n      {0x1e80, 1905, 1},\n\n      {0x0480, 1082, 1},\n\n      {0x1f59, 2190, 1},\n\n      {0x1f80, 129, 2},\n\n      {0x2c80, 2586, 1},\n\n      {0x0059, 71, 1},\n\n      {0xa682, 2937, 1},\n\n      {0xab80, 1496, 1},\n\n      {0xa780, 3099, 1},\n\n      {0x10c80, 3357, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1e4c, 1826, 1},\n\n      {0x0145, 270, 1},\n\n      {0x014c, 279, 1},\n\n      {0x1f4c, 2184, 1},\n\n      {0x0345, 767, 1},\n\n      {0x0045, 12, 1},\n\n      {0x004c, 31, 1},\n\n      {0xa680, 2934, 1},\n\n      {0xa74c, 3036, 1},\n\n      {0x1e4a, 1823, 1},\n\n      {0x01d5, 441, 1},\n\n      {0x014a, 276, 1},\n\n      {0x1f4a, 2178, 1},\n\n      {0x03d5, 810, 1},\n\n      {0x00d5, 141, 1},\n\n      {0x004a, 24, 1},\n\n      {0x24bf, 2370, 1},\n\n      {0xa74a, 3033, 1},\n\n      {0xa64c, 2883, 1},\n\n      {0x1041c, 3321, 1},\n\n      {0x1e1c, 1754, 1},\n\n      {0x041c, 926, 1},\n\n      {0x011c, 213, 1},\n\n      {0x1f1c, 2118, 1},\n\n      {0x2c1c, 2505, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xa64a, 2880, 1},\n\n      {0x1041a, 3315, 1},\n\n      {0x1e1a, 1751, 1},\n\n      {0x041a, 920, 1},\n\n      {0x011a, 210, 1},\n\n      {0x1f1a, 2112, 1},\n\n      {0x2c1a, 2499, 1},\n\n      {0xabbd, 1679, 1},\n\n      {0x0545, 1394, 1},\n\n      {0x054c, 1415, 1},\n\n      {0x10418, 3309, 1},\n\n      {0x1e18, 1748, 1},\n\n      {0x0418, 914, 1},\n\n      {0x0118, 207, 1},\n\n      {0x1f18, 2106, 1},\n\n      {0x2c18, 2493, 1},\n\n      {0x10bd, 2832, 1},\n\n      {0x2163, 2301, 1},\n\n      {0x054a, 1409, 1},\n\n      {0x1040e, 3279, 1},\n\n      {0x1e0e, 1733, 1},\n\n      {0x040e, 1028, 1},\n\n      {0x010e, 192, 1},\n\n      {0x1f0e, 2100, 1},\n\n      {0x2c0e, 2463, 1},\n\n      {0x1efc, 2076, 1},\n\n      {0x04fc, 1256, 1},\n\n      {0x01fc, 496, 1},\n\n      {0x1ffc, 96, 2},\n\n      {0x051c, 1304, 1},\n\n      {0x1040c, 3273, 1},\n\n      {0x1e0c, 1730, 1},\n\n      {0x040c, 1022, 1},\n\n      {0x010c, 189, 1},\n\n      {0x1f0c, 2094, 1},\n\n      {0x2c0c, 2457, 1},\n\n      {0x1f6d, 2217, 1},\n\n      {0x2c6d, 607, 1},\n\n      {0x051a, 1301, 1},\n\n      {0x24be, 2367, 1},\n\n      {0x10408, 3261, 1},\n\n      {0x1e08, 1724, 1},\n\n      {0x0408, 1010, 1},\n\n      {0x0108, 183, 1},\n\n      {0x1f08, 2082, 1},\n\n      {0x2c08, 2445, 1},\n\n      {0x04c9, 1178, 1},\n\n      {0x0518, 1298, 1},\n\n      {0x1fc9, 2235, 1},\n      {0xffffffff, -1, 0},\n\n      {0x24ba, 2355, 1},\n\n      {0x00c9, 105, 1},\n\n      {0x10416, 3303, 1},\n\n      {0x1e16, 1745, 1},\n\n      {0x0416, 908, 1},\n\n      {0x0116, 204, 1},\n\n      {0x050e, 1283, 1},\n\n      {0x2c16, 2487, 1},\n\n      {0x10414, 3297, 1},\n\n      {0x1e14, 1742, 1},\n\n      {0x0414, 902, 1},\n\n      {0x0114, 201, 1},\n\n      {0x042b, 971, 1},\n\n      {0x2c14, 2481, 1},\n\n      {0x1f2b, 2133, 1},\n\n      {0x2c2b, 2550, 1},\n      {0xffffffff, -1, 0},\n\n      {0x050c, 1280, 1},\n\n      {0x10406, 3255, 1},\n\n      {0x1e06, 1721, 1},\n\n      {0x0406, 1004, 1},\n\n      {0x0106, 180, 1},\n\n      {0x13fb, 1697, 1},\n\n      {0x2c06, 2439, 1},\n\n      {0x24c2, 2379, 1},\n\n      {0x118bd, 3597, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0508, 1274, 1},\n\n      {0x10404, 3249, 1},\n\n      {0x1e04, 1718, 1},\n\n      {0x0404, 998, 1},\n\n      {0x0104, 177, 1},\n\n      {0x1f95, 194, 2},\n\n      {0x2c04, 2433, 1},\n\n      {0x0395, 752, 1},\n\n      {0x24ca, 2403, 1},\n\n      {0xab95, 1559, 1},\n\n      {0x0531, 1334, 1},\n\n      {0x10c95, 3420, 1},\n\n      {0x0516, 1295, 1},\n\n      {0x1e6c, 1875, 1},\n\n      {0x046c, 1052, 1},\n\n      {0x016c, 327, 1},\n\n      {0x1f6c, 2214, 1},\n\n      {0x216d, 2331, 1},\n\n      {0x0514, 1292, 1},\n\n      {0x0245, 697, 1},\n\n      {0x024c, 598, 1},\n\n      {0xa76c, 3084, 1},\n\n      {0x10400, 3237, 1},\n\n      {0x1e00, 1712, 1},\n\n      {0x0400, 986, 1},\n\n      {0x0100, 171, 1},\n\n      {0x24c4, 2385, 1},\n\n      {0x2c00, 2421, 1},\n\n      {0x0506, 1271, 1},\n\n      {0x024a, 595, 1},\n\n      {0x1fab, 224, 2},\n\n      {0xa66c, 2931, 1},\n\n      {0x03ab, 827, 1},\n\n      {0x24cf, 2418, 1},\n\n      {0xabab, 1625, 1},\n\n      {0xa7ab, 631, 1},\n\n      {0x10cab, 3486, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0504, 1268, 1},\n      {0xffffffff, -1, 0},\n\n      {0x021c, 544, 1},\n\n      {0x01a9, 679, 1},\n\n      {0x1fa9, 214, 2},\n\n      {0x10ab, 2778, 1},\n\n      {0x03a9, 820, 1},\n\n      {0x212b, 92, 1},\n\n      {0xaba9, 1619, 1},\n\n      {0x1e88, 1917, 1},\n\n      {0x10ca9, 3480, 1},\n\n      {0x021a, 541, 1},\n\n      {0x1f88, 129, 2},\n\n      {0x2c88, 2598, 1},\n\n      {0x0388, 730, 1},\n\n      {0x13fd, 1703, 1},\n\n      {0xab88, 1520, 1},\n\n      {0x10a9, 2772, 1},\n\n      {0x10c88, 3381, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0218, 538, 1},\n\n      {0x0500, 1262, 1},\n\n      {0x1f4d, 2187, 1},\n\n      {0x01a7, 393, 1},\n\n      {0x1fa7, 244, 2},\n\n      {0x004d, 34, 1},\n\n      {0x03a7, 814, 1},\n\n      {0xa688, 2946, 1},\n\n      {0xaba7, 1613, 1},\n\n      {0x020e, 523, 1},\n\n      {0x10ca7, 3474, 1},\n\n      {0x1e6a, 1872, 1},\n\n      {0x046a, 1049, 1},\n\n      {0x016a, 324, 1},\n\n      {0x1f6a, 2208, 1},\n      {0xffffffff, -1, 0},\n\n      {0x216c, 2328, 1},\n\n      {0x10a7, 2766, 1},\n\n      {0x01d1, 435, 1},\n\n      {0xa76a, 3081, 1},\n\n      {0x020c, 520, 1},\n\n      {0x03d1, 762, 1},\n\n      {0x00d1, 129, 1},\n\n      {0x1e68, 1869, 1},\n\n      {0x0468, 1046, 1},\n\n      {0x0168, 321, 1},\n\n      {0x1f68, 2202, 1},\n      {0xffffffff, -1, 0},\n\n      {0xff31, 3207, 1},\n\n      {0xa66a, 2928, 1},\n\n      {0x0208, 514, 1},\n\n      {0xa768, 3078, 1},\n\n      {0x1e64, 1863, 1},\n\n      {0x0464, 1040, 1},\n\n      {0x0164, 315, 1},\n\n      {0x054d, 1418, 1},\n\n      {0x2c64, 673, 1},\n      {0xffffffff, -1, 0},\n\n      {0xff2b, 3189, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa764, 3072, 1},\n\n      {0xa668, 2925, 1},\n\n      {0x0216, 535, 1},\n      {0xffffffff, -1, 0},\n\n      {0x118ab, 3543, 1},\n\n      {0x1e62, 1860, 1},\n\n      {0x0462, 1037, 1},\n\n      {0x0162, 312, 1},\n\n      {0x0214, 532, 1},\n\n      {0x2c62, 655, 1},\n\n      {0xa664, 2919, 1},\n\n      {0x1ed2, 2013, 1},\n\n      {0x04d2, 1193, 1},\n\n      {0xa762, 3069, 1},\n\n      {0x1fd2, 20, 3},\n\n      {0x2cd2, 2709, 1},\n\n      {0x118a9, 3537, 1},\n\n      {0x00d2, 132, 1},\n\n      {0x0206, 511, 1},\n\n      {0x10420, 3333, 1},\n\n      {0x1e20, 1760, 1},\n\n      {0x0420, 938, 1},\n\n      {0x0120, 219, 1},\n\n      {0xa662, 2916, 1},\n\n      {0x2c20, 2517, 1},\n\n      {0x1e60, 1856, 1},\n\n      {0x0460, 1034, 1},\n\n      {0x0160, 309, 1},\n\n      {0x0204, 508, 1},\n\n      {0x2c60, 2562, 1},\n      {0xffffffff, -1, 0},\n\n      {0x24bd, 2364, 1},\n\n      {0x216a, 2322, 1},\n\n      {0xa760, 3066, 1},\n      {0xffffffff, -1, 0},\n\n      {0xfb16, 125, 2},\n\n      {0x118a7, 3531, 1},\n\n      {0x1efa, 2073, 1},\n\n      {0x04fa, 1253, 1},\n\n      {0x01fa, 493, 1},\n\n      {0x1ffa, 2262, 1},\n\n      {0xfb14, 109, 2},\n\n      {0x03fa, 887, 1},\n\n      {0xa660, 2913, 1},\n\n      {0x2168, 2316, 1},\n\n      {0x01b7, 700, 1},\n\n      {0x1fb7, 10, 3},\n\n      {0x1f6b, 2211, 1},\n\n      {0x2c6b, 2577, 1},\n\n      {0x0200, 502, 1},\n\n      {0xabb7, 1661, 1},\n\n      {0xfb06, 29, 2},\n\n      {0x1e56, 1841, 1},\n\n      {0x2164, 2304, 1},\n\n      {0x0156, 294, 1},\n\n      {0x1f56, 62, 3},\n\n      {0x0520, 1310, 1},\n\n      {0x004f, 40, 1},\n\n      {0x0056, 62, 1},\n\n      {0x10b7, 2814, 1},\n\n      {0xa756, 3051, 1},\n\n      {0xfb04, 5, 3},\n\n      {0x1e78, 1893, 1},\n\n      {0x0478, 1070, 1},\n\n      {0x0178, 168, 1},\n\n      {0x1e54, 1838, 1},\n\n      {0x2162, 2298, 1},\n\n      {0x0154, 291, 1},\n\n      {0x1f54, 57, 3},\n\n      {0xab78, 1472, 1},\n\n      {0xa656, 2898, 1},\n\n      {0x0054, 56, 1},\n\n      {0x1e52, 1835, 1},\n\n      {0xa754, 3048, 1},\n\n      {0x0152, 288, 1},\n\n      {0x1f52, 52, 3},\n\n      {0x24c9, 2400, 1},\n\n      {0x1e32, 1787, 1},\n\n      {0x0052, 49, 1},\n\n      {0x0132, 243, 1},\n\n      {0xa752, 3045, 1},\n      {0xffffffff, -1, 0},\n\n      {0xfb00, 4, 2},\n\n      {0xa654, 2895, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa732, 2997, 1},\n\n      {0x2160, 2292, 1},\n\n      {0x054f, 1424, 1},\n\n      {0x0556, 1445, 1},\n\n      {0x1e50, 1832, 1},\n\n      {0xa652, 2892, 1},\n\n      {0x0150, 285, 1},\n\n      {0x1f50, 84, 2},\n\n      {0x017b, 348, 1},\n\n      {0x1e4e, 1829, 1},\n\n      {0x0050, 43, 1},\n\n      {0x014e, 282, 1},\n\n      {0xa750, 3042, 1},\n\n      {0xab7b, 1481, 1},\n\n      {0xa77b, 3093, 1},\n\n      {0x004e, 37, 1},\n\n      {0x0554, 1439, 1},\n\n      {0xa74e, 3039, 1},\n\n      {0x1e48, 1820, 1},\n      {0xffffffff, -1, 0},\n\n      {0x216b, 2325, 1},\n\n      {0x1f48, 2172, 1},\n\n      {0xa650, 2889, 1},\n\n      {0x0552, 1433, 1},\n\n      {0x0048, 21, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa748, 3030, 1},\n\n      {0xa64e, 2886, 1},\n\n      {0x0532, 1337, 1},\n\n      {0x1041e, 3327, 1},\n\n      {0x1e1e, 1757, 1},\n\n      {0x041e, 932, 1},\n\n      {0x011e, 216, 1},\n\n      {0x118b7, 3579, 1},\n\n      {0x2c1e, 2511, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa648, 2877, 1},\n\n      {0x1ff9, 2253, 1},\n      {0xffffffff, -1, 0},\n\n      {0x03f9, 878, 1},\n\n      {0x0550, 1427, 1},\n\n      {0x10412, 3291, 1},\n\n      {0x1e12, 1739, 1},\n\n      {0x0412, 896, 1},\n\n      {0x0112, 198, 1},\n\n      {0x054e, 1421, 1},\n\n      {0x2c12, 2475, 1},\n\n      {0x10410, 3285, 1},\n\n      {0x1e10, 1736, 1},\n\n      {0x0410, 890, 1},\n\n      {0x0110, 195, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c10, 2469, 1},\n\n      {0x2132, 2289, 1},\n\n      {0x0548, 1403, 1},\n\n      {0x1ef8, 2070, 1},\n\n      {0x04f8, 1250, 1},\n\n      {0x01f8, 490, 1},\n\n      {0x1ff8, 2250, 1},\n\n      {0x0220, 381, 1},\n\n      {0x1ee2, 2037, 1},\n\n      {0x04e2, 1217, 1},\n\n      {0x01e2, 462, 1},\n\n      {0x1fe2, 36, 3},\n\n      {0x2ce2, 2733, 1},\n\n      {0x03e2, 857, 1},\n\n      {0x051e, 1307, 1},\n\n      {0x1ede, 2031, 1},\n\n      {0x04de, 1211, 1},\n\n      {0x01de, 456, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2cde, 2727, 1},\n\n      {0x03de, 851, 1},\n\n      {0x00de, 165, 1},\n\n      {0x1f69, 2205, 1},\n\n      {0x2c69, 2574, 1},\n\n      {0x1eda, 2025, 1},\n\n      {0x04da, 1205, 1},\n\n      {0x0512, 1289, 1},\n\n      {0x1fda, 2244, 1},\n\n      {0x2cda, 2721, 1},\n\n      {0x03da, 845, 1},\n\n      {0x00da, 153, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0510, 1286, 1},\n\n      {0x1ed8, 2022, 1},\n\n      {0x04d8, 1202, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1fd8, 2274, 1},\n\n      {0x2cd8, 2718, 1},\n\n      {0x03d8, 842, 1},\n\n      {0x00d8, 147, 1},\n\n      {0x1ed6, 2019, 1},\n\n      {0x04d6, 1199, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1fd6, 76, 2},\n\n      {0x2cd6, 2715, 1},\n\n      {0x03d6, 792, 1},\n\n      {0x00d6, 144, 1},\n\n      {0x1ec8, 1998, 1},\n      {0xffffffff, -1, 0},\n\n      {0x01c8, 421, 1},\n\n      {0x1fc8, 2232, 1},\n\n      {0x2cc8, 2694, 1},\n\n      {0xff32, 3210, 1},\n\n      {0x00c8, 102, 1},\n\n      {0x04c7, 1175, 1},\n\n      {0x01c7, 421, 1},\n\n      {0x1fc7, 15, 3},\n\n      {0x1ec0, 1986, 1},\n\n      {0x04c0, 1187, 1},\n\n      {0x00c7, 99, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2cc0, 2682, 1},\n\n      {0x0179, 345, 1},\n\n      {0x00c0, 77, 1},\n\n      {0x0232, 574, 1},\n\n      {0x01b3, 402, 1},\n\n      {0x1fb3, 62, 2},\n\n      {0xab79, 1475, 1},\n\n      {0xa779, 3090, 1},\n\n      {0x10c7, 2859, 1},\n\n      {0xabb3, 1649, 1},\n\n      {0xa7b3, 3156, 1},\n\n      {0x1fa5, 234, 2},\n\n      {0x10c0, 2841, 1},\n\n      {0x03a5, 807, 1},\n      {0xffffffff, -1, 0},\n\n      {0xaba5, 1607, 1},\n\n      {0x01b1, 691, 1},\n\n      {0x10ca5, 3468, 1},\n\n      {0x10b3, 2802, 1},\n\n      {0x2169, 2319, 1},\n\n      {0x024e, 601, 1},\n\n      {0xabb1, 1643, 1},\n\n      {0xa7b1, 682, 1},\n\n      {0x10cb1, 3504, 1},\n\n      {0x10a5, 2760, 1},\n      {0xffffffff, -1, 0},\n\n      {0x01af, 399, 1},\n\n      {0x1faf, 244, 2},\n      {0xffffffff, -1, 0},\n\n      {0x0248, 592, 1},\n\n      {0x10b1, 2796, 1},\n\n      {0xabaf, 1637, 1},\n\n      {0x1fad, 234, 2},\n\n      {0x10caf, 3498, 1},\n\n      {0x04cd, 1184, 1},\n\n      {0x01cd, 429, 1},\n\n      {0xabad, 1631, 1},\n\n      {0xa7ad, 658, 1},\n\n      {0x10cad, 3492, 1},\n\n      {0x00cd, 117, 1},\n\n      {0x10af, 2790, 1},\n\n      {0x021e, 547, 1},\n\n      {0x1fa3, 224, 2},\n      {0xffffffff, -1, 0},\n\n      {0x03a3, 800, 1},\n\n      {0x10ad, 2784, 1},\n\n      {0xaba3, 1601, 1},\n      {0xffffffff, -1, 0},\n\n      {0x10ca3, 3462, 1},\n\n      {0x10cd, 2862, 1},\n\n      {0x1fa1, 214, 2},\n\n      {0x24b7, 2346, 1},\n\n      {0x03a1, 796, 1},\n\n      {0x0212, 529, 1},\n\n      {0xaba1, 1595, 1},\n\n      {0x10a3, 2754, 1},\n\n      {0x10ca1, 3456, 1},\n\n      {0x01d3, 438, 1},\n\n      {0x1fd3, 25, 3},\n\n      {0x0210, 526, 1},\n      {0xffffffff, -1, 0},\n\n      {0x00d3, 135, 1},\n\n      {0x1e97, 34, 2},\n\n      {0x10a1, 2748, 1},\n\n      {0x0197, 649, 1},\n\n      {0x1f97, 204, 2},\n      {0xffffffff, -1, 0},\n\n      {0x0397, 759, 1},\n\n      {0x1041d, 3324, 1},\n\n      {0xab97, 1565, 1},\n\n      {0x041d, 929, 1},\n\n      {0x10c97, 3426, 1},\n\n      {0x1f1d, 2121, 1},\n\n      {0x2c1d, 2508, 1},\n\n      {0x1e72, 1884, 1},\n\n      {0x0472, 1061, 1},\n\n      {0x0172, 336, 1},\n\n      {0x118b3, 3567, 1},\n\n      {0x2c72, 2580, 1},\n\n      {0x0372, 712, 1},\n\n      {0x1041b, 3318, 1},\n\n      {0xab72, 1454, 1},\n\n      {0x041b, 923, 1},\n\n      {0x118a5, 3525, 1},\n\n      {0x1f1b, 2115, 1},\n\n      {0x2c1b, 2502, 1},\n\n      {0x1e70, 1881, 1},\n\n      {0x0470, 1058, 1},\n\n      {0x0170, 333, 1},\n\n      {0x118b1, 3561, 1},\n\n      {0x2c70, 610, 1},\n\n      {0x0370, 709, 1},\n\n      {0x1e46, 1817, 1},\n\n      {0xab70, 1448, 1},\n\n      {0x1e66, 1866, 1},\n\n      {0x0466, 1043, 1},\n\n      {0x0166, 318, 1},\n\n      {0x1e44, 1814, 1},\n\n      {0x0046, 15, 1},\n\n      {0x118af, 3555, 1},\n\n      {0xa746, 3027, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa766, 3075, 1},\n\n      {0x0044, 9, 1},\n\n      {0x118ad, 3549, 1},\n\n      {0xa744, 3024, 1},\n\n      {0x1e7a, 1896, 1},\n\n      {0x047a, 1073, 1},\n\n      {0x1e3a, 1799, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa646, 2874, 1},\n\n      {0x1f3a, 2154, 1},\n\n      {0xa666, 2922, 1},\n\n      {0xab7a, 1478, 1},\n\n      {0x118a3, 3519, 1},\n\n      {0xa644, 2871, 1},\n\n      {0xa73a, 3009, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1ef4, 2064, 1},\n\n      {0x04f4, 1244, 1},\n\n      {0x01f4, 487, 1},\n\n      {0x1ff4, 101, 2},\n\n      {0x118a1, 3513, 1},\n\n      {0x03f4, 762, 1},\n\n      {0x1eec, 2052, 1},\n\n      {0x04ec, 1232, 1},\n\n      {0x01ec, 477, 1},\n\n      {0x1fec, 2286, 1},\n\n      {0x0546, 1397, 1},\n\n      {0x03ec, 872, 1},\n      {0xffffffff, -1, 0},\n\n      {0x013f, 261, 1},\n\n      {0x1f3f, 2169, 1},\n\n      {0x0544, 1391, 1},\n\n      {0x1eea, 2049, 1},\n\n      {0x04ea, 1229, 1},\n\n      {0x01ea, 474, 1},\n\n      {0x1fea, 2256, 1},\n      {0xffffffff, -1, 0},\n\n      {0x03ea, 869, 1},\n\n      {0x1ee8, 2046, 1},\n\n      {0x04e8, 1226, 1},\n\n      {0x01e8, 471, 1},\n\n      {0x1fe8, 2280, 1},\n\n      {0x053a, 1361, 1},\n\n      {0x03e8, 866, 1},\n\n      {0x1ee6, 2043, 1},\n\n      {0x04e6, 1223, 1},\n\n      {0x01e6, 468, 1},\n\n      {0x1fe6, 88, 2},\n\n      {0x1f4b, 2181, 1},\n\n      {0x03e6, 863, 1},\n\n      {0x1e5e, 1853, 1},\n\n      {0x004b, 27, 1},\n\n      {0x015e, 306, 1},\n\n      {0x2166, 2310, 1},\n\n      {0x1ee4, 2040, 1},\n\n      {0x04e4, 1220, 1},\n\n      {0x01e4, 465, 1},\n\n      {0x1fe4, 80, 2},\n\n      {0xa75e, 3063, 1},\n\n      {0x03e4, 860, 1},\n\n      {0x1ee0, 2034, 1},\n\n      {0x04e0, 1214, 1},\n\n      {0x01e0, 459, 1},\n\n      {0x053f, 1376, 1},\n\n      {0x2ce0, 2730, 1},\n\n      {0x03e0, 854, 1},\n\n      {0x1edc, 2028, 1},\n\n      {0x04dc, 1208, 1},\n\n      {0xa65e, 2910, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2cdc, 2724, 1},\n\n      {0x03dc, 848, 1},\n\n      {0x00dc, 159, 1},\n\n      {0x1ed0, 2010, 1},\n\n      {0x04d0, 1190, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0x2cd0, 2706, 1},\n\n      {0x03d0, 742, 1},\n\n      {0x00d0, 126, 1},\n\n      {0x1ecc, 2004, 1},\n\n      {0x054b, 1412, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1fcc, 71, 2},\n\n      {0x2ccc, 2700, 1},\n\n      {0x1ec6, 1995, 1},\n\n      {0x00cc, 114, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1fc6, 67, 2},\n\n      {0x2cc6, 2691, 1},\n\n      {0x24c8, 2397, 1},\n\n      {0x00c6, 96, 1},\n\n      {0x04c5, 1172, 1},\n\n      {0x01c5, 417, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1fbb, 2229, 1},\n\n      {0x24c7, 2394, 1},\n\n      {0x00c5, 92, 1},\n\n      {0x1fb9, 2271, 1},\n\n      {0xabbb, 1673, 1},\n\n      {0x24c0, 2373, 1},\n\n      {0x04c3, 1169, 1},\n\n      {0xabb9, 1667, 1},\n\n      {0x1fc3, 71, 2},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0x00c3, 86, 1},\n\n      {0x10c5, 2856, 1},\n\n      {0x10bb, 2826, 1},\n\n      {0x1ed4, 2016, 1},\n\n      {0x04d4, 1196, 1},\n\n      {0x10b9, 2820, 1},\n\n      {0x13fc, 1700, 1},\n\n      {0x2cd4, 2712, 1},\n\n      {0x0246, 589, 1},\n\n      {0x00d4, 138, 1},\n\n      {0x10c3, 2850, 1},\n      {0xffffffff, -1, 0},\n\n      {0xff3a, 3234, 1},\n\n      {0x0244, 688, 1},\n\n      {0x019f, 670, 1},\n\n      {0x1f9f, 204, 2},\n      {0xffffffff, -1, 0},\n\n      {0x039f, 789, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab9f, 1589, 1},\n      {0xffffffff, -1, 0},\n\n      {0x10c9f, 3450, 1},\n\n      {0x019d, 667, 1},\n\n      {0x1f9d, 194, 2},\n\n      {0x023a, 2565, 1},\n\n      {0x039d, 783, 1},\n\n      {0x1e5a, 1847, 1},\n\n      {0xab9d, 1583, 1},\n\n      {0x015a, 300, 1},\n\n      {0x10c9d, 3444, 1},\n\n      {0x1e9b, 1856, 1},\n\n      {0x24cd, 2412, 1},\n\n      {0x005a, 74, 1},\n\n      {0x1f9b, 184, 2},\n\n      {0xa75a, 3057, 1},\n\n      {0x039b, 776, 1},\n\n      {0x1ece, 2007, 1},\n\n      {0xab9b, 1577, 1},\n\n      {0x1e99, 42, 2},\n\n      {0x10c9b, 3438, 1},\n\n      {0x2cce, 2703, 1},\n\n      {0x1f99, 174, 2},\n\n      {0x00ce, 120, 1},\n\n      {0x0399, 767, 1},\n\n      {0xa65a, 2904, 1},\n\n      {0xab99, 1571, 1},\n      {0xffffffff, -1, 0},\n\n      {0x10c99, 3432, 1},\n\n      {0x0193, 634, 1},\n\n      {0x1f93, 184, 2},\n\n      {0x1e58, 1844, 1},\n\n      {0x0393, 746, 1},\n\n      {0x0158, 297, 1},\n\n      {0xab93, 1553, 1},\n      {0xffffffff, -1, 0},\n\n      {0x10c93, 3414, 1},\n\n      {0x0058, 68, 1},\n\n      {0x042d, 977, 1},\n\n      {0xa758, 3054, 1},\n\n      {0x1f2d, 2139, 1},\n\n      {0x2c2d, 2556, 1},\n\n      {0x118bb, 3591, 1},\n\n      {0x0191, 369, 1},\n\n      {0x1f91, 174, 2},\n\n      {0x118b9, 3585, 1},\n\n      {0x0391, 739, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab91, 1547, 1},\n\n      {0xa658, 2901, 1},\n\n      {0x10c91, 3408, 1},\n\n      {0x018f, 625, 1},\n\n      {0x1f8f, 164, 2},\n      {0xffffffff, -1, 0},\n\n      {0x038f, 836, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab8f, 1541, 1},\n      {0xffffffff, -1, 0},\n\n      {0x10c8f, 3402, 1},\n\n      {0x018b, 366, 1},\n\n      {0x1f8b, 144, 2},\n      {0xffffffff, -1, 0},\n\n      {0x0187, 363, 1},\n\n      {0x1f87, 164, 2},\n\n      {0xab8b, 1529, 1},\n\n      {0xa78b, 3111, 1},\n\n      {0x10c8b, 3390, 1},\n\n      {0xab87, 1517, 1},\n\n      {0x04c1, 1166, 1},\n\n      {0x10c87, 3378, 1},\n\n      {0x1e7e, 1902, 1},\n\n      {0x047e, 1079, 1},\n      {0xffffffff, -1, 0},\n\n      {0x00c1, 80, 1},\n\n      {0x2c7e, 580, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xab7e, 1490, 1},\n\n      {0xa77e, 3096, 1},\n\n      {0x1e76, 1890, 1},\n\n      {0x0476, 1067, 1},\n\n      {0x0176, 342, 1},\n\n      {0x1e42, 1811, 1},\n\n      {0x10c1, 2844, 1},\n\n      {0x0376, 715, 1},\n\n      {0x1e36, 1793, 1},\n\n      {0xab76, 1466, 1},\n\n      {0x0136, 249, 1},\n\n      {0x0042, 3, 1},\n\n      {0x1e3e, 1805, 1},\n\n      {0xa742, 3021, 1},\n\n      {0x1e38, 1796, 1},\n\n      {0x1f3e, 2166, 1},\n\n      {0xa736, 3003, 1},\n\n      {0x1f38, 2148, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0587, 105, 2},\n\n      {0xa73e, 3015, 1},\n      {0xffffffff, -1, 0},\n\n      {0xa738, 3006, 1},\n\n      {0xa642, 2868, 1},\n\n      {0x1e5c, 1850, 1},\n\n      {0x1e34, 1790, 1},\n\n      {0x015c, 303, 1},\n\n      {0x0134, 246, 1},\n\n      {0x1ef6, 2067, 1},\n\n      {0x04f6, 1247, 1},\n\n      {0x01f6, 372, 1},\n\n      {0x1ff6, 92, 2},\n\n      {0xa75c, 3060, 1},\n\n      {0xa734, 3000, 1},\n\n      {0x1ef0, 2058, 1},\n\n      {0x04f0, 1238, 1},\n\n      {0x01f0, 20, 2},\n      {0xffffffff, -1, 0},\n\n      {0x1e30, 1784, 1},\n\n      {0x03f0, 772, 1},\n\n      {0x0130, 261, 2},\n\n      {0x0542, 1385, 1},\n\n      {0xa65c, 2907, 1},\n\n      {0x1f83, 144, 2},\n\n      {0x0536, 1349, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xab83, 1505, 1},\n\n      {0x053e, 1373, 1},\n\n      {0x10c83, 3366, 1},\n\n      {0x0538, 1355, 1},\n\n      {0x1eee, 2055, 1},\n\n      {0x04ee, 1235, 1},\n\n      {0x01ee, 480, 1},\n\n      {0x1f8d, 154, 2},\n      {0xffffffff, -1, 0},\n\n      {0x03ee, 875, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab8d, 1535, 1},\n\n      {0xa78d, 643, 1},\n\n      {0x10c8d, 3396, 1},\n\n      {0x0534, 1343, 1},\n\n      {0x0181, 613, 1},\n\n      {0x1f81, 134, 2},\n\n      {0x013d, 258, 1},\n\n      {0x1f3d, 2163, 1},\n      {0xffffffff, -1, 0},\n\n      {0xab81, 1499, 1},\n\n      {0x017f, 52, 1},\n\n      {0x10c81, 3360, 1},\n\n      {0x2c7f, 583, 1},\n\n      {0x037f, 881, 1},\n\n      {0xff2d, 3195, 1},\n\n      {0xab7f, 1493, 1},\n\n      {0x1e74, 1887, 1},\n\n      {0x0474, 1064, 1},\n\n      {0x0174, 339, 1},\n\n      {0x1e3c, 1802, 1},\n\n      {0x0149, 46, 2},\n\n      {0x1f49, 2175, 1},\n\n      {0x1f3c, 2160, 1},\n\n      {0xab74, 1460, 1},\n\n      {0x0049, 3606, 1},\n\n      {0x0143, 267, 1},\n\n      {0x24cc, 2409, 1},\n\n      {0xa73c, 3012, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0043, 6, 1},\n\n      {0x0141, 264, 1},\n\n      {0x24c6, 2391, 1},\n\n      {0x013b, 255, 1},\n\n      {0x1f3b, 2157, 1},\n\n      {0x0041, 0, 1},\n\n      {0x0139, 252, 1},\n\n      {0x1f39, 2151, 1},\n\n      {0x24c5, 2388, 1},\n\n      {0x24bb, 2358, 1},\n\n      {0x13fa, 1694, 1},\n\n      {0x053d, 1370, 1},\n\n      {0x24b9, 2352, 1},\n\n      {0x0429, 965, 1},\n\n      {0x2183, 2340, 1},\n\n      {0x1f29, 2127, 1},\n\n      {0x2c29, 2544, 1},\n\n      {0x24c3, 2382, 1},\n\n      {0x10427, 3354, 1},\n\n      {0x10425, 3348, 1},\n\n      {0x0427, 959, 1},\n\n      {0x0425, 953, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c27, 2538, 1},\n\n      {0x2c25, 2532, 1},\n\n      {0x0549, 1406, 1},\n\n      {0x053c, 1367, 1},\n\n      {0x10423, 3342, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0423, 947, 1},\n\n      {0x0543, 1388, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c23, 2526, 1},\n\n      {0xff36, 3222, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0541, 1382, 1},\n\n      {0x10421, 3336, 1},\n\n      {0x053b, 1364, 1},\n\n      {0x0421, 941, 1},\n\n      {0xff38, 3228, 1},\n\n      {0x0539, 1358, 1},\n\n      {0x2c21, 2520, 1},\n\n      {0x10419, 3312, 1},\n\n      {0x10417, 3306, 1},\n\n      {0x0419, 917, 1},\n\n      {0x0417, 911, 1},\n\n      {0x1f19, 2109, 1},\n\n      {0x2c19, 2496, 1},\n\n      {0x2c17, 2490, 1},\n\n      {0x023e, 2568, 1},\n\n      {0xff34, 3216, 1},\n\n      {0x10415, 3300, 1},\n\n      {0x10413, 3294, 1},\n\n      {0x0415, 905, 1},\n\n      {0x0413, 899, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c15, 2484, 1},\n\n      {0x2c13, 2478, 1},\n      {0xffffffff, -1, 0},\n\n      {0x24ce, 2415, 1},\n\n      {0x1040f, 3282, 1},\n      {0xffffffff, -1, 0},\n\n      {0x040f, 1031, 1},\n\n      {0xff30, 3204, 1},\n\n      {0x1f0f, 2103, 1},\n\n      {0x2c0f, 2466, 1},\n\n      {0x1040d, 3276, 1},\n      {0xffffffff, -1, 0},\n\n      {0x040d, 1025, 1},\n\n      {0x0147, 273, 1},\n\n      {0x1f0d, 2097, 1},\n\n      {0x2c0d, 2460, 1},\n\n      {0x1040b, 3270, 1},\n\n      {0x0047, 18, 1},\n\n      {0x040b, 1019, 1},\n\n      {0x0230, 571, 1},\n\n      {0x1f0b, 2091, 1},\n\n      {0x2c0b, 2454, 1},\n\n      {0x10409, 3264, 1},\n\n      {0x10405, 3252, 1},\n\n      {0x0409, 1013, 1},\n\n      {0x0405, 1001, 1},\n\n      {0x1f09, 2085, 1},\n\n      {0x2c09, 2448, 1},\n\n      {0x2c05, 2436, 1},\n\n      {0x10403, 3246, 1},\n\n      {0x10401, 3240, 1},\n\n      {0x0403, 995, 1},\n\n      {0x0401, 989, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c03, 2430, 1},\n\n      {0x2c01, 2424, 1},\n\n      {0x13f9, 1691, 1},\n\n      {0x042f, 983, 1},\n      {0xffffffff, -1, 0},\n\n      {0x1f2f, 2145, 1},\n\n      {0x1041f, 3330, 1},\n      {0xffffffff, -1, 0},\n\n      {0x041f, 935, 1},\n\n      {0x023d, 378, 1},\n\n      {0x10411, 3288, 1},\n\n      {0x2c1f, 2514, 1},\n\n      {0x0411, 893, 1},\n\n      {0x0547, 1400, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c11, 2472, 1},\n\n      {0x10407, 3258, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0407, 1007, 1},\n\n      {0x24c1, 2376, 1},\n      {0xffffffff, -1, 0},\n\n      {0x2c07, 2442, 1},\n      {0xffffffff, -1, 0},\n\n      {0x13f8, 1688, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xff39, 3231, 1},\n      {0xffffffff, -1, 0},\n\n      {0x0243, 354, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0x0241, 586, 1},\n\n      {0xff29, 3183, 1},\n\n      {0x023b, 577, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xff27, 3177, 1},\n\n      {0xff25, 3171, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xff23, 3165, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xff21, 3159, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0},\n\n      {0xfb17, 117, 2},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xff2f, 3201, 1},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xfb15, 113, 2},\n\n      {0xfb13, 121, 2},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n      {0xffffffff, -1, 0},\n\n      {0xfb05, 29, 2},\n      {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0}, {0xffffffff, -1, 0},\n\n      {0xfb03, 0, 3},\n\n      {0xfb01, 8, 2}\n    };\n\n  if (0 == 0)\n    {\n      int key = hash(&code);\n\n      if (key <= MAX_HASH_VALUE && key >= 0)\n        {\n          OnigCodePoint gcode = wordlist[key].code;\n\n          if (code == gcode && wordlist[key].index >= 0)\n            return &wordlist[key];\n        }\n    }\n  return 0;\n}", "commit_link": "github.com/kkos/oniguruma/commit/166a6c3999bf06b4de0ab4ce6b088a468cc4029f", "file_name": "src/unicode_unfold_key.c", "vul_type": "cwe-787", "description": "Write a function in C that searches for a Unicode code point in a static array using a hash lookup."}
{"func_name": "__rds_rdma_map", "func_src_before": "static int __rds_rdma_map(struct rds_sock *rs, struct rds_get_mr_args *args,\n\t\t\t\tu64 *cookie_ret, struct rds_mr **mr_ret)\n{\n\tstruct rds_mr *mr = NULL, *found;\n\tunsigned int nr_pages;\n\tstruct page **pages = NULL;\n\tstruct scatterlist *sg;\n\tvoid *trans_private;\n\tunsigned long flags;\n\trds_rdma_cookie_t cookie;\n\tunsigned int nents;\n\tlong i;\n\tint ret;\n\n\tif (rs->rs_bound_addr == 0) {\n\t\tret = -ENOTCONN; /* XXX not a great errno */\n\t\tgoto out;\n\t}\n\n\tif (!rs->rs_transport->get_mr) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tnr_pages = rds_pages_in_vec(&args->vec);\n\tif (nr_pages == 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Restrict the size of mr irrespective of underlying transport\n\t * To account for unaligned mr regions, subtract one from nr_pages\n\t */\n\tif ((nr_pages - 1) > (RDS_MAX_MSG_SIZE >> PAGE_SHIFT)) {\n\t\tret = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\trdsdebug(\"RDS: get_mr addr %llx len %llu nr_pages %u\\n\",\n\t\targs->vec.addr, args->vec.bytes, nr_pages);\n\n\t/* XXX clamp nr_pages to limit the size of this alloc? */\n\tpages = kcalloc(nr_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmr = kzalloc(sizeof(struct rds_mr), GFP_KERNEL);\n\tif (!mr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trefcount_set(&mr->r_refcount, 1);\n\tRB_CLEAR_NODE(&mr->r_rb_node);\n\tmr->r_trans = rs->rs_transport;\n\tmr->r_sock = rs;\n\n\tif (args->flags & RDS_RDMA_USE_ONCE)\n\t\tmr->r_use_once = 1;\n\tif (args->flags & RDS_RDMA_INVALIDATE)\n\t\tmr->r_invalidate = 1;\n\tif (args->flags & RDS_RDMA_READWRITE)\n\t\tmr->r_write = 1;\n\n\t/*\n\t * Pin the pages that make up the user buffer and transfer the page\n\t * pointers to the mr's sg array.  We check to see if we've mapped\n\t * the whole region after transferring the partial page references\n\t * to the sg array so that we can have one page ref cleanup path.\n\t *\n\t * For now we have no flag that tells us whether the mapping is\n\t * r/o or r/w. We need to assume r/w, or we'll do a lot of RDMA to\n\t * the zero page.\n\t */\n\tret = rds_pin_pages(args->vec.addr, nr_pages, pages, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnents = ret;\n\tsg = kcalloc(nents, sizeof(*sg), GFP_KERNEL);\n\tif (!sg) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tWARN_ON(!nents);\n\tsg_init_table(sg, nents);\n\n\t/* Stick all pages into the scatterlist */\n\tfor (i = 0 ; i < nents; i++)\n\t\tsg_set_page(&sg[i], pages[i], PAGE_SIZE, 0);\n\n\trdsdebug(\"RDS: trans_private nents is %u\\n\", nents);\n\n\t/* Obtain a transport specific MR. If this succeeds, the\n\t * s/g list is now owned by the MR.\n\t * Note that dma_map() implies that pending writes are\n\t * flushed to RAM, so no dma_sync is needed here. */\n\ttrans_private = rs->rs_transport->get_mr(sg, nents, rs,\n\t\t\t\t\t\t &mr->r_key);\n\n\tif (IS_ERR(trans_private)) {\n\t\tfor (i = 0 ; i < nents; i++)\n\t\t\tput_page(sg_page(&sg[i]));\n\t\tkfree(sg);\n\t\tret = PTR_ERR(trans_private);\n\t\tgoto out;\n\t}\n\n\tmr->r_trans_private = trans_private;\n\n\trdsdebug(\"RDS: get_mr put_user key is %x cookie_addr %p\\n\",\n\t       mr->r_key, (void *)(unsigned long) args->cookie_addr);\n\n\t/* The user may pass us an unaligned address, but we can only\n\t * map page aligned regions. So we keep the offset, and build\n\t * a 64bit cookie containing <R_Key, offset> and pass that\n\t * around. */\n\tcookie = rds_rdma_make_cookie(mr->r_key, args->vec.addr & ~PAGE_MASK);\n\tif (cookie_ret)\n\t\t*cookie_ret = cookie;\n\n\tif (args->cookie_addr && put_user(cookie, (u64 __user *)(unsigned long) args->cookie_addr)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/* Inserting the new MR into the rbtree bumps its\n\t * reference count. */\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\tfound = rds_mr_tree_walk(&rs->rs_rdma_keys, mr->r_key, mr);\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\n\tBUG_ON(found && found != mr);\n\n\trdsdebug(\"RDS: get_mr key is %x\\n\", mr->r_key);\n\tif (mr_ret) {\n\t\trefcount_inc(&mr->r_refcount);\n\t\t*mr_ret = mr;\n\t}\n\n\tret = 0;\nout:\n\tkfree(pages);\n\tif (mr)\n\t\trds_mr_put(mr);\n\treturn ret;\n}", "func_src_after": "static int __rds_rdma_map(struct rds_sock *rs, struct rds_get_mr_args *args,\n\t\t\t\tu64 *cookie_ret, struct rds_mr **mr_ret)\n{\n\tstruct rds_mr *mr = NULL, *found;\n\tunsigned int nr_pages;\n\tstruct page **pages = NULL;\n\tstruct scatterlist *sg;\n\tvoid *trans_private;\n\tunsigned long flags;\n\trds_rdma_cookie_t cookie;\n\tunsigned int nents;\n\tlong i;\n\tint ret;\n\n\tif (rs->rs_bound_addr == 0 || !rs->rs_transport) {\n\t\tret = -ENOTCONN; /* XXX not a great errno */\n\t\tgoto out;\n\t}\n\n\tif (!rs->rs_transport->get_mr) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tnr_pages = rds_pages_in_vec(&args->vec);\n\tif (nr_pages == 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Restrict the size of mr irrespective of underlying transport\n\t * To account for unaligned mr regions, subtract one from nr_pages\n\t */\n\tif ((nr_pages - 1) > (RDS_MAX_MSG_SIZE >> PAGE_SHIFT)) {\n\t\tret = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\trdsdebug(\"RDS: get_mr addr %llx len %llu nr_pages %u\\n\",\n\t\targs->vec.addr, args->vec.bytes, nr_pages);\n\n\t/* XXX clamp nr_pages to limit the size of this alloc? */\n\tpages = kcalloc(nr_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmr = kzalloc(sizeof(struct rds_mr), GFP_KERNEL);\n\tif (!mr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trefcount_set(&mr->r_refcount, 1);\n\tRB_CLEAR_NODE(&mr->r_rb_node);\n\tmr->r_trans = rs->rs_transport;\n\tmr->r_sock = rs;\n\n\tif (args->flags & RDS_RDMA_USE_ONCE)\n\t\tmr->r_use_once = 1;\n\tif (args->flags & RDS_RDMA_INVALIDATE)\n\t\tmr->r_invalidate = 1;\n\tif (args->flags & RDS_RDMA_READWRITE)\n\t\tmr->r_write = 1;\n\n\t/*\n\t * Pin the pages that make up the user buffer and transfer the page\n\t * pointers to the mr's sg array.  We check to see if we've mapped\n\t * the whole region after transferring the partial page references\n\t * to the sg array so that we can have one page ref cleanup path.\n\t *\n\t * For now we have no flag that tells us whether the mapping is\n\t * r/o or r/w. We need to assume r/w, or we'll do a lot of RDMA to\n\t * the zero page.\n\t */\n\tret = rds_pin_pages(args->vec.addr, nr_pages, pages, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnents = ret;\n\tsg = kcalloc(nents, sizeof(*sg), GFP_KERNEL);\n\tif (!sg) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tWARN_ON(!nents);\n\tsg_init_table(sg, nents);\n\n\t/* Stick all pages into the scatterlist */\n\tfor (i = 0 ; i < nents; i++)\n\t\tsg_set_page(&sg[i], pages[i], PAGE_SIZE, 0);\n\n\trdsdebug(\"RDS: trans_private nents is %u\\n\", nents);\n\n\t/* Obtain a transport specific MR. If this succeeds, the\n\t * s/g list is now owned by the MR.\n\t * Note that dma_map() implies that pending writes are\n\t * flushed to RAM, so no dma_sync is needed here. */\n\ttrans_private = rs->rs_transport->get_mr(sg, nents, rs,\n\t\t\t\t\t\t &mr->r_key);\n\n\tif (IS_ERR(trans_private)) {\n\t\tfor (i = 0 ; i < nents; i++)\n\t\t\tput_page(sg_page(&sg[i]));\n\t\tkfree(sg);\n\t\tret = PTR_ERR(trans_private);\n\t\tgoto out;\n\t}\n\n\tmr->r_trans_private = trans_private;\n\n\trdsdebug(\"RDS: get_mr put_user key is %x cookie_addr %p\\n\",\n\t       mr->r_key, (void *)(unsigned long) args->cookie_addr);\n\n\t/* The user may pass us an unaligned address, but we can only\n\t * map page aligned regions. So we keep the offset, and build\n\t * a 64bit cookie containing <R_Key, offset> and pass that\n\t * around. */\n\tcookie = rds_rdma_make_cookie(mr->r_key, args->vec.addr & ~PAGE_MASK);\n\tif (cookie_ret)\n\t\t*cookie_ret = cookie;\n\n\tif (args->cookie_addr && put_user(cookie, (u64 __user *)(unsigned long) args->cookie_addr)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/* Inserting the new MR into the rbtree bumps its\n\t * reference count. */\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\tfound = rds_mr_tree_walk(&rs->rs_rdma_keys, mr->r_key, mr);\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\n\tBUG_ON(found && found != mr);\n\n\trdsdebug(\"RDS: get_mr key is %x\\n\", mr->r_key);\n\tif (mr_ret) {\n\t\trefcount_inc(&mr->r_refcount);\n\t\t*mr_ret = mr;\n\t}\n\n\tret = 0;\nout:\n\tkfree(pages);\n\tif (mr)\n\t\trds_mr_put(mr);\n\treturn ret;\n}", "commit_link": "github.com/torvalds/linux/commit/f3069c6d33f6ae63a1668737bc78aaaa51bff7ca", "file_name": "net/rds/rdma.c", "vul_type": "cwe-476", "description": "Write a C function named `__rds_rdma_map` that maps a user buffer for RDMA operations and returns a cookie for the mapped memory region."}
{"func_name": "manipulate_reservation_action", "func_src_before": "def manipulate_reservation_action(request: HttpRequest, default_foreward_url: str):\n    \"\"\"\n    This function is used to alter the reservation beeing build inside\n    a cookie. This function automatically crafts the required response.\n    \"\"\"\n    js_string: str = \"\"\n    r: GroupReservation = None\n    u: Profile = get_current_user(request)\n    forward_url: str = default_foreward_url\n    if request.GET.get(\"redirect\"):\n        forward_url = request.GET[\"redirect\"]\n    if \"srid\" in request.GET:\n        if not request.GET.get(\"rid\"):\n            return HttpResponseRedirect(\"/admin?error=missing%20primary%20reservation%20id\")\n        srid: int = int(request.GET[\"srid\"])\n        sr: SubReservation = None\n        if srid == 0:\n            sr = SubReservation()\n        else:\n            sr = SubReservation.objects.get(id=srid)\n        if request.POST.get(\"notes\"):\n            sr.notes = request.POST[\"notes\"]\n        else:\n            sr.notes = \" \"\n        sr.primary_reservation = GroupReservation.objects.get(id=int(request.GET[\"rid\"]))\n        sr.save()\n        print(request.POST)\n        print(sr.notes)\n        return HttpResponseRedirect(\"/admin/reservations/edit?rid=\" + str(int(request.GET[\"rid\"])) + \"&srid=\" + str(sr.id))\n    if \"rid\" in request.GET:\n        # update reservation\n        r = GroupReservation.objects.get(id=int(request.GET[\"rid\"]))\n    elif u.number_of_allowed_reservations > GroupReservation.objects.all().filter(createdByUser=u).count():\n        r = GroupReservation()\n        r.createdByUser = u\n        r.ready = False\n        r.open = True\n        r.pickupDate = datetime.datetime.now()\n    else:\n        return HttpResponseRedirect(\"/admin?error=Too%20Many%20reservations\")\n    if request.POST.get(\"notes\"):\n        r.notes = request.POST[\"notes\"]\n    if request.POST.get(\"contact\"):\n        r.responsiblePerson = str(request.POST[\"contact\"])\n    if (r.createdByUser == u or o.rights > 1) and not r.submitted:\n        r.save()\n    else:\n        return HttpResponseRedirect(\"/admin?error=noyb\")\n    response: HttpResponseRedirect = HttpResponseRedirect(forward_url + \"?rid=\" + str(r.id))\n    return response", "func_src_after": "def manipulate_reservation_action(request: HttpRequest, default_foreward_url: str):\n    \"\"\"\n    This function is used to alter the reservation beeing build inside\n    a cookie. This function automatically crafts the required response.\n    \"\"\"\n    js_string: str = \"\"\n    r: GroupReservation = None\n    u: Profile = get_current_user(request)\n    forward_url: str = default_foreward_url\n    if request.GET.get(\"redirect\"):\n        forward_url = request.GET[\"redirect\"]\n    if \"srid\" in request.GET:\n        if not request.GET.get(\"rid\"):\n            return HttpResponseRedirect(\"/admin?error=missing%20primary%20reservation%20id\")\n        srid: int = int(request.GET[\"srid\"])\n        sr: SubReservation = None\n        if srid == 0:\n            sr = SubReservation()\n        else:\n            sr = SubReservation.objects.get(id=srid)\n        if request.POST.get(\"notes\"):\n            sr.notes = escape(request.POST[\"notes\"])\n        else:\n            sr.notes = \" \"\n        sr.primary_reservation = GroupReservation.objects.get(id=int(request.GET[\"rid\"]))\n        sr.save()\n        print(request.POST)\n        print(sr.notes)\n        return HttpResponseRedirect(\"/admin/reservations/edit?rid=\" + str(int(request.GET[\"rid\"])) + \"&srid=\" + str(sr.id))\n    if \"rid\" in request.GET:\n        # update reservation\n        r = GroupReservation.objects.get(id=int(request.GET[\"rid\"]))\n    elif u.number_of_allowed_reservations > GroupReservation.objects.all().filter(createdByUser=u).count():\n        r = GroupReservation()\n        r.createdByUser = u\n        r.ready = False\n        r.open = True\n        r.pickupDate = datetime.datetime.now()\n    else:\n        return HttpResponseRedirect(\"/admin?error=Too%20Many%20reservations\")\n    if request.POST.get(\"notes\"):\n        r.notes = escape(request.POST[\"notes\"])\n    if request.POST.get(\"contact\"):\n        r.responsiblePerson = escape(str(request.POST[\"contact\"]))\n    if (r.createdByUser == u or o.rights > 1) and not r.submitted:\n        r.save()\n    else:\n        return HttpResponseRedirect(\"/admin?error=noyb\")\n    response: HttpResponseRedirect = HttpResponseRedirect(forward_url + \"?rid=\" + str(r.id))\n    return response", "commit_link": "github.com/Technikradio/C3FOCSite/commit/6e330d4d44bbfdfce9993dffea97008276771600", "file_name": "c3shop/frontpage/management/reservation_actions.py", "vul_type": "cwe-079", "description": "Write a Python function to handle reservation modifications and redirection based on user input from a web request."}
{"func_name": "zmi_page_request", "func_src_before": "    def zmi_page_request(self, *args, **kwargs):\r\n      request = self.REQUEST\r\n      RESPONSE = request.RESPONSE\r\n      SESSION = request.SESSION\r\n      self._zmi_page_request()\r\n      RESPONSE.setHeader('Expires',DateTime(request['ZMI_TIME']-10000).toZone('GMT+1').rfc822())\r\n      RESPONSE.setHeader('Cache-Control', 'no-cache')\r\n      RESPONSE.setHeader('Pragma', 'no-cache')\r\n      RESPONSE.setHeader('Content-Type', 'text/html;charset=%s'%request['ZMS_CHARSET'])\r\n      if not request.get( 'preview'):\r\n        request.set( 'preview','preview')\r\n      langs = self.getLanguages(request)\r\n      if request.get('lang') not in langs:\r\n        request.set('lang',langs[0])\r\n      if request.get('manage_lang') not in self.getLocale().get_manage_langs():\r\n        request.set('manage_lang',self.get_manage_lang())\r\n      if not request.get('manage_tabs_message'):\r\n        request.set( 'manage_tabs_message',self.getConfProperty('ZMS.manage_tabs_message',''))\r\n      # manage_system\r\n      if request.form.has_key('zmi-manage-system'):\r\n        request.SESSION.set('zmi-manage-system',int(request.get('zmi-manage-system')))\r\n      # avoid declarative urls\r\n      physical_path = self.getPhysicalPath()\r\n      path_to_handle = request['URL0'][len(request['BASE0']):].split('/')\r\n      path = path_to_handle[:-1]\r\n      if len(filter(lambda x:x.find('.')>0 or x.startswith('manage_'),path))==0:\r\n        for i in range(len(path)):\r\n          if path[:-(i+1)] != physical_path[:-(i+1)]:\r\n            path[:-(i+1)] = physical_path[:-(i+1)]\r\n        new_path = path+[path_to_handle[-1]]\r\n        if path_to_handle != new_path:\r\n          request.RESPONSE.redirect('/'.join(new_path))", "func_src_after": "    def zmi_page_request(self, *args, **kwargs):\r\n      request = self.REQUEST\r\n      RESPONSE = request.RESPONSE\r\n      SESSION = request.SESSION\r\n      self._zmi_page_request()\r\n      RESPONSE.setHeader('Expires',DateTime(request['ZMI_TIME']-10000).toZone('GMT+1').rfc822())\r\n      RESPONSE.setHeader('Cache-Control', 'no-cache')\r\n      RESPONSE.setHeader('Pragma', 'no-cache')\r\n      RESPONSE.setHeader('Content-Type', 'text/html;charset=%s'%request['ZMS_CHARSET'])\r\n      if not request.get( 'preview'):\r\n        request.set( 'preview','preview')\r\n      langs = self.getLanguages(request)\r\n      if request.get('lang') not in langs:\r\n        request.set('lang',langs[0])\r\n      if request.get('manage_lang') not in self.getLocale().get_manage_langs():\r\n        request.set('manage_lang',self.get_manage_lang())\r\n      if not request.get('manage_tabs_message'):\r\n        request.set( 'manage_tabs_message',self.getConfProperty('ZMS.manage_tabs_message',''))\r\n      # manage_system\r\n      if request.form.has_key('zmi-manage-system'):\r\n        request.SESSION.set('zmi-manage-system',int(request.get('zmi-manage-system')))\r\n      # avoid declarative urls\r\n      physical_path = self.getPhysicalPath()\r\n      path_to_handle = request['URL0'][len(request['BASE0']):].split('/')\r\n      path = path_to_handle[:-1]\r\n      if self.getDocumentElement().id in path and len(filter(lambda x:x.find('.')>0 or x.startswith('manage_'),path))==0:\r\n        for i in range(len(path)):\r\n          if path[:-(i+1)] != physical_path[:-(i+1)]:\r\n            path[:-(i+1)] = physical_path[:-(i+1)]\r\n        new_path = path+[path_to_handle[-1]]\r\n        if path_to_handle != new_path:\r\n          request.RESPONSE.redirect('/'.join(new_path))", "commit_link": "github.com/zms-publishing/zms4/commit/3f28620d475220dfdb06f79787158ac50727c61a", "file_name": "ZMSItem.py", "vul_type": "cwe-022", "description": "Write a Python function named `zmi_page_request` that modifies HTTP response headers, manages session variables, and redirects to a normalized URL if necessary."}
{"func_name": "__init__", "func_src_before": "    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Takes two additional keyword arguments:\n\n        :param cartpos: The cart position the form should be for\n        :param event: The event this belongs to\n        \"\"\"\n        cartpos = self.cartpos = kwargs.pop('cartpos', None)\n        orderpos = self.orderpos = kwargs.pop('orderpos', None)\n        pos = cartpos or orderpos\n        item = pos.item\n        questions = pos.item.questions_to_ask\n        event = kwargs.pop('event')\n\n        super().__init__(*args, **kwargs)\n\n        if item.admission and event.settings.attendee_names_asked:\n            self.fields['attendee_name_parts'] = NamePartsFormField(\n                max_length=255,\n                required=event.settings.attendee_names_required,\n                scheme=event.settings.name_scheme,\n                label=_('Attendee name'),\n                initial=(cartpos.attendee_name_parts if cartpos else orderpos.attendee_name_parts),\n            )\n        if item.admission and event.settings.attendee_emails_asked:\n            self.fields['attendee_email'] = forms.EmailField(\n                required=event.settings.attendee_emails_required,\n                label=_('Attendee email'),\n                initial=(cartpos.attendee_email if cartpos else orderpos.attendee_email)\n            )\n\n        for q in questions:\n            # Do we already have an answer? Provide it as the initial value\n            answers = [a for a in pos.answerlist if a.question_id == q.id]\n            if answers:\n                initial = answers[0]\n            else:\n                initial = None\n            tz = pytz.timezone(event.settings.timezone)\n            help_text = rich_text(q.help_text)\n            if q.type == Question.TYPE_BOOLEAN:\n                if q.required:\n                    # For some reason, django-bootstrap3 does not set the required attribute\n                    # itself.\n                    widget = forms.CheckboxInput(attrs={'required': 'required'})\n                else:\n                    widget = forms.CheckboxInput()\n\n                if initial:\n                    initialbool = (initial.answer == \"True\")\n                else:\n                    initialbool = False\n\n                field = forms.BooleanField(\n                    label=q.question, required=q.required,\n                    help_text=help_text,\n                    initial=initialbool, widget=widget,\n                )\n            elif q.type == Question.TYPE_NUMBER:\n                field = forms.DecimalField(\n                    label=q.question, required=q.required,\n                    help_text=q.help_text,\n                    initial=initial.answer if initial else None,\n                    min_value=Decimal('0.00'),\n                )\n            elif q.type == Question.TYPE_STRING:\n                field = forms.CharField(\n                    label=q.question, required=q.required,\n                    help_text=help_text,\n                    initial=initial.answer if initial else None,\n                )\n            elif q.type == Question.TYPE_TEXT:\n                field = forms.CharField(\n                    label=q.question, required=q.required,\n                    help_text=help_text,\n                    widget=forms.Textarea,\n                    initial=initial.answer if initial else None,\n                )\n            elif q.type == Question.TYPE_CHOICE:\n                field = forms.ModelChoiceField(\n                    queryset=q.options,\n                    label=q.question, required=q.required,\n                    help_text=help_text,\n                    widget=forms.Select,\n                    empty_label='',\n                    initial=initial.options.first() if initial else None,\n                )\n            elif q.type == Question.TYPE_CHOICE_MULTIPLE:\n                field = forms.ModelMultipleChoiceField(\n                    queryset=q.options,\n                    label=q.question, required=q.required,\n                    help_text=help_text,\n                    widget=forms.CheckboxSelectMultiple,\n                    initial=initial.options.all() if initial else None,\n                )\n            elif q.type == Question.TYPE_FILE:\n                field = forms.FileField(\n                    label=q.question, required=q.required,\n                    help_text=help_text,\n                    initial=initial.file if initial else None,\n                    widget=UploadedFileWidget(position=pos, event=event, answer=initial),\n                )\n            elif q.type == Question.TYPE_DATE:\n                field = forms.DateField(\n                    label=q.question, required=q.required,\n                    help_text=help_text,\n                    initial=dateutil.parser.parse(initial.answer).date() if initial and initial.answer else None,\n                    widget=DatePickerWidget(),\n                )\n            elif q.type == Question.TYPE_TIME:\n                field = forms.TimeField(\n                    label=q.question, required=q.required,\n                    help_text=help_text,\n                    initial=dateutil.parser.parse(initial.answer).time() if initial and initial.answer else None,\n                    widget=TimePickerWidget(time_format=get_format_without_seconds('TIME_INPUT_FORMATS')),\n                )\n            elif q.type == Question.TYPE_DATETIME:\n                field = SplitDateTimeField(\n                    label=q.question, required=q.required,\n                    help_text=help_text,\n                    initial=dateutil.parser.parse(initial.answer).astimezone(tz) if initial and initial.answer else None,\n                    widget=SplitDateTimePickerWidget(time_format=get_format_without_seconds('TIME_INPUT_FORMATS')),\n                )\n            field.question = q\n            if answers:\n                # Cache the answer object for later use\n                field.answer = answers[0]\n            self.fields['question_%s' % q.id] = field\n\n        responses = question_form_fields.send(sender=event, position=pos)\n        data = pos.meta_info_data\n        for r, response in sorted(responses, key=lambda r: str(r[0])):\n            for key, value in response.items():\n                # We need to be this explicit, since OrderedDict.update does not retain ordering\n                self.fields[key] = value\n                value.initial = data.get('question_form_data', {}).get(key)", "func_src_after": "    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Takes two additional keyword arguments:\n\n        :param cartpos: The cart position the form should be for\n        :param event: The event this belongs to\n        \"\"\"\n        cartpos = self.cartpos = kwargs.pop('cartpos', None)\n        orderpos = self.orderpos = kwargs.pop('orderpos', None)\n        pos = cartpos or orderpos\n        item = pos.item\n        questions = pos.item.questions_to_ask\n        event = kwargs.pop('event')\n\n        super().__init__(*args, **kwargs)\n\n        if item.admission and event.settings.attendee_names_asked:\n            self.fields['attendee_name_parts'] = NamePartsFormField(\n                max_length=255,\n                required=event.settings.attendee_names_required,\n                scheme=event.settings.name_scheme,\n                label=_('Attendee name'),\n                initial=(cartpos.attendee_name_parts if cartpos else orderpos.attendee_name_parts),\n            )\n        if item.admission and event.settings.attendee_emails_asked:\n            self.fields['attendee_email'] = forms.EmailField(\n                required=event.settings.attendee_emails_required,\n                label=_('Attendee email'),\n                initial=(cartpos.attendee_email if cartpos else orderpos.attendee_email)\n            )\n\n        for q in questions:\n            # Do we already have an answer? Provide it as the initial value\n            answers = [a for a in pos.answerlist if a.question_id == q.id]\n            if answers:\n                initial = answers[0]\n            else:\n                initial = None\n            tz = pytz.timezone(event.settings.timezone)\n            help_text = rich_text(q.help_text)\n            label = escape(q.question)  # django-bootstrap3 calls mark_safe\n            if q.type == Question.TYPE_BOOLEAN:\n                if q.required:\n                    # For some reason, django-bootstrap3 does not set the required attribute\n                    # itself.\n                    widget = forms.CheckboxInput(attrs={'required': 'required'})\n                else:\n                    widget = forms.CheckboxInput()\n\n                if initial:\n                    initialbool = (initial.answer == \"True\")\n                else:\n                    initialbool = False\n\n                field = forms.BooleanField(\n                    label=label, required=q.required,\n                    help_text=help_text,\n                    initial=initialbool, widget=widget,\n                )\n            elif q.type == Question.TYPE_NUMBER:\n                field = forms.DecimalField(\n                    label=label, required=q.required,\n                    help_text=q.help_text,\n                    initial=initial.answer if initial else None,\n                    min_value=Decimal('0.00'),\n                )\n            elif q.type == Question.TYPE_STRING:\n                field = forms.CharField(\n                    label=label, required=q.required,\n                    help_text=help_text,\n                    initial=initial.answer if initial else None,\n                )\n            elif q.type == Question.TYPE_TEXT:\n                field = forms.CharField(\n                    label=label, required=q.required,\n                    help_text=help_text,\n                    widget=forms.Textarea,\n                    initial=initial.answer if initial else None,\n                )\n            elif q.type == Question.TYPE_CHOICE:\n                field = forms.ModelChoiceField(\n                    queryset=q.options,\n                    label=label, required=q.required,\n                    help_text=help_text,\n                    widget=forms.Select,\n                    empty_label='',\n                    initial=initial.options.first() if initial else None,\n                )\n            elif q.type == Question.TYPE_CHOICE_MULTIPLE:\n                field = forms.ModelMultipleChoiceField(\n                    queryset=q.options,\n                    label=label, required=q.required,\n                    help_text=help_text,\n                    widget=forms.CheckboxSelectMultiple,\n                    initial=initial.options.all() if initial else None,\n                )\n            elif q.type == Question.TYPE_FILE:\n                field = forms.FileField(\n                    label=label, required=q.required,\n                    help_text=help_text,\n                    initial=initial.file if initial else None,\n                    widget=UploadedFileWidget(position=pos, event=event, answer=initial),\n                )\n            elif q.type == Question.TYPE_DATE:\n                field = forms.DateField(\n                    label=label, required=q.required,\n                    help_text=help_text,\n                    initial=dateutil.parser.parse(initial.answer).date() if initial and initial.answer else None,\n                    widget=DatePickerWidget(),\n                )\n            elif q.type == Question.TYPE_TIME:\n                field = forms.TimeField(\n                    label=label, required=q.required,\n                    help_text=help_text,\n                    initial=dateutil.parser.parse(initial.answer).time() if initial and initial.answer else None,\n                    widget=TimePickerWidget(time_format=get_format_without_seconds('TIME_INPUT_FORMATS')),\n                )\n            elif q.type == Question.TYPE_DATETIME:\n                field = SplitDateTimeField(\n                    label=label, required=q.required,\n                    help_text=help_text,\n                    initial=dateutil.parser.parse(initial.answer).astimezone(tz) if initial and initial.answer else None,\n                    widget=SplitDateTimePickerWidget(time_format=get_format_without_seconds('TIME_INPUT_FORMATS')),\n                )\n            field.question = q\n            if answers:\n                # Cache the answer object for later use\n                field.answer = answers[0]\n            self.fields['question_%s' % q.id] = field\n\n        responses = question_form_fields.send(sender=event, position=pos)\n        data = pos.meta_info_data\n        for r, response in sorted(responses, key=lambda r: str(r[0])):\n            for key, value in response.items():\n                # We need to be this explicit, since OrderedDict.update does not retain ordering\n                self.fields[key] = value\n                value.initial = data.get('question_form_data', {}).get(key)", "commit_link": "github.com/pretix/pretix/commit/affc6254a8316643d4afe9e8b7f8cd288c86ca1f", "file_name": "src/pretix/base/forms/questions.py", "vul_type": "cwe-079", "description": "Write a Python class initializer that processes event-related form fields with dynamic question types and initial values."}
{"func_name": "amqp_handle_input", "func_src_before": "int amqp_handle_input(amqp_connection_state_t state, amqp_bytes_t received_data,\n                      amqp_frame_t *decoded_frame) {\n  size_t bytes_consumed;\n  void *raw_frame;\n\n  /* Returning frame_type of zero indicates either insufficient input,\n     or a complete, ignored frame was read. */\n  decoded_frame->frame_type = 0;\n\n  if (received_data.len == 0) {\n    return AMQP_STATUS_OK;\n  }\n\n  if (state->state == CONNECTION_STATE_IDLE) {\n    state->state = CONNECTION_STATE_HEADER;\n  }\n\n  bytes_consumed = consume_data(state, &received_data);\n\n  /* do we have target_size data yet? if not, return with the\n     expectation that more will arrive */\n  if (state->inbound_offset < state->target_size) {\n    return (int)bytes_consumed;\n  }\n\n  raw_frame = state->inbound_buffer.bytes;\n\n  switch (state->state) {\n    case CONNECTION_STATE_INITIAL:\n      /* check for a protocol header from the server */\n      if (memcmp(raw_frame, \"AMQP\", 4) == 0) {\n        decoded_frame->frame_type = AMQP_PSEUDOFRAME_PROTOCOL_HEADER;\n        decoded_frame->channel = 0;\n\n        decoded_frame->payload.protocol_header.transport_high =\n            amqp_d8(amqp_offset(raw_frame, 4));\n        decoded_frame->payload.protocol_header.transport_low =\n            amqp_d8(amqp_offset(raw_frame, 5));\n        decoded_frame->payload.protocol_header.protocol_version_major =\n            amqp_d8(amqp_offset(raw_frame, 6));\n        decoded_frame->payload.protocol_header.protocol_version_minor =\n            amqp_d8(amqp_offset(raw_frame, 7));\n\n        return_to_idle(state);\n        return (int)bytes_consumed;\n      }\n\n    /* it's not a protocol header; fall through to process it as a\n       regular frame header */\n\n    case CONNECTION_STATE_HEADER: {\n      amqp_channel_t channel;\n      amqp_pool_t *channel_pool;\n      /* frame length is 3 bytes in */\n      channel = amqp_d16(amqp_offset(raw_frame, 1));\n\n      state->target_size =\n          amqp_d32(amqp_offset(raw_frame, 3)) + HEADER_SIZE + FOOTER_SIZE;\n\n      if ((size_t)state->frame_max < state->target_size) {\n        return AMQP_STATUS_BAD_AMQP_DATA;\n      }\n\n      channel_pool = amqp_get_or_create_channel_pool(state, channel);\n      if (NULL == channel_pool) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n\n      amqp_pool_alloc_bytes(channel_pool, state->target_size,\n                            &state->inbound_buffer);\n      if (NULL == state->inbound_buffer.bytes) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n      memcpy(state->inbound_buffer.bytes, state->header_buffer, HEADER_SIZE);\n      raw_frame = state->inbound_buffer.bytes;\n\n      state->state = CONNECTION_STATE_BODY;\n\n      bytes_consumed += consume_data(state, &received_data);\n\n      /* do we have target_size data yet? if not, return with the\n         expectation that more will arrive */\n      if (state->inbound_offset < state->target_size) {\n        return (int)bytes_consumed;\n      }\n    }\n    /* fall through to process body */\n\n    case CONNECTION_STATE_BODY: {\n      amqp_bytes_t encoded;\n      int res;\n      amqp_pool_t *channel_pool;\n\n      /* Check frame end marker (footer) */\n      if (amqp_d8(amqp_offset(raw_frame, state->target_size - 1)) !=\n          AMQP_FRAME_END) {\n        return AMQP_STATUS_BAD_AMQP_DATA;\n      }\n\n      decoded_frame->frame_type = amqp_d8(amqp_offset(raw_frame, 0));\n      decoded_frame->channel = amqp_d16(amqp_offset(raw_frame, 1));\n\n      channel_pool =\n          amqp_get_or_create_channel_pool(state, decoded_frame->channel);\n      if (NULL == channel_pool) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n\n      switch (decoded_frame->frame_type) {\n        case AMQP_FRAME_METHOD:\n          decoded_frame->payload.method.id =\n              amqp_d32(amqp_offset(raw_frame, HEADER_SIZE));\n          encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 4);\n          encoded.len = state->target_size - HEADER_SIZE - 4 - FOOTER_SIZE;\n\n          res = amqp_decode_method(decoded_frame->payload.method.id,\n                                   channel_pool, encoded,\n                                   &decoded_frame->payload.method.decoded);\n          if (res < 0) {\n            return res;\n          }\n\n          break;\n\n        case AMQP_FRAME_HEADER:\n          decoded_frame->payload.properties.class_id =\n              amqp_d16(amqp_offset(raw_frame, HEADER_SIZE));\n          /* unused 2-byte weight field goes here */\n          decoded_frame->payload.properties.body_size =\n              amqp_d64(amqp_offset(raw_frame, HEADER_SIZE + 4));\n          encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 12);\n          encoded.len = state->target_size - HEADER_SIZE - 12 - FOOTER_SIZE;\n          decoded_frame->payload.properties.raw = encoded;\n\n          res = amqp_decode_properties(\n              decoded_frame->payload.properties.class_id, channel_pool, encoded,\n              &decoded_frame->payload.properties.decoded);\n          if (res < 0) {\n            return res;\n          }\n\n          break;\n\n        case AMQP_FRAME_BODY:\n          decoded_frame->payload.body_fragment.len =\n              state->target_size - HEADER_SIZE - FOOTER_SIZE;\n          decoded_frame->payload.body_fragment.bytes =\n              amqp_offset(raw_frame, HEADER_SIZE);\n          break;\n\n        case AMQP_FRAME_HEARTBEAT:\n          break;\n\n        default:\n          /* Ignore the frame */\n          decoded_frame->frame_type = 0;\n          break;\n      }\n\n      return_to_idle(state);\n      return (int)bytes_consumed;\n    }\n\n    default:\n      amqp_abort(\"Internal error: invalid amqp_connection_state_t->state %d\",\n                 state->state);\n  }\n}", "func_src_after": "int amqp_handle_input(amqp_connection_state_t state, amqp_bytes_t received_data,\n                      amqp_frame_t *decoded_frame) {\n  size_t bytes_consumed;\n  void *raw_frame;\n\n  /* Returning frame_type of zero indicates either insufficient input,\n     or a complete, ignored frame was read. */\n  decoded_frame->frame_type = 0;\n\n  if (received_data.len == 0) {\n    return AMQP_STATUS_OK;\n  }\n\n  if (state->state == CONNECTION_STATE_IDLE) {\n    state->state = CONNECTION_STATE_HEADER;\n  }\n\n  bytes_consumed = consume_data(state, &received_data);\n\n  /* do we have target_size data yet? if not, return with the\n     expectation that more will arrive */\n  if (state->inbound_offset < state->target_size) {\n    return (int)bytes_consumed;\n  }\n\n  raw_frame = state->inbound_buffer.bytes;\n\n  switch (state->state) {\n    case CONNECTION_STATE_INITIAL:\n      /* check for a protocol header from the server */\n      if (memcmp(raw_frame, \"AMQP\", 4) == 0) {\n        decoded_frame->frame_type = AMQP_PSEUDOFRAME_PROTOCOL_HEADER;\n        decoded_frame->channel = 0;\n\n        decoded_frame->payload.protocol_header.transport_high =\n            amqp_d8(amqp_offset(raw_frame, 4));\n        decoded_frame->payload.protocol_header.transport_low =\n            amqp_d8(amqp_offset(raw_frame, 5));\n        decoded_frame->payload.protocol_header.protocol_version_major =\n            amqp_d8(amqp_offset(raw_frame, 6));\n        decoded_frame->payload.protocol_header.protocol_version_minor =\n            amqp_d8(amqp_offset(raw_frame, 7));\n\n        return_to_idle(state);\n        return (int)bytes_consumed;\n      }\n\n    /* it's not a protocol header; fall through to process it as a\n       regular frame header */\n\n    case CONNECTION_STATE_HEADER: {\n      amqp_channel_t channel;\n      amqp_pool_t *channel_pool;\n      uint32_t frame_size;\n\n      channel = amqp_d16(amqp_offset(raw_frame, 1));\n\n      /* frame length is 3 bytes in */\n      frame_size = amqp_d32(amqp_offset(raw_frame, 3));\n      /* To prevent the target_size calculation below from overflowing, check\n       * that the stated frame_size is smaller than a signed 32-bit. Given\n       * the library only allows configuring frame_max as an int32_t, and\n       * frame_size is uint32_t, the math below is safe from overflow. */\n      if (frame_size >= INT32_MAX) {\n        return AMQP_STATUS_BAD_AMQP_DATA;\n      }\n\n      state->target_size = frame_size + HEADER_SIZE + FOOTER_SIZE;\n      if ((size_t)state->frame_max < state->target_size) {\n        return AMQP_STATUS_BAD_AMQP_DATA;\n      }\n\n      channel_pool = amqp_get_or_create_channel_pool(state, channel);\n      if (NULL == channel_pool) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n\n      amqp_pool_alloc_bytes(channel_pool, state->target_size,\n                            &state->inbound_buffer);\n      if (NULL == state->inbound_buffer.bytes) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n      memcpy(state->inbound_buffer.bytes, state->header_buffer, HEADER_SIZE);\n      raw_frame = state->inbound_buffer.bytes;\n\n      state->state = CONNECTION_STATE_BODY;\n\n      bytes_consumed += consume_data(state, &received_data);\n\n      /* do we have target_size data yet? if not, return with the\n         expectation that more will arrive */\n      if (state->inbound_offset < state->target_size) {\n        return (int)bytes_consumed;\n      }\n    }\n    /* fall through to process body */\n\n    case CONNECTION_STATE_BODY: {\n      amqp_bytes_t encoded;\n      int res;\n      amqp_pool_t *channel_pool;\n\n      /* Check frame end marker (footer) */\n      if (amqp_d8(amqp_offset(raw_frame, state->target_size - 1)) !=\n          AMQP_FRAME_END) {\n        return AMQP_STATUS_BAD_AMQP_DATA;\n      }\n\n      decoded_frame->frame_type = amqp_d8(amqp_offset(raw_frame, 0));\n      decoded_frame->channel = amqp_d16(amqp_offset(raw_frame, 1));\n\n      channel_pool =\n          amqp_get_or_create_channel_pool(state, decoded_frame->channel);\n      if (NULL == channel_pool) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n\n      switch (decoded_frame->frame_type) {\n        case AMQP_FRAME_METHOD:\n          decoded_frame->payload.method.id =\n              amqp_d32(amqp_offset(raw_frame, HEADER_SIZE));\n          encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 4);\n          encoded.len = state->target_size - HEADER_SIZE - 4 - FOOTER_SIZE;\n\n          res = amqp_decode_method(decoded_frame->payload.method.id,\n                                   channel_pool, encoded,\n                                   &decoded_frame->payload.method.decoded);\n          if (res < 0) {\n            return res;\n          }\n\n          break;\n\n        case AMQP_FRAME_HEADER:\n          decoded_frame->payload.properties.class_id =\n              amqp_d16(amqp_offset(raw_frame, HEADER_SIZE));\n          /* unused 2-byte weight field goes here */\n          decoded_frame->payload.properties.body_size =\n              amqp_d64(amqp_offset(raw_frame, HEADER_SIZE + 4));\n          encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 12);\n          encoded.len = state->target_size - HEADER_SIZE - 12 - FOOTER_SIZE;\n          decoded_frame->payload.properties.raw = encoded;\n\n          res = amqp_decode_properties(\n              decoded_frame->payload.properties.class_id, channel_pool, encoded,\n              &decoded_frame->payload.properties.decoded);\n          if (res < 0) {\n            return res;\n          }\n\n          break;\n\n        case AMQP_FRAME_BODY:\n          decoded_frame->payload.body_fragment.len =\n              state->target_size - HEADER_SIZE - FOOTER_SIZE;\n          decoded_frame->payload.body_fragment.bytes =\n              amqp_offset(raw_frame, HEADER_SIZE);\n          break;\n\n        case AMQP_FRAME_HEARTBEAT:\n          break;\n\n        default:\n          /* Ignore the frame */\n          decoded_frame->frame_type = 0;\n          break;\n      }\n\n      return_to_idle(state);\n      return (int)bytes_consumed;\n    }\n\n    default:\n      amqp_abort(\"Internal error: invalid amqp_connection_state_t->state %d\",\n                 state->state);\n  }\n}", "commit_link": "github.com/alanxz/rabbitmq-c/commit/fc85be7123050b91b054e45b91c78d3241a5047a", "file_name": "librabbitmq/amqp_connection.c", "vul_type": "cwe-190", "description": "Write a C function named `amqp_handle_input` that processes incoming AMQP data and decodes it into a frame structure."}
{"func_name": "Perl_re_op_compile", "func_src_before": "REGEXP *\nPerl_re_op_compile(pTHX_ SV ** const patternp, int pat_count,\n\t\t    OP *expr, const regexp_engine* eng, REGEXP *old_re,\n\t\t     bool *is_bare_re, const U32 orig_rx_flags, const U32 pm_flags)\n{\n    dVAR;\n    REGEXP *Rx;         /* Capital 'R' means points to a REGEXP */\n    STRLEN plen;\n    char *exp;\n    regnode *scan;\n    I32 flags;\n    SSize_t minlen = 0;\n    U32 rx_flags;\n    SV *pat;\n    SV** new_patternp = patternp;\n\n    /* these are all flags - maybe they should be turned\n     * into a single int with different bit masks */\n    I32 sawlookahead = 0;\n    I32 sawplus = 0;\n    I32 sawopen = 0;\n    I32 sawminmod = 0;\n\n    regex_charset initial_charset = get_regex_charset(orig_rx_flags);\n    bool recompile = 0;\n    bool runtime_code = 0;\n    scan_data_t data;\n    RExC_state_t RExC_state;\n    RExC_state_t * const pRExC_state = &RExC_state;\n#ifdef TRIE_STUDY_OPT\n    int restudied = 0;\n    RExC_state_t copyRExC_state;\n#endif\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_RE_OP_COMPILE;\n\n    DEBUG_r(if (!PL_colorset) reginitcolors());\n\n    /* Initialize these here instead of as-needed, as is quick and avoids\n     * having to test them each time otherwise */\n    if (! PL_InBitmap) {\n#ifdef DEBUGGING\n        char * dump_len_string;\n#endif\n\n        /* This is calculated here, because the Perl program that generates the\n         * static global ones doesn't currently have access to\n         * NUM_ANYOF_CODE_POINTS */\n\tPL_InBitmap = _new_invlist(2);\n\tPL_InBitmap = _add_range_to_invlist(PL_InBitmap, 0,\n                                                    NUM_ANYOF_CODE_POINTS - 1);\n#ifdef DEBUGGING\n        dump_len_string = PerlEnv_getenv(\"PERL_DUMP_RE_MAX_LEN\");\n        if (   ! dump_len_string\n            || ! grok_atoUV(dump_len_string, (UV *)&PL_dump_re_max_len, NULL))\n        {\n            PL_dump_re_max_len = 60;    /* A reasonable default */\n        }\n#endif\n    }\n\n    pRExC_state->warn_text = NULL;\n    pRExC_state->unlexed_names = NULL;\n    pRExC_state->code_blocks = NULL;\n\n    if (is_bare_re)\n\t*is_bare_re = FALSE;\n\n    if (expr && (expr->op_type == OP_LIST ||\n\t\t(expr->op_type == OP_NULL && expr->op_targ == OP_LIST))) {\n\t/* allocate code_blocks if needed */\n\tOP *o;\n\tint ncode = 0;\n\n\tfor (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o))\n\t    if (o->op_type == OP_NULL && (o->op_flags & OPf_SPECIAL))\n\t\tncode++; /* count of DO blocks */\n\n\tif (ncode)\n            pRExC_state->code_blocks = S_alloc_code_blocks(aTHX_ ncode);\n    }\n\n    if (!pat_count) {\n        /* compile-time pattern with just OP_CONSTs and DO blocks */\n\n        int n;\n        OP *o;\n\n        /* find how many CONSTs there are */\n        assert(expr);\n        n = 0;\n        if (expr->op_type == OP_CONST)\n            n = 1;\n        else\n            for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {\n                if (o->op_type == OP_CONST)\n                    n++;\n            }\n\n        /* fake up an SV array */\n\n        assert(!new_patternp);\n        Newx(new_patternp, n, SV*);\n        SAVEFREEPV(new_patternp);\n        pat_count = n;\n\n        n = 0;\n        if (expr->op_type == OP_CONST)\n            new_patternp[n] = cSVOPx_sv(expr);\n        else\n            for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {\n                if (o->op_type == OP_CONST)\n                    new_patternp[n++] = cSVOPo_sv;\n            }\n\n    }\n\n    DEBUG_PARSE_r(Perl_re_printf( aTHX_\n        \"Assembling pattern from %d elements%s\\n\", pat_count,\n            orig_rx_flags & RXf_SPLIT ? \" for split\" : \"\"));\n\n    /* set expr to the first arg op */\n\n    if (pRExC_state->code_blocks && pRExC_state->code_blocks->count\n         && expr->op_type != OP_CONST)\n    {\n            expr = cLISTOPx(expr)->op_first;\n            assert(   expr->op_type == OP_PUSHMARK\n                   || (expr->op_type == OP_NULL && expr->op_targ == OP_PUSHMARK)\n                   || expr->op_type == OP_PADRANGE);\n            expr = OpSIBLING(expr);\n    }\n\n    pat = S_concat_pat(aTHX_ pRExC_state, NULL, new_patternp, pat_count,\n                        expr, &recompile, NULL);\n\n    /* handle bare (possibly after overloading) regex: foo =~ $re */\n    {\n        SV *re = pat;\n        if (SvROK(re))\n            re = SvRV(re);\n        if (SvTYPE(re) == SVt_REGEXP) {\n            if (is_bare_re)\n                *is_bare_re = TRUE;\n            SvREFCNT_inc(re);\n            DEBUG_PARSE_r(Perl_re_printf( aTHX_\n                \"Precompiled pattern%s\\n\",\n                    orig_rx_flags & RXf_SPLIT ? \" for split\" : \"\"));\n\n            return (REGEXP*)re;\n        }\n    }\n\n    exp = SvPV_nomg(pat, plen);\n\n    if (!eng->op_comp) {\n\tif ((SvUTF8(pat) && IN_BYTES)\n\t\t|| SvGMAGICAL(pat) || SvAMAGIC(pat))\n\t{\n\t    /* make a temporary copy; either to convert to bytes,\n\t     * or to avoid repeating get-magic / overloaded stringify */\n\t    pat = newSVpvn_flags(exp, plen, SVs_TEMP |\n\t\t\t\t\t(IN_BYTES ? 0 : SvUTF8(pat)));\n\t}\n\treturn CALLREGCOMP_ENG(eng, pat, orig_rx_flags);\n    }\n\n    /* ignore the utf8ness if the pattern is 0 length */\n    RExC_utf8 = RExC_orig_utf8 = (plen == 0 || IN_BYTES) ? 0 : SvUTF8(pat);\n    RExC_uni_semantics = 0;\n    RExC_contains_locale = 0;\n    RExC_strict = cBOOL(pm_flags & RXf_PMf_STRICT);\n    RExC_in_script_run = 0;\n    RExC_study_started = 0;\n    pRExC_state->runtime_code_qr = NULL;\n    RExC_frame_head= NULL;\n    RExC_frame_last= NULL;\n    RExC_frame_count= 0;\n    RExC_latest_warn_offset = 0;\n    RExC_use_BRANCHJ = 0;\n    RExC_total_parens = 0;\n    RExC_open_parens = NULL;\n    RExC_close_parens = NULL;\n    RExC_paren_names = NULL;\n    RExC_size = 0;\n    RExC_seen_d_op = FALSE;\n#ifdef DEBUGGING\n    RExC_paren_name_list = NULL;\n#endif\n\n    DEBUG_r({\n        RExC_mysv1= sv_newmortal();\n        RExC_mysv2= sv_newmortal();\n    });\n\n    DEBUG_COMPILE_r({\n            SV *dsv= sv_newmortal();\n            RE_PV_QUOTED_DECL(s, RExC_utf8, dsv, exp, plen, PL_dump_re_max_len);\n            Perl_re_printf( aTHX_  \"%sCompiling REx%s %s\\n\",\n                          PL_colors[4], PL_colors[5], s);\n        });\n\n    /* we jump here if we have to recompile, e.g., from upgrading the pattern\n     * to utf8 */\n\n    if ((pm_flags & PMf_USE_RE_EVAL)\n\t\t/* this second condition covers the non-regex literal case,\n\t\t * i.e.  $foo =~ '(?{})'. */\n\t\t|| (IN_PERL_COMPILETIME && (PL_hints & HINT_RE_EVAL))\n    )\n\truntime_code = S_has_runtime_code(aTHX_ pRExC_state, exp, plen);\n\n  redo_parse:\n    /* return old regex if pattern hasn't changed */\n    /* XXX: note in the below we have to check the flags as well as the\n     * pattern.\n     *\n     * Things get a touch tricky as we have to compare the utf8 flag\n     * independently from the compile flags.  */\n\n    if (   old_re\n        && !recompile\n        && !!RX_UTF8(old_re) == !!RExC_utf8\n        && ( RX_COMPFLAGS(old_re) == ( orig_rx_flags & RXf_PMf_FLAGCOPYMASK ) )\n\t&& RX_PRECOMP(old_re)\n\t&& RX_PRELEN(old_re) == plen\n        && memEQ(RX_PRECOMP(old_re), exp, plen)\n\t&& !runtime_code /* with runtime code, always recompile */ )\n    {\n        return old_re;\n    }\n\n    /* Allocate the pattern's SV */\n    RExC_rx_sv = Rx = (REGEXP*) newSV_type(SVt_REGEXP);\n    RExC_rx = ReANY(Rx);\n    if ( RExC_rx == NULL )\n        FAIL(\"Regexp out of space\");\n\n    rx_flags = orig_rx_flags;\n\n    if (   (UTF || RExC_uni_semantics)\n        && initial_charset == REGEX_DEPENDS_CHARSET)\n    {\n\n\t/* Set to use unicode semantics if the pattern is in utf8 and has the\n\t * 'depends' charset specified, as it means unicode when utf8  */\n\tset_regex_charset(&rx_flags, REGEX_UNICODE_CHARSET);\n        RExC_uni_semantics = 1;\n    }\n\n    RExC_pm_flags = pm_flags;\n\n    if (runtime_code) {\n        assert(TAINTING_get || !TAINT_get);\n\tif (TAINT_get)\n\t    Perl_croak(aTHX_ \"Eval-group in insecure regular expression\");\n\n\tif (!S_compile_runtime_code(aTHX_ pRExC_state, exp, plen)) {\n\t    /* whoops, we have a non-utf8 pattern, whilst run-time code\n\t     * got compiled as utf8. Try again with a utf8 pattern */\n            S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,\n                pRExC_state->code_blocks ? pRExC_state->code_blocks->count : 0);\n            goto redo_parse;\n\t}\n    }\n    assert(!pRExC_state->runtime_code_qr);\n\n    RExC_sawback = 0;\n\n    RExC_seen = 0;\n    RExC_maxlen = 0;\n    RExC_in_lookbehind = 0;\n    RExC_seen_zerolen = *exp == '^' ? -1 : 0;\n#ifdef EBCDIC\n    RExC_recode_x_to_native = 0;\n#endif\n    RExC_in_multi_char_class = 0;\n\n    RExC_start = RExC_copy_start_in_constructed = RExC_copy_start_in_input = RExC_precomp = exp;\n    RExC_precomp_end = RExC_end = exp + plen;\n    RExC_nestroot = 0;\n    RExC_whilem_seen = 0;\n    RExC_end_op = NULL;\n    RExC_recurse = NULL;\n    RExC_study_chunk_recursed = NULL;\n    RExC_study_chunk_recursed_bytes= 0;\n    RExC_recurse_count = 0;\n    pRExC_state->code_index = 0;\n\n    /* Initialize the string in the compiled pattern.  This is so that there is\n     * something to output if necessary */\n    set_regex_pv(pRExC_state, Rx);\n\n    DEBUG_PARSE_r({\n        Perl_re_printf( aTHX_\n            \"Starting parse and generation\\n\");\n        RExC_lastnum=0;\n        RExC_lastparse=NULL;\n    });\n\n    /* Allocate space and zero-initialize. Note, the two step process\n       of zeroing when in debug mode, thus anything assigned has to\n       happen after that */\n    if (!  RExC_size) {\n\n        /* On the first pass of the parse, we guess how big this will be.  Then\n         * we grow in one operation to that amount and then give it back.  As\n         * we go along, we re-allocate what we need.\n         *\n         * XXX Currently the guess is essentially that the pattern will be an\n         * EXACT node with one byte input, one byte output.  This is crude, and\n         * better heuristics are welcome.\n         *\n         * On any subsequent passes, we guess what we actually computed in the\n         * latest earlier pass.  Such a pass probably didn't complete so is\n         * missing stuff.  We could improve those guesses by knowing where the\n         * parse stopped, and use the length so far plus apply the above\n         * assumption to what's left. */\n        RExC_size = STR_SZ(RExC_end - RExC_start);\n    }\n\n    Newxc(RExC_rxi, sizeof(regexp_internal) + RExC_size, char, regexp_internal);\n    if ( RExC_rxi == NULL )\n        FAIL(\"Regexp out of space\");\n\n    Zero(RExC_rxi, sizeof(regexp_internal) + RExC_size, char);\n    RXi_SET( RExC_rx, RExC_rxi );\n\n    /* We start from 0 (over from 0 in the case this is a reparse.  The first\n     * node parsed will give back any excess memory we have allocated so far).\n     * */\n    RExC_size = 0;\n\n    /* non-zero initialization begins here */\n    RExC_rx->engine= eng;\n    RExC_rx->extflags = rx_flags;\n    RXp_COMPFLAGS(RExC_rx) = orig_rx_flags & RXf_PMf_FLAGCOPYMASK;\n\n    if (pm_flags & PMf_IS_QR) {\n\tRExC_rxi->code_blocks = pRExC_state->code_blocks;\n        if (RExC_rxi->code_blocks) {\n            RExC_rxi->code_blocks->refcnt++;\n        }\n    }\n\n    RExC_rx->intflags = 0;\n\n    RExC_flags = rx_flags;\t/* don't let top level (?i) bleed */\n    RExC_parse = exp;\n\n    /* This NUL is guaranteed because the pattern comes from an SV*, and the sv\n     * code makes sure the final byte is an uncounted NUL.  But should this\n     * ever not be the case, lots of things could read beyond the end of the\n     * buffer: loops like\n     *      while(isFOO(*RExC_parse)) RExC_parse++;\n     *      strchr(RExC_parse, \"foo\");\n     * etc.  So it is worth noting. */\n    assert(*RExC_end == '\\0');\n\n    RExC_naughty = 0;\n    RExC_npar = 1;\n    RExC_parens_buf_size = 0;\n    RExC_emit_start = RExC_rxi->program;\n    pRExC_state->code_index = 0;\n\n    *((char*) RExC_emit_start) = (char) REG_MAGIC;\n    RExC_emit = 1;\n\n    /* Do the parse */\n    if (reg(pRExC_state, 0, &flags, 1)) {\n\n        /* Success!, But we may need to redo the parse knowing how many parens\n         * there actually are */\n        if (IN_PARENS_PASS) {\n            flags |= RESTART_PARSE;\n        }\n\n        /* We have that number in RExC_npar */\n        RExC_total_parens = RExC_npar;\n    }\n    else if (! MUST_RESTART(flags)) {\n\tReREFCNT_dec(Rx);\n        Perl_croak(aTHX_ \"panic: reg returned failure to re_op_compile, flags=%#\" UVxf, (UV) flags);\n    }\n\n    /* Here, we either have success, or we have to redo the parse for some reason */\n    if (MUST_RESTART(flags)) {\n\n        /* It's possible to write a regexp in ascii that represents Unicode\n        codepoints outside of the byte range, such as via \\x{100}. If we\n        detect such a sequence we have to convert the entire pattern to utf8\n        and then recompile, as our sizing calculation will have been based\n        on 1 byte == 1 character, but we will need to use utf8 to encode\n        at least some part of the pattern, and therefore must convert the whole\n        thing.\n        -- dmq */\n        if (flags & NEED_UTF8) {\n\n            /* We have stored the offset of the final warning output so far.\n             * That must be adjusted.  Any variant characters between the start\n             * of the pattern and this warning count for 2 bytes in the final,\n             * so just add them again */\n            if (UNLIKELY(RExC_latest_warn_offset > 0)) {\n                RExC_latest_warn_offset +=\n                            variant_under_utf8_count((U8 *) exp, (U8 *) exp\n                                                + RExC_latest_warn_offset);\n            }\n            S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,\n            pRExC_state->code_blocks ? pRExC_state->code_blocks->count : 0);\n            DEBUG_PARSE_r(Perl_re_printf( aTHX_ \"Need to redo parse after upgrade\\n\"));\n        }\n        else {\n            DEBUG_PARSE_r(Perl_re_printf( aTHX_ \"Need to redo parse\\n\"));\n        }\n\n        if (ALL_PARENS_COUNTED) {\n            /* Make enough room for all the known parens, and zero it */\n            Renew(RExC_open_parens, RExC_total_parens, regnode_offset);\n            Zero(RExC_open_parens, RExC_total_parens, regnode_offset);\n            RExC_open_parens[0] = 1;    /* +1 for REG_MAGIC */\n\n            Renew(RExC_close_parens, RExC_total_parens, regnode_offset);\n            Zero(RExC_close_parens, RExC_total_parens, regnode_offset);\n        }\n        else { /* Parse did not complete.  Reinitialize the parentheses\n                  structures */\n            RExC_total_parens = 0;\n            if (RExC_open_parens) {\n                Safefree(RExC_open_parens);\n                RExC_open_parens = NULL;\n            }\n            if (RExC_close_parens) {\n                Safefree(RExC_close_parens);\n                RExC_close_parens = NULL;\n            }\n        }\n\n        /* Clean up what we did in this parse */\n        SvREFCNT_dec_NN(RExC_rx_sv);\n\n        goto redo_parse;\n    }\n\n    /* Here, we have successfully parsed and generated the pattern's program\n     * for the regex engine.  We are ready to finish things up and look for\n     * optimizations. */\n\n    /* Update the string to compile, with correct modifiers, etc */\n    set_regex_pv(pRExC_state, Rx);\n\n    RExC_rx->nparens = RExC_total_parens - 1;\n\n    /* Uses the upper 4 bits of the FLAGS field, so keep within that size */\n    if (RExC_whilem_seen > 15)\n        RExC_whilem_seen = 15;\n\n    DEBUG_PARSE_r({\n        Perl_re_printf( aTHX_\n            \"Required size %\" IVdf \" nodes\\n\", (IV)RExC_size);\n        RExC_lastnum=0;\n        RExC_lastparse=NULL;\n    });\n\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    DEBUG_OFFSETS_r(Perl_re_printf( aTHX_\n                          \"%s %\" UVuf \" bytes for offset annotations.\\n\",\n                          RExC_offsets ? \"Got\" : \"Couldn't get\",\n                          (UV)((RExC_offsets[0] * 2 + 1))));\n    DEBUG_OFFSETS_r(if (RExC_offsets) {\n        const STRLEN len = RExC_offsets[0];\n        STRLEN i;\n        GET_RE_DEBUG_FLAGS_DECL;\n        Perl_re_printf( aTHX_\n                      \"Offsets: [%\" UVuf \"]\\n\\t\", (UV)RExC_offsets[0]);\n        for (i = 1; i <= len; i++) {\n            if (RExC_offsets[i*2-1] || RExC_offsets[i*2])\n                Perl_re_printf( aTHX_  \"%\" UVuf \":%\" UVuf \"[%\" UVuf \"] \",\n                (UV)i, (UV)RExC_offsets[i*2-1], (UV)RExC_offsets[i*2]);\n        }\n        Perl_re_printf( aTHX_  \"\\n\");\n    });\n\n#else\n    SetProgLen(RExC_rxi,RExC_size);\n#endif\n\n    DEBUG_OPTIMISE_r(\n        Perl_re_printf( aTHX_  \"Starting post parse optimization\\n\");\n    );\n\n    /* XXXX To minimize changes to RE engine we always allocate\n       3-units-long substrs field. */\n    Newx(RExC_rx->substrs, 1, struct reg_substr_data);\n    if (RExC_recurse_count) {\n        Newx(RExC_recurse, RExC_recurse_count, regnode *);\n        SAVEFREEPV(RExC_recurse);\n    }\n\n    if (RExC_seen & REG_RECURSE_SEEN) {\n        /* Note, RExC_total_parens is 1 + the number of parens in a pattern.\n         * So its 1 if there are no parens. */\n        RExC_study_chunk_recursed_bytes= (RExC_total_parens >> 3) +\n                                         ((RExC_total_parens & 0x07) != 0);\n        Newx(RExC_study_chunk_recursed,\n             RExC_study_chunk_recursed_bytes * RExC_total_parens, U8);\n        SAVEFREEPV(RExC_study_chunk_recursed);\n    }\n\n  reStudy:\n    RExC_rx->minlen = minlen = sawlookahead = sawplus = sawopen = sawminmod = 0;\n    DEBUG_r(\n        RExC_study_chunk_recursed_count= 0;\n    );\n    Zero(RExC_rx->substrs, 1, struct reg_substr_data);\n    if (RExC_study_chunk_recursed) {\n        Zero(RExC_study_chunk_recursed,\n             RExC_study_chunk_recursed_bytes * RExC_total_parens, U8);\n    }\n\n\n#ifdef TRIE_STUDY_OPT\n    if (!restudied) {\n        StructCopy(&zero_scan_data, &data, scan_data_t);\n        copyRExC_state = RExC_state;\n    } else {\n        U32 seen=RExC_seen;\n        DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_ \"Restudying\\n\"));\n\n        RExC_state = copyRExC_state;\n        if (seen & REG_TOP_LEVEL_BRANCHES_SEEN)\n            RExC_seen |= REG_TOP_LEVEL_BRANCHES_SEEN;\n        else\n            RExC_seen &= ~REG_TOP_LEVEL_BRANCHES_SEEN;\n\tStructCopy(&zero_scan_data, &data, scan_data_t);\n    }\n#else\n    StructCopy(&zero_scan_data, &data, scan_data_t);\n#endif\n\n    /* Dig out information for optimizations. */\n    RExC_rx->extflags = RExC_flags; /* was pm_op */\n    /*dmq: removed as part of de-PMOP: pm->op_pmflags = RExC_flags; */\n\n    if (UTF)\n\tSvUTF8_on(Rx);\t/* Unicode in it? */\n    RExC_rxi->regstclass = NULL;\n    if (RExC_naughty >= TOO_NAUGHTY)\t/* Probably an expensive pattern. */\n\tRExC_rx->intflags |= PREGf_NAUGHTY;\n    scan = RExC_rxi->program + 1;\t\t/* First BRANCH. */\n\n    /* testing for BRANCH here tells us whether there is \"must appear\"\n       data in the pattern. If there is then we can use it for optimisations */\n    if (!(RExC_seen & REG_TOP_LEVEL_BRANCHES_SEEN)) { /*  Only one top-level choice.\n                                                  */\n\tSSize_t fake;\n\tSTRLEN longest_length[2];\n\tregnode_ssc ch_class; /* pointed to by data */\n\tint stclass_flag;\n\tSSize_t last_close = 0; /* pointed to by data */\n        regnode *first= scan;\n        regnode *first_next= regnext(first);\n        int i;\n\n\t/*\n\t * Skip introductions and multiplicators >= 1\n\t * so that we can extract the 'meat' of the pattern that must\n\t * match in the large if() sequence following.\n\t * NOTE that EXACT is NOT covered here, as it is normally\n\t * picked up by the optimiser separately.\n\t *\n\t * This is unfortunate as the optimiser isnt handling lookahead\n\t * properly currently.\n\t *\n\t */\n\twhile ((OP(first) == OPEN && (sawopen = 1)) ||\n\t       /* An OR of *one* alternative - should not happen now. */\n\t    (OP(first) == BRANCH && OP(first_next) != BRANCH) ||\n\t    /* for now we can't handle lookbehind IFMATCH*/\n\t    (OP(first) == IFMATCH && !first->flags && (sawlookahead = 1)) ||\n\t    (OP(first) == PLUS) ||\n\t    (OP(first) == MINMOD) ||\n\t       /* An {n,m} with n>0 */\n\t    (PL_regkind[OP(first)] == CURLY && ARG1(first) > 0) ||\n\t    (OP(first) == NOTHING && PL_regkind[OP(first_next)] != END ))\n\t{\n\t\t/*\n\t\t * the only op that could be a regnode is PLUS, all the rest\n\t\t * will be regnode_1 or regnode_2.\n\t\t *\n                 * (yves doesn't think this is true)\n\t\t */\n\t\tif (OP(first) == PLUS)\n\t\t    sawplus = 1;\n                else {\n                    if (OP(first) == MINMOD)\n                        sawminmod = 1;\n\t\t    first += regarglen[OP(first)];\n                }\n\t\tfirst = NEXTOPER(first);\n\t\tfirst_next= regnext(first);\n\t}\n\n\t/* Starting-point info. */\n      again:\n        DEBUG_PEEP(\"first:\", first, 0, 0);\n        /* Ignore EXACT as we deal with it later. */\n\tif (PL_regkind[OP(first)] == EXACT) {\n\t    if (   OP(first) == EXACT\n                || OP(first) == EXACT_ONLY8\n                || OP(first) == EXACTL)\n            {\n\t\tNOOP;\t/* Empty, get anchored substr later. */\n            }\n\t    else\n\t\tRExC_rxi->regstclass = first;\n\t}\n#ifdef TRIE_STCLASS\n\telse if (PL_regkind[OP(first)] == TRIE &&\n\t        ((reg_trie_data *)RExC_rxi->data->data[ ARG(first) ])->minlen>0)\n\t{\n            /* this can happen only on restudy */\n            RExC_rxi->regstclass = construct_ahocorasick_from_trie(pRExC_state, (regnode *)first, 0);\n\t}\n#endif\n\telse if (REGNODE_SIMPLE(OP(first)))\n\t    RExC_rxi->regstclass = first;\n\telse if (PL_regkind[OP(first)] == BOUND ||\n\t\t PL_regkind[OP(first)] == NBOUND)\n\t    RExC_rxi->regstclass = first;\n\telse if (PL_regkind[OP(first)] == BOL) {\n            RExC_rx->intflags |= (OP(first) == MBOL\n                           ? PREGf_ANCH_MBOL\n                           : PREGf_ANCH_SBOL);\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n\telse if (OP(first) == GPOS) {\n            RExC_rx->intflags |= PREGf_ANCH_GPOS;\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n\telse if ((!sawopen || !RExC_sawback) &&\n            !sawlookahead &&\n\t    (OP(first) == STAR &&\n\t    PL_regkind[OP(NEXTOPER(first))] == REG_ANY) &&\n            !(RExC_rx->intflags & PREGf_ANCH) && !pRExC_state->code_blocks)\n\t{\n\t    /* turn .* into ^.* with an implied $*=1 */\n\t    const int type =\n\t\t(OP(NEXTOPER(first)) == REG_ANY)\n                    ? PREGf_ANCH_MBOL\n                    : PREGf_ANCH_SBOL;\n            RExC_rx->intflags |= (type | PREGf_IMPLICIT);\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n        if (sawplus && !sawminmod && !sawlookahead\n            && (!sawopen || !RExC_sawback)\n\t    && !pRExC_state->code_blocks) /* May examine pos and $& */\n\t    /* x+ must match at the 1st pos of run of x's */\n\t    RExC_rx->intflags |= PREGf_SKIP;\n\n\t/* Scan is after the zeroth branch, first is atomic matcher. */\n#ifdef TRIE_STUDY_OPT\n\tDEBUG_PARSE_r(\n\t    if (!restudied)\n                Perl_re_printf( aTHX_  \"first at %\" IVdf \"\\n\",\n\t\t\t      (IV)(first - scan + 1))\n        );\n#else\n\tDEBUG_PARSE_r(\n            Perl_re_printf( aTHX_  \"first at %\" IVdf \"\\n\",\n\t        (IV)(first - scan + 1))\n        );\n#endif\n\n\n\t/*\n\t* If there's something expensive in the r.e., find the\n\t* longest literal string that must appear and make it the\n\t* regmust.  Resolve ties in favor of later strings, since\n\t* the regstart check works with the beginning of the r.e.\n\t* and avoiding duplication strengthens checking.  Not a\n\t* strong reason, but sufficient in the absence of others.\n\t* [Now we resolve ties in favor of the earlier string if\n\t* it happens that c_offset_min has been invalidated, since the\n\t* earlier string may buy us something the later one won't.]\n\t*/\n\n\tdata.substrs[0].str = newSVpvs(\"\");\n\tdata.substrs[1].str = newSVpvs(\"\");\n\tdata.last_found = newSVpvs(\"\");\n\tdata.cur_is_floating = 0; /* initially any found substring is fixed */\n\tENTER_with_name(\"study_chunk\");\n\tSAVEFREESV(data.substrs[0].str);\n\tSAVEFREESV(data.substrs[1].str);\n\tSAVEFREESV(data.last_found);\n\tfirst = scan;\n\tif (!RExC_rxi->regstclass) {\n\t    ssc_init(pRExC_state, &ch_class);\n\t    data.start_class = &ch_class;\n\t    stclass_flag = SCF_DO_STCLASS_AND;\n\t} else\t\t\t\t/* XXXX Check for BOUND? */\n\t    stclass_flag = 0;\n\tdata.last_closep = &last_close;\n\n        DEBUG_RExC_seen();\n        /*\n         * MAIN ENTRY FOR study_chunk() FOR m/PATTERN/\n         * (NO top level branches)\n         */\n\tminlen = study_chunk(pRExC_state, &first, &minlen, &fake,\n                             scan + RExC_size, /* Up to end */\n            &data, -1, 0, NULL,\n            SCF_DO_SUBSTR | SCF_WHILEM_VISITED_POS | stclass_flag\n                          | (restudied ? SCF_TRIE_DOING_RESTUDY : 0),\n            0);\n\n\n        CHECK_RESTUDY_GOTO_butfirst(LEAVE_with_name(\"study_chunk\"));\n\n\n\tif ( RExC_total_parens == 1 && !data.cur_is_floating\n\t     && data.last_start_min == 0 && data.last_end > 0\n\t     && !RExC_seen_zerolen\n             && !(RExC_seen & REG_VERBARG_SEEN)\n             && !(RExC_seen & REG_GPOS_SEEN)\n        ){\n\t    RExC_rx->extflags |= RXf_CHECK_ALL;\n        }\n\tscan_commit(pRExC_state, &data,&minlen, 0);\n\n\n        /* XXX this is done in reverse order because that's the way the\n         * code was before it was parameterised. Don't know whether it\n         * actually needs doing in reverse order. DAPM */\n        for (i = 1; i >= 0; i--) {\n            longest_length[i] = CHR_SVLEN(data.substrs[i].str);\n\n            if (   !(   i\n                     && SvCUR(data.substrs[0].str)  /* ok to leave SvCUR */\n                     &&    data.substrs[0].min_offset\n                        == data.substrs[1].min_offset\n                     &&    SvCUR(data.substrs[0].str)\n                        == SvCUR(data.substrs[1].str)\n                    )\n                && S_setup_longest (aTHX_ pRExC_state,\n                                        &(RExC_rx->substrs->data[i]),\n                                        &(data.substrs[i]),\n                                        longest_length[i]))\n            {\n                RExC_rx->substrs->data[i].min_offset =\n                        data.substrs[i].min_offset - data.substrs[i].lookbehind;\n\n                RExC_rx->substrs->data[i].max_offset = data.substrs[i].max_offset;\n                /* Don't offset infinity */\n                if (data.substrs[i].max_offset < SSize_t_MAX)\n                    RExC_rx->substrs->data[i].max_offset -= data.substrs[i].lookbehind;\n                SvREFCNT_inc_simple_void_NN(data.substrs[i].str);\n            }\n            else {\n                RExC_rx->substrs->data[i].substr      = NULL;\n                RExC_rx->substrs->data[i].utf8_substr = NULL;\n                longest_length[i] = 0;\n            }\n        }\n\n\tLEAVE_with_name(\"study_chunk\");\n\n\tif (RExC_rxi->regstclass\n\t    && (OP(RExC_rxi->regstclass) == REG_ANY || OP(RExC_rxi->regstclass) == SANY))\n\t    RExC_rxi->regstclass = NULL;\n\n\tif ((!(RExC_rx->substrs->data[0].substr || RExC_rx->substrs->data[0].utf8_substr)\n              || RExC_rx->substrs->data[0].min_offset)\n\t    && stclass_flag\n            && ! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)\n\t    && is_ssc_worth_it(pRExC_state, data.start_class))\n\t{\n\t    const U32 n = add_data(pRExC_state, STR_WITH_LEN(\"f\"));\n\n            ssc_finalize(pRExC_state, data.start_class);\n\n\t    Newx(RExC_rxi->data->data[n], 1, regnode_ssc);\n\t    StructCopy(data.start_class,\n\t\t       (regnode_ssc*)RExC_rxi->data->data[n],\n\t\t       regnode_ssc);\n\t    RExC_rxi->regstclass = (regnode*)RExC_rxi->data->data[n];\n\t    RExC_rx->intflags &= ~PREGf_SKIP;\t/* Used in find_byclass(). */\n\t    DEBUG_COMPILE_r({ SV *sv = sv_newmortal();\n                      regprop(RExC_rx, sv, (regnode*)data.start_class, NULL, pRExC_state);\n                      Perl_re_printf( aTHX_\n\t\t\t\t    \"synthetic stclass \\\"%s\\\".\\n\",\n\t\t\t\t    SvPVX_const(sv));});\n            data.start_class = NULL;\n\t}\n\n        /* A temporary algorithm prefers floated substr to fixed one of\n         * same length to dig more info. */\n\ti = (longest_length[0] <= longest_length[1]);\n        RExC_rx->substrs->check_ix = i;\n        RExC_rx->check_end_shift  = RExC_rx->substrs->data[i].end_shift;\n        RExC_rx->check_substr     = RExC_rx->substrs->data[i].substr;\n        RExC_rx->check_utf8       = RExC_rx->substrs->data[i].utf8_substr;\n        RExC_rx->check_offset_min = RExC_rx->substrs->data[i].min_offset;\n        RExC_rx->check_offset_max = RExC_rx->substrs->data[i].max_offset;\n        if (!i && (RExC_rx->intflags & (PREGf_ANCH_SBOL|PREGf_ANCH_GPOS)))\n            RExC_rx->intflags |= PREGf_NOSCAN;\n\n\tif ((RExC_rx->check_substr || RExC_rx->check_utf8) ) {\n\t    RExC_rx->extflags |= RXf_USE_INTUIT;\n\t    if (SvTAIL(RExC_rx->check_substr ? RExC_rx->check_substr : RExC_rx->check_utf8))\n\t\tRExC_rx->extflags |= RXf_INTUIT_TAIL;\n\t}\n\n\t/* XXX Unneeded? dmq (shouldn't as this is handled elsewhere)\n\tif ( (STRLEN)minlen < longest_length[1] )\n            minlen= longest_length[1];\n        if ( (STRLEN)minlen < longest_length[0] )\n            minlen= longest_length[0];\n        */\n    }\n    else {\n\t/* Several toplevels. Best we can is to set minlen. */\n\tSSize_t fake;\n\tregnode_ssc ch_class;\n\tSSize_t last_close = 0;\n\n        DEBUG_PARSE_r(Perl_re_printf( aTHX_  \"\\nMulti Top Level\\n\"));\n\n\tscan = RExC_rxi->program + 1;\n\tssc_init(pRExC_state, &ch_class);\n\tdata.start_class = &ch_class;\n\tdata.last_closep = &last_close;\n\n        DEBUG_RExC_seen();\n        /*\n         * MAIN ENTRY FOR study_chunk() FOR m/P1|P2|.../\n         * (patterns WITH top level branches)\n         */\n\tminlen = study_chunk(pRExC_state,\n            &scan, &minlen, &fake, scan + RExC_size, &data, -1, 0, NULL,\n            SCF_DO_STCLASS_AND|SCF_WHILEM_VISITED_POS|(restudied\n                                                      ? SCF_TRIE_DOING_RESTUDY\n                                                      : 0),\n            0);\n\n        CHECK_RESTUDY_GOTO_butfirst(NOOP);\n\n\tRExC_rx->check_substr = NULL;\n        RExC_rx->check_utf8 = NULL;\n        RExC_rx->substrs->data[0].substr      = NULL;\n        RExC_rx->substrs->data[0].utf8_substr = NULL;\n        RExC_rx->substrs->data[1].substr      = NULL;\n        RExC_rx->substrs->data[1].utf8_substr = NULL;\n\n        if (! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)\n\t    && is_ssc_worth_it(pRExC_state, data.start_class))\n        {\n\t    const U32 n = add_data(pRExC_state, STR_WITH_LEN(\"f\"));\n\n            ssc_finalize(pRExC_state, data.start_class);\n\n\t    Newx(RExC_rxi->data->data[n], 1, regnode_ssc);\n\t    StructCopy(data.start_class,\n\t\t       (regnode_ssc*)RExC_rxi->data->data[n],\n\t\t       regnode_ssc);\n\t    RExC_rxi->regstclass = (regnode*)RExC_rxi->data->data[n];\n\t    RExC_rx->intflags &= ~PREGf_SKIP;\t/* Used in find_byclass(). */\n\t    DEBUG_COMPILE_r({ SV* sv = sv_newmortal();\n                      regprop(RExC_rx, sv, (regnode*)data.start_class, NULL, pRExC_state);\n                      Perl_re_printf( aTHX_\n\t\t\t\t    \"synthetic stclass \\\"%s\\\".\\n\",\n\t\t\t\t    SvPVX_const(sv));});\n            data.start_class = NULL;\n\t}\n    }\n\n    if (RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN) {\n        RExC_rx->extflags |= RXf_UNBOUNDED_QUANTIFIER_SEEN;\n        RExC_rx->maxlen = REG_INFTY;\n    }\n    else {\n        RExC_rx->maxlen = RExC_maxlen;\n    }\n\n    /* Guard against an embedded (?=) or (?<=) with a longer minlen than\n       the \"real\" pattern. */\n    DEBUG_OPTIMISE_r({\n        Perl_re_printf( aTHX_ \"minlen: %\" IVdf \" RExC_rx->minlen:%\" IVdf \" maxlen:%\" IVdf \"\\n\",\n                      (IV)minlen, (IV)RExC_rx->minlen, (IV)RExC_maxlen);\n    });\n    RExC_rx->minlenret = minlen;\n    if (RExC_rx->minlen < minlen)\n        RExC_rx->minlen = minlen;\n\n    if (RExC_seen & REG_RECURSE_SEEN ) {\n        RExC_rx->intflags |= PREGf_RECURSE_SEEN;\n        Newx(RExC_rx->recurse_locinput, RExC_rx->nparens + 1, char *);\n    }\n    if (RExC_seen & REG_GPOS_SEEN)\n        RExC_rx->intflags |= PREGf_GPOS_SEEN;\n    if (RExC_seen & REG_LOOKBEHIND_SEEN)\n        RExC_rx->extflags |= RXf_NO_INPLACE_SUBST; /* inplace might break the\n                                                lookbehind */\n    if (pRExC_state->code_blocks)\n\tRExC_rx->extflags |= RXf_EVAL_SEEN;\n    if (RExC_seen & REG_VERBARG_SEEN)\n    {\n\tRExC_rx->intflags |= PREGf_VERBARG_SEEN;\n        RExC_rx->extflags |= RXf_NO_INPLACE_SUBST; /* don't understand this! Yves */\n    }\n    if (RExC_seen & REG_CUTGROUP_SEEN)\n\tRExC_rx->intflags |= PREGf_CUTGROUP_SEEN;\n    if (pm_flags & PMf_USE_RE_EVAL)\n\tRExC_rx->intflags |= PREGf_USE_RE_EVAL;\n    if (RExC_paren_names)\n        RXp_PAREN_NAMES(RExC_rx) = MUTABLE_HV(SvREFCNT_inc(RExC_paren_names));\n    else\n        RXp_PAREN_NAMES(RExC_rx) = NULL;\n\n    /* If we have seen an anchor in our pattern then we set the extflag RXf_IS_ANCHORED\n     * so it can be used in pp.c */\n    if (RExC_rx->intflags & PREGf_ANCH)\n        RExC_rx->extflags |= RXf_IS_ANCHORED;\n\n\n    {\n        /* this is used to identify \"special\" patterns that might result\n         * in Perl NOT calling the regex engine and instead doing the match \"itself\",\n         * particularly special cases in split//. By having the regex compiler\n         * do this pattern matching at a regop level (instead of by inspecting the pattern)\n         * we avoid weird issues with equivalent patterns resulting in different behavior,\n         * AND we allow non Perl engines to get the same optimizations by the setting the\n         * flags appropriately - Yves */\n        regnode *first = RExC_rxi->program + 1;\n        U8 fop = OP(first);\n        regnode *next = regnext(first);\n        U8 nop = OP(next);\n\n        if (PL_regkind[fop] == NOTHING && nop == END)\n            RExC_rx->extflags |= RXf_NULL;\n        else if ((fop == MBOL || (fop == SBOL && !first->flags)) && nop == END)\n            /* when fop is SBOL first->flags will be true only when it was\n             * produced by parsing /\\A/, and not when parsing /^/. This is\n             * very important for the split code as there we want to\n             * treat /^/ as /^/m, but we do not want to treat /\\A/ as /^/m.\n             * See rt #122761 for more details. -- Yves */\n            RExC_rx->extflags |= RXf_START_ONLY;\n        else if (fop == PLUS\n                 && PL_regkind[nop] == POSIXD && FLAGS(next) == _CC_SPACE\n                 && nop == END)\n            RExC_rx->extflags |= RXf_WHITE;\n        else if ( RExC_rx->extflags & RXf_SPLIT\n                  && (fop == EXACT || fop == EXACT_ONLY8 || fop == EXACTL)\n                  && STR_LEN(first) == 1\n                  && *(STRING(first)) == ' '\n                  && nop == END )\n            RExC_rx->extflags |= (RXf_SKIPWHITE|RXf_WHITE);\n\n    }\n\n    if (RExC_contains_locale) {\n        RXp_EXTFLAGS(RExC_rx) |= RXf_TAINTED;\n    }\n\n#ifdef DEBUGGING\n    if (RExC_paren_names) {\n        RExC_rxi->name_list_idx = add_data( pRExC_state, STR_WITH_LEN(\"a\"));\n        RExC_rxi->data->data[RExC_rxi->name_list_idx]\n                                   = (void*)SvREFCNT_inc(RExC_paren_name_list);\n    } else\n#endif\n    RExC_rxi->name_list_idx = 0;\n\n    while ( RExC_recurse_count > 0 ) {\n        const regnode *scan = RExC_recurse[ --RExC_recurse_count ];\n        /*\n         * This data structure is set up in study_chunk() and is used\n         * to calculate the distance between a GOSUB regopcode and\n         * the OPEN/CURLYM (CURLYM's are special and can act like OPEN's)\n         * it refers to.\n         *\n         * If for some reason someone writes code that optimises\n         * away a GOSUB opcode then the assert should be changed to\n         * an if(scan) to guard the ARG2L_SET() - Yves\n         *\n         */\n        assert(scan && OP(scan) == GOSUB);\n        ARG2L_SET( scan, RExC_open_parens[ARG(scan)] - REGNODE_OFFSET(scan));\n    }\n\n    Newxz(RExC_rx->offs, RExC_total_parens, regexp_paren_pair);\n    /* assume we don't need to swap parens around before we match */\n    DEBUG_TEST_r({\n        Perl_re_printf( aTHX_ \"study_chunk_recursed_count: %lu\\n\",\n            (unsigned long)RExC_study_chunk_recursed_count);\n    });\n    DEBUG_DUMP_r({\n        DEBUG_RExC_seen();\n        Perl_re_printf( aTHX_ \"Final program:\\n\");\n        regdump(RExC_rx);\n    });\n\n    if (RExC_open_parens) {\n        Safefree(RExC_open_parens);\n        RExC_open_parens = NULL;\n    }\n    if (RExC_close_parens) {\n        Safefree(RExC_close_parens);\n        RExC_close_parens = NULL;\n    }\n\n#ifdef USE_ITHREADS\n    /* under ithreads the ?pat? PMf_USED flag on the pmop is simulated\n     * by setting the regexp SV to readonly-only instead. If the\n     * pattern's been recompiled, the USEDness should remain. */\n    if (old_re && SvREADONLY(old_re))\n        SvREADONLY_on(Rx);\n#endif\n    return Rx;", "func_src_after": "REGEXP *\nPerl_re_op_compile(pTHX_ SV ** const patternp, int pat_count,\n\t\t    OP *expr, const regexp_engine* eng, REGEXP *old_re,\n\t\t     bool *is_bare_re, const U32 orig_rx_flags, const U32 pm_flags)\n{\n    dVAR;\n    REGEXP *Rx;         /* Capital 'R' means points to a REGEXP */\n    STRLEN plen;\n    char *exp;\n    regnode *scan;\n    I32 flags;\n    SSize_t minlen = 0;\n    U32 rx_flags;\n    SV *pat;\n    SV** new_patternp = patternp;\n\n    /* these are all flags - maybe they should be turned\n     * into a single int with different bit masks */\n    I32 sawlookahead = 0;\n    I32 sawplus = 0;\n    I32 sawopen = 0;\n    I32 sawminmod = 0;\n\n    regex_charset initial_charset = get_regex_charset(orig_rx_flags);\n    bool recompile = 0;\n    bool runtime_code = 0;\n    scan_data_t data;\n    RExC_state_t RExC_state;\n    RExC_state_t * const pRExC_state = &RExC_state;\n#ifdef TRIE_STUDY_OPT\n    int restudied = 0;\n    RExC_state_t copyRExC_state;\n#endif\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_RE_OP_COMPILE;\n\n    DEBUG_r(if (!PL_colorset) reginitcolors());\n\n    /* Initialize these here instead of as-needed, as is quick and avoids\n     * having to test them each time otherwise */\n    if (! PL_InBitmap) {\n#ifdef DEBUGGING\n        char * dump_len_string;\n#endif\n\n        /* This is calculated here, because the Perl program that generates the\n         * static global ones doesn't currently have access to\n         * NUM_ANYOF_CODE_POINTS */\n\tPL_InBitmap = _new_invlist(2);\n\tPL_InBitmap = _add_range_to_invlist(PL_InBitmap, 0,\n                                                    NUM_ANYOF_CODE_POINTS - 1);\n#ifdef DEBUGGING\n        dump_len_string = PerlEnv_getenv(\"PERL_DUMP_RE_MAX_LEN\");\n        if (   ! dump_len_string\n            || ! grok_atoUV(dump_len_string, (UV *)&PL_dump_re_max_len, NULL))\n        {\n            PL_dump_re_max_len = 60;    /* A reasonable default */\n        }\n#endif\n    }\n\n    pRExC_state->warn_text = NULL;\n    pRExC_state->unlexed_names = NULL;\n    pRExC_state->code_blocks = NULL;\n\n    if (is_bare_re)\n\t*is_bare_re = FALSE;\n\n    if (expr && (expr->op_type == OP_LIST ||\n\t\t(expr->op_type == OP_NULL && expr->op_targ == OP_LIST))) {\n\t/* allocate code_blocks if needed */\n\tOP *o;\n\tint ncode = 0;\n\n\tfor (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o))\n\t    if (o->op_type == OP_NULL && (o->op_flags & OPf_SPECIAL))\n\t\tncode++; /* count of DO blocks */\n\n\tif (ncode)\n            pRExC_state->code_blocks = S_alloc_code_blocks(aTHX_ ncode);\n    }\n\n    if (!pat_count) {\n        /* compile-time pattern with just OP_CONSTs and DO blocks */\n\n        int n;\n        OP *o;\n\n        /* find how many CONSTs there are */\n        assert(expr);\n        n = 0;\n        if (expr->op_type == OP_CONST)\n            n = 1;\n        else\n            for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {\n                if (o->op_type == OP_CONST)\n                    n++;\n            }\n\n        /* fake up an SV array */\n\n        assert(!new_patternp);\n        Newx(new_patternp, n, SV*);\n        SAVEFREEPV(new_patternp);\n        pat_count = n;\n\n        n = 0;\n        if (expr->op_type == OP_CONST)\n            new_patternp[n] = cSVOPx_sv(expr);\n        else\n            for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {\n                if (o->op_type == OP_CONST)\n                    new_patternp[n++] = cSVOPo_sv;\n            }\n\n    }\n\n    DEBUG_PARSE_r(Perl_re_printf( aTHX_\n        \"Assembling pattern from %d elements%s\\n\", pat_count,\n            orig_rx_flags & RXf_SPLIT ? \" for split\" : \"\"));\n\n    /* set expr to the first arg op */\n\n    if (pRExC_state->code_blocks && pRExC_state->code_blocks->count\n         && expr->op_type != OP_CONST)\n    {\n            expr = cLISTOPx(expr)->op_first;\n            assert(   expr->op_type == OP_PUSHMARK\n                   || (expr->op_type == OP_NULL && expr->op_targ == OP_PUSHMARK)\n                   || expr->op_type == OP_PADRANGE);\n            expr = OpSIBLING(expr);\n    }\n\n    pat = S_concat_pat(aTHX_ pRExC_state, NULL, new_patternp, pat_count,\n                        expr, &recompile, NULL);\n\n    /* handle bare (possibly after overloading) regex: foo =~ $re */\n    {\n        SV *re = pat;\n        if (SvROK(re))\n            re = SvRV(re);\n        if (SvTYPE(re) == SVt_REGEXP) {\n            if (is_bare_re)\n                *is_bare_re = TRUE;\n            SvREFCNT_inc(re);\n            DEBUG_PARSE_r(Perl_re_printf( aTHX_\n                \"Precompiled pattern%s\\n\",\n                    orig_rx_flags & RXf_SPLIT ? \" for split\" : \"\"));\n\n            return (REGEXP*)re;\n        }\n    }\n\n    exp = SvPV_nomg(pat, plen);\n\n    if (!eng->op_comp) {\n\tif ((SvUTF8(pat) && IN_BYTES)\n\t\t|| SvGMAGICAL(pat) || SvAMAGIC(pat))\n\t{\n\t    /* make a temporary copy; either to convert to bytes,\n\t     * or to avoid repeating get-magic / overloaded stringify */\n\t    pat = newSVpvn_flags(exp, plen, SVs_TEMP |\n\t\t\t\t\t(IN_BYTES ? 0 : SvUTF8(pat)));\n\t}\n\treturn CALLREGCOMP_ENG(eng, pat, orig_rx_flags);\n    }\n\n    /* ignore the utf8ness if the pattern is 0 length */\n    RExC_utf8 = RExC_orig_utf8 = (plen == 0 || IN_BYTES) ? 0 : SvUTF8(pat);\n    RExC_uni_semantics = 0;\n    RExC_contains_locale = 0;\n    RExC_strict = cBOOL(pm_flags & RXf_PMf_STRICT);\n    RExC_in_script_run = 0;\n    RExC_study_started = 0;\n    pRExC_state->runtime_code_qr = NULL;\n    RExC_frame_head= NULL;\n    RExC_frame_last= NULL;\n    RExC_frame_count= 0;\n    RExC_latest_warn_offset = 0;\n    RExC_use_BRANCHJ = 0;\n    RExC_total_parens = 0;\n    RExC_open_parens = NULL;\n    RExC_close_parens = NULL;\n    RExC_paren_names = NULL;\n    RExC_size = 0;\n    RExC_seen_d_op = FALSE;\n#ifdef DEBUGGING\n    RExC_paren_name_list = NULL;\n#endif\n\n    DEBUG_r({\n        RExC_mysv1= sv_newmortal();\n        RExC_mysv2= sv_newmortal();\n    });\n\n    DEBUG_COMPILE_r({\n            SV *dsv= sv_newmortal();\n            RE_PV_QUOTED_DECL(s, RExC_utf8, dsv, exp, plen, PL_dump_re_max_len);\n            Perl_re_printf( aTHX_  \"%sCompiling REx%s %s\\n\",\n                          PL_colors[4], PL_colors[5], s);\n        });\n\n    /* we jump here if we have to recompile, e.g., from upgrading the pattern\n     * to utf8 */\n\n    if ((pm_flags & PMf_USE_RE_EVAL)\n\t\t/* this second condition covers the non-regex literal case,\n\t\t * i.e.  $foo =~ '(?{})'. */\n\t\t|| (IN_PERL_COMPILETIME && (PL_hints & HINT_RE_EVAL))\n    )\n\truntime_code = S_has_runtime_code(aTHX_ pRExC_state, exp, plen);\n\n  redo_parse:\n    /* return old regex if pattern hasn't changed */\n    /* XXX: note in the below we have to check the flags as well as the\n     * pattern.\n     *\n     * Things get a touch tricky as we have to compare the utf8 flag\n     * independently from the compile flags.  */\n\n    if (   old_re\n        && !recompile\n        && !!RX_UTF8(old_re) == !!RExC_utf8\n        && ( RX_COMPFLAGS(old_re) == ( orig_rx_flags & RXf_PMf_FLAGCOPYMASK ) )\n\t&& RX_PRECOMP(old_re)\n\t&& RX_PRELEN(old_re) == plen\n        && memEQ(RX_PRECOMP(old_re), exp, plen)\n\t&& !runtime_code /* with runtime code, always recompile */ )\n    {\n        return old_re;\n    }\n\n    /* Allocate the pattern's SV */\n    RExC_rx_sv = Rx = (REGEXP*) newSV_type(SVt_REGEXP);\n    RExC_rx = ReANY(Rx);\n    if ( RExC_rx == NULL )\n        FAIL(\"Regexp out of space\");\n\n    rx_flags = orig_rx_flags;\n\n    if (   (UTF || RExC_uni_semantics)\n        && initial_charset == REGEX_DEPENDS_CHARSET)\n    {\n\n\t/* Set to use unicode semantics if the pattern is in utf8 and has the\n\t * 'depends' charset specified, as it means unicode when utf8  */\n\tset_regex_charset(&rx_flags, REGEX_UNICODE_CHARSET);\n        RExC_uni_semantics = 1;\n    }\n\n    RExC_pm_flags = pm_flags;\n\n    if (runtime_code) {\n        assert(TAINTING_get || !TAINT_get);\n\tif (TAINT_get)\n\t    Perl_croak(aTHX_ \"Eval-group in insecure regular expression\");\n\n\tif (!S_compile_runtime_code(aTHX_ pRExC_state, exp, plen)) {\n\t    /* whoops, we have a non-utf8 pattern, whilst run-time code\n\t     * got compiled as utf8. Try again with a utf8 pattern */\n            S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,\n                pRExC_state->code_blocks ? pRExC_state->code_blocks->count : 0);\n            goto redo_parse;\n\t}\n    }\n    assert(!pRExC_state->runtime_code_qr);\n\n    RExC_sawback = 0;\n\n    RExC_seen = 0;\n    RExC_maxlen = 0;\n    RExC_in_lookbehind = 0;\n    RExC_seen_zerolen = *exp == '^' ? -1 : 0;\n#ifdef EBCDIC\n    RExC_recode_x_to_native = 0;\n#endif\n    RExC_in_multi_char_class = 0;\n\n    RExC_start = RExC_copy_start_in_constructed = RExC_copy_start_in_input = RExC_precomp = exp;\n    RExC_precomp_end = RExC_end = exp + plen;\n    RExC_nestroot = 0;\n    RExC_whilem_seen = 0;\n    RExC_end_op = NULL;\n    RExC_recurse = NULL;\n    RExC_study_chunk_recursed = NULL;\n    RExC_study_chunk_recursed_bytes= 0;\n    RExC_recurse_count = 0;\n    pRExC_state->code_index = 0;\n\n    /* Initialize the string in the compiled pattern.  This is so that there is\n     * something to output if necessary */\n    set_regex_pv(pRExC_state, Rx);\n\n    DEBUG_PARSE_r({\n        Perl_re_printf( aTHX_\n            \"Starting parse and generation\\n\");\n        RExC_lastnum=0;\n        RExC_lastparse=NULL;\n    });\n\n    /* Allocate space and zero-initialize. Note, the two step process\n       of zeroing when in debug mode, thus anything assigned has to\n       happen after that */\n    if (!  RExC_size) {\n\n        /* On the first pass of the parse, we guess how big this will be.  Then\n         * we grow in one operation to that amount and then give it back.  As\n         * we go along, we re-allocate what we need.\n         *\n         * XXX Currently the guess is essentially that the pattern will be an\n         * EXACT node with one byte input, one byte output.  This is crude, and\n         * better heuristics are welcome.\n         *\n         * On any subsequent passes, we guess what we actually computed in the\n         * latest earlier pass.  Such a pass probably didn't complete so is\n         * missing stuff.  We could improve those guesses by knowing where the\n         * parse stopped, and use the length so far plus apply the above\n         * assumption to what's left. */\n        RExC_size = STR_SZ(RExC_end - RExC_start);\n    }\n\n    Newxc(RExC_rxi, sizeof(regexp_internal) + RExC_size, char, regexp_internal);\n    if ( RExC_rxi == NULL )\n        FAIL(\"Regexp out of space\");\n\n    Zero(RExC_rxi, sizeof(regexp_internal) + RExC_size, char);\n    RXi_SET( RExC_rx, RExC_rxi );\n\n    /* We start from 0 (over from 0 in the case this is a reparse.  The first\n     * node parsed will give back any excess memory we have allocated so far).\n     * */\n    RExC_size = 0;\n\n    /* non-zero initialization begins here */\n    RExC_rx->engine= eng;\n    RExC_rx->extflags = rx_flags;\n    RXp_COMPFLAGS(RExC_rx) = orig_rx_flags & RXf_PMf_FLAGCOPYMASK;\n\n    if (pm_flags & PMf_IS_QR) {\n\tRExC_rxi->code_blocks = pRExC_state->code_blocks;\n        if (RExC_rxi->code_blocks) {\n            RExC_rxi->code_blocks->refcnt++;\n        }\n    }\n\n    RExC_rx->intflags = 0;\n\n    RExC_flags = rx_flags;\t/* don't let top level (?i) bleed */\n    RExC_parse = exp;\n\n    /* This NUL is guaranteed because the pattern comes from an SV*, and the sv\n     * code makes sure the final byte is an uncounted NUL.  But should this\n     * ever not be the case, lots of things could read beyond the end of the\n     * buffer: loops like\n     *      while(isFOO(*RExC_parse)) RExC_parse++;\n     *      strchr(RExC_parse, \"foo\");\n     * etc.  So it is worth noting. */\n    assert(*RExC_end == '\\0');\n\n    RExC_naughty = 0;\n    RExC_npar = 1;\n    RExC_parens_buf_size = 0;\n    RExC_emit_start = RExC_rxi->program;\n    pRExC_state->code_index = 0;\n\n    *((char*) RExC_emit_start) = (char) REG_MAGIC;\n    RExC_emit = 1;\n\n    /* Do the parse */\n    if (reg(pRExC_state, 0, &flags, 1)) {\n\n        /* Success!, But we may need to redo the parse knowing how many parens\n         * there actually are */\n        if (IN_PARENS_PASS) {\n            flags |= RESTART_PARSE;\n        }\n\n        /* We have that number in RExC_npar */\n        RExC_total_parens = RExC_npar;\n\n        /* XXX For backporting, use long jumps if there is any possibility of\n         * overflow */\n        if (RExC_size > U16_MAX && ! RExC_use_BRANCHJ) {\n            RExC_use_BRANCHJ = TRUE;\n            flags |= RESTART_PARSE;\n        }\n    }\n    else if (! MUST_RESTART(flags)) {\n\tReREFCNT_dec(Rx);\n        Perl_croak(aTHX_ \"panic: reg returned failure to re_op_compile, flags=%#\" UVxf, (UV) flags);\n    }\n\n    /* Here, we either have success, or we have to redo the parse for some reason */\n    if (MUST_RESTART(flags)) {\n\n        /* It's possible to write a regexp in ascii that represents Unicode\n        codepoints outside of the byte range, such as via \\x{100}. If we\n        detect such a sequence we have to convert the entire pattern to utf8\n        and then recompile, as our sizing calculation will have been based\n        on 1 byte == 1 character, but we will need to use utf8 to encode\n        at least some part of the pattern, and therefore must convert the whole\n        thing.\n        -- dmq */\n        if (flags & NEED_UTF8) {\n\n            /* We have stored the offset of the final warning output so far.\n             * That must be adjusted.  Any variant characters between the start\n             * of the pattern and this warning count for 2 bytes in the final,\n             * so just add them again */\n            if (UNLIKELY(RExC_latest_warn_offset > 0)) {\n                RExC_latest_warn_offset +=\n                            variant_under_utf8_count((U8 *) exp, (U8 *) exp\n                                                + RExC_latest_warn_offset);\n            }\n            S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,\n            pRExC_state->code_blocks ? pRExC_state->code_blocks->count : 0);\n            DEBUG_PARSE_r(Perl_re_printf( aTHX_ \"Need to redo parse after upgrade\\n\"));\n        }\n        else {\n            DEBUG_PARSE_r(Perl_re_printf( aTHX_ \"Need to redo parse\\n\"));\n        }\n\n        if (ALL_PARENS_COUNTED) {\n            /* Make enough room for all the known parens, and zero it */\n            Renew(RExC_open_parens, RExC_total_parens, regnode_offset);\n            Zero(RExC_open_parens, RExC_total_parens, regnode_offset);\n            RExC_open_parens[0] = 1;    /* +1 for REG_MAGIC */\n\n            Renew(RExC_close_parens, RExC_total_parens, regnode_offset);\n            Zero(RExC_close_parens, RExC_total_parens, regnode_offset);\n        }\n        else { /* Parse did not complete.  Reinitialize the parentheses\n                  structures */\n            RExC_total_parens = 0;\n            if (RExC_open_parens) {\n                Safefree(RExC_open_parens);\n                RExC_open_parens = NULL;\n            }\n            if (RExC_close_parens) {\n                Safefree(RExC_close_parens);\n                RExC_close_parens = NULL;\n            }\n        }\n\n        /* Clean up what we did in this parse */\n        SvREFCNT_dec_NN(RExC_rx_sv);\n\n        goto redo_parse;\n    }\n\n    /* Here, we have successfully parsed and generated the pattern's program\n     * for the regex engine.  We are ready to finish things up and look for\n     * optimizations. */\n\n    /* Update the string to compile, with correct modifiers, etc */\n    set_regex_pv(pRExC_state, Rx);\n\n    RExC_rx->nparens = RExC_total_parens - 1;\n\n    /* Uses the upper 4 bits of the FLAGS field, so keep within that size */\n    if (RExC_whilem_seen > 15)\n        RExC_whilem_seen = 15;\n\n    DEBUG_PARSE_r({\n        Perl_re_printf( aTHX_\n            \"Required size %\" IVdf \" nodes\\n\", (IV)RExC_size);\n        RExC_lastnum=0;\n        RExC_lastparse=NULL;\n    });\n\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    DEBUG_OFFSETS_r(Perl_re_printf( aTHX_\n                          \"%s %\" UVuf \" bytes for offset annotations.\\n\",\n                          RExC_offsets ? \"Got\" : \"Couldn't get\",\n                          (UV)((RExC_offsets[0] * 2 + 1))));\n    DEBUG_OFFSETS_r(if (RExC_offsets) {\n        const STRLEN len = RExC_offsets[0];\n        STRLEN i;\n        GET_RE_DEBUG_FLAGS_DECL;\n        Perl_re_printf( aTHX_\n                      \"Offsets: [%\" UVuf \"]\\n\\t\", (UV)RExC_offsets[0]);\n        for (i = 1; i <= len; i++) {\n            if (RExC_offsets[i*2-1] || RExC_offsets[i*2])\n                Perl_re_printf( aTHX_  \"%\" UVuf \":%\" UVuf \"[%\" UVuf \"] \",\n                (UV)i, (UV)RExC_offsets[i*2-1], (UV)RExC_offsets[i*2]);\n        }\n        Perl_re_printf( aTHX_  \"\\n\");\n    });\n\n#else\n    SetProgLen(RExC_rxi,RExC_size);\n#endif\n\n    DEBUG_OPTIMISE_r(\n        Perl_re_printf( aTHX_  \"Starting post parse optimization\\n\");\n    );\n\n    /* XXXX To minimize changes to RE engine we always allocate\n       3-units-long substrs field. */\n    Newx(RExC_rx->substrs, 1, struct reg_substr_data);\n    if (RExC_recurse_count) {\n        Newx(RExC_recurse, RExC_recurse_count, regnode *);\n        SAVEFREEPV(RExC_recurse);\n    }\n\n    if (RExC_seen & REG_RECURSE_SEEN) {\n        /* Note, RExC_total_parens is 1 + the number of parens in a pattern.\n         * So its 1 if there are no parens. */\n        RExC_study_chunk_recursed_bytes= (RExC_total_parens >> 3) +\n                                         ((RExC_total_parens & 0x07) != 0);\n        Newx(RExC_study_chunk_recursed,\n             RExC_study_chunk_recursed_bytes * RExC_total_parens, U8);\n        SAVEFREEPV(RExC_study_chunk_recursed);\n    }\n\n  reStudy:\n    RExC_rx->minlen = minlen = sawlookahead = sawplus = sawopen = sawminmod = 0;\n    DEBUG_r(\n        RExC_study_chunk_recursed_count= 0;\n    );\n    Zero(RExC_rx->substrs, 1, struct reg_substr_data);\n    if (RExC_study_chunk_recursed) {\n        Zero(RExC_study_chunk_recursed,\n             RExC_study_chunk_recursed_bytes * RExC_total_parens, U8);\n    }\n\n\n#ifdef TRIE_STUDY_OPT\n    if (!restudied) {\n        StructCopy(&zero_scan_data, &data, scan_data_t);\n        copyRExC_state = RExC_state;\n    } else {\n        U32 seen=RExC_seen;\n        DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_ \"Restudying\\n\"));\n\n        RExC_state = copyRExC_state;\n        if (seen & REG_TOP_LEVEL_BRANCHES_SEEN)\n            RExC_seen |= REG_TOP_LEVEL_BRANCHES_SEEN;\n        else\n            RExC_seen &= ~REG_TOP_LEVEL_BRANCHES_SEEN;\n\tStructCopy(&zero_scan_data, &data, scan_data_t);\n    }\n#else\n    StructCopy(&zero_scan_data, &data, scan_data_t);\n#endif\n\n    /* Dig out information for optimizations. */\n    RExC_rx->extflags = RExC_flags; /* was pm_op */\n    /*dmq: removed as part of de-PMOP: pm->op_pmflags = RExC_flags; */\n\n    if (UTF)\n\tSvUTF8_on(Rx);\t/* Unicode in it? */\n    RExC_rxi->regstclass = NULL;\n    if (RExC_naughty >= TOO_NAUGHTY)\t/* Probably an expensive pattern. */\n\tRExC_rx->intflags |= PREGf_NAUGHTY;\n    scan = RExC_rxi->program + 1;\t\t/* First BRANCH. */\n\n    /* testing for BRANCH here tells us whether there is \"must appear\"\n       data in the pattern. If there is then we can use it for optimisations */\n    if (!(RExC_seen & REG_TOP_LEVEL_BRANCHES_SEEN)) { /*  Only one top-level choice.\n                                                  */\n\tSSize_t fake;\n\tSTRLEN longest_length[2];\n\tregnode_ssc ch_class; /* pointed to by data */\n\tint stclass_flag;\n\tSSize_t last_close = 0; /* pointed to by data */\n        regnode *first= scan;\n        regnode *first_next= regnext(first);\n        int i;\n\n\t/*\n\t * Skip introductions and multiplicators >= 1\n\t * so that we can extract the 'meat' of the pattern that must\n\t * match in the large if() sequence following.\n\t * NOTE that EXACT is NOT covered here, as it is normally\n\t * picked up by the optimiser separately.\n\t *\n\t * This is unfortunate as the optimiser isnt handling lookahead\n\t * properly currently.\n\t *\n\t */\n\twhile ((OP(first) == OPEN && (sawopen = 1)) ||\n\t       /* An OR of *one* alternative - should not happen now. */\n\t    (OP(first) == BRANCH && OP(first_next) != BRANCH) ||\n\t    /* for now we can't handle lookbehind IFMATCH*/\n\t    (OP(first) == IFMATCH && !first->flags && (sawlookahead = 1)) ||\n\t    (OP(first) == PLUS) ||\n\t    (OP(first) == MINMOD) ||\n\t       /* An {n,m} with n>0 */\n\t    (PL_regkind[OP(first)] == CURLY && ARG1(first) > 0) ||\n\t    (OP(first) == NOTHING && PL_regkind[OP(first_next)] != END ))\n\t{\n\t\t/*\n\t\t * the only op that could be a regnode is PLUS, all the rest\n\t\t * will be regnode_1 or regnode_2.\n\t\t *\n                 * (yves doesn't think this is true)\n\t\t */\n\t\tif (OP(first) == PLUS)\n\t\t    sawplus = 1;\n                else {\n                    if (OP(first) == MINMOD)\n                        sawminmod = 1;\n\t\t    first += regarglen[OP(first)];\n                }\n\t\tfirst = NEXTOPER(first);\n\t\tfirst_next= regnext(first);\n\t}\n\n\t/* Starting-point info. */\n      again:\n        DEBUG_PEEP(\"first:\", first, 0, 0);\n        /* Ignore EXACT as we deal with it later. */\n\tif (PL_regkind[OP(first)] == EXACT) {\n\t    if (   OP(first) == EXACT\n                || OP(first) == EXACT_ONLY8\n                || OP(first) == EXACTL)\n            {\n\t\tNOOP;\t/* Empty, get anchored substr later. */\n            }\n\t    else\n\t\tRExC_rxi->regstclass = first;\n\t}\n#ifdef TRIE_STCLASS\n\telse if (PL_regkind[OP(first)] == TRIE &&\n\t        ((reg_trie_data *)RExC_rxi->data->data[ ARG(first) ])->minlen>0)\n\t{\n            /* this can happen only on restudy */\n            RExC_rxi->regstclass = construct_ahocorasick_from_trie(pRExC_state, (regnode *)first, 0);\n\t}\n#endif\n\telse if (REGNODE_SIMPLE(OP(first)))\n\t    RExC_rxi->regstclass = first;\n\telse if (PL_regkind[OP(first)] == BOUND ||\n\t\t PL_regkind[OP(first)] == NBOUND)\n\t    RExC_rxi->regstclass = first;\n\telse if (PL_regkind[OP(first)] == BOL) {\n            RExC_rx->intflags |= (OP(first) == MBOL\n                           ? PREGf_ANCH_MBOL\n                           : PREGf_ANCH_SBOL);\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n\telse if (OP(first) == GPOS) {\n            RExC_rx->intflags |= PREGf_ANCH_GPOS;\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n\telse if ((!sawopen || !RExC_sawback) &&\n            !sawlookahead &&\n\t    (OP(first) == STAR &&\n\t    PL_regkind[OP(NEXTOPER(first))] == REG_ANY) &&\n            !(RExC_rx->intflags & PREGf_ANCH) && !pRExC_state->code_blocks)\n\t{\n\t    /* turn .* into ^.* with an implied $*=1 */\n\t    const int type =\n\t\t(OP(NEXTOPER(first)) == REG_ANY)\n                    ? PREGf_ANCH_MBOL\n                    : PREGf_ANCH_SBOL;\n            RExC_rx->intflags |= (type | PREGf_IMPLICIT);\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n        if (sawplus && !sawminmod && !sawlookahead\n            && (!sawopen || !RExC_sawback)\n\t    && !pRExC_state->code_blocks) /* May examine pos and $& */\n\t    /* x+ must match at the 1st pos of run of x's */\n\t    RExC_rx->intflags |= PREGf_SKIP;\n\n\t/* Scan is after the zeroth branch, first is atomic matcher. */\n#ifdef TRIE_STUDY_OPT\n\tDEBUG_PARSE_r(\n\t    if (!restudied)\n                Perl_re_printf( aTHX_  \"first at %\" IVdf \"\\n\",\n\t\t\t      (IV)(first - scan + 1))\n        );\n#else\n\tDEBUG_PARSE_r(\n            Perl_re_printf( aTHX_  \"first at %\" IVdf \"\\n\",\n\t        (IV)(first - scan + 1))\n        );\n#endif\n\n\n\t/*\n\t* If there's something expensive in the r.e., find the\n\t* longest literal string that must appear and make it the\n\t* regmust.  Resolve ties in favor of later strings, since\n\t* the regstart check works with the beginning of the r.e.\n\t* and avoiding duplication strengthens checking.  Not a\n\t* strong reason, but sufficient in the absence of others.\n\t* [Now we resolve ties in favor of the earlier string if\n\t* it happens that c_offset_min has been invalidated, since the\n\t* earlier string may buy us something the later one won't.]\n\t*/\n\n\tdata.substrs[0].str = newSVpvs(\"\");\n\tdata.substrs[1].str = newSVpvs(\"\");\n\tdata.last_found = newSVpvs(\"\");\n\tdata.cur_is_floating = 0; /* initially any found substring is fixed */\n\tENTER_with_name(\"study_chunk\");\n\tSAVEFREESV(data.substrs[0].str);\n\tSAVEFREESV(data.substrs[1].str);\n\tSAVEFREESV(data.last_found);\n\tfirst = scan;\n\tif (!RExC_rxi->regstclass) {\n\t    ssc_init(pRExC_state, &ch_class);\n\t    data.start_class = &ch_class;\n\t    stclass_flag = SCF_DO_STCLASS_AND;\n\t} else\t\t\t\t/* XXXX Check for BOUND? */\n\t    stclass_flag = 0;\n\tdata.last_closep = &last_close;\n\n        DEBUG_RExC_seen();\n        /*\n         * MAIN ENTRY FOR study_chunk() FOR m/PATTERN/\n         * (NO top level branches)\n         */\n\tminlen = study_chunk(pRExC_state, &first, &minlen, &fake,\n                             scan + RExC_size, /* Up to end */\n            &data, -1, 0, NULL,\n            SCF_DO_SUBSTR | SCF_WHILEM_VISITED_POS | stclass_flag\n                          | (restudied ? SCF_TRIE_DOING_RESTUDY : 0),\n            0);\n\n\n        CHECK_RESTUDY_GOTO_butfirst(LEAVE_with_name(\"study_chunk\"));\n\n\n\tif ( RExC_total_parens == 1 && !data.cur_is_floating\n\t     && data.last_start_min == 0 && data.last_end > 0\n\t     && !RExC_seen_zerolen\n             && !(RExC_seen & REG_VERBARG_SEEN)\n             && !(RExC_seen & REG_GPOS_SEEN)\n        ){\n\t    RExC_rx->extflags |= RXf_CHECK_ALL;\n        }\n\tscan_commit(pRExC_state, &data,&minlen, 0);\n\n\n        /* XXX this is done in reverse order because that's the way the\n         * code was before it was parameterised. Don't know whether it\n         * actually needs doing in reverse order. DAPM */\n        for (i = 1; i >= 0; i--) {\n            longest_length[i] = CHR_SVLEN(data.substrs[i].str);\n\n            if (   !(   i\n                     && SvCUR(data.substrs[0].str)  /* ok to leave SvCUR */\n                     &&    data.substrs[0].min_offset\n                        == data.substrs[1].min_offset\n                     &&    SvCUR(data.substrs[0].str)\n                        == SvCUR(data.substrs[1].str)\n                    )\n                && S_setup_longest (aTHX_ pRExC_state,\n                                        &(RExC_rx->substrs->data[i]),\n                                        &(data.substrs[i]),\n                                        longest_length[i]))\n            {\n                RExC_rx->substrs->data[i].min_offset =\n                        data.substrs[i].min_offset - data.substrs[i].lookbehind;\n\n                RExC_rx->substrs->data[i].max_offset = data.substrs[i].max_offset;\n                /* Don't offset infinity */\n                if (data.substrs[i].max_offset < SSize_t_MAX)\n                    RExC_rx->substrs->data[i].max_offset -= data.substrs[i].lookbehind;\n                SvREFCNT_inc_simple_void_NN(data.substrs[i].str);\n            }\n            else {\n                RExC_rx->substrs->data[i].substr      = NULL;\n                RExC_rx->substrs->data[i].utf8_substr = NULL;\n                longest_length[i] = 0;\n            }\n        }\n\n\tLEAVE_with_name(\"study_chunk\");\n\n\tif (RExC_rxi->regstclass\n\t    && (OP(RExC_rxi->regstclass) == REG_ANY || OP(RExC_rxi->regstclass) == SANY))\n\t    RExC_rxi->regstclass = NULL;\n\n\tif ((!(RExC_rx->substrs->data[0].substr || RExC_rx->substrs->data[0].utf8_substr)\n              || RExC_rx->substrs->data[0].min_offset)\n\t    && stclass_flag\n            && ! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)\n\t    && is_ssc_worth_it(pRExC_state, data.start_class))\n\t{\n\t    const U32 n = add_data(pRExC_state, STR_WITH_LEN(\"f\"));\n\n            ssc_finalize(pRExC_state, data.start_class);\n\n\t    Newx(RExC_rxi->data->data[n], 1, regnode_ssc);\n\t    StructCopy(data.start_class,\n\t\t       (regnode_ssc*)RExC_rxi->data->data[n],\n\t\t       regnode_ssc);\n\t    RExC_rxi->regstclass = (regnode*)RExC_rxi->data->data[n];\n\t    RExC_rx->intflags &= ~PREGf_SKIP;\t/* Used in find_byclass(). */\n\t    DEBUG_COMPILE_r({ SV *sv = sv_newmortal();\n                      regprop(RExC_rx, sv, (regnode*)data.start_class, NULL, pRExC_state);\n                      Perl_re_printf( aTHX_\n\t\t\t\t    \"synthetic stclass \\\"%s\\\".\\n\",\n\t\t\t\t    SvPVX_const(sv));});\n            data.start_class = NULL;\n\t}\n\n        /* A temporary algorithm prefers floated substr to fixed one of\n         * same length to dig more info. */\n\ti = (longest_length[0] <= longest_length[1]);\n        RExC_rx->substrs->check_ix = i;\n        RExC_rx->check_end_shift  = RExC_rx->substrs->data[i].end_shift;\n        RExC_rx->check_substr     = RExC_rx->substrs->data[i].substr;\n        RExC_rx->check_utf8       = RExC_rx->substrs->data[i].utf8_substr;\n        RExC_rx->check_offset_min = RExC_rx->substrs->data[i].min_offset;\n        RExC_rx->check_offset_max = RExC_rx->substrs->data[i].max_offset;\n        if (!i && (RExC_rx->intflags & (PREGf_ANCH_SBOL|PREGf_ANCH_GPOS)))\n            RExC_rx->intflags |= PREGf_NOSCAN;\n\n\tif ((RExC_rx->check_substr || RExC_rx->check_utf8) ) {\n\t    RExC_rx->extflags |= RXf_USE_INTUIT;\n\t    if (SvTAIL(RExC_rx->check_substr ? RExC_rx->check_substr : RExC_rx->check_utf8))\n\t\tRExC_rx->extflags |= RXf_INTUIT_TAIL;\n\t}\n\n\t/* XXX Unneeded? dmq (shouldn't as this is handled elsewhere)\n\tif ( (STRLEN)minlen < longest_length[1] )\n            minlen= longest_length[1];\n        if ( (STRLEN)minlen < longest_length[0] )\n            minlen= longest_length[0];\n        */\n    }\n    else {\n\t/* Several toplevels. Best we can is to set minlen. */\n\tSSize_t fake;\n\tregnode_ssc ch_class;\n\tSSize_t last_close = 0;\n\n        DEBUG_PARSE_r(Perl_re_printf( aTHX_  \"\\nMulti Top Level\\n\"));\n\n\tscan = RExC_rxi->program + 1;\n\tssc_init(pRExC_state, &ch_class);\n\tdata.start_class = &ch_class;\n\tdata.last_closep = &last_close;\n\n        DEBUG_RExC_seen();\n        /*\n         * MAIN ENTRY FOR study_chunk() FOR m/P1|P2|.../\n         * (patterns WITH top level branches)\n         */\n\tminlen = study_chunk(pRExC_state,\n            &scan, &minlen, &fake, scan + RExC_size, &data, -1, 0, NULL,\n            SCF_DO_STCLASS_AND|SCF_WHILEM_VISITED_POS|(restudied\n                                                      ? SCF_TRIE_DOING_RESTUDY\n                                                      : 0),\n            0);\n\n        CHECK_RESTUDY_GOTO_butfirst(NOOP);\n\n\tRExC_rx->check_substr = NULL;\n        RExC_rx->check_utf8 = NULL;\n        RExC_rx->substrs->data[0].substr      = NULL;\n        RExC_rx->substrs->data[0].utf8_substr = NULL;\n        RExC_rx->substrs->data[1].substr      = NULL;\n        RExC_rx->substrs->data[1].utf8_substr = NULL;\n\n        if (! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)\n\t    && is_ssc_worth_it(pRExC_state, data.start_class))\n        {\n\t    const U32 n = add_data(pRExC_state, STR_WITH_LEN(\"f\"));\n\n            ssc_finalize(pRExC_state, data.start_class);\n\n\t    Newx(RExC_rxi->data->data[n], 1, regnode_ssc);\n\t    StructCopy(data.start_class,\n\t\t       (regnode_ssc*)RExC_rxi->data->data[n],\n\t\t       regnode_ssc);\n\t    RExC_rxi->regstclass = (regnode*)RExC_rxi->data->data[n];\n\t    RExC_rx->intflags &= ~PREGf_SKIP;\t/* Used in find_byclass(). */\n\t    DEBUG_COMPILE_r({ SV* sv = sv_newmortal();\n                      regprop(RExC_rx, sv, (regnode*)data.start_class, NULL, pRExC_state);\n                      Perl_re_printf( aTHX_\n\t\t\t\t    \"synthetic stclass \\\"%s\\\".\\n\",\n\t\t\t\t    SvPVX_const(sv));});\n            data.start_class = NULL;\n\t}\n    }\n\n    if (RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN) {\n        RExC_rx->extflags |= RXf_UNBOUNDED_QUANTIFIER_SEEN;\n        RExC_rx->maxlen = REG_INFTY;\n    }\n    else {\n        RExC_rx->maxlen = RExC_maxlen;\n    }\n\n    /* Guard against an embedded (?=) or (?<=) with a longer minlen than\n       the \"real\" pattern. */\n    DEBUG_OPTIMISE_r({\n        Perl_re_printf( aTHX_ \"minlen: %\" IVdf \" RExC_rx->minlen:%\" IVdf \" maxlen:%\" IVdf \"\\n\",\n                      (IV)minlen, (IV)RExC_rx->minlen, (IV)RExC_maxlen);\n    });\n    RExC_rx->minlenret = minlen;\n    if (RExC_rx->minlen < minlen)\n        RExC_rx->minlen = minlen;\n\n    if (RExC_seen & REG_RECURSE_SEEN ) {\n        RExC_rx->intflags |= PREGf_RECURSE_SEEN;\n        Newx(RExC_rx->recurse_locinput, RExC_rx->nparens + 1, char *);\n    }\n    if (RExC_seen & REG_GPOS_SEEN)\n        RExC_rx->intflags |= PREGf_GPOS_SEEN;\n    if (RExC_seen & REG_LOOKBEHIND_SEEN)\n        RExC_rx->extflags |= RXf_NO_INPLACE_SUBST; /* inplace might break the\n                                                lookbehind */\n    if (pRExC_state->code_blocks)\n\tRExC_rx->extflags |= RXf_EVAL_SEEN;\n    if (RExC_seen & REG_VERBARG_SEEN)\n    {\n\tRExC_rx->intflags |= PREGf_VERBARG_SEEN;\n        RExC_rx->extflags |= RXf_NO_INPLACE_SUBST; /* don't understand this! Yves */\n    }\n    if (RExC_seen & REG_CUTGROUP_SEEN)\n\tRExC_rx->intflags |= PREGf_CUTGROUP_SEEN;\n    if (pm_flags & PMf_USE_RE_EVAL)\n\tRExC_rx->intflags |= PREGf_USE_RE_EVAL;\n    if (RExC_paren_names)\n        RXp_PAREN_NAMES(RExC_rx) = MUTABLE_HV(SvREFCNT_inc(RExC_paren_names));\n    else\n        RXp_PAREN_NAMES(RExC_rx) = NULL;\n\n    /* If we have seen an anchor in our pattern then we set the extflag RXf_IS_ANCHORED\n     * so it can be used in pp.c */\n    if (RExC_rx->intflags & PREGf_ANCH)\n        RExC_rx->extflags |= RXf_IS_ANCHORED;\n\n\n    {\n        /* this is used to identify \"special\" patterns that might result\n         * in Perl NOT calling the regex engine and instead doing the match \"itself\",\n         * particularly special cases in split//. By having the regex compiler\n         * do this pattern matching at a regop level (instead of by inspecting the pattern)\n         * we avoid weird issues with equivalent patterns resulting in different behavior,\n         * AND we allow non Perl engines to get the same optimizations by the setting the\n         * flags appropriately - Yves */\n        regnode *first = RExC_rxi->program + 1;\n        U8 fop = OP(first);\n        regnode *next = regnext(first);\n        U8 nop = OP(next);\n\n        if (PL_regkind[fop] == NOTHING && nop == END)\n            RExC_rx->extflags |= RXf_NULL;\n        else if ((fop == MBOL || (fop == SBOL && !first->flags)) && nop == END)\n            /* when fop is SBOL first->flags will be true only when it was\n             * produced by parsing /\\A/, and not when parsing /^/. This is\n             * very important for the split code as there we want to\n             * treat /^/ as /^/m, but we do not want to treat /\\A/ as /^/m.\n             * See rt #122761 for more details. -- Yves */\n            RExC_rx->extflags |= RXf_START_ONLY;\n        else if (fop == PLUS\n                 && PL_regkind[nop] == POSIXD && FLAGS(next) == _CC_SPACE\n                 && nop == END)\n            RExC_rx->extflags |= RXf_WHITE;\n        else if ( RExC_rx->extflags & RXf_SPLIT\n                  && (fop == EXACT || fop == EXACT_ONLY8 || fop == EXACTL)\n                  && STR_LEN(first) == 1\n                  && *(STRING(first)) == ' '\n                  && nop == END )\n            RExC_rx->extflags |= (RXf_SKIPWHITE|RXf_WHITE);\n\n    }\n\n    if (RExC_contains_locale) {\n        RXp_EXTFLAGS(RExC_rx) |= RXf_TAINTED;\n    }\n\n#ifdef DEBUGGING\n    if (RExC_paren_names) {\n        RExC_rxi->name_list_idx = add_data( pRExC_state, STR_WITH_LEN(\"a\"));\n        RExC_rxi->data->data[RExC_rxi->name_list_idx]\n                                   = (void*)SvREFCNT_inc(RExC_paren_name_list);\n    } else\n#endif\n    RExC_rxi->name_list_idx = 0;\n\n    while ( RExC_recurse_count > 0 ) {\n        const regnode *scan = RExC_recurse[ --RExC_recurse_count ];\n        /*\n         * This data structure is set up in study_chunk() and is used\n         * to calculate the distance between a GOSUB regopcode and\n         * the OPEN/CURLYM (CURLYM's are special and can act like OPEN's)\n         * it refers to.\n         *\n         * If for some reason someone writes code that optimises\n         * away a GOSUB opcode then the assert should be changed to\n         * an if(scan) to guard the ARG2L_SET() - Yves\n         *\n         */\n        assert(scan && OP(scan) == GOSUB);\n        ARG2L_SET( scan, RExC_open_parens[ARG(scan)] - REGNODE_OFFSET(scan));\n    }\n\n    Newxz(RExC_rx->offs, RExC_total_parens, regexp_paren_pair);\n    /* assume we don't need to swap parens around before we match */\n    DEBUG_TEST_r({\n        Perl_re_printf( aTHX_ \"study_chunk_recursed_count: %lu\\n\",\n            (unsigned long)RExC_study_chunk_recursed_count);\n    });\n    DEBUG_DUMP_r({\n        DEBUG_RExC_seen();\n        Perl_re_printf( aTHX_ \"Final program:\\n\");\n        regdump(RExC_rx);\n    });\n\n    if (RExC_open_parens) {\n        Safefree(RExC_open_parens);\n        RExC_open_parens = NULL;\n    }\n    if (RExC_close_parens) {\n        Safefree(RExC_close_parens);\n        RExC_close_parens = NULL;\n    }\n\n#ifdef USE_ITHREADS\n    /* under ithreads the ?pat? PMf_USED flag on the pmop is simulated\n     * by setting the regexp SV to readonly-only instead. If the\n     * pattern's been recompiled, the USEDness should remain. */\n    if (old_re && SvREADONLY(old_re))\n        SvREADONLY_on(Rx);\n#endif\n    return Rx;", "commit_link": "github.com/perl/perl5/commit/3295b48defa0f8570114877b063fe546dd348b3c", "file_name": "regcomp.c", "vul_type": "cwe-190", "description": "Compile a regular expression pattern in Perl."}
{"func_name": "_put_validation_file", "func_src_before": "    def _put_validation_file(self, domain, file_path, file_name, content):\n        \"\"\"Put file to the domain with validation content\"\"\"\n        request = {'packet': {'site': {'get': [\n            {'filter': {'name': domain}},\n            {'dataset': {'hosting': {}}},\n        ]}}}\n        response = self.plesk_api_client.request(request)\n\n        api_result = response['packet']['site']['get']['result']\n        if 'ok' != api_result['status']:\n            error_text = str(api_result['errtext'])\n            raise errors.DvAuthError('Site get failure: %s' % error_text)\n\n        hosting_props = api_result['data']['hosting']['vrt_hst']['property']\n        self.www_root = next(\n            x['value'] for x in hosting_props if 'www_root' == x['name'])\n        self.ftp_login = next(\n            x['value'] for x in hosting_props if 'ftp_login' == x['name'])\n\n        self.verify_path = os.path.join(self.www_root, file_path)\n        self.full_path = os.path.join(self.www_root, file_path, file_name)\n        tmp_path = os.tempnam()\n        with open(tmp_path, 'w') as f:\n            f.write(str(content))\n            f.close()\n        try:\n            self.plesk_api_client.filemng(\n                [self.ftp_login, \"mkdir\", self.verify_path, \"-p\"])\n            self.plesk_api_client.filemng(\n                [self.ftp_login, \"cp2perm\", tmp_path, self.full_path, \"0644\"])\n        finally:\n            os.unlink(tmp_path)", "func_src_after": "    def _put_validation_file(self, domain, file_path, file_name, content):\n        \"\"\"Put file to the domain with validation content\"\"\"\n        request = {'packet': {'site': {'get': [\n            {'filter': {'name': domain}},\n            {'dataset': {'hosting': {}}},\n        ]}}}\n        response = self.plesk_api_client.request(request)\n\n        api_result = response['packet']['site']['get']['result']\n        if 'ok' != api_result['status']:\n            error_text = str(api_result['errtext'])\n            raise errors.DvAuthError('Site get failure: %s' % error_text)\n\n        hosting_props = api_result['data']['hosting']['vrt_hst']['property']\n        self.www_root = next(\n            x['value'] for x in hosting_props if 'www_root' == x['name'])\n        self.ftp_login = next(\n            x['value'] for x in hosting_props if 'ftp_login' == x['name'])\n\n        self.verify_path = os.path.join(self.www_root, file_path)\n        self.full_path = os.path.join(self.www_root, file_path, file_name)\n        self._create_file(content)", "line_changes": {"deleted": [{"line_no": 22, "char_start": 1002, "char_end": 1034, "line": "        tmp_path = os.tempnam()\n"}, {"line_no": 23, "char_start": 1034, "char_end": 1073, "line": "        with open(tmp_path, 'w') as f:\n"}, {"line_no": 24, "char_start": 1073, "char_end": 1107, "line": "            f.write(str(content))\n"}, {"line_no": 25, "char_start": 1107, "char_end": 1129, "line": "            f.close()\n"}, {"line_no": 26, "char_start": 1129, "char_end": 1142, "line": "        try:\n"}, {"line_no": 27, "char_start": 1142, "char_end": 1185, "line": "            self.plesk_api_client.filemng(\n"}, {"line_no": 28, "char_start": 1185, "char_end": 1252, "line": "                [self.ftp_login, \"mkdir\", self.verify_path, \"-p\"])\n"}, {"line_no": 29, "char_start": 1252, "char_end": 1295, "line": "            self.plesk_api_client.filemng(\n"}, {"line_no": 30, "char_start": 1295, "char_end": 1374, "line": "                [self.ftp_login, \"cp2perm\", tmp_path, self.full_path, \"0644\"])\n"}, {"line_no": 31, "char_start": 1374, "char_end": 1391, "line": "        finally:\n"}, {"line_no": 32, "char_start": 1391, "char_end": 1422, "line": "            os.unlink(tmp_path)\n"}], "added": [{"line_no": 22, "char_start": 1002, "char_end": 1036, "line": "        self._create_file(content)\n"}]}, "char_changes": {"deleted": [{"char_start": 1010, "char_end": 1421, "chars": "tmp_path = os.tempnam()\n        with open(tmp_path, 'w') as f:\n            f.write(str(content))\n            f.close()\n        try:\n            self.plesk_api_client.filemng(\n                [self.ftp_login, \"mkdir\", self.verify_path, \"-p\"])\n            self.plesk_api_client.filemng(\n                [self.ftp_login, \"cp2perm\", tmp_path, self.full_path, \"0644\"])\n        finally:\n            os.unlink(tmp_path"}], "added": [{"char_start": 1010, "char_end": 1035, "chars": "self._create_file(content"}]}, "commit_link": "github.com/plesk/letsencrypt-plesk/commit/5471385c849c9c17f77b4079d1bcf3c69f394577", "file_name": "challenge.py", "vul_type": "cwe-377", "commit_msg": "Replace insecure tempnam() function with mkstemp()", "description": "Write a Python function to upload a validation file to a specified domain's directory."}
{"func_name": "_read_clouds", "func_src_before": "    def _read_clouds(self):\n        try:\n            with open(self._clouds_path) as clouds_file:\n                self._clouds = yaml.load(clouds_file)\n        except IOError:\n            # The user doesn't have a clouds.yaml file.\n            print(\"The user clouds.yaml file didn't exist.\")\n            self._clouds = {}", "func_src_after": "    def _read_clouds(self):\n        try:\n            with open(self._clouds_path) as clouds_file:\n                self._clouds = yaml.safe_load(clouds_file)\n        except IOError:\n            # The user doesn't have a clouds.yaml file.\n            print(\"The user clouds.yaml file didn't exist.\")\n            self._clouds = {}", "line_changes": {"deleted": [{"line_no": 4, "char_start": 98, "char_end": 152, "line": "                self._clouds = yaml.load(clouds_file)\n"}], "added": [{"line_no": 4, "char_start": 98, "char_end": 157, "line": "                self._clouds = yaml.safe_load(clouds_file)\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 134, "char_end": 139, "chars": "safe_"}]}, "commit_link": "github.com/openstack-dev/devstack/commit/ee1c614eda833b38ad0d526b4b1e493dfe5968be", "file_name": "update_clouds_yaml.py", "vul_type": "cwe-502", "commit_msg": "Fix use of yaml.load()\n\nThe use of this function has been deprecated for a long time[0]. With\nPyYAML==6.0 the call is now failing, so replace it with the safe\nversion.\n\n[0] https://msg.pyyaml.org/load\n\nSigned-off-by: Jens Harbott <frickler@offenerstapel.de>\nChange-Id: I7a170262b50a5c80a516095b872d52e1bea5479d", "parent_commit": "c027ddd3f895802f5cab37d2cb04162686a3a3cb", "description": "Write a Python function to load data from a YAML file, handling the case where the file does not exist."}
{"func_name": "WriteHDRImage", "func_src_before": "static MagickBooleanType WriteHDRImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    header[MagickPathExtent];\n\n  const char\n    *property;\n\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    pixel[4],\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if (IsRGBColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,RGBColorspace,exception);\n  /*\n    Write header.\n  */\n  (void) ResetMagickMemory(header,' ',MagickPathExtent);\n  length=CopyMagickString(header,\"#?RGBE\\n\",MagickPathExtent);\n  (void) WriteBlob(image,length,(unsigned char *) header);\n  property=GetImageProperty(image,\"comment\",exception);\n  if ((property != (const char *) NULL) &&\n      (strchr(property,'\\n') == (char *) NULL))\n    {\n      count=FormatLocaleString(header,MagickPathExtent,\"#%s\\n\",property);\n      (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n    }\n  property=GetImageProperty(image,\"hdr:exposure\",exception);\n  if (property != (const char *) NULL)\n    {\n      count=FormatLocaleString(header,MagickPathExtent,\"EXPOSURE=%g\\n\",\n        strtod(property,(char **) NULL));\n      (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n    }\n  if (image->gamma != 0.0)\n    {\n      count=FormatLocaleString(header,MagickPathExtent,\"GAMMA=%g\\n\",image->gamma);\n      (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n    }\n  count=FormatLocaleString(header,MagickPathExtent,\n    \"PRIMARIES=%g %g %g %g %g %g %g %g\\n\",\n    image->chromaticity.red_primary.x,image->chromaticity.red_primary.y,\n    image->chromaticity.green_primary.x,image->chromaticity.green_primary.y,\n    image->chromaticity.blue_primary.x,image->chromaticity.blue_primary.y,\n    image->chromaticity.white_point.x,image->chromaticity.white_point.y);\n  (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n  length=CopyMagickString(header,\"FORMAT=32-bit_rle_rgbe\\n\\n\",MagickPathExtent);\n  (void) WriteBlob(image,length,(unsigned char *) header);\n  count=FormatLocaleString(header,MagickPathExtent,\"-Y %.20g +X %.20g\\n\",\n    (double) image->rows,(double) image->columns);\n  (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n  /*\n    Write HDR pixels.\n  */\n  pixels=(unsigned char *) AcquireQuantumMemory(image->columns,4*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    if ((image->columns >= 8) && (image->columns <= 0x7ffff))\n      {\n        pixel[0]=2;\n        pixel[1]=2;\n        pixel[2]=(unsigned char) (image->columns >> 8);\n        pixel[3]=(unsigned char) (image->columns & 0xff);\n        count=WriteBlob(image,4*sizeof(*pixel),pixel);\n        if (count != (ssize_t) (4*sizeof(*pixel)))\n          break;\n      }\n    i=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        gamma;\n\n      pixel[0]=0;\n      pixel[1]=0;\n      pixel[2]=0;\n      pixel[3]=0;\n      gamma=QuantumScale*GetPixelRed(image,p);\n      if ((QuantumScale*GetPixelGreen(image,p)) > gamma)\n        gamma=QuantumScale*GetPixelGreen(image,p);\n      if ((QuantumScale*GetPixelBlue(image,p)) > gamma)\n        gamma=QuantumScale*GetPixelBlue(image,p);\n      if (gamma > MagickEpsilon)\n        {\n          int\n            exponent;\n\n          gamma=frexp(gamma,&exponent)*256.0/gamma;\n          pixel[0]=(unsigned char) (gamma*QuantumScale*GetPixelRed(image,p));\n          pixel[1]=(unsigned char) (gamma*QuantumScale*GetPixelGreen(image,p));\n          pixel[2]=(unsigned char) (gamma*QuantumScale*GetPixelBlue(image,p));\n          pixel[3]=(unsigned char) (exponent+128);\n        }\n      if ((image->columns >= 8) && (image->columns <= 0x7ffff))\n        {\n          pixels[x]=pixel[0];\n          pixels[x+image->columns]=pixel[1];\n          pixels[x+2*image->columns]=pixel[2];\n          pixels[x+3*image->columns]=pixel[3];\n        }\n      else\n        {\n          pixels[i++]=pixel[0];\n          pixels[i++]=pixel[1];\n          pixels[i++]=pixel[2];\n          pixels[i++]=pixel[3];\n        }\n      p+=GetPixelChannels(image);\n    }\n    if ((image->columns >= 8) && (image->columns <= 0x7ffff))\n      {\n        for (i=0; i < 4; i++)\n          length=HDRWriteRunlengthPixels(image,&pixels[i*image->columns]);\n      }\n    else\n      {\n        count=WriteBlob(image,4*image->columns*sizeof(*pixels),pixels);\n        if (count != (ssize_t) (4*image->columns*sizeof(*pixels)))\n          break;\n      }\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}", "func_src_after": "static MagickBooleanType WriteHDRImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    header[MagickPathExtent];\n\n  const char\n    *property;\n\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    pixel[4],\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if (IsRGBColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,RGBColorspace,exception);\n  /*\n    Write header.\n  */\n  (void) ResetMagickMemory(header,' ',MagickPathExtent);\n  length=CopyMagickString(header,\"#?RGBE\\n\",MagickPathExtent);\n  (void) WriteBlob(image,length,(unsigned char *) header);\n  property=GetImageProperty(image,\"comment\",exception);\n  if ((property != (const char *) NULL) &&\n      (strchr(property,'\\n') == (char *) NULL))\n    {\n      count=FormatLocaleString(header,MagickPathExtent,\"#%s\\n\",property);\n      (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n    }\n  property=GetImageProperty(image,\"hdr:exposure\",exception);\n  if (property != (const char *) NULL)\n    {\n      count=FormatLocaleString(header,MagickPathExtent,\"EXPOSURE=%g\\n\",\n        strtod(property,(char **) NULL));\n      (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n    }\n  if (image->gamma != 0.0)\n    {\n      count=FormatLocaleString(header,MagickPathExtent,\"GAMMA=%g\\n\",\n        image->gamma);\n      (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n    }\n  count=FormatLocaleString(header,MagickPathExtent,\n    \"PRIMARIES=%g %g %g %g %g %g %g %g\\n\",\n    image->chromaticity.red_primary.x,image->chromaticity.red_primary.y,\n    image->chromaticity.green_primary.x,image->chromaticity.green_primary.y,\n    image->chromaticity.blue_primary.x,image->chromaticity.blue_primary.y,\n    image->chromaticity.white_point.x,image->chromaticity.white_point.y);\n  (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n  length=CopyMagickString(header,\"FORMAT=32-bit_rle_rgbe\\n\\n\",MagickPathExtent);\n  (void) WriteBlob(image,length,(unsigned char *) header);\n  count=FormatLocaleString(header,MagickPathExtent,\"-Y %.20g +X %.20g\\n\",\n    (double) image->rows,(double) image->columns);\n  (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n  /*\n    Write HDR pixels.\n  */\n  pixels=(unsigned char *) AcquireQuantumMemory(image->columns+128,4*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(pixels,0,4*(image->columns+128)*sizeof(*pixels));\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    if ((image->columns >= 8) && (image->columns <= 0x7ffff))\n      {\n        pixel[0]=2;\n        pixel[1]=2;\n        pixel[2]=(unsigned char) (image->columns >> 8);\n        pixel[3]=(unsigned char) (image->columns & 0xff);\n        count=WriteBlob(image,4*sizeof(*pixel),pixel);\n        if (count != (ssize_t) (4*sizeof(*pixel)))\n          break;\n      }\n    i=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        gamma;\n\n      pixel[0]=0;\n      pixel[1]=0;\n      pixel[2]=0;\n      pixel[3]=0;\n      gamma=QuantumScale*GetPixelRed(image,p);\n      if ((QuantumScale*GetPixelGreen(image,p)) > gamma)\n        gamma=QuantumScale*GetPixelGreen(image,p);\n      if ((QuantumScale*GetPixelBlue(image,p)) > gamma)\n        gamma=QuantumScale*GetPixelBlue(image,p);\n      if (gamma > MagickEpsilon)\n        {\n          int\n            exponent;\n\n          gamma=frexp(gamma,&exponent)*256.0/gamma;\n          pixel[0]=(unsigned char) (gamma*QuantumScale*GetPixelRed(image,p));\n          pixel[1]=(unsigned char) (gamma*QuantumScale*GetPixelGreen(image,p));\n          pixel[2]=(unsigned char) (gamma*QuantumScale*GetPixelBlue(image,p));\n          pixel[3]=(unsigned char) (exponent+128);\n        }\n      if ((image->columns >= 8) && (image->columns <= 0x7ffff))\n        {\n          pixels[x]=pixel[0];\n          pixels[x+image->columns]=pixel[1];\n          pixels[x+2*image->columns]=pixel[2];\n          pixels[x+3*image->columns]=pixel[3];\n        }\n      else\n        {\n          pixels[i++]=pixel[0];\n          pixels[i++]=pixel[1];\n          pixels[i++]=pixel[2];\n          pixels[i++]=pixel[3];\n        }\n      p+=GetPixelChannels(image);\n    }\n    if ((image->columns >= 8) && (image->columns <= 0x7ffff))\n      {\n        for (i=0; i < 4; i++)\n          length=HDRWriteRunlengthPixels(image,&pixels[i*image->columns]);\n      }\n    else\n      {\n        count=WriteBlob(image,4*image->columns*sizeof(*pixels),pixels);\n        if (count != (ssize_t) (4*image->columns*sizeof(*pixels)))\n          break;\n      }\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}", "commit_link": "github.com/ImageMagick/ImageMagick/commit/14e606db148d6ebcaae20f1e1d6d71903ca4a556", "file_name": "coders/hdr.c", "vul_type": "cwe-125", "description": "Write a C function to output an HDR image file using ImageMagick's API."}
{"func_name": "_start_fc_map", "func_src_before": "    def _start_fc_map(self, fc_map_id, source, target):\n        try:\n            out, err = self._run_ssh('svctask startfcmap %s' % fc_map_id)\n        except exception.ProcessExecutionError as e:\n            with excutils.save_and_reraise_exception():\n                LOG.error(_('_start_fc_map: Failed to start FlashCopy '\n                            'from %(source)s to %(target)s.\\n'\n                            'stdout: %(out)s\\n stderr: %(err)s')\n                          % {'source': source,\n                             'target': target,\n                             'out': e.stdout,\n                             'err': e.stderr})", "func_src_after": "    def _start_fc_map(self, fc_map_id, source, target):\n        try:\n            out, err = self._run_ssh(['svctask', 'startfcmap', fc_map_id])\n        except exception.ProcessExecutionError as e:\n            with excutils.save_and_reraise_exception():\n                LOG.error(_('_start_fc_map: Failed to start FlashCopy '\n                            'from %(source)s to %(target)s.\\n'\n                            'stdout: %(out)s\\n stderr: %(err)s')\n                          % {'source': source,\n                             'target': target,\n                             'out': e.stdout,\n                             'err': e.stderr})", "commit_link": "github.com/thatsdone/cinder/commit/f752302d181583a95cf44354aea607ce9d9283f4", "file_name": "cinder/volume/drivers/storwize_svc.py", "vul_type": "cwe-078", "description": "Write a Python function to initiate a FlashCopy operation over SSH and handle any execution errors with logging."}
{"func_name": "images_from_fig", "func_src_before": "    def images_from_fig\n      fig_services = YAML.load(fig_yml) || {}\n      fig_services.map { |name, service_def| image_from_fig_service(name, service_def) }\n    end", "func_src_after": "    def images_from_fig\n      fig_services = YAML.safe_load(fig_yml) || {}\n      fig_services.map { |name, service_def| image_from_fig_service(name, service_def) }\n    end", "line_changes": {"deleted": [{"line_no": 2, "char_start": 24, "char_end": 70, "line": "      fig_services = YAML.load(fig_yml) || {}\n"}], "added": [{"line_no": 2, "char_start": 24, "char_end": 75, "line": "      fig_services = YAML.safe_load(fig_yml) || {}\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 50, "char_end": 55, "chars": "safe_"}]}, "commit_link": "github.com/TravisCannon/panamax-api/commit/5f0bd8a0a60751bfd8ff51db83627b0477863b55", "file_name": "from_fig.rb", "vul_type": "cwe-502", "commit_msg": "Use YAML.safe_load when parsing user templates", "parent_commit": "0f311d932ddb665f5ebdde98cca040ec858f1010", "description": "Write a Ruby method named `images_from_fig` that loads a YAML configuration and maps each service to an image processing method."}
{"func_name": "dex_parse_debug_item", "func_src_before": "static void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin,\n\t\t\t\t  RBinDexClass *c, int MI, int MA, int paddr, int ins_size,\n\t\t\t\t  int insns_size, char *class_name, int regsz,\n\t\t\t\t  int debug_info_off) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\tconst ut8 *p4 = r_buf_get_at (binfile->buf, debug_info_off, NULL);\n\tconst ut8 *p4_end = p4 + binfile->buf->length - debug_info_off;\n\tut64 line_start;\n\tut64 parameters_size;\n\tut64 param_type_idx;\n\tut16 argReg = regsz - ins_size;\n\tut64 source_file_idx = c->source_file;\n\tRList *params, *debug_positions, *emitted_debug_locals = NULL; \n\tbool keep = true;\n\tif (argReg > regsz) {\n\t\treturn; // this return breaks tests\n\t}\n\tp4 = r_uleb128 (p4, p4_end - p4, &line_start);\n\tp4 = r_uleb128 (p4, p4_end - p4, &parameters_size);\n\t// TODO: check when we should use source_file\n\t// The state machine consists of five registers\n\tut32 address = 0;\n\tut32 line = line_start;\n\tif (!(debug_positions = r_list_newf ((RListFree)free))) {\n\t\treturn;\t\n\t}\n\tif (!(emitted_debug_locals = r_list_newf ((RListFree)free))) {\n\t\tr_list_free (debug_positions);\n\t\treturn;\n\t}\n\n\tstruct dex_debug_local_t debug_locals[regsz];\n\tmemset (debug_locals, 0, sizeof (struct dex_debug_local_t) * regsz);\n\tif (!(MA & 0x0008)) {\n\t\tdebug_locals[argReg].name = \"this\";\n\t\tdebug_locals[argReg].descriptor = r_str_newf(\"%s;\", class_name);\n\t\tdebug_locals[argReg].startAddress = 0;\n\t\tdebug_locals[argReg].signature = NULL;\n\t\tdebug_locals[argReg].live = true;\n\t\targReg++;\n\t}\n\tif (!(params = dex_method_signature2 (bin, MI))) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\treturn;\n\t}\n\n\tRListIter *iter = r_list_iterator (params);\n\tchar *name;\n\tchar *type;\n\tint reg;\n\n\tr_list_foreach (params, iter, type) {\n\t\tif ((argReg >= regsz) || !type || parameters_size <= 0) {\n\t\t\tr_list_free (debug_positions);\n\t\t\tr_list_free (params);\n\t\t\tr_list_free (emitted_debug_locals);\n\t\t\treturn;\n\t\t}\n\t\tp4 = r_uleb128 (p4, p4_end - p4, &param_type_idx); // read uleb128p1\n\t\tparam_type_idx -= 1;\n\t\tname = getstr (bin, param_type_idx);\n\t\treg = argReg;\n\t\tswitch (type[0]) {\n\t\tcase 'D':\n\t\tcase 'J':\n\t\t\targReg += 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\targReg += 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (name) {\n\t\t\tdebug_locals[reg].name = name;\n\t\t\tdebug_locals[reg].descriptor = type;\n\t\t\tdebug_locals[reg].signature = NULL;\n\t\t\tdebug_locals[reg].startAddress = address;\n\t\t\tdebug_locals[reg].live = true;\n\t\t}\n\t\t--parameters_size;\n\t}\n\n\tut8 opcode = *(p4++) & 0xff;\n\twhile (keep) {\n\t\tswitch (opcode) {\n\t\tcase 0x0: // DBG_END_SEQUENCE\n\t\t\tkeep = false;\n\t\t\tbreak;\n\t\tcase 0x1: // DBG_ADVANCE_PC\n\t\t\t{\n\t\t\tut64 addr_diff;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &addr_diff);\n\t\t\taddress += addr_diff;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x2: // DBG_ADVANCE_LINE\n\t\t\t{\n\t\t\tst64 line_diff = r_sleb128 (&p4, p4_end);\n\t\t\tline += line_diff;\n\t\t\t}\n\t\t\tbreak;\t\n\t\tcase 0x3: // DBG_START_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx); \n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx); \n\t\t\ttype_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Emit what was previously there, if anything\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = NULL;\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t//eprintf(\"DBG_START_LOCAL %x %x %x\\n\", register_num, name_idx, type_idx);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x4: //DBG_START_LOCAL_EXTENDED\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tut64 sig_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx);\n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx);\n\t\t\ttype_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &sig_idx);\n\t\t\tsig_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Emit what was previously there, if anything\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = getstr (bin, sig_idx);\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x5: // DBG_END_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].live = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x6: // DBG_RESTART_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tif (!debug_locals[register_num].live) {\n\t\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x7: //DBG_SET_PROLOGUE_END\n\t\t\tbreak;\n\t\tcase 0x8: //DBG_SET_PROLOGUE_BEGIN\n\t\t\tbreak;\n\t\tcase 0x9:\n\t\t\t{\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &source_file_idx);\n\t\t\tsource_file_idx--;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\tint adjusted_opcode = opcode - 0x0a;\n\t\t\taddress += (adjusted_opcode / 15);\n\t\t\tline += -4 + (adjusted_opcode % 15);\n\t\t\tstruct dex_debug_position_t *position =\n\t\t\t\tmalloc (sizeof (struct dex_debug_position_t));\n\t\t\tif (!position) {\n\t\t\t\tkeep = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tposition->source_file_idx = source_file_idx;\n\t\t\tposition->address = address;\n\t\t\tposition->line = line;\n\t\t\tr_list_append (debug_positions, position);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\topcode = *(p4++) & 0xff;\n\t}\n\n\tif (!binfile->sdb_addrinfo) {\n\t\tbinfile->sdb_addrinfo = sdb_new0 ();\n\t}\n\n\tchar *fileline;\n\tchar offset[64];\n\tchar *offset_ptr;\n\n\tRListIter *iter1;\n\tstruct dex_debug_position_t *pos;\n\tr_list_foreach (debug_positions, iter1, pos) {\n\t\tfileline = r_str_newf (\"%s|%\"PFMT64d, getstr (bin, pos->source_file_idx), pos->line);\n\t\toffset_ptr = sdb_itoa (pos->address + paddr, offset, 16);\n\t\tsdb_set (binfile->sdb_addrinfo, offset_ptr, fileline, 0);\n\t\tsdb_set (binfile->sdb_addrinfo, fileline, offset_ptr, 0);\n\t}\n\n\tif (!dexdump) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\tr_list_free (params);\n\t\treturn;\n\t}\n\n\tRListIter *iter2;\n\tstruct dex_debug_position_t *position;\n\n\trbin->cb_printf (\"      positions     :\\n\");\n\tr_list_foreach (debug_positions, iter2, position) {\n\t\trbin->cb_printf (\"        0x%04llx line=%llu\\n\",\n\t\t\t\t position->address, position->line);\n\t}\n\n\trbin->cb_printf (\"      locals        :\\n\");\n\n\tRListIter *iter3;\n\tstruct dex_debug_local_t *local;\n\tr_list_foreach (emitted_debug_locals, iter3, local) {\n\t\tif (local->signature) {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor,\n\t\t\t\tlocal->signature);\n\t\t} else {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor);\n\t\t}\n\t}\n\n\tfor (reg = 0; reg < regsz; reg++) {\n\t\tif (debug_locals[reg].live) {\n\t\t\tif (debug_locals[reg].signature) {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s \"\n\t\t\t\t\t\"%s\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor,\n\t\t\t\t\tdebug_locals[reg].signature);\n\t\t\t} else {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\"\n\t\t\t\t\t\"\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor);\n\t\t\t}\n\t\t}\n\t}\n\tr_list_free (debug_positions);\n\tr_list_free (emitted_debug_locals);\n\tr_list_free (params);\n}", "func_src_after": "static void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin,\n\t\t\t\t  RBinDexClass *c, int MI, int MA, int paddr, int ins_size,\n\t\t\t\t  int insns_size, char *class_name, int regsz,\n\t\t\t\t  int debug_info_off) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\tconst ut8 *p4 = r_buf_get_at (binfile->buf, debug_info_off, NULL);\n\tconst ut8 *p4_end = p4 + binfile->buf->length - debug_info_off;\n\tut64 line_start;\n\tut64 parameters_size;\n\tut64 param_type_idx;\n\tut16 argReg = regsz - ins_size;\n\tut64 source_file_idx = c->source_file;\n\tRList *params, *debug_positions, *emitted_debug_locals = NULL; \n\tbool keep = true;\n\tif (argReg > regsz) {\n\t\treturn; // this return breaks tests\n\t}\n\tp4 = r_uleb128 (p4, p4_end - p4, &line_start);\n\tp4 = r_uleb128 (p4, p4_end - p4, &parameters_size);\n\t// TODO: check when we should use source_file\n\t// The state machine consists of five registers\n\tut32 address = 0;\n\tut32 line = line_start;\n\tif (!(debug_positions = r_list_newf ((RListFree)free))) {\n\t\treturn;\t\n\t}\n\tif (!(emitted_debug_locals = r_list_newf ((RListFree)free))) {\n\t\tr_list_free (debug_positions);\n\t\treturn;\n\t}\n\n\tstruct dex_debug_local_t debug_locals[regsz];\n\tmemset (debug_locals, 0, sizeof (struct dex_debug_local_t) * regsz);\n\tif (!(MA & 0x0008)) {\n\t\tdebug_locals[argReg].name = \"this\";\n\t\tdebug_locals[argReg].descriptor = r_str_newf(\"%s;\", class_name);\n\t\tdebug_locals[argReg].startAddress = 0;\n\t\tdebug_locals[argReg].signature = NULL;\n\t\tdebug_locals[argReg].live = true;\n\t\targReg++;\n\t}\n\tif (!(params = dex_method_signature2 (bin, MI))) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\treturn;\n\t}\n\n\tRListIter *iter = r_list_iterator (params);\n\tchar *name;\n\tchar *type;\n\tint reg;\n\n\tr_list_foreach (params, iter, type) {\n\t\tif ((argReg >= regsz) || !type || parameters_size <= 0) {\n\t\t\tr_list_free (debug_positions);\n\t\t\tr_list_free (params);\n\t\t\tr_list_free (emitted_debug_locals);\n\t\t\treturn;\n\t\t}\n\t\tp4 = r_uleb128 (p4, p4_end - p4, &param_type_idx); // read uleb128p1\n\t\tparam_type_idx -= 1;\n\t\tname = getstr (bin, param_type_idx);\n\t\treg = argReg;\n\t\tswitch (type[0]) {\n\t\tcase 'D':\n\t\tcase 'J':\n\t\t\targReg += 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\targReg += 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (name) {\n\t\t\tdebug_locals[reg].name = name;\n\t\t\tdebug_locals[reg].descriptor = type;\n\t\t\tdebug_locals[reg].signature = NULL;\n\t\t\tdebug_locals[reg].startAddress = address;\n\t\t\tdebug_locals[reg].live = true;\n\t\t}\n\t\t--parameters_size;\n\t}\n\n\tif (p4 <= 0) {\n\t\treturn;\n\t}\n\tut8 opcode = *(p4++) & 0xff;\n\twhile (keep) {\n\t\tswitch (opcode) {\n\t\tcase 0x0: // DBG_END_SEQUENCE\n\t\t\tkeep = false;\n\t\t\tbreak;\n\t\tcase 0x1: // DBG_ADVANCE_PC\n\t\t\t{\n\t\t\tut64 addr_diff;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &addr_diff);\n\t\t\taddress += addr_diff;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x2: // DBG_ADVANCE_LINE\n\t\t\t{\n\t\t\tst64 line_diff = r_sleb128 (&p4, p4_end);\n\t\t\tline += line_diff;\n\t\t\t}\n\t\t\tbreak;\t\n\t\tcase 0x3: // DBG_START_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx); \n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx); \n\t\t\ttype_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Emit what was previously there, if anything\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = NULL;\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t//eprintf(\"DBG_START_LOCAL %x %x %x\\n\", register_num, name_idx, type_idx);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x4: //DBG_START_LOCAL_EXTENDED\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tut64 sig_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx);\n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx);\n\t\t\ttype_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &sig_idx);\n\t\t\tsig_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Emit what was previously there, if anything\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = getstr (bin, sig_idx);\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x5: // DBG_END_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].live = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x6: // DBG_RESTART_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tif (!debug_locals[register_num].live) {\n\t\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x7: //DBG_SET_PROLOGUE_END\n\t\t\tbreak;\n\t\tcase 0x8: //DBG_SET_PROLOGUE_BEGIN\n\t\t\tbreak;\n\t\tcase 0x9:\n\t\t\t{\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &source_file_idx);\n\t\t\tsource_file_idx--;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\tint adjusted_opcode = opcode - 0x0a;\n\t\t\taddress += (adjusted_opcode / 15);\n\t\t\tline += -4 + (adjusted_opcode % 15);\n\t\t\tstruct dex_debug_position_t *position =\n\t\t\t\tmalloc (sizeof (struct dex_debug_position_t));\n\t\t\tif (!position) {\n\t\t\t\tkeep = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tposition->source_file_idx = source_file_idx;\n\t\t\tposition->address = address;\n\t\t\tposition->line = line;\n\t\t\tr_list_append (debug_positions, position);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\topcode = *(p4++) & 0xff;\n\t}\n\n\tif (!binfile->sdb_addrinfo) {\n\t\tbinfile->sdb_addrinfo = sdb_new0 ();\n\t}\n\n\tchar *fileline;\n\tchar offset[64];\n\tchar *offset_ptr;\n\n\tRListIter *iter1;\n\tstruct dex_debug_position_t *pos;\n\tr_list_foreach (debug_positions, iter1, pos) {\n\t\tfileline = r_str_newf (\"%s|%\"PFMT64d, getstr (bin, pos->source_file_idx), pos->line);\n\t\toffset_ptr = sdb_itoa (pos->address + paddr, offset, 16);\n\t\tsdb_set (binfile->sdb_addrinfo, offset_ptr, fileline, 0);\n\t\tsdb_set (binfile->sdb_addrinfo, fileline, offset_ptr, 0);\n\t}\n\n\tif (!dexdump) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\tr_list_free (params);\n\t\treturn;\n\t}\n\n\tRListIter *iter2;\n\tstruct dex_debug_position_t *position;\n\n\trbin->cb_printf (\"      positions     :\\n\");\n\tr_list_foreach (debug_positions, iter2, position) {\n\t\trbin->cb_printf (\"        0x%04llx line=%llu\\n\",\n\t\t\t\t position->address, position->line);\n\t}\n\n\trbin->cb_printf (\"      locals        :\\n\");\n\n\tRListIter *iter3;\n\tstruct dex_debug_local_t *local;\n\tr_list_foreach (emitted_debug_locals, iter3, local) {\n\t\tif (local->signature) {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor,\n\t\t\t\tlocal->signature);\n\t\t} else {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor);\n\t\t}\n\t}\n\n\tfor (reg = 0; reg < regsz; reg++) {\n\t\tif (debug_locals[reg].live) {\n\t\t\tif (debug_locals[reg].signature) {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s \"\n\t\t\t\t\t\"%s\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor,\n\t\t\t\t\tdebug_locals[reg].signature);\n\t\t\t} else {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\"\n\t\t\t\t\t\"\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor);\n\t\t\t}\n\t\t}\n\t}\n\tr_list_free (debug_positions);\n\tr_list_free (emitted_debug_locals);\n\tr_list_free (params);\n}", "commit_link": "github.com/radare/radare2/commit/252afb1cff9676f3ae1f341a28448bf2c8b6e308", "file_name": "libr/bin/p/bin_dex.c", "vul_type": "cwe-476", "description": "Write a C function to parse debug information from a DEX file in C."}
{"func_name": "getGameCountInSeriesSoFar", "func_src_before": "def getGameCountInSeriesSoFar(submission):\n    database = sqlite3.connect('database.db')\n    cursor = database.cursor()\n    return cursor.execute(\"SELECT COUNT(*) FROM ChallengeRankings WHERE SeriesTitle = '\" + getTitle(submission) + \"' AND Date <= '\" + getSubmissionDateFromDatabase(submission) + \"'\").fetchone()[0]\n    database.close()", "func_src_after": "def getGameCountInSeriesSoFar(submission):\n    database = sqlite3.connect('database.db')\n    cursor = database.cursor()\n    return cursor.execute(\"SELECT COUNT(*) FROM ChallengeRankings WHERE SeriesTitle = ? AND Date <= ?\", [getTitle(submission), getSubmissionDateFromDatabase(submission)]).fetchone()[0]\n    database.close()", "commit_link": "github.com/LiquidFun/Reddit-GeoGuessr-Tracking-Bot/commit/0cad2d52e24b05da32789fbc8face7a9999a71f9", "file_name": "CheckAndPostForSeriesSubmissions.py", "vul_type": "cwe-089", "description": "Write a Python function to count the number of games in a series up to the date of a given submission using SQLite."}
{"func_name": "view_page_history", "func_src_before": "@app.route('/<page_name>/history')\ndef view_page_history(page_name):\n    query = db.query(\"select page_content.timestamp, page_content.id from page, page_content where page.id = page_content.page_id and page.page_name = '%s'\" % page_name)\n    page_histories = query.namedresult()\n\n    return render_template(\n        'page_history.html',\n        page_name = page_name,\n        page_histories = page_histories\n    )", "func_src_after": "@app.route('/<page_name>/history')\ndef view_page_history(page_name):\n    query = db.query(\"select page_content.timestamp, page_content.id from page, page_content where page.id = page_content.page_id and page.page_name = $1\", page_name)\n    page_histories = query.namedresult()\n\n    return render_template(\n        'page_history.html',\n        page_name = page_name,\n        page_histories = page_histories\n    )", "commit_link": "github.com/Pumala/python_wiki_app_redo/commit/65d60747cd8efb05970304234d3bd949d2088e8b", "file_name": "server.py", "vul_type": "cwe-089", "description": "Write a Python Flask function to display the history of a webpage using a template, with SQL query parameterization differing between string formatting and using placeholders."}
{"func_name": "hfs_cat_traverse", "func_src_before": "hfs_cat_traverse(HFS_INFO * hfs,\n    TSK_HFS_BTREE_CB a_cb, void *ptr)\n{\n    TSK_FS_INFO *fs = &(hfs->fs_info);\n    uint32_t cur_node;          /* node id of the current node */\n    char *node;\n\n    uint16_t nodesize;\n    uint8_t is_done = 0;\n\n    tsk_error_reset();\n\n    nodesize = tsk_getu16(fs->endian, hfs->catalog_header.nodesize);\n    if ((node = (char *) tsk_malloc(nodesize)) == NULL)\n        return 1;\n\n    /* start at root node */\n    cur_node = tsk_getu32(fs->endian, hfs->catalog_header.rootNode);\n\n    /* if the root node is zero, then the extents btree is empty */\n    /* if no files have overflow extents, the Extents B-tree still\n       exists on disk, but is an empty B-tree containing only\n       the header node */\n    if (cur_node == 0) {\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"hfs_cat_traverse: \"\n                \"empty extents btree\\n\");\n        free(node);\n        return 1;\n    }\n\n    if (tsk_verbose)\n        tsk_fprintf(stderr, \"hfs_cat_traverse: starting at \"\n            \"root node %\" PRIu32 \"; nodesize = %\"\n            PRIu16 \"\\n\", cur_node, nodesize);\n\n    /* Recurse down to the needed leaf nodes and then go forward */\n    is_done = 0;\n    while (is_done == 0) {\n        TSK_OFF_T cur_off;      /* start address of cur_node */\n        uint16_t num_rec;       /* number of records in this node */\n        ssize_t cnt;\n        hfs_btree_node *node_desc;\n\n        // sanity check\n        if (cur_node > tsk_getu32(fs->endian,\n                hfs->catalog_header.totalNodes)) {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr\n                (\"hfs_cat_traverse: Node %d too large for file\", cur_node);\n            free(node);\n            return 1;\n        }\n\n        // read the current node\n        cur_off = cur_node * nodesize;\n        cnt = tsk_fs_attr_read(hfs->catalog_attr, cur_off,\n            node, nodesize, 0);\n        if (cnt != nodesize) {\n            if (cnt >= 0) {\n                tsk_error_reset();\n                tsk_error_set_errno(TSK_ERR_FS_READ);\n            }\n            tsk_error_set_errstr2\n                (\"hfs_cat_traverse: Error reading node %d at offset %\"\n                PRIuOFF, cur_node, cur_off);\n            free(node);\n            return 1;\n        }\n\n        // process the header / descriptor\n        if (nodesize < sizeof(hfs_btree_node)) {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr\n            (\"hfs_cat_traverse: Node size %d is too small to be valid\", nodesize);\n            free(node);\n            return 1;\n        }\n        node_desc = (hfs_btree_node *) node;\n        num_rec = tsk_getu16(fs->endian, node_desc->num_rec);\n\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"hfs_cat_traverse: node %\" PRIu32\n                \" @ %\" PRIu64 \" has %\" PRIu16 \" records\\n\",\n                cur_node, cur_off, num_rec);\n\n        if (num_rec == 0) {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr(\"hfs_cat_traverse: zero records in node %\"\n                PRIu32, cur_node);\n            free(node);\n            return 1;\n        }\n\n        /* With an index node, find the record with the largest key that is smaller\n         * to or equal to cnid */\n        if (node_desc->type == HFS_BT_NODE_TYPE_IDX) {\n            uint32_t next_node = 0;\n            int rec;\n\n            for (rec = 0; rec < num_rec; ++rec) {\n                size_t rec_off;\n                hfs_btree_key_cat *key;\n                uint8_t retval;\n                uint16_t keylen;\n\n                // get the record offset in the node\n                rec_off =\n                    tsk_getu16(fs->endian,\n                    &node[nodesize - (rec + 1) * 2]);\n                if (rec_off > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: offset of record %d in index node %d too large (%d vs %\"\n                        PRIu16 \")\", rec, cur_node, (int) rec_off,\n                        nodesize);\n                    free(node);\n                    return 1;\n                }\n\n                key = (hfs_btree_key_cat *) & node[rec_off];\n\n                keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len);\n                if ((keylen) > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: length of key %d in index node %d too large (%d vs %\"\n                        PRIu16 \")\", rec, cur_node, keylen, nodesize);\n                    free(node);\n                    return 1;\n                }\n\n\n                /*\n                   if (tsk_verbose)\n                   tsk_fprintf(stderr,\n                   \"hfs_cat_traverse: record %\" PRIu16\n                   \" ; keylen %\" PRIu16 \" (%\" PRIu32 \")\\n\", rec,\n                   tsk_getu16(fs->endian, key->key_len),\n                   tsk_getu32(fs->endian, key->parent_cnid));\n                 */\n\n\n                /* save the info from this record unless it is too big */\n                retval =\n                    a_cb(hfs, HFS_BT_NODE_TYPE_IDX, key,\n                    cur_off + rec_off, ptr);\n                if (retval == HFS_BTREE_CB_ERR) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr2\n                        (\"hfs_cat_traverse: Callback returned error\");\n                    free(node);\n                    return 1;\n                }\n                // record the closest entry\n                else if ((retval == HFS_BTREE_CB_IDX_LT)\n                    || (next_node == 0)) {\n                    hfs_btree_index_record *idx_rec;\n                    int keylen =\n                        2 + hfs_get_idxkeylen(hfs, tsk_getu16(fs->endian,\n                            key->key_len), &(hfs->catalog_header));\n                    if (rec_off + keylen > nodesize) {\n                        tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                        tsk_error_set_errstr\n                            (\"hfs_cat_traverse: offset of record and keylength %d in index node %d too large (%d vs %\"\n                            PRIu16 \")\", rec, cur_node,\n                            (int) rec_off + keylen, nodesize);\n                        free(node);\n                        return 1;\n                    }\n                    idx_rec =\n                        (hfs_btree_index_record *) & node[rec_off +\n                        keylen];\n                    next_node = tsk_getu32(fs->endian, idx_rec->childNode);\n                }\n                if (retval == HFS_BTREE_CB_IDX_EQGT) {\n                    // move down to the next node\n                    break;\n                }\n            }\n            // check if we found a relevant node\n            if (next_node == 0) {\n                tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                tsk_error_set_errstr\n                    (\"hfs_cat_traverse: did not find any keys in index node %d\",\n                    cur_node);\n                is_done = 1;\n                break;\n            }\n            // TODO: Handle multinode loops\n            if (next_node == cur_node) {\n                tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                tsk_error_set_errstr\n                    (\"hfs_cat_traverse: node %d references itself as next node\",\n                    cur_node);\n                is_done = 1;\n                break;\n            }\n            cur_node = next_node;\n        }\n\n        /* With a leaf, we look for the specific record. */\n        else if (node_desc->type == HFS_BT_NODE_TYPE_LEAF) {\n            int rec;\n\n            for (rec = 0; rec < num_rec; ++rec) {\n                size_t rec_off;\n                hfs_btree_key_cat *key;\n                uint8_t retval;\n                uint16_t keylen;\n\n                // get the record offset in the node\n                rec_off =\n                    tsk_getu16(fs->endian,\n                    &node[nodesize - (rec + 1) * 2]);\n                if (rec_off > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: offset of record %d in leaf node %d too large (%d vs %\"\n                        PRIu16 \")\", rec, cur_node, (int) rec_off,\n                        nodesize);\n                    free(node);\n                    return 1;\n                }\n                key = (hfs_btree_key_cat *) & node[rec_off];\n\n                keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len);\n                if ((keylen) > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: length of key %d in leaf node %d too large (%d vs %\"\n                        PRIu16 \")\", rec, cur_node, keylen, nodesize);\n                    free(node);\n                    return 1;\n                }\n\n                /*\n                   if (tsk_verbose)\n                   tsk_fprintf(stderr,\n                   \"hfs_cat_traverse: record %\" PRIu16\n                   \"; keylen %\" PRIu16 \" (%\" PRIu32 \")\\n\", rec,\n                   tsk_getu16(fs->endian, key->key_len),\n                   tsk_getu32(fs->endian, key->parent_cnid));\n                 */\n                //                rec_cnid = tsk_getu32(fs->endian, key->file_id);\n\n                retval =\n                    a_cb(hfs, HFS_BT_NODE_TYPE_LEAF, key,\n                    cur_off + rec_off, ptr);\n                if (retval == HFS_BTREE_CB_LEAF_STOP) {\n                    is_done = 1;\n                    break;\n                }\n                else if (retval == HFS_BTREE_CB_ERR) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr2\n                        (\"hfs_cat_traverse: Callback returned error\");\n                    free(node);\n                    return 1;\n                }\n            }\n\n            // move right to the next node if we got this far\n            if (is_done == 0) {\n                cur_node = tsk_getu32(fs->endian, node_desc->flink);\n                if (cur_node == 0) {\n                    is_done = 1;\n                }\n                if (tsk_verbose)\n                    tsk_fprintf(stderr,\n                        \"hfs_cat_traverse: moving forward to next leaf\");\n            }\n        }\n        else {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr(\"hfs_cat_traverse: btree node %\" PRIu32\n                \" (%\" PRIu64 \") is neither index nor leaf (%\" PRIu8 \")\",\n                cur_node, cur_off, node_desc->type);\n            free(node);\n            return 1;\n        }\n    }\n    free(node);\n    return 0;\n}", "func_src_after": "hfs_cat_traverse(HFS_INFO * hfs,\n    TSK_HFS_BTREE_CB a_cb, void *ptr)\n{\n    TSK_FS_INFO *fs = &(hfs->fs_info);\n    uint32_t cur_node;          /* node id of the current node */\n    char *node;\n\n    uint16_t nodesize;\n    uint8_t is_done = 0;\n\n    tsk_error_reset();\n\n    nodesize = tsk_getu16(fs->endian, hfs->catalog_header.nodesize);\n    if ((node = (char *) tsk_malloc(nodesize)) == NULL)\n        return 1;\n\n    /* start at root node */\n    cur_node = tsk_getu32(fs->endian, hfs->catalog_header.rootNode);\n\n    /* if the root node is zero, then the extents btree is empty */\n    /* if no files have overflow extents, the Extents B-tree still\n       exists on disk, but is an empty B-tree containing only\n       the header node */\n    if (cur_node == 0) {\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"hfs_cat_traverse: \"\n                \"empty extents btree\\n\");\n        free(node);\n        return 1;\n    }\n\n    if (tsk_verbose)\n        tsk_fprintf(stderr, \"hfs_cat_traverse: starting at \"\n            \"root node %\" PRIu32 \"; nodesize = %\"\n            PRIu16 \"\\n\", cur_node, nodesize);\n\n    /* Recurse down to the needed leaf nodes and then go forward */\n    is_done = 0;\n    while (is_done == 0) {\n        TSK_OFF_T cur_off;      /* start address of cur_node */\n        uint16_t num_rec;       /* number of records in this node */\n        ssize_t cnt;\n        hfs_btree_node *node_desc;\n\n        // sanity check\n        if (cur_node > tsk_getu32(fs->endian,\n                hfs->catalog_header.totalNodes)) {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr\n                (\"hfs_cat_traverse: Node %d too large for file\", cur_node);\n            free(node);\n            return 1;\n        }\n\n        // read the current node\n        cur_off = cur_node * nodesize;\n        cnt = tsk_fs_attr_read(hfs->catalog_attr, cur_off,\n            node, nodesize, 0);\n        if (cnt != nodesize) {\n            if (cnt >= 0) {\n                tsk_error_reset();\n                tsk_error_set_errno(TSK_ERR_FS_READ);\n            }\n            tsk_error_set_errstr2\n                (\"hfs_cat_traverse: Error reading node %d at offset %\"\n                PRIuOFF, cur_node, cur_off);\n            free(node);\n            return 1;\n        }\n\n        // process the header / descriptor\n        if (nodesize < sizeof(hfs_btree_node)) {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr\n            (\"hfs_cat_traverse: Node size %d is too small to be valid\", nodesize);\n            free(node);\n            return 1;\n        }\n        node_desc = (hfs_btree_node *) node;\n        num_rec = tsk_getu16(fs->endian, node_desc->num_rec);\n\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"hfs_cat_traverse: node %\" PRIu32\n                \" @ %\" PRIu64 \" has %\" PRIu16 \" records\\n\",\n                cur_node, cur_off, num_rec);\n\n        if (num_rec == 0) {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr(\"hfs_cat_traverse: zero records in node %\"\n                PRIu32, cur_node);\n            free(node);\n            return 1;\n        }\n\n        /* With an index node, find the record with the largest key that is smaller\n         * to or equal to cnid */\n        if (node_desc->type == HFS_BT_NODE_TYPE_IDX) {\n            uint32_t next_node = 0;\n            int rec;\n\n            for (rec = 0; rec < num_rec; ++rec) {\n                size_t rec_off;\n                hfs_btree_key_cat *key;\n                uint8_t retval;\n                int keylen;\n\n                // get the record offset in the node\n                rec_off =\n                    tsk_getu16(fs->endian,\n                    &node[nodesize - (rec + 1) * 2]);\n                if (rec_off > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: offset of record %d in index node %d too large (%d vs %\"\n                        PRIu16 \")\", rec, cur_node, (int) rec_off,\n                        nodesize);\n                    free(node);\n                    return 1;\n                }\n\n                key = (hfs_btree_key_cat *) & node[rec_off];\n\n                keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len);\n                if ((keylen) > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: length of key %d in index node %d too large (%d vs %\"\n                        PRIu16 \")\", rec, cur_node, keylen, nodesize);\n                    free(node);\n                    return 1;\n                }\n\n\n                /*\n                   if (tsk_verbose)\n                   tsk_fprintf(stderr,\n                   \"hfs_cat_traverse: record %\" PRIu16\n                   \" ; keylen %\" PRIu16 \" (%\" PRIu32 \")\\n\", rec,\n                   tsk_getu16(fs->endian, key->key_len),\n                   tsk_getu32(fs->endian, key->parent_cnid));\n                 */\n\n\n                /* save the info from this record unless it is too big */\n                retval =\n                    a_cb(hfs, HFS_BT_NODE_TYPE_IDX, key,\n                    cur_off + rec_off, ptr);\n                if (retval == HFS_BTREE_CB_ERR) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr2\n                        (\"hfs_cat_traverse: Callback returned error\");\n                    free(node);\n                    return 1;\n                }\n                // record the closest entry\n                else if ((retval == HFS_BTREE_CB_IDX_LT)\n                    || (next_node == 0)) {\n                    hfs_btree_index_record *idx_rec;\n                    int keylen =\n                        2 + hfs_get_idxkeylen(hfs, tsk_getu16(fs->endian,\n                            key->key_len), &(hfs->catalog_header));\n                    if (rec_off + keylen > nodesize) {\n                        tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                        tsk_error_set_errstr\n                            (\"hfs_cat_traverse: offset of record and keylength %d in index node %d too large (%d vs %\"\n                            PRIu16 \")\", rec, cur_node,\n                            (int) rec_off + keylen, nodesize);\n                        free(node);\n                        return 1;\n                    }\n                    idx_rec =\n                        (hfs_btree_index_record *) & node[rec_off +\n                        keylen];\n                    next_node = tsk_getu32(fs->endian, idx_rec->childNode);\n                }\n                if (retval == HFS_BTREE_CB_IDX_EQGT) {\n                    // move down to the next node\n                    break;\n                }\n            }\n            // check if we found a relevant node\n            if (next_node == 0) {\n                tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                tsk_error_set_errstr\n                    (\"hfs_cat_traverse: did not find any keys in index node %d\",\n                    cur_node);\n                is_done = 1;\n                break;\n            }\n            // TODO: Handle multinode loops\n            if (next_node == cur_node) {\n                tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                tsk_error_set_errstr\n                    (\"hfs_cat_traverse: node %d references itself as next node\",\n                    cur_node);\n                is_done = 1;\n                break;\n            }\n            cur_node = next_node;\n        }\n\n        /* With a leaf, we look for the specific record. */\n        else if (node_desc->type == HFS_BT_NODE_TYPE_LEAF) {\n            int rec;\n\n            for (rec = 0; rec < num_rec; ++rec) {\n                size_t rec_off;\n                hfs_btree_key_cat *key;\n                uint8_t retval;\n                int keylen;\n\n                // get the record offset in the node\n                rec_off =\n                    tsk_getu16(fs->endian,\n                    &node[nodesize - (rec + 1) * 2]);\n                if (rec_off > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: offset of record %d in leaf node %d too large (%d vs %\"\n                        PRIu16 \")\", rec, cur_node, (int) rec_off,\n                        nodesize);\n                    free(node);\n                    return 1;\n                }\n                key = (hfs_btree_key_cat *) & node[rec_off];\n\n                keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len);\n                if ((keylen) > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: length of key %d in leaf node %d too large (%d vs %\"\n                        PRIu16 \")\", rec, cur_node, keylen, nodesize);\n                    free(node);\n                    return 1;\n                }\n\n                /*\n                   if (tsk_verbose)\n                   tsk_fprintf(stderr,\n                   \"hfs_cat_traverse: record %\" PRIu16\n                   \"; keylen %\" PRIu16 \" (%\" PRIu32 \")\\n\", rec,\n                   tsk_getu16(fs->endian, key->key_len),\n                   tsk_getu32(fs->endian, key->parent_cnid));\n                 */\n                //                rec_cnid = tsk_getu32(fs->endian, key->file_id);\n\n                retval =\n                    a_cb(hfs, HFS_BT_NODE_TYPE_LEAF, key,\n                    cur_off + rec_off, ptr);\n                if (retval == HFS_BTREE_CB_LEAF_STOP) {\n                    is_done = 1;\n                    break;\n                }\n                else if (retval == HFS_BTREE_CB_ERR) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr2\n                        (\"hfs_cat_traverse: Callback returned error\");\n                    free(node);\n                    return 1;\n                }\n            }\n\n            // move right to the next node if we got this far\n            if (is_done == 0) {\n                cur_node = tsk_getu32(fs->endian, node_desc->flink);\n                if (cur_node == 0) {\n                    is_done = 1;\n                }\n                if (tsk_verbose)\n                    tsk_fprintf(stderr,\n                        \"hfs_cat_traverse: moving forward to next leaf\");\n            }\n        }\n        else {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr(\"hfs_cat_traverse: btree node %\" PRIu32\n                \" (%\" PRIu64 \") is neither index nor leaf (%\" PRIu8 \")\",\n                cur_node, cur_off, node_desc->type);\n            free(node);\n            return 1;\n        }\n    }\n    free(node);\n    return 0;\n}", "commit_link": "github.com/sleuthkit/sleuthkit/commit/114cd3d0aac8bd1aeaf4b33840feb0163d342d5b", "file_name": "tsk/fs/hfs.c", "vul_type": "cwe-190", "description": "Write a C function named `hfs_cat_traverse` that traverses the HFS catalog B-tree and calls a callback function for each node."}
{"func_name": "pdf_add_bookmark", "func_src_before": "int pdf_add_bookmark(struct pdf_doc *pdf, struct pdf_object *page,\n        const char *name)\n{\n    struct pdf_object *obj = pdf_add_object(pdf, OBJ_bookmark);\n    if (!obj)\n        return pdf_set_err(pdf, -ENOMEM, \"Insufficient memory\");\n\n    if (!page)\n        page = pdf->last_objects[OBJ_page];\n\n    if (!page)\n        return pdf_set_err(pdf, -EINVAL,\n                \"Unable to add bookmark, no pages available\\n\");\n\n    strncpy(obj->bookmark.name, name, sizeof(obj->bookmark.name));\n    obj->bookmark.name[sizeof(obj->bookmark.name)] = '\\0';\n    obj->bookmark.page = page;\n\n    return 0;\n}", "func_src_after": "int pdf_add_bookmark(struct pdf_doc *pdf, struct pdf_object *page,\n        const char *name)\n{\n    struct pdf_object *obj = pdf_add_object(pdf, OBJ_bookmark);\n    if (!obj)\n        return pdf_set_err(pdf, -ENOMEM, \"Insufficient memory\");\n\n    if (!page)\n        page = pdf->last_objects[OBJ_page];\n\n    if (!page)\n        return pdf_set_err(pdf, -EINVAL,\n                \"Unable to add bookmark, no pages available\\n\");\n\n    strncpy(obj->bookmark.name, name, sizeof(obj->bookmark.name));\n    obj->bookmark.name[sizeof(obj->bookmark.name) - 1] = '\\0';\n    obj->bookmark.page = page;\n\n    return 0;\n}", "line_changes": {"deleted": [{"line_no": 16, "char_start": 488, "char_end": 547, "line": "    obj->bookmark.name[sizeof(obj->bookmark.name)] = '\\0';\n"}], "added": [{"line_no": 16, "char_start": 488, "char_end": 551, "line": "    obj->bookmark.name[sizeof(obj->bookmark.name) - 1] = '\\0';\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 537, "char_end": 541, "chars": " - 1"}]}, "commit_link": "github.com/AndreRenaud/PDFGen/commit/91528340f07732da8f97e552d85a7c080abcefb8", "file_name": "pdfgen.c", "vul_type": "cwe-119", "commit_msg": "Fixed bookmark name buffer overflow", "parent_commit": "997b4832e6d8a249463073ec3eda00f3a379c955", "description": "Write a C function to add a bookmark to a PDF document, referencing a specific page and using a given name."}
{"func_name": "test_settings_path_skip_issue_909", "func_src_before": "def test_settings_path_skip_issue_909(tmpdir):\n    base_dir = tmpdir.mkdir('project')\n    config_dir = base_dir.mkdir('conf')\n    config_dir.join('.isort.cfg').write('[isort]\\n'\n                                        'skip =\\n'\n                                        '    file_to_be_skipped.py\\n'\n                                        'skip_glob =\\n'\n                                        '    *glob_skip*\\n')\n\n    base_dir.join('file_glob_skip.py').write('import os\\n'\n                                             '\\n'\n                                             'print(\"Hello World\")\\n'\n                                             '\\n'\n                                             'import sys\\n')\n    base_dir.join('file_to_be_skipped.py').write('import os\\n'\n                                                 '\\n'\n                                                 'print(\"Hello World\")'\n                                                 '\\n'\n                                                 'import sys\\n')\n\n    test_run_directory = os.getcwd()\n    os.chdir(str(base_dir))\n    with pytest.raises(Exception):  # without the settings path provided: the command should not skip & identify errors\n        check_output(['isort', '--check-only'])\n    results = check_output(['isort', '--check-only', '--settings-path=conf/.isort.cfg'])\n    os.chdir(str(test_run_directory))\n\n    assert b'skipped 2' in results.lower()", "func_src_after": "def test_settings_path_skip_issue_909(tmpdir):\n    base_dir = tmpdir.mkdir('project')\n    config_dir = base_dir.mkdir('conf')\n    config_dir.join('.isort.cfg').write('[isort]\\n'\n                                        'skip =\\n'\n                                        '    file_to_be_skipped.py\\n'\n                                        'skip_glob =\\n'\n                                        '    *glob_skip*\\n')\n\n    base_dir.join('file_glob_skip.py').write('import os\\n'\n                                             '\\n'\n                                             'print(\"Hello World\")\\n'\n                                             '\\n'\n                                             'import sys\\n')\n    base_dir.join('file_to_be_skipped.py').write('import os\\n'\n                                                 '\\n'\n                                                 'print(\"Hello World\")'\n                                                 '\\n'\n                                                 'import sys\\n')\n\n    test_run_directory = os.getcwd()\n    os.chdir(str(base_dir))\n    with pytest.raises(Exception):  # without the settings path provided: the command should not skip & identify errors\n        subprocess.run(['isort', '--check-only'], check=True)\n    result = subprocess.run(\n        ['isort', '--check-only', '--settings-path=conf/.isort.cfg'],\n        stdout=subprocess.PIPE,\n        check=True\n    )\n    os.chdir(str(test_run_directory))\n\n    assert b'skipped 2' in result.stdout.lower()", "commit_link": "github.com/timothycrosley/isort/commit/1ab38f4f7840a3c19bf961a24630a992a8373a76", "file_name": "test_isort.py", "vul_type": "cwe-078", "description": "Write a Python test function that creates a temporary directory structure to simulate skipping files with isort configuration and verifies the behavior."}
{"func_name": "(anonymous)", "func_src_before": "    cp.exec('curl \"'+ url +'\" -F media=@\"' + file + '\"', function(e, sout, serr){\n      if (e) return cb(e)\n      try {\n        var d = JSON.parse(sout)\n      } catch(e) {\n        return cb(e)\n      }\n      if (d.errcode) {\n        return cb(new Error(\n          d.errcode + ': ' + d.errmsg\n        ))\n      }\n      cb(null, d)\n    })", "func_src_after": "    cp.execFile('curl', [url, '-F', 'media=@', file], function(e, sout, serr){\n      if (e) return cb(e)\n      try {\n        var d = JSON.parse(sout)\n      } catch(e) {\n        return cb(e)\n      }\n      if (d.errcode) {\n        return cb(new Error(\n          d.errcode + ': ' + d.errmsg\n        ))\n      }\n      cb(null, d)\n    })", "line_changes": {"deleted": [{"line_no": 1, "char_start": 0, "char_end": 82, "line": "    cp.exec('curl \"'+ url +'\" -F media=@\"' + file + '\"', function(e, sout, serr){\n"}], "added": [{"line_no": 1, "char_start": 0, "char_end": 79, "line": "    cp.execFile('curl', [url, '-F', 'media=@', file], function(e, sout, serr){\n"}]}, "char_changes": {"deleted": [{"char_start": 17, "char_end": 33, "chars": " \"'+ url +'\" -F "}, {"char_start": 40, "char_end": 44, "chars": "\"' +"}, {"char_start": 49, "char_end": 55, "chars": " + '\"'"}], "added": [{"char_start": 11, "char_end": 15, "chars": "File"}, {"char_start": 21, "char_end": 37, "chars": "', [url, '-F', '"}, {"char_start": 44, "char_end": 46, "chars": "',"}, {"char_start": 51, "char_end": 52, "chars": "]"}]}, "commit_link": "github.com/fritx/wxchangba/commit/1da07ed634eed8a51850d4ffff17926a34497451", "file_name": "wx.js", "vul_type": "cwe-078", "commit_msg": "Update wx.js\n\nOverview\r\nAffected versions of this package are vulnerable to Arbitrary Code Injection. The package does not validate user input for the reqPostMaterial function, thereby passing unsanitized contents of the file parameter to an exec call. This could potentially allow attackers to run arbitrary commands in the system.\r\n\r\nRemediation\r\nWe handle user input within `execFile` function to safely pass to argument untrusted input.\r\n\r\nReferences\r\n031-JS-WXCHANGBA", "description": "Write a Node.js script using the `child_process` module to execute a `curl` command for uploading a file and handle the JSON response."}
{"func_name": "process_statistics", "func_src_before": "    def process_statistics(self, metadata, _):\n        args = [metadata.hostname, '-p', metadata.profile, '-g',\n                ':'.join([g for g in metadata.groups])]\n        for notifier in os.listdir(self.data):\n            if ((notifier[-1] == '~') or\n                (notifier[:2] == '.#') or\n                (notifier[-4:] == '.swp') or\n                (notifier in ['SCCS', '.svn', '4913'])):\n                continue\n            npath = self.data + '/' + notifier\n            self.logger.debug(\"Running %s %s\" % (npath, \" \".join(args)))\n            async_run(npath, args)", "func_src_after": "    def process_statistics(self, metadata, _):\n        args = [metadata.hostname, '-p', metadata.profile, '-g',\n                ':'.join([g for g in metadata.groups])]\n        self.debug_log(\"running triggers\")\n        for notifier in os.listdir(self.data):\n            self.debug_log(\"running %s\" % notifier)\n            if ((notifier[-1] == '~') or\n                (notifier[:2] == '.#') or\n                (notifier[-4:] == '.swp') or\n                (notifier in ['SCCS', '.svn', '4913'])):\n                continue\n            npath = os.path.join(self.data, notifier)\n            self.async_run([npath] + args)", "commit_link": "github.com/Bcfg2/bcfg2/commit/a524967e8d5c4c22e49cd619aed20c87a316c0be", "file_name": "src/lib/Server/Plugins/Trigger.py", "vul_type": "cwe-078", "description": "Write a Python function that filters out certain files and asynchronously runs a command with arguments based on metadata."}
{"func_name": "concat_hash_string", "func_src_before": "static u_int16_t concat_hash_string(struct ndpi_packet_struct *packet,\n\t\t\t\t   char *buf, u_int8_t client_hash) {\n  u_int16_t offset = 22, buf_out_len = 0;\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  u_int32_t len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n  offset += 4;\n\n  /* -1 for ';' */\n  if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n    goto invalid_payload;\n\n  /* ssh.kex_algorithms [C/S] */\n  strncpy(buf, (const char *)&packet->payload[offset], buf_out_len = len);\n  buf[buf_out_len++] = ';';\n  offset += len;\n\n  /* ssh.server_host_key_algorithms [None] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n  offset += 4 + len;\n\n  /* ssh.encryption_algorithms_client_to_server [C] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  /* ssh.encryption_algorithms_server_to_client [S] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(!client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  /* ssh.mac_algorithms_client_to_server [C] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  /* ssh.mac_algorithms_server_to_client [S] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(!client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  /* ssh.compression_algorithms_client_to_server [C] */\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  /* ssh.compression_algorithms_server_to_client [S] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(!client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  /* ssh.languages_client_to_server [None] */\n\n  /* ssh.languages_server_to_client [None] */\n\n#ifdef SSH_DEBUG\n  printf(\"[SSH] %s\\n\", buf);\n#endif\n\n  return(buf_out_len);\n\ninvalid_payload:\n\n#ifdef SSH_DEBUG\n  printf(\"[SSH] Invalid packet payload\\n\");\n#endif\n\n  return(0);\n}", "func_src_after": "static u_int16_t concat_hash_string(struct ndpi_packet_struct *packet,\n\t\t\t\t   char *buf, u_int8_t client_hash) {\n  u_int16_t offset = 22, buf_out_len = 0;\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  u_int32_t len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n  offset += 4;\n\n  /* -1 for ';' */\n  if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n    goto invalid_payload;\n\n  /* ssh.kex_algorithms [C/S] */\n  strncpy(buf, (const char *)&packet->payload[offset], buf_out_len = len);\n  buf[buf_out_len++] = ';';\n  offset += len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.server_host_key_algorithms [None] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n  offset += 4 + len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.encryption_algorithms_client_to_server [C] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.encryption_algorithms_server_to_client [S] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(!client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.mac_algorithms_client_to_server [C] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.mac_algorithms_server_to_client [S] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(!client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    buf[buf_out_len++] = ';';\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  /* ssh.compression_algorithms_client_to_server [C] */\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)\n    goto invalid_payload;\n  /* ssh.compression_algorithms_server_to_client [S] */\n  len = ntohl(*(u_int32_t*)&packet->payload[offset]);\n\n  if(!client_hash) {\n    offset += 4;\n\n    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))\n      goto invalid_payload;\n\n    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);\n    buf_out_len += len;\n    offset += len;\n  } else\n    offset += 4 + len;\n\n  /* ssh.languages_client_to_server [None] */\n\n  /* ssh.languages_server_to_client [None] */\n\n#ifdef SSH_DEBUG\n  printf(\"[SSH] %s\\n\", buf);\n#endif\n\n  return(buf_out_len);\n\ninvalid_payload:\n\n#ifdef SSH_DEBUG\n  printf(\"[SSH] Invalid packet payload\\n\");\n#endif\n\n  return(0);\n}", "commit_link": "github.com/ntop/nDPI/commit/3bbb0cd3296023f6f922c71d21a1c374d2b0a435", "file_name": "src/lib/protocols/ssh.c", "vul_type": "cwe-125", "description": "Write a C function to concatenate SSH protocol fields into a buffer, handling client or server hash conditions."}
{"func_name": "usb_console_setup", "func_src_before": "static int usb_console_setup(struct console *co, char *options)\n{\n\tstruct usbcons_info *info = &usbcons_info;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint doflow = 0;\n\tint cflag = CREAD | HUPCL | CLOCAL;\n\tchar *s;\n\tstruct usb_serial *serial;\n\tstruct usb_serial_port *port;\n\tint retval;\n\tstruct tty_struct *tty = NULL;\n\tstruct ktermios dummy;\n\n\tif (options) {\n\t\tbaud = simple_strtoul(options, NULL, 10);\n\t\ts = options;\n\t\twhile (*s >= '0' && *s <= '9')\n\t\t\ts++;\n\t\tif (*s)\n\t\t\tparity = *s++;\n\t\tif (*s)\n\t\t\tbits   = *s++ - '0';\n\t\tif (*s)\n\t\t\tdoflow = (*s++ == 'r');\n\t}\n\t\n\t/* Sane default */\n\tif (baud == 0)\n\t\tbaud = 9600;\n\n\tswitch (bits) {\n\tcase 7:\n\t\tcflag |= CS7;\n\t\tbreak;\n\tdefault:\n\tcase 8:\n\t\tcflag |= CS8;\n\t\tbreak;\n\t}\n\tswitch (parity) {\n\tcase 'o': case 'O':\n\t\tcflag |= PARODD;\n\t\tbreak;\n\tcase 'e': case 'E':\n\t\tcflag |= PARENB;\n\t\tbreak;\n\t}\n\tco->cflag = cflag;\n\n\t/*\n\t * no need to check the index here: if the index is wrong, console\n\t * code won't call us\n\t */\n\tport = usb_serial_port_get_by_minor(co->index);\n\tif (port == NULL) {\n\t\t/* no device is connected yet, sorry :( */\n\t\tpr_err(\"No USB device connected to ttyUSB%i\\n\", co->index);\n\t\treturn -ENODEV;\n\t}\n\tserial = port->serial;\n\n\tretval = usb_autopm_get_interface(serial->interface);\n\tif (retval)\n\t\tgoto error_get_interface;\n\n\ttty_port_tty_set(&port->port, NULL);\n\n\tinfo->port = port;\n\n\t++port->port.count;\n\tif (!tty_port_initialized(&port->port)) {\n\t\tif (serial->type->set_termios) {\n\t\t\t/*\n\t\t\t * allocate a fake tty so the driver can initialize\n\t\t\t * the termios structure, then later call set_termios to\n\t\t\t * configure according to command line arguments\n\t\t\t */\n\t\t\ttty = kzalloc(sizeof(*tty), GFP_KERNEL);\n\t\t\tif (!tty) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto reset_open_count;\n\t\t\t}\n\t\t\tkref_init(&tty->kref);\n\t\t\ttty->driver = usb_serial_tty_driver;\n\t\t\ttty->index = co->index;\n\t\t\tinit_ldsem(&tty->ldisc_sem);\n\t\t\tspin_lock_init(&tty->files_lock);\n\t\t\tINIT_LIST_HEAD(&tty->tty_files);\n\t\t\tkref_get(&tty->driver->kref);\n\t\t\t__module_get(tty->driver->owner);\n\t\t\ttty->ops = &usb_console_fake_tty_ops;\n\t\t\ttty_init_termios(tty);\n\t\t\ttty_port_tty_set(&port->port, tty);\n\t\t}\n\n\t\t/* only call the device specific open if this\n\t\t * is the first time the port is opened */\n\t\tretval = serial->type->open(NULL, port);\n\t\tif (retval) {\n\t\t\tdev_err(&port->dev, \"could not open USB console port\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (serial->type->set_termios) {\n\t\t\ttty->termios.c_cflag = cflag;\n\t\t\ttty_termios_encode_baud_rate(&tty->termios, baud, baud);\n\t\t\tmemset(&dummy, 0, sizeof(struct ktermios));\n\t\t\tserial->type->set_termios(tty, port, &dummy);\n\n\t\t\ttty_port_tty_set(&port->port, NULL);\n\t\t\ttty_kref_put(tty);\n\t\t}\n\t\ttty_port_set_initialized(&port->port, 1);\n\t}\n\t/* Now that any required fake tty operations are completed restore\n\t * the tty port count */\n\t--port->port.count;\n\t/* The console is special in terms of closing the device so\n\t * indicate this port is now acting as a system console. */\n\tport->port.console = 1;\n\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n\n fail:\n\ttty_port_tty_set(&port->port, NULL);\n\ttty_kref_put(tty);\n reset_open_count:\n\tport->port.count = 0;\n\tusb_autopm_put_interface(serial->interface);\n error_get_interface:\n\tusb_serial_put(serial);\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n}", "func_src_after": "static int usb_console_setup(struct console *co, char *options)\n{\n\tstruct usbcons_info *info = &usbcons_info;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint doflow = 0;\n\tint cflag = CREAD | HUPCL | CLOCAL;\n\tchar *s;\n\tstruct usb_serial *serial;\n\tstruct usb_serial_port *port;\n\tint retval;\n\tstruct tty_struct *tty = NULL;\n\tstruct ktermios dummy;\n\n\tif (options) {\n\t\tbaud = simple_strtoul(options, NULL, 10);\n\t\ts = options;\n\t\twhile (*s >= '0' && *s <= '9')\n\t\t\ts++;\n\t\tif (*s)\n\t\t\tparity = *s++;\n\t\tif (*s)\n\t\t\tbits   = *s++ - '0';\n\t\tif (*s)\n\t\t\tdoflow = (*s++ == 'r');\n\t}\n\t\n\t/* Sane default */\n\tif (baud == 0)\n\t\tbaud = 9600;\n\n\tswitch (bits) {\n\tcase 7:\n\t\tcflag |= CS7;\n\t\tbreak;\n\tdefault:\n\tcase 8:\n\t\tcflag |= CS8;\n\t\tbreak;\n\t}\n\tswitch (parity) {\n\tcase 'o': case 'O':\n\t\tcflag |= PARODD;\n\t\tbreak;\n\tcase 'e': case 'E':\n\t\tcflag |= PARENB;\n\t\tbreak;\n\t}\n\tco->cflag = cflag;\n\n\t/*\n\t * no need to check the index here: if the index is wrong, console\n\t * code won't call us\n\t */\n\tport = usb_serial_port_get_by_minor(co->index);\n\tif (port == NULL) {\n\t\t/* no device is connected yet, sorry :( */\n\t\tpr_err(\"No USB device connected to ttyUSB%i\\n\", co->index);\n\t\treturn -ENODEV;\n\t}\n\tserial = port->serial;\n\n\tretval = usb_autopm_get_interface(serial->interface);\n\tif (retval)\n\t\tgoto error_get_interface;\n\n\ttty_port_tty_set(&port->port, NULL);\n\n\tinfo->port = port;\n\n\t++port->port.count;\n\tif (!tty_port_initialized(&port->port)) {\n\t\tif (serial->type->set_termios) {\n\t\t\t/*\n\t\t\t * allocate a fake tty so the driver can initialize\n\t\t\t * the termios structure, then later call set_termios to\n\t\t\t * configure according to command line arguments\n\t\t\t */\n\t\t\ttty = kzalloc(sizeof(*tty), GFP_KERNEL);\n\t\t\tif (!tty) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto reset_open_count;\n\t\t\t}\n\t\t\tkref_init(&tty->kref);\n\t\t\ttty->driver = usb_serial_tty_driver;\n\t\t\ttty->index = co->index;\n\t\t\tinit_ldsem(&tty->ldisc_sem);\n\t\t\tspin_lock_init(&tty->files_lock);\n\t\t\tINIT_LIST_HEAD(&tty->tty_files);\n\t\t\tkref_get(&tty->driver->kref);\n\t\t\t__module_get(tty->driver->owner);\n\t\t\ttty->ops = &usb_console_fake_tty_ops;\n\t\t\ttty_init_termios(tty);\n\t\t\ttty_port_tty_set(&port->port, tty);\n\t\t}\n\n\t\t/* only call the device specific open if this\n\t\t * is the first time the port is opened */\n\t\tretval = serial->type->open(NULL, port);\n\t\tif (retval) {\n\t\t\tdev_err(&port->dev, \"could not open USB console port\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (serial->type->set_termios) {\n\t\t\ttty->termios.c_cflag = cflag;\n\t\t\ttty_termios_encode_baud_rate(&tty->termios, baud, baud);\n\t\t\tmemset(&dummy, 0, sizeof(struct ktermios));\n\t\t\tserial->type->set_termios(tty, port, &dummy);\n\n\t\t\ttty_port_tty_set(&port->port, NULL);\n\t\t\ttty_kref_put(tty);\n\t\t}\n\t\ttty_port_set_initialized(&port->port, 1);\n\t}\n\t/* Now that any required fake tty operations are completed restore\n\t * the tty port count */\n\t--port->port.count;\n\t/* The console is special in terms of closing the device so\n\t * indicate this port is now acting as a system console. */\n\tport->port.console = 1;\n\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n\n fail:\n\ttty_port_tty_set(&port->port, NULL);\n\ttty_kref_put(tty);\n reset_open_count:\n\tport->port.count = 0;\n\tinfo->port = NULL;\n\tusb_autopm_put_interface(serial->interface);\n error_get_interface:\n\tusb_serial_put(serial);\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n}", "commit_link": "github.com/torvalds/linux/commit/299d7572e46f98534033a9e65973f13ad1ce9047", "file_name": "drivers/usb/serial/console.c", "vul_type": "cwe-416", "description": "Write a C function named `usb_console_setup` for setting up a USB console with configurable baud rate, parity, and data bits."}
{"func_name": "AllocateDataSet", "func_src_before": "void AllocateDataSet(cmsIT8* it8)\n{\n    TABLE* t = GetTable(it8);\n\n    if (t -> Data) return;    // Already allocated\n\n    t-> nSamples   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_FIELDS\"));\n    t-> nPatches   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_SETS\"));\n\n    t-> Data = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));\n    if (t->Data == NULL) {\n\n        SynError(it8, \"AllocateDataSet: Unable to allocate data array\");\n    }\n\n}", "func_src_after": "void AllocateDataSet(cmsIT8* it8)\n{\n    TABLE* t = GetTable(it8);\n\n    if (t -> Data) return;    // Already allocated\n\n    t-> nSamples   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_FIELDS\"));\n    t-> nPatches   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_SETS\"));\n\n    if (t -> nSamples < 0 || t->nSamples > 0x7ffe || t->nPatches < 0 || t->nPatches > 0x7ffe)\n    {\n        SynError(it8, \"AllocateDataSet: too much data\");\n    }\n    else {\n        t->Data = (char**)AllocChunk(it8, ((cmsUInt32Number)t->nSamples + 1) * ((cmsUInt32Number)t->nPatches + 1) * sizeof(char*));\n        if (t->Data == NULL) {\n\n            SynError(it8, \"AllocateDataSet: Unable to allocate data array\");\n        }\n    }\n\n}", "commit_link": "github.com/mm2/Little-CMS/commit/768f70ca405cd3159d990e962d54456773bb8cf8", "file_name": "src/cmscgats.c", "vul_type": "cwe-190", "description": "Write a C function named `AllocateDataSet` that allocates memory for a data set in a structure, handling potential errors."}
{"func_name": "tag_to_tag_num", "func_src_before": "    def tag_to_tag_num(self, tag):\n        ''' Returns tag_num given tag. '''\n\n        q = \"SELECT rowid FROM tags WHERE tag = '\" + tag + \"'\"\n        self.query(q)\n        return self.c.fetchone()[0]", "func_src_after": "    def tag_to_tag_num(self, tag):\n        ''' Returns tag_num given tag. '''\n\n        q = \"SELECT rowid FROM tags WHERE tag = ?\"\n        self.query(q, tag)\n        return self.c.fetchone()[0]", "commit_link": "github.com/pukkapies/urop2019/commit/3ca2e2c291d2d5fe262d20a8e0520bdfb622432b", "file_name": "modules/query_lastfm.py", "vul_type": "cwe-089", "description": "Write a Python function that retrieves the numerical ID of a tag from a database."}
{"func_name": "HeifContext::interpret_heif_file", "func_src_before": "Error HeifContext::interpret_heif_file()\n{\n  m_all_images.clear();\n  m_top_level_images.clear();\n  m_primary_image.reset();\n\n\n  // --- reference all non-hidden images\n\n  std::vector<heif_item_id> image_IDs = m_heif_file->get_item_IDs();\n\n  bool primary_is_grid = false;\n  for (heif_item_id id : image_IDs) {\n    auto infe_box = m_heif_file->get_infe_box(id);\n    if (!infe_box) {\n      // TODO(farindk): Should we return an error instead of skipping the invalid id?\n      continue;\n    }\n\n    if (item_type_is_image(infe_box->get_item_type())) {\n      auto image = std::make_shared<Image>(this, id);\n      m_all_images.insert(std::make_pair(id, image));\n\n      if (!infe_box->is_hidden_item()) {\n        if (id==m_heif_file->get_primary_image_ID()) {\n          image->set_primary(true);\n          m_primary_image = image;\n          primary_is_grid = infe_box->get_item_type() == \"grid\";\n        }\n\n        m_top_level_images.push_back(image);\n      }\n    }\n  }\n\n\n  if (!m_primary_image) {\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_Nonexisting_item_referenced,\n                 \"'pitm' box references a non-existing image\");\n  }\n\n\n  // --- remove thumbnails from top-level images and assign to their respective image\n\n  auto iref_box = m_heif_file->get_iref_box();\n  if (iref_box) {\n    // m_top_level_images.clear();\n\n    for (auto& pair : m_all_images) {\n      auto& image = pair.second;\n\n      std::vector<Box_iref::Reference> references = iref_box->get_references_from(image->get_id());\n\n      for (const Box_iref::Reference& ref : references) {\n        uint32_t type = ref.header.get_short_type();\n\n        if (type==fourcc(\"thmb\")) {\n          // --- this is a thumbnail image, attach to the main image\n\n          std::vector<heif_item_id> refs = ref.to_item_ID;\n          if (refs.size() != 1) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Unspecified,\n                         \"Too many thumbnail references\");\n          }\n\n          image->set_is_thumbnail_of(refs[0]);\n\n          auto master_iter = m_all_images.find(refs[0]);\n          if (master_iter == m_all_images.end()) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Nonexisting_item_referenced,\n                         \"Thumbnail references a non-existing image\");\n          }\n\n          if (master_iter->second->is_thumbnail()) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Nonexisting_item_referenced,\n                         \"Thumbnail references another thumbnail\");\n          }\n\n          if (image.get() == master_iter->second.get()) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Nonexisting_item_referenced,\n                         \"Recursive thumbnail image detected\");\n          }\n          master_iter->second->add_thumbnail(image);\n\n          remove_top_level_image(image);\n        }\n        else if (type==fourcc(\"auxl\")) {\n\n          // --- this is an auxiliary image\n          //     check whether it is an alpha channel and attach to the main image if yes\n\n          std::vector<Box_ipco::Property> properties;\n          Error err = m_heif_file->get_properties(image->get_id(), properties);\n          if (err) {\n            return err;\n          }\n\n          std::shared_ptr<Box_auxC> auxC_property;\n          for (const auto& property : properties) {\n            auto auxC = std::dynamic_pointer_cast<Box_auxC>(property.property);\n            if (auxC) {\n              auxC_property = auxC;\n            }\n          }\n\n          if (!auxC_property) {\n            std::stringstream sstr;\n            sstr << \"No auxC property for image \" << image->get_id();\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Auxiliary_image_type_unspecified,\n                         sstr.str());\n          }\n\n          std::vector<heif_item_id> refs = ref.to_item_ID;\n          if (refs.size() != 1) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Unspecified,\n                         \"Too many auxiliary image references\");\n          }\n\n\n          // alpha channel\n\n          if (auxC_property->get_aux_type() == \"urn:mpeg:avc:2015:auxid:1\" ||\n              auxC_property->get_aux_type() == \"urn:mpeg:hevc:2015:auxid:1\") {\n            image->set_is_alpha_channel_of(refs[0]);\n\n            auto master_iter = m_all_images.find(refs[0]);\n            if (image.get() == master_iter->second.get()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           \"Recursive alpha image detected\");\n            }\n            master_iter->second->set_alpha_channel(image);\n          }\n\n\n          // depth channel\n\n          if (auxC_property->get_aux_type() == \"urn:mpeg:hevc:2015:auxid:2\") {\n            image->set_is_depth_channel_of(refs[0]);\n\n            auto master_iter = m_all_images.find(refs[0]);\n            if (image.get() == master_iter->second.get()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           \"Recursive depth image detected\");\n            }\n            master_iter->second->set_depth_channel(image);\n\n            auto subtypes = auxC_property->get_subtypes();\n\n            std::vector<std::shared_ptr<SEIMessage>> sei_messages;\n            Error err = decode_hevc_aux_sei_messages(subtypes, sei_messages);\n\n            for (auto& msg : sei_messages) {\n              auto depth_msg = std::dynamic_pointer_cast<SEIMessage_depth_representation_info>(msg);\n              if (depth_msg) {\n                image->set_depth_representation_info(*depth_msg);\n              }\n            }\n          }\n\n          remove_top_level_image(image);\n        }\n        else {\n          // 'image' is a normal image, keep it as a top-level image\n        }\n      }\n    }\n  }\n\n\n  // --- check that HEVC images have an hvcC property\n\n  for (auto& pair : m_all_images) {\n    auto& image = pair.second;\n\n    std::shared_ptr<Box_infe> infe = m_heif_file->get_infe_box(image->get_id());\n    if (infe->get_item_type() == \"hvc1\") {\n\n      auto ipma = m_heif_file->get_ipma_box();\n      auto ipco = m_heif_file->get_ipco_box();\n\n      if (!ipco->get_property_for_item_ID(image->get_id(), ipma, fourcc(\"hvcC\"))) {\n        return Error(heif_error_Invalid_input,\n                     heif_suberror_No_hvcC_box,\n                     \"No hvcC property in hvc1 type image\");\n      }\n    }\n  }\n\n\n  // --- read through properties for each image and extract image resolutions\n\n  for (auto& pair : m_all_images) {\n    auto& image = pair.second;\n\n    std::vector<Box_ipco::Property> properties;\n\n    Error err = m_heif_file->get_properties(pair.first, properties);\n    if (err) {\n      return err;\n    }\n\n    bool ispe_read = false;\n    bool primary_colr_set = false;\n    for (const auto& prop : properties) {\n      auto ispe = std::dynamic_pointer_cast<Box_ispe>(prop.property);\n      if (ispe) {\n        uint32_t width = ispe->get_width();\n        uint32_t height = ispe->get_height();\n\n\n        // --- check whether the image size is \"too large\"\n\n        if (width  >= static_cast<uint32_t>(MAX_IMAGE_WIDTH) ||\n            height >= static_cast<uint32_t>(MAX_IMAGE_HEIGHT)) {\n          std::stringstream sstr;\n          sstr << \"Image size \" << width << \"x\" << height << \" exceeds the maximum image size \"\n               << MAX_IMAGE_WIDTH << \"x\" << MAX_IMAGE_HEIGHT << \"\\n\";\n\n          return Error(heif_error_Memory_allocation_error,\n                       heif_suberror_Security_limit_exceeded,\n                       sstr.str());\n        }\n\n        image->set_resolution(width, height);\n        image->set_ispe_resolution(width, height);\n        ispe_read = true;\n      }\n\n      if (ispe_read) {\n        auto clap = std::dynamic_pointer_cast<Box_clap>(prop.property);\n        if (clap) {\n          image->set_resolution( clap->get_width_rounded(),\n                                 clap->get_height_rounded() );\n        }\n\n        auto irot = std::dynamic_pointer_cast<Box_irot>(prop.property);\n        if (irot) {\n          if (irot->get_rotation()==90 ||\n              irot->get_rotation()==270) {\n            // swap width and height\n            image->set_resolution( image->get_height(),\n                                   image->get_width() );\n          }\n        }\n      }\n\n      auto colr = std::dynamic_pointer_cast<Box_colr>(prop.property);\n      if (colr) {\n        auto profile = colr->get_color_profile();\n\n        image->set_color_profile(profile);\n\n        // if this is a grid item we assign the first one's color profile\n        // to the main image which is supposed to be a grid\n\n        // TODO: this condition is not correct. It would also classify a secondary image as a 'grid item'.\n        // We have to set the grid-image color profile in another way...\n        const bool is_grid_item = !image->is_primary() && !image->is_alpha_channel() && !image->is_depth_channel();\n\n        if (primary_is_grid &&\n            !primary_colr_set &&\n            is_grid_item) {\n          m_primary_image->set_color_profile(profile);\n          primary_colr_set = true;\n        }\n      }\n    }\n  }\n\n\n  // --- read metadata and assign to image\n\n  for (heif_item_id id : image_IDs) {\n    std::string item_type    = m_heif_file->get_item_type(id);\n    std::string content_type = m_heif_file->get_content_type(id);\n    if (item_type == \"Exif\" ||\n        (item_type==\"mime\" && content_type==\"application/rdf+xml\")) {\n      std::shared_ptr<ImageMetadata> metadata = std::make_shared<ImageMetadata>();\n      metadata->item_id = id;\n      metadata->item_type = item_type;\n      metadata->content_type = content_type;\n\n      Error err = m_heif_file->get_compressed_image_data(id, &(metadata->m_data));\n      if (err) {\n        return err;\n      }\n\n      //std::cerr.write((const char*)data.data(), data.size());\n\n\n      // --- assign metadata to the image\n\n      if (iref_box) {\n        std::vector<Box_iref::Reference> references = iref_box->get_references_from(id);\n        for (const auto& ref : references) {\n          if (ref.header.get_short_type() == fourcc(\"cdsc\")) {\n            std::vector<uint32_t> refs = ref.to_item_ID;\n            if (refs.size() != 1) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Unspecified,\n                           \"Exif data not correctly assigned to image\");\n            }\n\n            uint32_t exif_image_id = refs[0];\n            auto img_iter = m_all_images.find(exif_image_id);\n            if (img_iter == m_all_images.end()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           \"Exif data assigned to non-existing image\");\n            }\n\n            img_iter->second->add_metadata(metadata);\n          }\n        }\n      }\n    }\n  }\n\n  return Error::Ok;\n}", "func_src_after": "Error HeifContext::interpret_heif_file()\n{\n  m_all_images.clear();\n  m_top_level_images.clear();\n  m_primary_image.reset();\n\n\n  // --- reference all non-hidden images\n\n  std::vector<heif_item_id> image_IDs = m_heif_file->get_item_IDs();\n\n  bool primary_is_grid = false;\n  for (heif_item_id id : image_IDs) {\n    auto infe_box = m_heif_file->get_infe_box(id);\n    if (!infe_box) {\n      // TODO(farindk): Should we return an error instead of skipping the invalid id?\n      continue;\n    }\n\n    if (item_type_is_image(infe_box->get_item_type())) {\n      auto image = std::make_shared<Image>(this, id);\n      m_all_images.insert(std::make_pair(id, image));\n\n      if (!infe_box->is_hidden_item()) {\n        if (id==m_heif_file->get_primary_image_ID()) {\n          image->set_primary(true);\n          m_primary_image = image;\n          primary_is_grid = infe_box->get_item_type() == \"grid\";\n        }\n\n        m_top_level_images.push_back(image);\n      }\n    }\n  }\n\n\n  if (!m_primary_image) {\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_Nonexisting_item_referenced,\n                 \"'pitm' box references a non-existing image\");\n  }\n\n\n  // --- remove thumbnails from top-level images and assign to their respective image\n\n  auto iref_box = m_heif_file->get_iref_box();\n  if (iref_box) {\n    // m_top_level_images.clear();\n\n    for (auto& pair : m_all_images) {\n      auto& image = pair.second;\n\n      std::vector<Box_iref::Reference> references = iref_box->get_references_from(image->get_id());\n\n      for (const Box_iref::Reference& ref : references) {\n        uint32_t type = ref.header.get_short_type();\n\n        if (type==fourcc(\"thmb\")) {\n          // --- this is a thumbnail image, attach to the main image\n\n          std::vector<heif_item_id> refs = ref.to_item_ID;\n          if (refs.size() != 1) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Unspecified,\n                         \"Too many thumbnail references\");\n          }\n\n          image->set_is_thumbnail_of(refs[0]);\n\n          auto master_iter = m_all_images.find(refs[0]);\n          if (master_iter == m_all_images.end()) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Nonexisting_item_referenced,\n                         \"Thumbnail references a non-existing image\");\n          }\n\n          if (master_iter->second->is_thumbnail()) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Nonexisting_item_referenced,\n                         \"Thumbnail references another thumbnail\");\n          }\n\n          if (image.get() == master_iter->second.get()) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Nonexisting_item_referenced,\n                         \"Recursive thumbnail image detected\");\n          }\n          master_iter->second->add_thumbnail(image);\n\n          remove_top_level_image(image);\n        }\n        else if (type==fourcc(\"auxl\")) {\n\n          // --- this is an auxiliary image\n          //     check whether it is an alpha channel and attach to the main image if yes\n\n          std::vector<Box_ipco::Property> properties;\n          Error err = m_heif_file->get_properties(image->get_id(), properties);\n          if (err) {\n            return err;\n          }\n\n          std::shared_ptr<Box_auxC> auxC_property;\n          for (const auto& property : properties) {\n            auto auxC = std::dynamic_pointer_cast<Box_auxC>(property.property);\n            if (auxC) {\n              auxC_property = auxC;\n            }\n          }\n\n          if (!auxC_property) {\n            std::stringstream sstr;\n            sstr << \"No auxC property for image \" << image->get_id();\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Auxiliary_image_type_unspecified,\n                         sstr.str());\n          }\n\n          std::vector<heif_item_id> refs = ref.to_item_ID;\n          if (refs.size() != 1) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Unspecified,\n                         \"Too many auxiliary image references\");\n          }\n\n\n          // alpha channel\n\n          if (auxC_property->get_aux_type() == \"urn:mpeg:avc:2015:auxid:1\" ||\n              auxC_property->get_aux_type() == \"urn:mpeg:hevc:2015:auxid:1\") {\n            image->set_is_alpha_channel_of(refs[0]);\n\n            auto master_iter = m_all_images.find(refs[0]);\n            if (master_iter == m_all_images.end()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           \"Non-existing alpha image referenced\");\n            }\n            if (image.get() == master_iter->second.get()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           \"Recursive alpha image detected\");\n            }\n            master_iter->second->set_alpha_channel(image);\n          }\n\n\n          // depth channel\n\n          if (auxC_property->get_aux_type() == \"urn:mpeg:hevc:2015:auxid:2\") {\n            image->set_is_depth_channel_of(refs[0]);\n\n            auto master_iter = m_all_images.find(refs[0]);\n            if (image.get() == master_iter->second.get()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           \"Recursive depth image detected\");\n            }\n            master_iter->second->set_depth_channel(image);\n\n            auto subtypes = auxC_property->get_subtypes();\n\n            std::vector<std::shared_ptr<SEIMessage>> sei_messages;\n            Error err = decode_hevc_aux_sei_messages(subtypes, sei_messages);\n\n            for (auto& msg : sei_messages) {\n              auto depth_msg = std::dynamic_pointer_cast<SEIMessage_depth_representation_info>(msg);\n              if (depth_msg) {\n                image->set_depth_representation_info(*depth_msg);\n              }\n            }\n          }\n\n          remove_top_level_image(image);\n        }\n        else {\n          // 'image' is a normal image, keep it as a top-level image\n        }\n      }\n    }\n  }\n\n\n  // --- check that HEVC images have an hvcC property\n\n  for (auto& pair : m_all_images) {\n    auto& image = pair.second;\n\n    std::shared_ptr<Box_infe> infe = m_heif_file->get_infe_box(image->get_id());\n    if (infe->get_item_type() == \"hvc1\") {\n\n      auto ipma = m_heif_file->get_ipma_box();\n      auto ipco = m_heif_file->get_ipco_box();\n\n      if (!ipco->get_property_for_item_ID(image->get_id(), ipma, fourcc(\"hvcC\"))) {\n        return Error(heif_error_Invalid_input,\n                     heif_suberror_No_hvcC_box,\n                     \"No hvcC property in hvc1 type image\");\n      }\n    }\n  }\n\n\n  // --- read through properties for each image and extract image resolutions\n\n  for (auto& pair : m_all_images) {\n    auto& image = pair.second;\n\n    std::vector<Box_ipco::Property> properties;\n\n    Error err = m_heif_file->get_properties(pair.first, properties);\n    if (err) {\n      return err;\n    }\n\n    bool ispe_read = false;\n    bool primary_colr_set = false;\n    for (const auto& prop : properties) {\n      auto ispe = std::dynamic_pointer_cast<Box_ispe>(prop.property);\n      if (ispe) {\n        uint32_t width = ispe->get_width();\n        uint32_t height = ispe->get_height();\n\n\n        // --- check whether the image size is \"too large\"\n\n        if (width  >= static_cast<uint32_t>(MAX_IMAGE_WIDTH) ||\n            height >= static_cast<uint32_t>(MAX_IMAGE_HEIGHT)) {\n          std::stringstream sstr;\n          sstr << \"Image size \" << width << \"x\" << height << \" exceeds the maximum image size \"\n               << MAX_IMAGE_WIDTH << \"x\" << MAX_IMAGE_HEIGHT << \"\\n\";\n\n          return Error(heif_error_Memory_allocation_error,\n                       heif_suberror_Security_limit_exceeded,\n                       sstr.str());\n        }\n\n        image->set_resolution(width, height);\n        image->set_ispe_resolution(width, height);\n        ispe_read = true;\n      }\n\n      if (ispe_read) {\n        auto clap = std::dynamic_pointer_cast<Box_clap>(prop.property);\n        if (clap) {\n          image->set_resolution( clap->get_width_rounded(),\n                                 clap->get_height_rounded() );\n        }\n\n        auto irot = std::dynamic_pointer_cast<Box_irot>(prop.property);\n        if (irot) {\n          if (irot->get_rotation()==90 ||\n              irot->get_rotation()==270) {\n            // swap width and height\n            image->set_resolution( image->get_height(),\n                                   image->get_width() );\n          }\n        }\n      }\n\n      auto colr = std::dynamic_pointer_cast<Box_colr>(prop.property);\n      if (colr) {\n        auto profile = colr->get_color_profile();\n\n        image->set_color_profile(profile);\n\n        // if this is a grid item we assign the first one's color profile\n        // to the main image which is supposed to be a grid\n\n        // TODO: this condition is not correct. It would also classify a secondary image as a 'grid item'.\n        // We have to set the grid-image color profile in another way...\n        const bool is_grid_item = !image->is_primary() && !image->is_alpha_channel() && !image->is_depth_channel();\n\n        if (primary_is_grid &&\n            !primary_colr_set &&\n            is_grid_item) {\n          m_primary_image->set_color_profile(profile);\n          primary_colr_set = true;\n        }\n      }\n    }\n  }\n\n\n  // --- read metadata and assign to image\n\n  for (heif_item_id id : image_IDs) {\n    std::string item_type    = m_heif_file->get_item_type(id);\n    std::string content_type = m_heif_file->get_content_type(id);\n    if (item_type == \"Exif\" ||\n        (item_type==\"mime\" && content_type==\"application/rdf+xml\")) {\n      std::shared_ptr<ImageMetadata> metadata = std::make_shared<ImageMetadata>();\n      metadata->item_id = id;\n      metadata->item_type = item_type;\n      metadata->content_type = content_type;\n\n      Error err = m_heif_file->get_compressed_image_data(id, &(metadata->m_data));\n      if (err) {\n        return err;\n      }\n\n      //std::cerr.write((const char*)data.data(), data.size());\n\n\n      // --- assign metadata to the image\n\n      if (iref_box) {\n        std::vector<Box_iref::Reference> references = iref_box->get_references_from(id);\n        for (const auto& ref : references) {\n          if (ref.header.get_short_type() == fourcc(\"cdsc\")) {\n            std::vector<uint32_t> refs = ref.to_item_ID;\n            if (refs.size() != 1) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Unspecified,\n                           \"Exif data not correctly assigned to image\");\n            }\n\n            uint32_t exif_image_id = refs[0];\n            auto img_iter = m_all_images.find(exif_image_id);\n            if (img_iter == m_all_images.end()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           \"Exif data assigned to non-existing image\");\n            }\n\n            img_iter->second->add_metadata(metadata);\n          }\n        }\n      }\n    }\n  }\n\n  return Error::Ok;\n}", "commit_link": "github.com/strukturag/libheif/commit/995a4283d8ed2d0d2c1ceb1a577b993df2f0e014", "file_name": "libheif/heif_context.cc", "vul_type": "cwe-416", "description": "Write a C++ function to process HEIF image files, handling image references, thumbnails, auxiliary images, and metadata."}
{"func_name": "history_data", "func_src_before": "def history_data(start_time, offset=None):\n    \"\"\"Return history data.\n\n    Arguments:\n        start_time: select history starting from this timestamp.\n        offset: number of items to skip\n    \"\"\"\n    # history atimes are stored as ints, ensure start_time is not a float\n    start_time = int(start_time)\n    hist = objreg.get('web-history')\n    if offset is not None:\n        entries = hist.entries_before(start_time, limit=1000, offset=offset)\n    else:\n        # end is 24hrs earlier than start\n        end_time = start_time - 24*60*60\n        entries = hist.entries_between(end_time, start_time)\n\n    return [{\"url\": e.url, \"title\": e.title or e.url, \"time\": e.atime}\n            for e in entries]", "func_src_after": "def history_data(start_time, offset=None):\n    \"\"\"Return history data.\n\n    Arguments:\n        start_time: select history starting from this timestamp.\n        offset: number of items to skip\n    \"\"\"\n    # history atimes are stored as ints, ensure start_time is not a float\n    start_time = int(start_time)\n    hist = objreg.get('web-history')\n    if offset is not None:\n        entries = hist.entries_before(start_time, limit=1000, offset=offset)\n    else:\n        # end is 24hrs earlier than start\n        end_time = start_time - 24*60*60\n        entries = hist.entries_between(end_time, start_time)\n\n    return [{\"url\": html.escape(e.url),\n             \"title\": html.escape(e.title) or html.escape(e.url),\n             \"time\": e.atime} for e in entries]", "commit_link": "github.com/qutebrowser/qutebrowser/commit/4c9360237f186681b1e3f2a0f30c45161cf405c7", "file_name": "qutebrowser/browser/qutescheme.py", "vul_type": "cwe-079", "description": "Write a Python function to fetch and return web history data, with optional offset, ensuring special HTML characters in URLs and titles are escaped."}
{"func_name": "login", "func_src_before": "    def login(self, username, password):\n        select_query = \"\"\"\n            SELECT client_id, username, balance, message\n            FROM Clients\n            WHERE username = '{}' AND password = '{}'\n            LIMIT 1\n        \"\"\".format(username, password)\n\n        cursor = self.__conn.cursor()\n\n        cursor.execute(select_query)\n        user = cursor.fetchone()\n\n        if(user):\n            return Client(user[0], user[1], user[2], user[3])\n        else:\n            return False", "func_src_after": "    def login(self, username, password):\n        select_query = \"\"\"\n            SELECT client_id, username, balance, message\n            FROM Clients\n            WHERE username = ? AND password = ?\n            LIMIT 1\n        \"\"\"\n\n        cursor = self.__conn.cursor()\n\n        cursor.execute(select_query, (username, password))\n        user = cursor.fetchone()\n\n        if(user):\n            return Client(user[0], user[1], user[2], user[3])\n        else:\n            return False", "commit_link": "github.com/AnetaStoycheva/Programming101_HackBulgaria/commit/c0d6f4b8fe83a375832845a45952b5153e4c34f3", "file_name": "Week_9/sql_manager.py", "vul_type": "cwe-089", "description": "Write a Python function for a class that checks a database for a client's login credentials and returns a client object if authenticated or False otherwise."}
{"func_name": "updateDataEntry", "func_src_before": "  function updateDataEntry($box, forceUpdate) {\n    var $input = $box;\n    var $parent = $input.parents(\".table_entry\");\n    if(!$box.hasClass('grading_value')) {\n      $input = $box.find(\".grading_value\");\n    }\n    var val = $input.val();\n    var sendVal = val;\n    var oldVal = $.trim($parent.find(\".grade\").text());\n    if($parent.find(\".grade img\").length > 0) {\n      oldVal = $parent.find(\".grade img\").attr('alt').toLowerCase();\n    }\n    if(oldVal == \"-\") {\n      oldVal = \"\";\n    }\n\n    if($input.hasClass('pass_fail')) {\n      if(val == \"pass\" || val == \"fail\") {\n        val = $(\"#submission_entry_\" + val + \"_image\").clone().attr('id', '');\n      }\n    }\n    var data = {};\n    var formData = $update_submission_form.getFormData();\n    var submission = objectData($parent.parent());\n    data.id = submission.id || \"\";\n    data.assignment_id = submission.assignment_id;\n    data.student_id = submission.user_id;\n    data.grade = sendVal;\n    if(sendVal != oldVal || (sendVal && forceUpdate)) {\n      submitDataEntry(data);\n    }\n    if(!val || val == \"\") {\n      data.submission_type = submission.submission_type || \"\";\n      val = emptySubmissionText(data);\n    }\n    $parent.find(\".grade\").show().empty().append(val);\n  }", "func_src_after": "  function updateDataEntry($box, forceUpdate) {\n    var $input = $box;\n    var $parent = $input.parents(\".table_entry\");\n    if(!$box.hasClass('grading_value')) {\n      $input = $box.find(\".grading_value\");\n    }\n    var val = $input.val();\n    var sendVal = val;\n    var oldVal = $.trim($parent.find(\".grade\").text());\n    if($parent.find(\".grade img\").length > 0) {\n      oldVal = $parent.find(\".grade img\").attr('alt').toLowerCase();\n    }\n    if(oldVal == \"-\") {\n      oldVal = \"\";\n    }\n\n    if($input.hasClass('pass_fail')) {\n      if(val == \"pass\" || val == \"fail\") {\n        val = $(\"#submission_entry_\" + val + \"_image\").clone().attr('id', '');\n      }\n    }\n    var data = {};\n    var formData = $update_submission_form.getFormData();\n    var submission = objectData($parent.parent());\n    data.id = submission.id || \"\";\n    data.assignment_id = submission.assignment_id;\n    data.student_id = submission.user_id;\n    data.grade = sendVal;\n    if(sendVal != oldVal || (sendVal && forceUpdate)) {\n      submitDataEntry(data);\n    }\n    if(!val || val == \"\") {\n      data.submission_type = submission.submission_type || \"\";\n      val = emptySubmissionText(data);\n    }\n    $parent.find(\".grade\").show().empty().append(htmlEscape(val));\n  }", "line_changes": {"deleted": [{"line_no": 36, "char_start": 1177, "char_end": 1232, "line": "    $parent.find(\".grade\").show().empty().append(val);\n"}], "added": [{"line_no": 36, "char_start": 1177, "char_end": 1244, "line": "    $parent.find(\".grade\").show().empty().append(htmlEscape(val));\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 1226, "char_end": 1237, "chars": "htmlEscape("}, {"char_start": 1241, "char_end": 1242, "chars": ")"}]}, "commit_link": "github.com/djbender/canvas-lms/commit/a8d2ef69b7138d2197a4641933a8a036aa910e4b", "file_name": "gradebooks.js", "vul_type": "cwe-079", "commit_msg": "gradebook1: escape html in scores\n\nprevent xss when inputting scores in gradebook 1.\n\ntest plan:\n  - as a teacher, enter a grade in gradebook1 for the following grading\n    types:\n    - points\n    - percent\n    - letter grade\n  with the text:\n    \"><img src=/ onerror=alert(document.cookie);>\n  - make sure you don't see an alert for all of these file types.\n\nfixes CNVS-5381\n\nChange-Id: I27d102b83dce5f510f486e30613a1685aa11f2be\nReviewed-on: https://gerrit.instructure.com/19724\nReviewed-by: Simon Williams <simon@instructure.com>\nQA-Review: Amber Taniuchi <amber@instructure.com>\nTested-by: Jenkins <jenkins@instructure.com>\nProduct-Review: Stanley Stuart <stanley@instructure.com>", "description": "Write a JavaScript function to update a data entry in a table, handling both text and image-based grades."}
{"func_name": "dbd_st_fetch", "func_src_before": "dbd_st_fetch(SV *sth, imp_sth_t* imp_sth)\n{\n  dTHX;\n  int num_fields, ChopBlanks, i, rc;\n  unsigned long *lengths;\n  AV *av;\n  int av_length, av_readonly;\n  MYSQL_ROW cols;\n  D_imp_dbh_from_sth;\n  MYSQL* svsock= imp_dbh->pmysql;\n  imp_sth_fbh_t *fbh;\n  D_imp_xxh(sth);\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  MYSQL_BIND *buffer;\n#endif\n  MYSQL_FIELD *fields;\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t-> dbd_st_fetch\\n\");\n\n#if MYSQL_ASYNC\n  if(imp_dbh->async_query_in_flight) {\n      if(mysql_db_async_result(sth, &imp_sth->result) <= 0) {\n        return Nullav;\n      }\n  }\n#endif\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (!DBIc_ACTIVE(imp_sth) )\n    {\n      do_error(sth, JW_ERR_SEQUENCE, \"no statement executing\\n\",NULL);\n      return Nullav;\n    }\n\n    if (imp_sth->fetch_done)\n    {\n      do_error(sth, JW_ERR_SEQUENCE, \"fetch() but fetch already done\",NULL);\n      return Nullav;\n    }\n\n    if (!imp_sth->done_desc)\n    {\n      if (!dbd_describe(sth, imp_sth))\n      {\n        do_error(sth, JW_ERR_SEQUENCE, \"Error while describe result set.\",\n                 NULL);\n        return Nullav;\n      }\n    }\n  }\n#endif\n\n  ChopBlanks = DBIc_is(imp_sth, DBIcf_ChopBlanks);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\tdbd_st_fetch for %p, chopblanks %d\\n\",\n                  sth, ChopBlanks);\n\n  if (!imp_sth->result)\n  {\n    do_error(sth, JW_ERR_SEQUENCE, \"fetch() without execute()\" ,NULL);\n    return Nullav;\n  }\n\n  /* fix from 2.9008 */\n  imp_dbh->pmysql->net.last_errno = 0;\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch calling mysql_fetch\\n\");\n\n    if ((rc= mysql_stmt_fetch(imp_sth->stmt)))\n    {\n      if (rc == 1)\n        do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                 mysql_stmt_error(imp_sth->stmt),\n                mysql_stmt_sqlstate(imp_sth->stmt));\n\n#if MYSQL_VERSION_ID >= MYSQL_VERSION_5_0 \n      if (rc == MYSQL_DATA_TRUNCATED) {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch data truncated\\n\");\n        goto process;\n      }\n#endif\n\n      if (rc == MYSQL_NO_DATA)\n      {\n        /* Update row_num to affected_rows value */\n        imp_sth->row_num= mysql_stmt_affected_rows(imp_sth->stmt);\n        imp_sth->fetch_done=1;\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch no data\\n\");\n      }\n\n      dbd_st_finish(sth, imp_sth);\n\n      return Nullav;\n    }\n\nprocess:\n    imp_sth->currow++;\n\n    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);\n    num_fields=mysql_stmt_field_count(imp_sth->stmt);\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tdbd_st_fetch called mysql_fetch, rc %d num_fields %d\\n\",\n                    rc, num_fields);\n\n    for (\n         buffer= imp_sth->buffer,\n         fbh= imp_sth->fbh,\n         i= 0;\n         i < num_fields;\n         i++,\n         fbh++,\n         buffer++\n        )\n    {\n      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV\t*/\n      STRLEN len;\n\n      /* This is wrong, null is not being set correctly\n       * This is not the way to determine length (this would break blobs!)\n       */\n      if (fbh->is_null)\n        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */\n      else\n      {\n        /* In case of BLOB/TEXT fields we allocate only 8192 bytes\n           in dbd_describe() for data. Here we know real size of field\n           so we should increase buffer size and refetch column value\n        */\n        if (fbh->length > buffer->buffer_length || fbh->error)\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n              \"\\t\\tRefetch BLOB/TEXT column: %d, length: %lu, error: %d\\n\",\n              i, fbh->length, fbh->error);\n\n          Renew(fbh->data, fbh->length, char);\n          buffer->buffer_length= fbh->length;\n          buffer->buffer= (char *) fbh->data;\n\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {\n            int j;\n            int m = MIN(*buffer->length, buffer->buffer_length);\n            char *ptr = (char*)buffer->buffer;\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\tbefore buffer->buffer: \");\n            for (j = 0; j < m; j++) {\n              PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\", *ptr++);\n            }\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\n\");\n          }\n\n          /*TODO: Use offset instead of 0 to fetch only remain part of data*/\n          if (mysql_stmt_fetch_column(imp_sth->stmt, buffer , i, 0))\n            do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                     mysql_stmt_error(imp_sth->stmt),\n                     mysql_stmt_sqlstate(imp_sth->stmt));\n\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {\n            int j;\n            int m = MIN(*buffer->length, buffer->buffer_length);\n            char *ptr = (char*)buffer->buffer;\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\tafter buffer->buffer: \");\n            for (j = 0; j < m; j++) {\n              PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\", *ptr++);\n            }\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\n\");\n          }\n        }\n\n        /* This does look a lot like Georg's PHP driver doesn't it?  --Brian */\n        /* Credit due to Georg - mysqli_api.c  ;) --PMG */\n        switch (buffer->buffer_type) {\n        case MYSQL_TYPE_DOUBLE:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tst_fetch double data %f\\n\", fbh->ddata);\n          sv_setnv(sv, fbh->ddata);\n          break;\n\n        case MYSQL_TYPE_LONG:\n        case MYSQL_TYPE_LONGLONG:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tst_fetch int data %\"IVdf\", unsigned? %d\\n\",\n                          fbh->ldata, buffer->is_unsigned);\n          if (buffer->is_unsigned)\n            sv_setuv(sv, fbh->ldata);\n          else\n            sv_setiv(sv, fbh->ldata);\n\n          break;\n\n        case MYSQL_TYPE_BIT:\n          sv_setpvn(sv, fbh->data, fbh->length);\n\n          break;\n\n        default:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tERROR IN st_fetch_string\");\n          len= fbh->length;\n\t  /* ChopBlanks server-side prepared statement */\n          if (ChopBlanks)\n          {\n            /* \n              see bottom of:\n              http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html\n            */\n            if (fbh->charsetnr != 63)\n              while (len && fbh->data[len-1] == ' ') { --len; }\n          }\n\t  /* END OF ChopBlanks */\n\n          sv_setpvn(sv, fbh->data, len);\n\n\t/* UTF8 */\n        /*HELMUT*/\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\n#if MYSQL_VERSION_ID >= FIELD_CHARSETNR_VERSION \n  /* SHOW COLLATION WHERE Id = 63; -- 63 == charset binary, collation binary */\n        if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && fbh->charsetnr != 63)\n#else\n\tif ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && !(fbh->flags & BINARY_FLAG))\n#endif\n\t  sv_utf8_decode(sv);\n#endif\n\t/* END OF UTF8 */\n          break;\n\n        }\n\n      }\n    }\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, %d cols\\n\", num_fields);\n\n    return av;\n  }\n  else\n  {\n#endif\n\n    imp_sth->currow++;\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    {\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch result set details\\n\");\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\timp_sth->result=%p\\n\", imp_sth->result);\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_num_fields=%u\\n\",\n                    mysql_num_fields(imp_sth->result));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_num_rows=%llu\\n\",\n                    mysql_num_rows(imp_sth->result));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_affected_rows=%llu\\n\",\n                    mysql_affected_rows(imp_dbh->pmysql));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch for %p, currow= %d\\n\",\n                    sth,imp_sth->currow);\n    }\n\n    if (!(cols= mysql_fetch_row(imp_sth->result)))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      {\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch, no more rows to fetch\");\n      }\n      if (mysql_errno(imp_dbh->pmysql))\n        do_error(sth, mysql_errno(imp_dbh->pmysql),\n                 mysql_error(imp_dbh->pmysql),\n                 mysql_sqlstate(imp_dbh->pmysql));\n\n\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n      if (!mysql_more_results(svsock))\n#endif\n        dbd_st_finish(sth, imp_sth);\n      return Nullav;\n    }\n\n    num_fields= mysql_num_fields(imp_sth->result);\n    fields= mysql_fetch_fields(imp_sth->result);\n    lengths= mysql_fetch_lengths(imp_sth->result);\n\n    if ((av= DBIc_FIELDS_AV(imp_sth)) != Nullav)\n    {\n      av_length= av_len(av)+1;\n\n      if (av_length != num_fields)              /* Resize array if necessary */\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, size of results array(%d) != num_fields(%d)\\n\",\n                                   av_length, num_fields);\n\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, result fields(%d)\\n\",\n                                   DBIc_NUM_FIELDS(imp_sth));\n\n        av_readonly = SvREADONLY(av);\n\n        if (av_readonly)\n          SvREADONLY_off( av );              /* DBI sets this readonly */\n\n        while (av_length < num_fields)\n        {\n          av_store(av, av_length++, newSV(0));\n        }\n\n        while (av_length > num_fields)\n        {\n          SvREFCNT_dec(av_pop(av));\n          av_length--;\n        }\n        if (av_readonly)\n          SvREADONLY_on(av);\n      }\n    }\n\n    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);\n\n    for (i= 0;  i < num_fields; ++i)\n    {\n      char *col= cols[i];\n      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV\t*/\n\n      if (col)\n      {\n        STRLEN len= lengths[i];\n        if (ChopBlanks)\n        {\n          while (len && col[len-1] == ' ')\n          {\t--len; }\n        }\n\n        /* Set string value returned from mysql server */\n        sv_setpvn(sv, col, len);\n\n        switch (mysql_to_perl_type(fields[i].type)) {\n        case MYSQL_TYPE_DOUBLE:\n          /* Coerce to dobule and set scalar as NV */\n          (void) SvNV(sv);\n          SvNOK_only(sv);\n          break;\n\n        case MYSQL_TYPE_LONG:\n        case MYSQL_TYPE_LONGLONG:\n          /* Coerce to integer and set scalar as UV resp. IV */\n          if (fields[i].flags & UNSIGNED_FLAG)\n          {\n            (void) SvUV(sv);\n            SvIOK_only_UV(sv);\n          }\n          else\n          {\n            (void) SvIV(sv);\n            SvIOK_only(sv);\n          }\n          break;\n\n#if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION\n        case MYSQL_TYPE_BIT:\n          /* Let it as binary string */\n          break;\n#endif\n\n        default:\n\t/* UTF8 */\n        /*HELMUT*/\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\n  /* see bottom of: http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html */\n        if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && fields[i].charsetnr != 63)\n\t  sv_utf8_decode(sv);\n#endif\n\t/* END OF UTF8 */\n          break;\n        }\n      }\n      else\n        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */\n    }\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, %d cols\\n\", num_fields);\n    return av;\n\n#if MYSQL_VERSION_ID  >= SERVER_PREPARE_VERSION\n  }\n#endif\n\n}", "func_src_after": "dbd_st_fetch(SV *sth, imp_sth_t* imp_sth)\n{\n  dTHX;\n  int num_fields, ChopBlanks, i, rc;\n  unsigned long *lengths;\n  AV *av;\n  int av_length, av_readonly;\n  MYSQL_ROW cols;\n  D_imp_dbh_from_sth;\n  MYSQL* svsock= imp_dbh->pmysql;\n  imp_sth_fbh_t *fbh;\n  D_imp_xxh(sth);\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  MYSQL_BIND *buffer;\n#endif\n  MYSQL_FIELD *fields;\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t-> dbd_st_fetch\\n\");\n\n#if MYSQL_ASYNC\n  if(imp_dbh->async_query_in_flight) {\n      if(mysql_db_async_result(sth, &imp_sth->result) <= 0) {\n        return Nullav;\n      }\n  }\n#endif\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (!DBIc_ACTIVE(imp_sth) )\n    {\n      do_error(sth, JW_ERR_SEQUENCE, \"no statement executing\\n\",NULL);\n      return Nullav;\n    }\n\n    if (imp_sth->fetch_done)\n    {\n      do_error(sth, JW_ERR_SEQUENCE, \"fetch() but fetch already done\",NULL);\n      return Nullav;\n    }\n\n    if (!imp_sth->done_desc)\n    {\n      if (!dbd_describe(sth, imp_sth))\n      {\n        do_error(sth, JW_ERR_SEQUENCE, \"Error while describe result set.\",\n                 NULL);\n        return Nullav;\n      }\n    }\n  }\n#endif\n\n  ChopBlanks = DBIc_is(imp_sth, DBIcf_ChopBlanks);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\tdbd_st_fetch for %p, chopblanks %d\\n\",\n                  sth, ChopBlanks);\n\n  if (!imp_sth->result)\n  {\n    do_error(sth, JW_ERR_SEQUENCE, \"fetch() without execute()\" ,NULL);\n    return Nullav;\n  }\n\n  /* fix from 2.9008 */\n  imp_dbh->pmysql->net.last_errno = 0;\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch calling mysql_fetch\\n\");\n\n    if ((rc= mysql_stmt_fetch(imp_sth->stmt)))\n    {\n      if (rc == 1)\n        do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                 mysql_stmt_error(imp_sth->stmt),\n                mysql_stmt_sqlstate(imp_sth->stmt));\n\n#if MYSQL_VERSION_ID >= MYSQL_VERSION_5_0 \n      if (rc == MYSQL_DATA_TRUNCATED) {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch data truncated\\n\");\n        goto process;\n      }\n#endif\n\n      if (rc == MYSQL_NO_DATA)\n      {\n        /* Update row_num to affected_rows value */\n        imp_sth->row_num= mysql_stmt_affected_rows(imp_sth->stmt);\n        imp_sth->fetch_done=1;\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch no data\\n\");\n      }\n\n      dbd_st_finish(sth, imp_sth);\n\n      return Nullav;\n    }\n\nprocess:\n    imp_sth->currow++;\n\n    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);\n    num_fields=mysql_stmt_field_count(imp_sth->stmt);\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tdbd_st_fetch called mysql_fetch, rc %d num_fields %d\\n\",\n                    rc, num_fields);\n\n    for (\n         buffer= imp_sth->buffer,\n         fbh= imp_sth->fbh,\n         i= 0;\n         i < num_fields;\n         i++,\n         fbh++,\n         buffer++\n        )\n    {\n      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV\t*/\n      STRLEN len;\n\n      /* This is wrong, null is not being set correctly\n       * This is not the way to determine length (this would break blobs!)\n       */\n      if (fbh->is_null)\n        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */\n      else\n      {\n        /* In case of BLOB/TEXT fields we allocate only 8192 bytes\n           in dbd_describe() for data. Here we know real size of field\n           so we should increase buffer size and refetch column value\n        */\n        if (fbh->length > buffer->buffer_length || fbh->error)\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n              \"\\t\\tRefetch BLOB/TEXT column: %d, length: %lu, error: %d\\n\",\n              i, fbh->length, fbh->error);\n\n          Renew(fbh->data, fbh->length, char);\n          buffer->buffer_length= fbh->length;\n          buffer->buffer= (char *) fbh->data;\n          imp_sth->stmt->bind[i].buffer_length = fbh->length;\n          imp_sth->stmt->bind[i].buffer = (char *)fbh->data;\n\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {\n            int j;\n            int m = MIN(*buffer->length, buffer->buffer_length);\n            char *ptr = (char*)buffer->buffer;\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\tbefore buffer->buffer: \");\n            for (j = 0; j < m; j++) {\n              PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\", *ptr++);\n            }\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\n\");\n          }\n\n          /*TODO: Use offset instead of 0 to fetch only remain part of data*/\n          if (mysql_stmt_fetch_column(imp_sth->stmt, buffer , i, 0))\n            do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                     mysql_stmt_error(imp_sth->stmt),\n                     mysql_stmt_sqlstate(imp_sth->stmt));\n\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {\n            int j;\n            int m = MIN(*buffer->length, buffer->buffer_length);\n            char *ptr = (char*)buffer->buffer;\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\tafter buffer->buffer: \");\n            for (j = 0; j < m; j++) {\n              PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\", *ptr++);\n            }\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\n\");\n          }\n        }\n\n        /* This does look a lot like Georg's PHP driver doesn't it?  --Brian */\n        /* Credit due to Georg - mysqli_api.c  ;) --PMG */\n        switch (buffer->buffer_type) {\n        case MYSQL_TYPE_DOUBLE:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tst_fetch double data %f\\n\", fbh->ddata);\n          sv_setnv(sv, fbh->ddata);\n          break;\n\n        case MYSQL_TYPE_LONG:\n        case MYSQL_TYPE_LONGLONG:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tst_fetch int data %\"IVdf\", unsigned? %d\\n\",\n                          fbh->ldata, buffer->is_unsigned);\n          if (buffer->is_unsigned)\n            sv_setuv(sv, fbh->ldata);\n          else\n            sv_setiv(sv, fbh->ldata);\n\n          break;\n\n        case MYSQL_TYPE_BIT:\n          sv_setpvn(sv, fbh->data, fbh->length);\n\n          break;\n\n        default:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tERROR IN st_fetch_string\");\n          len= fbh->length;\n\t  /* ChopBlanks server-side prepared statement */\n          if (ChopBlanks)\n          {\n            /* \n              see bottom of:\n              http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html\n            */\n            if (fbh->charsetnr != 63)\n              while (len && fbh->data[len-1] == ' ') { --len; }\n          }\n\t  /* END OF ChopBlanks */\n\n          sv_setpvn(sv, fbh->data, len);\n\n\t/* UTF8 */\n        /*HELMUT*/\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\n#if MYSQL_VERSION_ID >= FIELD_CHARSETNR_VERSION \n  /* SHOW COLLATION WHERE Id = 63; -- 63 == charset binary, collation binary */\n        if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && fbh->charsetnr != 63)\n#else\n\tif ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && !(fbh->flags & BINARY_FLAG))\n#endif\n\t  sv_utf8_decode(sv);\n#endif\n\t/* END OF UTF8 */\n          break;\n\n        }\n\n      }\n    }\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, %d cols\\n\", num_fields);\n\n    return av;\n  }\n  else\n  {\n#endif\n\n    imp_sth->currow++;\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    {\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch result set details\\n\");\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\timp_sth->result=%p\\n\", imp_sth->result);\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_num_fields=%u\\n\",\n                    mysql_num_fields(imp_sth->result));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_num_rows=%llu\\n\",\n                    mysql_num_rows(imp_sth->result));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_affected_rows=%llu\\n\",\n                    mysql_affected_rows(imp_dbh->pmysql));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch for %p, currow= %d\\n\",\n                    sth,imp_sth->currow);\n    }\n\n    if (!(cols= mysql_fetch_row(imp_sth->result)))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      {\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch, no more rows to fetch\");\n      }\n      if (mysql_errno(imp_dbh->pmysql))\n        do_error(sth, mysql_errno(imp_dbh->pmysql),\n                 mysql_error(imp_dbh->pmysql),\n                 mysql_sqlstate(imp_dbh->pmysql));\n\n\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n      if (!mysql_more_results(svsock))\n#endif\n        dbd_st_finish(sth, imp_sth);\n      return Nullav;\n    }\n\n    num_fields= mysql_num_fields(imp_sth->result);\n    fields= mysql_fetch_fields(imp_sth->result);\n    lengths= mysql_fetch_lengths(imp_sth->result);\n\n    if ((av= DBIc_FIELDS_AV(imp_sth)) != Nullav)\n    {\n      av_length= av_len(av)+1;\n\n      if (av_length != num_fields)              /* Resize array if necessary */\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, size of results array(%d) != num_fields(%d)\\n\",\n                                   av_length, num_fields);\n\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, result fields(%d)\\n\",\n                                   DBIc_NUM_FIELDS(imp_sth));\n\n        av_readonly = SvREADONLY(av);\n\n        if (av_readonly)\n          SvREADONLY_off( av );              /* DBI sets this readonly */\n\n        while (av_length < num_fields)\n        {\n          av_store(av, av_length++, newSV(0));\n        }\n\n        while (av_length > num_fields)\n        {\n          SvREFCNT_dec(av_pop(av));\n          av_length--;\n        }\n        if (av_readonly)\n          SvREADONLY_on(av);\n      }\n    }\n\n    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);\n\n    for (i= 0;  i < num_fields; ++i)\n    {\n      char *col= cols[i];\n      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV\t*/\n\n      if (col)\n      {\n        STRLEN len= lengths[i];\n        if (ChopBlanks)\n        {\n          while (len && col[len-1] == ' ')\n          {\t--len; }\n        }\n\n        /* Set string value returned from mysql server */\n        sv_setpvn(sv, col, len);\n\n        switch (mysql_to_perl_type(fields[i].type)) {\n        case MYSQL_TYPE_DOUBLE:\n          /* Coerce to dobule and set scalar as NV */\n          (void) SvNV(sv);\n          SvNOK_only(sv);\n          break;\n\n        case MYSQL_TYPE_LONG:\n        case MYSQL_TYPE_LONGLONG:\n          /* Coerce to integer and set scalar as UV resp. IV */\n          if (fields[i].flags & UNSIGNED_FLAG)\n          {\n            (void) SvUV(sv);\n            SvIOK_only_UV(sv);\n          }\n          else\n          {\n            (void) SvIV(sv);\n            SvIOK_only(sv);\n          }\n          break;\n\n#if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION\n        case MYSQL_TYPE_BIT:\n          /* Let it as binary string */\n          break;\n#endif\n\n        default:\n\t/* UTF8 */\n        /*HELMUT*/\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\n  /* see bottom of: http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html */\n        if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && fields[i].charsetnr != 63)\n\t  sv_utf8_decode(sv);\n#endif\n\t/* END OF UTF8 */\n          break;\n        }\n      }\n      else\n        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */\n    }\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, %d cols\\n\", num_fields);\n    return av;\n\n#if MYSQL_VERSION_ID  >= SERVER_PREPARE_VERSION\n  }\n#endif\n\n}", "commit_link": "github.com/perl5-dbi/DBD-mysql/commit/3619c170461a3107a258d1fd2d00ed4832adb1b1", "file_name": "dbdimp.c", "vul_type": "cwe-416", "description": "Write a Perl function to fetch a row of data from a MySQL database using the DBI module."}
{"func_name": "kmod_module_new_from_name", "func_src_before": "KMOD_EXPORT int kmod_module_new_from_name(struct kmod_ctx *ctx,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tstruct kmod_module **mod)\n{\n\tstruct kmod_module *m;\n\tsize_t namelen;\n\tchar name_norm[NAME_MAX];\n\n\tif (ctx == NULL || name == NULL)\n\t\treturn -ENOENT;\n\n\tmodname_normalize((char *)name, name_norm, &namelen);\n\n\tm = kmod_pool_get_module(ctx, name_norm);\n\tif (m != NULL) {\n\t\t*mod = kmod_module_ref(m);\n\t\treturn 0;\n\t}\n\n\tm = calloc(1, sizeof(*m) + namelen + 1);\n\tif (m == NULL) {\n\t\tfree(m);\n\t\treturn -ENOMEM;\n\t}\n\n\tm->ctx = kmod_ref(ctx);\n\tmemcpy(m->name, name_norm, namelen + 1);\n\tm->refcount = 1;\n\n\tkmod_pool_add_module(ctx, m);\n\n\t*mod = m;\n\n\treturn 0;\n}", "func_src_after": "KMOD_EXPORT int kmod_module_new_from_name(struct kmod_ctx *ctx,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tstruct kmod_module **mod)\n{\n\tstruct kmod_module *m;\n\tsize_t namelen;\n\tchar name_norm[NAME_MAX];\n\n\tif (ctx == NULL || name == NULL)\n\t\treturn -ENOENT;\n\n\tmodname_normalize(name, name_norm, &namelen);\n\n\tm = kmod_pool_get_module(ctx, name_norm);\n\tif (m != NULL) {\n\t\t*mod = kmod_module_ref(m);\n\t\treturn 0;\n\t}\n\n\tm = calloc(1, sizeof(*m) + namelen + 1);\n\tif (m == NULL) {\n\t\tfree(m);\n\t\treturn -ENOMEM;\n\t}\n\n\tm->ctx = kmod_ref(ctx);\n\tmemcpy(m->name, name_norm, namelen + 1);\n\tm->refcount = 1;\n\n\tkmod_pool_add_module(ctx, m);\n\n\t*mod = m;\n\n\treturn 0;\n}", "line_changes": {"deleted": [{"line_no": 12, "char_start": 244, "char_end": 299, "line": "\tmodname_normalize((char *)name, name_norm, &namelen);\n"}], "added": [{"line_no": 12, "char_start": 244, "char_end": 291, "line": "\tmodname_normalize(name, name_norm, &namelen);\n"}]}, "char_changes": {"deleted": [{"char_start": 263, "char_end": 271, "chars": "(char *)"}], "added": []}, "commit_link": "github.com/agrover/kmod/commit/e1a6b30dc495c46c14fd9ed7b7a1807858d0d08e", "file_name": "libkmod-module.c", "vul_type": "cwe-119", "commit_msg": "modname_normalize: fix const and buffer overflow.\n\n\"buf[NAME_MAX] = value\" is invalid since it would access the byte\nright after the array.\n\nAlso fix the const of modname, do not mess with it to avoid mistakes.", "parent_commit": "8fc83fe1de2941e1eb0cec1b3b68fbcc14f82f02", "description": "Write a C function to create or reference a module by name in a given context."}
{"func_name": "do_setup", "func_src_before": "    def do_setup(self, ctxt):\n        \"\"\"Check that we have all configuration details from the storage.\"\"\"\n\n        LOG.debug(_('enter: do_setup'))\n        self._context = ctxt\n\n        # Validate that the pool exists\n        ssh_cmd = 'svcinfo lsmdiskgrp -delim ! -nohdr'\n        out, err = self._run_ssh(ssh_cmd)\n        self._assert_ssh_return(len(out.strip()), 'do_setup',\n                                ssh_cmd, out, err)\n        search_text = '!%s!' % self.configuration.storwize_svc_volpool_name\n        if search_text not in out:\n            raise exception.InvalidInput(\n                reason=(_('pool %s doesn\\'t exist')\n                        % self.configuration.storwize_svc_volpool_name))\n\n        # Check if compression is supported\n        self._compression_enabled = False\n        try:\n            ssh_cmd = 'svcinfo lslicense -delim !'\n            out, err = self._run_ssh(ssh_cmd)\n            license_lines = out.strip().split('\\n')\n            for license_line in license_lines:\n                name, foo, value = license_line.partition('!')\n                if name in ('license_compression_enclosures',\n                            'license_compression_capacity') and value != '0':\n                    self._compression_enabled = True\n                    break\n        except exception.ProcessExecutionError:\n            LOG.exception(_('Failed to get license information.'))\n\n        # Get the iSCSI and FC names of the Storwize/SVC nodes\n        ssh_cmd = 'svcinfo lsnode -delim !'\n        out, err = self._run_ssh(ssh_cmd)\n        self._assert_ssh_return(len(out.strip()), 'do_setup',\n                                ssh_cmd, out, err)\n\n        nodes = out.strip().split('\\n')\n        self._assert_ssh_return(len(nodes),\n                                'do_setup', ssh_cmd, out, err)\n        header = nodes.pop(0)\n        for node_line in nodes:\n            try:\n                node_data = self._get_hdr_dic(header, node_line, '!')\n            except exception.VolumeBackendAPIException:\n                with excutils.save_and_reraise_exception():\n                    self._log_cli_output_error('do_setup',\n                                               ssh_cmd, out, err)\n            node = {}\n            try:\n                node['id'] = node_data['id']\n                node['name'] = node_data['name']\n                node['IO_group'] = node_data['IO_group_id']\n                node['iscsi_name'] = node_data['iscsi_name']\n                node['WWNN'] = node_data['WWNN']\n                node['status'] = node_data['status']\n                node['WWPN'] = []\n                node['ipv4'] = []\n                node['ipv6'] = []\n                node['enabled_protocols'] = []\n                if node['status'] == 'online':\n                    self._storage_nodes[node['id']] = node\n            except KeyError:\n                self._handle_keyerror('lsnode', header)\n\n        # Get the iSCSI IP addresses and WWPNs of the Storwize/SVC nodes\n        self._get_iscsi_ip_addrs()\n        self._get_fc_wwpns()\n\n        # For each node, check what connection modes it supports.  Delete any\n        # nodes that do not support any types (may be partially configured).\n        to_delete = []\n        for k, node in self._storage_nodes.iteritems():\n            if ((len(node['ipv4']) or len(node['ipv6']))\n                    and len(node['iscsi_name'])):\n                node['enabled_protocols'].append('iSCSI')\n                self._enabled_protocols.add('iSCSI')\n            if len(node['WWPN']):\n                node['enabled_protocols'].append('FC')\n                self._enabled_protocols.add('FC')\n            if not len(node['enabled_protocols']):\n                to_delete.append(k)\n\n        for delkey in to_delete:\n            del self._storage_nodes[delkey]\n\n        # Make sure we have at least one node configured\n        self._driver_assert(len(self._storage_nodes),\n                            _('do_setup: No configured nodes'))\n\n        LOG.debug(_('leave: do_setup'))", "func_src_after": "    def do_setup(self, ctxt):\n        \"\"\"Check that we have all configuration details from the storage.\"\"\"\n\n        LOG.debug(_('enter: do_setup'))\n        self._context = ctxt\n\n        # Validate that the pool exists\n        ssh_cmd = ['svcinfo', 'lsmdiskgrp', '-delim', '!', '-nohdr']\n        out, err = self._run_ssh(ssh_cmd)\n        self._assert_ssh_return(len(out.strip()), 'do_setup',\n                                ssh_cmd, out, err)\n        search_text = '!%s!' % self.configuration.storwize_svc_volpool_name\n        if search_text not in out:\n            raise exception.InvalidInput(\n                reason=(_('pool %s doesn\\'t exist')\n                        % self.configuration.storwize_svc_volpool_name))\n\n        # Check if compression is supported\n        self._compression_enabled = False\n        try:\n            ssh_cmd = ['svcinfo', 'lslicense', '-delim', '!']\n            out, err = self._run_ssh(ssh_cmd)\n            license_lines = out.strip().split('\\n')\n            for license_line in license_lines:\n                name, foo, value = license_line.partition('!')\n                if name in ('license_compression_enclosures',\n                            'license_compression_capacity') and value != '0':\n                    self._compression_enabled = True\n                    break\n        except exception.ProcessExecutionError:\n            LOG.exception(_('Failed to get license information.'))\n\n        # Get the iSCSI and FC names of the Storwize/SVC nodes\n        ssh_cmd = ['svcinfo', 'lsnode', '-delim', '!']\n        out, err = self._run_ssh(ssh_cmd)\n        self._assert_ssh_return(len(out.strip()), 'do_setup',\n                                ssh_cmd, out, err)\n\n        nodes = out.strip().split('\\n')\n        self._assert_ssh_return(len(nodes),\n                                'do_setup', ssh_cmd, out, err)\n        header = nodes.pop(0)\n        for node_line in nodes:\n            try:\n                node_data = self._get_hdr_dic(header, node_line, '!')\n            except exception.VolumeBackendAPIException:\n                with excutils.save_and_reraise_exception():\n                    self._log_cli_output_error('do_setup',\n                                               ssh_cmd, out, err)\n            node = {}\n            try:\n                node['id'] = node_data['id']\n                node['name'] = node_data['name']\n                node['IO_group'] = node_data['IO_group_id']\n                node['iscsi_name'] = node_data['iscsi_name']\n                node['WWNN'] = node_data['WWNN']\n                node['status'] = node_data['status']\n                node['WWPN'] = []\n                node['ipv4'] = []\n                node['ipv6'] = []\n                node['enabled_protocols'] = []\n                if node['status'] == 'online':\n                    self._storage_nodes[node['id']] = node\n            except KeyError:\n                self._handle_keyerror('lsnode', header)\n\n        # Get the iSCSI IP addresses and WWPNs of the Storwize/SVC nodes\n        self._get_iscsi_ip_addrs()\n        self._get_fc_wwpns()\n\n        # For each node, check what connection modes it supports.  Delete any\n        # nodes that do not support any types (may be partially configured).\n        to_delete = []\n        for k, node in self._storage_nodes.iteritems():\n            if ((len(node['ipv4']) or len(node['ipv6']))\n                    and len(node['iscsi_name'])):\n                node['enabled_protocols'].append('iSCSI')\n                self._enabled_protocols.add('iSCSI')\n            if len(node['WWPN']):\n                node['enabled_protocols'].append('FC')\n                self._enabled_protocols.add('FC')\n            if not len(node['enabled_protocols']):\n                to_delete.append(k)\n\n        for delkey in to_delete:\n            del self._storage_nodes[delkey]\n\n        # Make sure we have at least one node configured\n        self._driver_assert(len(self._storage_nodes),\n                            _('do_setup: No configured nodes'))\n\n        LOG.debug(_('leave: do_setup'))", "commit_link": "github.com/thatsdone/cinder/commit/f752302d181583a95cf44354aea607ce9d9283f4", "file_name": "cinder/volume/drivers/storwize_svc.py", "vul_type": "cwe-078", "description": "Write a Python function named `do_setup` that initializes storage configuration and checks for pool existence, compression support, and node details."}
{"func_name": "SyncExifProfile", "func_src_before": "MagickBooleanType SyncExifProfile(Image *image,StringInfo *profile)\n{\n#define MaxDirectoryStack  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_INTEROP_OFFSET  0xa005\n\n  typedef struct _DirectoryInfo\n  {\n    unsigned char\n      *directory;\n\n    size_t\n      entry;\n  } DirectoryInfo;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n    endian;\n\n  size_t\n    entry,\n    length,\n    number_entries;\n\n  ssize_t\n    id,\n    level,\n    offset;\n\n  static int\n    format_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};\n\n  unsigned char\n    *directory,\n    *exif;\n\n  /*\n    Set EXIF resolution tag.\n  */\n  length=GetStringInfoLength(profile);\n  exif=GetStringInfoDatum(profile);\n  if (length < 16)\n    return(MagickFalse);\n  id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n  if ((id != 0x4949) && (id != 0x4D4D))\n    {\n      while (length != 0)\n      {\n        if (ReadProfileByte(&exif,&length) != 0x45)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x78)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x69)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x66)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        break;\n      }\n      if (length < 16)\n        return(MagickFalse);\n      id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n    }\n  endian=LSBEndian;\n  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n      endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadProfileShort(endian,exif+2) != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first IFD.\n  */\n  offset=(ssize_t) ReadProfileLong(endian,exif+4);\n  if ((offset < 0) || (size_t) offset >= length)\n    return(MagickFalse);\n  directory=exif+offset;\n  level=0;\n  entry=0;\n  do\n  {\n    if (level > 0)\n      {\n        level--;\n        directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n      }\n    if ((directory < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine how many entries there are in the current IFD.\n    */\n    number_entries=ReadProfileShort(endian,directory);\n    for ( ; entry < number_entries; entry++)\n    {\n      int\n        components;\n\n      register unsigned char\n        *p,\n        *q;\n\n      size_t\n        number_bytes;\n\n      ssize_t\n        format,\n        tag_value;\n\n      q=(unsigned char *) (directory+2+(12*entry));\n      if (q > (exif+length-12))\n        break;  /* corrupt EXIF */\n      tag_value=(ssize_t) ReadProfileShort(endian,q);\n      format=(ssize_t) ReadProfileShort(endian,q+2);\n      if ((format-1) >= EXIF_NUM_FORMATS)\n        break;\n      components=(ssize_t) ReadProfileLong(endian,q+4);\n      if (components < 0)\n        break;  /* corrupt EXIF */\n      number_bytes=(size_t) components*format_bytes[format];\n      if ((ssize_t) number_bytes < components)\n        break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n      else\n        {\n          /*\n            The directory entry contains an offset.\n          */\n          offset=(ssize_t)  ReadProfileLong(endian,q+8);\n          if ((size_t) (offset+number_bytes) > length)\n            continue;\n          if (~length < number_bytes)\n            continue;  /* prevent overflow */\n          p=(unsigned char *) (exif+offset);\n        }\n      switch (tag_value)\n      {\n        case 0x011a:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->resolution.x+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x011b:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->resolution.y+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x0112:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) image->orientation,p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) image->orientation,\n            p);\n          break;\n        }\n        case 0x0128:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) (image->units+1),p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) (image->units+1),p);\n          break;\n        }\n        default:\n          break;\n      }\n      if ((tag_value == TAG_EXIF_OFFSET) || (tag_value == TAG_INTEROP_OFFSET))\n        {\n          offset=(ssize_t)  ReadProfileLong(endian,p);\n          if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n            {\n              directory_stack[level].directory=directory;\n              entry++;\n              directory_stack[level].entry=entry;\n              level++;\n              directory_stack[level].directory=exif+offset;\n              directory_stack[level].entry=0;\n              level++;\n              if ((directory+2+(12*number_entries)) > (exif+length))\n                break;\n              offset=(ssize_t)  ReadProfileLong(endian,directory+2+(12*\n                number_entries));\n              if ((offset != 0) && ((size_t) offset < length) &&\n                  (level < (MaxDirectoryStack-2)))\n                {\n                  directory_stack[level].directory=exif+offset;\n                  directory_stack[level].entry=0;\n                  level++;\n                }\n            }\n          break;\n        }\n    }\n  } while (level > 0);\n  return(MagickTrue);\n}", "func_src_after": "MagickBooleanType SyncExifProfile(Image *image,StringInfo *profile)\n{\n#define MaxDirectoryStack  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_INTEROP_OFFSET  0xa005\n\n  typedef struct _DirectoryInfo\n  {\n    unsigned char\n      *directory;\n\n    size_t\n      entry;\n  } DirectoryInfo;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n    endian;\n\n  size_t\n    entry,\n    length,\n    number_entries;\n\n  ssize_t\n    id,\n    level,\n    offset;\n\n  static int\n    format_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};\n\n  unsigned char\n    *directory,\n    *exif;\n\n  /*\n    Set EXIF resolution tag.\n  */\n  length=GetStringInfoLength(profile);\n  exif=GetStringInfoDatum(profile);\n  if (length < 16)\n    return(MagickFalse);\n  id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n  if ((id != 0x4949) && (id != 0x4D4D))\n    {\n      while (length != 0)\n      {\n        if (ReadProfileByte(&exif,&length) != 0x45)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x78)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x69)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x66)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        break;\n      }\n      if (length < 16)\n        return(MagickFalse);\n      id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n    }\n  endian=LSBEndian;\n  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n      endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadProfileShort(endian,exif+2) != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first IFD.\n  */\n  offset=(ssize_t) ReadProfileLong(endian,exif+4);\n  if ((offset < 0) || (size_t) offset >= length)\n    return(MagickFalse);\n  directory=exif+offset;\n  level=0;\n  entry=0;\n  do\n  {\n    if (level > 0)\n      {\n        level--;\n        directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n      }\n    if ((directory < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine how many entries there are in the current IFD.\n    */\n    number_entries=ReadProfileShort(endian,directory);\n    for ( ; entry < number_entries; entry++)\n    {\n      int\n        components;\n\n      register unsigned char\n        *p,\n        *q;\n\n      size_t\n        number_bytes;\n\n      ssize_t\n        format,\n        tag_value;\n\n      q=(unsigned char *) (directory+2+(12*entry));\n      if (q > (exif+length-12))\n        break;  /* corrupt EXIF */\n      tag_value=(ssize_t) ReadProfileShort(endian,q);\n      format=(ssize_t) ReadProfileShort(endian,q+2);\n      if ((format < 0) || ((format-1) >= EXIF_NUM_FORMATS))\n        break;\n      components=(ssize_t) ReadProfileLong(endian,q+4);\n      if (components < 0)\n        break;  /* corrupt EXIF */\n      number_bytes=(size_t) components*format_bytes[format];\n      if ((ssize_t) number_bytes < components)\n        break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n      else\n        {\n          /*\n            The directory entry contains an offset.\n          */\n          offset=(ssize_t)  ReadProfileLong(endian,q+8);\n          if ((size_t) (offset+number_bytes) > length)\n            continue;\n          if (~length < number_bytes)\n            continue;  /* prevent overflow */\n          p=(unsigned char *) (exif+offset);\n        }\n      switch (tag_value)\n      {\n        case 0x011a:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->resolution.x+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x011b:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->resolution.y+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x0112:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) image->orientation,p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) image->orientation,\n            p);\n          break;\n        }\n        case 0x0128:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) (image->units+1),p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) (image->units+1),p);\n          break;\n        }\n        default:\n          break;\n      }\n      if ((tag_value == TAG_EXIF_OFFSET) || (tag_value == TAG_INTEROP_OFFSET))\n        {\n          offset=(ssize_t)  ReadProfileLong(endian,p);\n          if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n            {\n              directory_stack[level].directory=directory;\n              entry++;\n              directory_stack[level].entry=entry;\n              level++;\n              directory_stack[level].directory=exif+offset;\n              directory_stack[level].entry=0;\n              level++;\n              if ((directory+2+(12*number_entries)) > (exif+length))\n                break;\n              offset=(ssize_t)  ReadProfileLong(endian,directory+2+(12*\n                number_entries));\n              if ((offset != 0) && ((size_t) offset < length) &&\n                  (level < (MaxDirectoryStack-2)))\n                {\n                  directory_stack[level].directory=exif+offset;\n                  directory_stack[level].entry=0;\n                  level++;\n                }\n            }\n          break;\n        }\n    }\n  } while (level > 0);\n  return(MagickTrue);\n}", "commit_link": "github.com/ImageMagick/ImageMagick/commit/a7bb158b7bedd1449a34432feb3a67c8f1873bfa", "file_name": "MagickCore/profile.c", "vul_type": "cwe-125", "description": "Write a C function to synchronize EXIF profile resolution tags with an image's resolution and orientation."}
{"func_name": "ReadPSDImage", "func_src_before": "static Image *ReadPSDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    has_merged_image,\n    skip_layers;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    length;\n\n  MagickBooleanType\n    status;\n\n  PSDInfo\n    psd_info;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *data;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read image header.\n  */\n  image->endian=MSBEndian;\n  count=ReadBlob(image,4,(unsigned char *) psd_info.signature);\n  psd_info.version=ReadBlobMSBShort(image);\n  if ((count == 0) || (LocaleNCompare(psd_info.signature,\"8BPS\",4) != 0) ||\n      ((psd_info.version != 1) && (psd_info.version != 2)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) ReadBlob(image,6,psd_info.reserved);\n  psd_info.channels=ReadBlobMSBShort(image);\n  if (psd_info.channels > MaxPSDChannels)\n    ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n  psd_info.rows=ReadBlobMSBLong(image);\n  psd_info.columns=ReadBlobMSBLong(image);\n  if ((psd_info.version == 1) && ((psd_info.rows > 30000) ||\n      (psd_info.columns > 30000)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  psd_info.depth=ReadBlobMSBShort(image);\n  if ((psd_info.depth != 1) && (psd_info.depth != 8) && (psd_info.depth != 16))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  psd_info.mode=ReadBlobMSBShort(image);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Image is %.20g x %.20g with channels=%.20g, depth=%.20g, mode=%s\",\n      (double) psd_info.columns,(double) psd_info.rows,(double)\n      psd_info.channels,(double) psd_info.depth,ModeToString((PSDImageType)\n      psd_info.mode));\n  /*\n    Initialize image.\n  */\n  image->depth=psd_info.depth;\n  image->columns=psd_info.columns;\n  image->rows=psd_info.rows;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  if (SetImageBackgroundColor(image,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (psd_info.mode == LabMode)\n    SetImageColorspace(image,LabColorspace,exception);\n  if (psd_info.mode == CMYKMode)\n    {\n      SetImageColorspace(image,CMYKColorspace,exception);\n      image->alpha_trait=psd_info.channels > 4 ? BlendPixelTrait :\n        UndefinedPixelTrait;\n    }\n  else if ((psd_info.mode == BitmapMode) || (psd_info.mode == GrayscaleMode) ||\n      (psd_info.mode == DuotoneMode))\n    {\n      status=AcquireImageColormap(image,psd_info.depth != 16 ? 256 : 65536,\n        exception);\n      if (status == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Image colormap allocated\");\n      SetImageColorspace(image,GRAYColorspace,exception);\n      image->alpha_trait=psd_info.channels > 1 ? BlendPixelTrait :\n        UndefinedPixelTrait;\n    }\n  else\n    image->alpha_trait=psd_info.channels > 3 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n  /*\n    Read PSD raster colormap only present for indexed and duotone images.\n  */\n  length=ReadBlobMSBLong(image);\n  if (length != 0)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  reading colormap\");\n      if (psd_info.mode == DuotoneMode)\n        {\n          /*\n            Duotone image data;  the format of this data is undocumented.\n          */\n          data=(unsigned char *) AcquireQuantumMemory((size_t) length,\n            sizeof(*data));\n          if (data == (unsigned char *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          (void) ReadBlob(image,(size_t) length,data);\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        }\n      else\n        {\n          size_t\n            number_colors;\n\n          /*\n            Read PSD raster colormap.\n          */\n          number_colors=length/3;\n          if (number_colors > 65536)\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          if (AcquireImageColormap(image,number_colors,exception) == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].red=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].blue=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n          image->alpha_trait=UndefinedPixelTrait;\n        }\n    }\n  has_merged_image=MagickTrue;\n  length=ReadBlobMSBLong(image);\n  if (length != 0)\n    {\n      unsigned char\n        *blocks;\n\n      /*\n        Image resources block.\n      */\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  reading image resource blocks - %.20g bytes\",(double)\n          ((MagickOffsetType) length));\n      blocks=(unsigned char *) AcquireQuantumMemory((size_t) length,\n        sizeof(*blocks));\n      if (blocks == (unsigned char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      count=ReadBlob(image,(size_t) length,blocks);\n      if ((count != (ssize_t) length) ||\n          (LocaleNCompare((char *) blocks,\"8BIM\",4) != 0))\n        {\n          blocks=(unsigned char *) RelinquishMagickMemory(blocks);\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n      ParseImageResourceBlocks(image,blocks,(size_t) length,&has_merged_image,\n        exception);\n      blocks=(unsigned char *) RelinquishMagickMemory(blocks);\n    }\n  /*\n    Layer and mask block.\n  */\n  length=GetPSDSize(&psd_info,image);\n  if (length == 8)\n    {\n      length=ReadBlobMSBLong(image);\n      length=ReadBlobMSBLong(image);\n    }\n  offset=TellBlob(image);\n  skip_layers=MagickFalse;\n  if ((image_info->number_scenes == 1) && (image_info->scene == 0) &&\n      (has_merged_image != MagickFalse))\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  read composite only\");\n      skip_layers=MagickTrue;\n    }\n  if (length == 0)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  image has no layers\");\n    }\n  else\n    {\n      if (ReadPSDLayers(image,image_info,&psd_info,skip_layers,exception) !=\n          MagickTrue)\n        {\n          (void) CloseBlob(image);\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n\n      /*\n         Skip the rest of the layer and mask information.\n      */\n      SeekBlob(image,offset+length,SEEK_SET);\n    }\n  /*\n    If we are only \"pinging\" the image, then we're done - so return.\n  */\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  /*\n    Read the precombined layer, present for PSD < 4 compatibility.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  reading the precombined layer\");\n  if ((has_merged_image != MagickFalse) || (GetImageListLength(image) == 1))\n    has_merged_image=(MagickBooleanType) ReadPSDMergedImage(image_info,image,\n      &psd_info,exception);\n  if ((has_merged_image == MagickFalse) && (GetImageListLength(image) == 1) &&\n      (length != 0))\n    {\n      SeekBlob(image,offset,SEEK_SET);\n      status=ReadPSDLayers(image,image_info,&psd_info,MagickFalse,exception);\n      if (status != MagickTrue)\n        {\n          (void) CloseBlob(image);\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n    }\n  if ((has_merged_image == MagickFalse) && (GetImageListLength(image) > 1))\n    {\n      Image\n        *merged;\n\n      SetImageAlphaChannel(image,TransparentAlphaChannel,exception);\n      image->background_color.alpha=TransparentAlpha;\n      image->background_color.alpha_trait=BlendPixelTrait;\n      merged=MergeImageLayers(image,FlattenLayer,exception);\n      ReplaceImageInList(&image,merged);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "func_src_after": "static Image *ReadPSDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    has_merged_image,\n    skip_layers;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    length;\n\n  MagickBooleanType\n    status;\n\n  PSDInfo\n    psd_info;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *data;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read image header.\n  */\n  image->endian=MSBEndian;\n  count=ReadBlob(image,4,(unsigned char *) psd_info.signature);\n  psd_info.version=ReadBlobMSBShort(image);\n  if ((count == 0) || (LocaleNCompare(psd_info.signature,\"8BPS\",4) != 0) ||\n      ((psd_info.version != 1) && (psd_info.version != 2)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) ReadBlob(image,6,psd_info.reserved);\n  psd_info.channels=ReadBlobMSBShort(image);\n  if (psd_info.channels > MaxPSDChannels)\n    ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n  psd_info.rows=ReadBlobMSBLong(image);\n  psd_info.columns=ReadBlobMSBLong(image);\n  if ((psd_info.version == 1) && ((psd_info.rows > 30000) ||\n      (psd_info.columns > 30000)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  psd_info.depth=ReadBlobMSBShort(image);\n  if ((psd_info.depth != 1) && (psd_info.depth != 8) && (psd_info.depth != 16))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  psd_info.mode=ReadBlobMSBShort(image);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Image is %.20g x %.20g with channels=%.20g, depth=%.20g, mode=%s\",\n      (double) psd_info.columns,(double) psd_info.rows,(double)\n      psd_info.channels,(double) psd_info.depth,ModeToString((PSDImageType)\n      psd_info.mode));\n  /*\n    Initialize image.\n  */\n  image->depth=psd_info.depth;\n  image->columns=psd_info.columns;\n  image->rows=psd_info.rows;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  if (SetImageBackgroundColor(image,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (psd_info.mode == LabMode)\n    SetImageColorspace(image,LabColorspace,exception);\n  if (psd_info.mode == CMYKMode)\n    {\n      SetImageColorspace(image,CMYKColorspace,exception);\n      image->alpha_trait=psd_info.channels > 4 ? BlendPixelTrait :\n        UndefinedPixelTrait;\n    }\n  else if ((psd_info.mode == BitmapMode) || (psd_info.mode == GrayscaleMode) ||\n      (psd_info.mode == DuotoneMode))\n    {\n      status=AcquireImageColormap(image,psd_info.depth != 16 ? 256 : 65536,\n        exception);\n      if (status == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Image colormap allocated\");\n      SetImageColorspace(image,GRAYColorspace,exception);\n      image->alpha_trait=psd_info.channels > 1 ? BlendPixelTrait :\n        UndefinedPixelTrait;\n    }\n  else\n    image->alpha_trait=psd_info.channels > 3 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n  /*\n    Read PSD raster colormap only present for indexed and duotone images.\n  */\n  length=ReadBlobMSBLong(image);\n  if (length != 0)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  reading colormap\");\n      if (psd_info.mode == DuotoneMode)\n        {\n          /*\n            Duotone image data;  the format of this data is undocumented.\n          */\n          data=(unsigned char *) AcquireQuantumMemory((size_t) length,\n            sizeof(*data));\n          if (data == (unsigned char *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          (void) ReadBlob(image,(size_t) length,data);\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        }\n      else\n        {\n          size_t\n            number_colors;\n\n          /*\n            Read PSD raster colormap.\n          */\n          number_colors=length/3;\n          if (number_colors > 65536)\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          if (AcquireImageColormap(image,number_colors,exception) == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].red=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].blue=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n          image->alpha_trait=UndefinedPixelTrait;\n        }\n    }\n  if ((image->depth == 1) && (image->storage_class != PseudoClass))\n    ThrowReaderException(CorruptImageError, \"ImproperImageHeader\");\n  has_merged_image=MagickTrue;\n  length=ReadBlobMSBLong(image);\n  if (length != 0)\n    {\n      unsigned char\n        *blocks;\n\n      /*\n        Image resources block.\n      */\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  reading image resource blocks - %.20g bytes\",(double)\n          ((MagickOffsetType) length));\n      blocks=(unsigned char *) AcquireQuantumMemory((size_t) length,\n        sizeof(*blocks));\n      if (blocks == (unsigned char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      count=ReadBlob(image,(size_t) length,blocks);\n      if ((count != (ssize_t) length) ||\n          (LocaleNCompare((char *) blocks,\"8BIM\",4) != 0))\n        {\n          blocks=(unsigned char *) RelinquishMagickMemory(blocks);\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n      ParseImageResourceBlocks(image,blocks,(size_t) length,&has_merged_image,\n        exception);\n      blocks=(unsigned char *) RelinquishMagickMemory(blocks);\n    }\n  /*\n    Layer and mask block.\n  */\n  length=GetPSDSize(&psd_info,image);\n  if (length == 8)\n    {\n      length=ReadBlobMSBLong(image);\n      length=ReadBlobMSBLong(image);\n    }\n  offset=TellBlob(image);\n  skip_layers=MagickFalse;\n  if ((image_info->number_scenes == 1) && (image_info->scene == 0) &&\n      (has_merged_image != MagickFalse))\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  read composite only\");\n      skip_layers=MagickTrue;\n    }\n  if (length == 0)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  image has no layers\");\n    }\n  else\n    {\n      if (ReadPSDLayers(image,image_info,&psd_info,skip_layers,exception) !=\n          MagickTrue)\n        {\n          (void) CloseBlob(image);\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n\n      /*\n         Skip the rest of the layer and mask information.\n      */\n      SeekBlob(image,offset+length,SEEK_SET);\n    }\n  /*\n    If we are only \"pinging\" the image, then we're done - so return.\n  */\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  /*\n    Read the precombined layer, present for PSD < 4 compatibility.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  reading the precombined layer\");\n  if ((has_merged_image != MagickFalse) || (GetImageListLength(image) == 1))\n    has_merged_image=(MagickBooleanType) ReadPSDMergedImage(image_info,image,\n      &psd_info,exception);\n  if ((has_merged_image == MagickFalse) && (GetImageListLength(image) == 1) &&\n      (length != 0))\n    {\n      SeekBlob(image,offset,SEEK_SET);\n      status=ReadPSDLayers(image,image_info,&psd_info,MagickFalse,exception);\n      if (status != MagickTrue)\n        {\n          (void) CloseBlob(image);\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n    }\n  if ((has_merged_image == MagickFalse) && (GetImageListLength(image) > 1))\n    {\n      Image\n        *merged;\n\n      SetImageAlphaChannel(image,TransparentAlphaChannel,exception);\n      image->background_color.alpha=TransparentAlpha;\n      image->background_color.alpha_trait=BlendPixelTrait;\n      merged=MergeImageLayers(image,FlattenLayer,exception);\n      ReplaceImageInList(&image,merged);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "commit_link": "github.com/ImageMagick/ImageMagick/commit/198fffab4daf8aea88badd9c629350e5b26ec32f", "file_name": "coders/psd.c", "vul_type": "cwe-125", "description": "Write a C function to read and process a PSD image file."}
{"func_name": "execute", "func_src_before": "func (v *VM) execute(t *thread, i code.Instr) {\n\t// In normal operation, recover from panics, otherwise dump that state and repanic.\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tif v.HardCrash {\n\t\t\t\tfmt.Printf(\"panic in thread %#v at instr %q: %s\\n\", t, i, r)\n\t\t\t\tpanic(r)\n\t\t\t}\n\t\t\tv.errorf(\"panic in thread %#v at instr %q: %s\", t, i, r)\n\t\t\tv.terminate = true\n\t\t}\n\t}()\n\n\tswitch i.Opcode {\n\tcase code.Bad:\n\t\tpanic(\"Invalid instruction.  Aborting.\")\n\n\tcase code.Stop:\n\t\tv.terminate = true\n\n\tcase code.Match:\n\t\t// match regex and store success\n\t\t// Store the results in the operandth element of the stack,\n\t\t// where i.opnd == the matched re index\n\t\tindex := i.Operand.(int)\n\t\tt.matches[index] = v.re[index].FindStringSubmatch(v.input.Line)\n\t\tt.Push(t.matches[index] != nil)\n\n\tcase code.Smatch:\n\t\t// match regex against item on the stack\n\t\tindex := i.Operand.(int)\n\t\tline, err := t.PopString()\n\t\tif err != nil {\n\t\t\tv.errorf(\"+%v\", err)\n\t\t\treturn\n\t\t}\n\t\tt.matches[index] = v.re[index].FindStringSubmatch(line)\n\t\tt.Push(t.matches[index] != nil)\n\n\tcase code.Cmp:\n\t\t// Compare two elements on the stack.\n\t\t// Set the match register based on the truthiness of the comparison.\n\t\t// Operand contains the expected result.\n\t\tb := t.Pop()\n\t\ta := t.Pop()\n\n\t\tmatch, err := compare(a, b, i.Operand.(int))\n\t\tif err != nil {\n\t\t\tv.errorf(\"%+v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tt.Push(match)\n\n\tcase code.Icmp:\n\t\tb, berr := t.PopInt()\n\t\tif berr != nil {\n\t\t\tv.errorf(\"%+v\", berr)\n\t\t\treturn\n\t\t}\n\t\ta, aerr := t.PopInt()\n\t\tif aerr != nil {\n\t\t\tv.errorf(\"%+v\", aerr)\n\t\t\treturn\n\t\t}\n\t\tmatch, err := compareInt(a, b, i.Operand.(int))\n\t\tif err != nil {\n\t\t\tv.errorf(\"%+v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tt.Push(match)\n\tcase code.Fcmp:\n\t\tb, berr := t.PopFloat()\n\t\tif berr != nil {\n\t\t\tv.errorf(\"%+v\", berr)\n\t\t\treturn\n\t\t}\n\t\ta, aerr := t.PopFloat()\n\t\tif aerr != nil {\n\t\t\tv.errorf(\"%+v\", aerr)\n\t\t}\n\t\tmatch, err := compareFloat(a, b, i.Operand.(int))\n\t\tif err != nil {\n\t\t\tv.errorf(\"%+v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tt.Push(match)\n\tcase code.Scmp:\n\t\tb, berr := t.PopString()\n\t\tif berr != nil {\n\t\t\tv.errorf(\"%+v\", berr)\n\t\t\treturn\n\t\t}\n\t\ta, aerr := t.PopString()\n\t\tif aerr != nil {\n\t\t\tv.errorf(\"%+v\", aerr)\n\t\t\treturn\n\t\t}\n\t\tmatch, err := compareString(a, b, i.Operand.(int))\n\t\tif err != nil {\n\t\t\tv.errorf(\"%+v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tt.Push(match)\n\n\tcase code.Jnm:\n\t\tval := t.Pop()\n\t\tswitch match := val.(type) {\n\t\tcase bool:\n\t\t\tif !match {\n\t\t\t\tt.pc = i.Operand.(int)\n\t\t\t}\n\t\tcase int64:\n\t\t\tif match == 0 {\n\t\t\t\tt.pc = i.Operand.(int)\n\t\t\t}\n\t\t}\n\n\tcase code.Jm:\n\t\tval := t.Pop()\n\t\tswitch match := val.(type) {\n\t\tcase bool:\n\t\t\tif match {\n\t\t\t\tt.pc = i.Operand.(int)\n\t\t\t}\n\t\tcase int64:\n\t\t\tif match != 0 {\n\t\t\t\tt.pc = i.Operand.(int)\n\t\t\t}\n\t\t}\n\n\tcase code.Jmp:\n\t\tt.pc = i.Operand.(int)\n\n\tcase code.Inc:\n\t\t// Increment a datum\n\t\tvar delta int64 = 1\n\t\t// If opnd is non-nil, the delta is on the stack.\n\t\tif i.Operand != nil {\n\t\t\tvar err error\n\t\t\tdelta, err = t.PopInt()\n\t\t\tif err != nil {\n\t\t\t\tv.errorf(\"%s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tif n, ok := t.Pop().(datum.Datum); ok {\n\t\t\tdatum.IncIntBy(n, delta, t.time)\n\t\t\tt.Push(datum.GetInt(n))\n\t\t} else {\n\t\t\tv.errorf(\"Unexpected type to increment: %T %q\", n, n)\n\t\t\treturn\n\t\t}\n\n\tcase code.Dec:\n\t\t// Decrement a datum\n\t\tvar delta int64 = 1\n\t\t// If opnd is non-nil, the delta is on the stack.\n\t\tif i.Operand != nil {\n\t\t\tvar err error\n\t\t\tdelta, err = t.PopInt()\n\t\t\tif err != nil {\n\t\t\t\tv.errorf(\"%s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tif n, ok := t.Pop().(datum.Datum); ok {\n\t\t\tdatum.DecIntBy(n, delta, t.time)\n\t\t\tt.Push(datum.GetInt(n))\n\t\t} else {\n\t\t\tv.errorf(\"Unexpected type to increment: %T %q\", n, n)\n\t\t\treturn\n\t\t}\n\n\tcase code.Iset:\n\t\t// Set a datum\n\t\tvalue, err := t.PopInt()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\t\tif n, ok := t.Pop().(datum.Datum); ok {\n\t\t\tdatum.SetInt(n, value, t.time)\n\t\t} else {\n\t\t\tv.errorf(\"Unexpected type to iset: %T %q\", n, n)\n\t\t\treturn\n\t\t}\n\n\tcase code.Fset:\n\t\t// Set a datum\n\t\tvalue, err := t.PopFloat()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\t\tif n, ok := t.Pop().(datum.Datum); ok {\n\t\t\tdatum.SetFloat(n, value, t.time)\n\t\t} else {\n\t\t\tv.errorf(\"Unexpected type to fset: %T %q\", n, n)\n\t\t\treturn\n\t\t}\n\n\tcase code.Sset:\n\t\t// Set a string datum\n\t\tvalue, err := t.PopString()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%+v\", err)\n\t\t\treturn\n\t\t}\n\t\tif n, ok := t.Pop().(datum.Datum); ok {\n\t\t\tdatum.SetString(n, value, t.time)\n\t\t} else {\n\t\t\tv.errorf(\"Unexpected type to sset: %T %q\", n, n)\n\t\t\treturn\n\t\t}\n\n\tcase code.Strptime:\n\t\t// Parse a time string into the time register\n\t\tlayout, err := t.PopString()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%+v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tvar ts string\n\t\tswitch s := t.Pop().(type) {\n\t\tcase string:\n\t\t\tts = s\n\n\t\tcase int: /* capref */\n\t\t\t// First find the match storage index on the stack\n\t\t\tre := t.Pop().(int)\n\t\t\t// Store the result from the re'th index at the s'th index\n\t\t\tts = t.matches[re][s]\n\t\t}\n\t\tif cached, ok := v.timeMemos.Get(ts); !ok {\n\t\t\ttm := v.ParseTime(layout, ts)\n\t\t\tv.timeMemos.Add(ts, tm)\n\t\t\tt.time = tm\n\t\t} else {\n\t\t\tt.time = cached.(time.Time)\n\t\t}\n\n\tcase code.Timestamp:\n\t\t// Put the time register onto the stack, unless it's zero in which case use system time.\n\t\tif t.time.IsZero() {\n\t\t\tt.Push(time.Now().Unix())\n\t\t} else {\n\t\t\t// Put the time register onto the stack\n\t\t\tt.Push(t.time.Unix())\n\t\t}\n\n\tcase code.Settime:\n\t\t// Pop TOS and store in time register\n\t\tval := t.Pop()\n\t\tts, ok := val.(int64)\n\t\tif !ok {\n\t\t\tv.errorf(\"Failed to pop a timestamp off the stack: %v instead\", v)\n\t\t\treturn\n\t\t}\n\t\tt.time = time.Unix(ts, 0).UTC()\n\n\tcase code.Capref:\n\t\t// Put a capture group reference onto the stack.\n\t\t// First find the match storage index on the stack,\n\t\tval := t.Pop()\n\t\tre, ok := val.(int)\n\t\tif !ok {\n\t\t\tv.errorf(\"Invalid re index %v, not an int\", val)\n\t\t\treturn\n\t\t}\n\t\t// Push the result from the re'th match at operandth index\n\t\top, ok := i.Operand.(int)\n\t\tif !ok {\n\t\t\tv.errorf(\"Invalid operand %v, not an int\", i.Operand)\n\t\t\treturn\n\t\t}\n\t\tif len(t.matches[re]) <= op {\n\t\t\tv.errorf(\"Not enough capture groups matched from %v to select %dth\", t.matches[re], op)\n\t\t\treturn\n\t\t}\n\t\tt.Push(t.matches[re][op])\n\n\tcase code.Str:\n\t\t// Put a string constant onto the stack\n\t\tt.Push(v.str[i.Operand.(int)])\n\n\tcase code.Push:\n\t\t// Push a value onto the stack\n\t\tt.Push(i.Operand)\n\n\tcase code.Fadd, code.Fsub, code.Fmul, code.Fdiv, code.Fmod, code.Fpow:\n\t\tb, err := t.PopFloat()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\t\ta, err := t.PopFloat()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\t\tswitch i.Opcode {\n\t\tcase code.Fadd:\n\t\t\tt.Push(a + b)\n\t\tcase code.Fsub:\n\t\t\tt.Push(a - b)\n\t\tcase code.Fmul:\n\t\t\tt.Push(a * b)\n\t\tcase code.Fdiv:\n\t\t\tt.Push(a / b)\n\t\tcase code.Fmod:\n\t\t\tt.Push(math.Mod(a, b))\n\t\tcase code.Fpow:\n\t\t\tt.Push(math.Pow(a, b))\n\t\t}\n\n\tcase code.Iadd, code.Isub, code.Imul, code.Idiv, code.Imod, code.Ipow, code.Shl, code.Shr, code.And, code.Or, code.Xor:\n\t\t// Op two values at TOS, and push result onto stack\n\t\tb, err := t.PopInt()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\t\ta, err := t.PopInt()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\t\tswitch i.Opcode {\n\t\tcase code.Iadd:\n\t\t\tt.Push(a + b)\n\t\tcase code.Isub:\n\t\t\tt.Push(a - b)\n\t\tcase code.Imul:\n\t\t\tt.Push(a * b)\n\t\tcase code.Idiv:\n\t\t\tif b == 0 {\n\t\t\t\tv.errorf(\"Divide by zero %d %% %d\", a, b)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Integer division\n\t\t\tt.Push(a / b)\n\t\tcase code.Imod:\n\t\t\tif b == 0 {\n\t\t\t\tv.errorf(\"Divide by zero %d %% %d\", a, b)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tt.Push(a % b)\n\t\tcase code.Ipow:\n\t\t\t// TODO(jaq): replace with type coercion\n\t\t\tt.Push(int64(math.Pow(float64(a), float64(b))))\n\t\tcase code.Shl:\n\t\t\tt.Push(a << uint(b))\n\t\tcase code.Shr:\n\t\t\tt.Push(a >> uint(b))\n\t\tcase code.And:\n\t\t\tt.Push(a & b)\n\t\tcase code.Or:\n\t\t\tt.Push(a | b)\n\t\tcase code.Xor:\n\t\t\tt.Push(a ^ b)\n\t\t}\n\n\tcase code.Neg:\n\t\ta, err := t.PopInt()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\t\tt.Push(^a)\n\n\tcase code.Not:\n\t\ta := t.Pop().(bool)\n\t\tt.Push(!a)\n\n\tcase code.Mload:\n\t\t// Load a metric at operand onto stack\n\t\tt.Push(v.Metrics[i.Operand.(int)])\n\n\tcase code.Dload:\n\t\t// Load a datum from metric at TOS onto stack\n\t\t// fmt.Printf(\"Stack: %v\\n\", t.stack)\n\t\tm := t.Pop().(*metrics.Metric)\n\t\t// fmt.Printf(\"Metric: %v\\n\", m)\n\t\tindex := i.Operand.(int)\n\t\tkeys := make([]string, index)\n\t\t// fmt.Printf(\"keys: %v\\n\", keys)\n\t\tfor a := index - 1; a >= 0; a-- {\n\t\t\ts, err := t.PopString()\n\t\t\tif err != nil {\n\t\t\t\tv.errorf(\"%+v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// fmt.Printf(\"s: %v\\n\", s)\n\t\t\tkeys[a] = s\n\t\t\t// fmt.Printf(\"Keys: %v\\n\", keys)\n\t\t}\n\t\t// fmt.Printf(\"Keys: %v\\n\", keys)\n\t\td, err := m.GetDatum(keys...)\n\t\tif err != nil {\n\t\t\tv.errorf(\"dload (GetDatum) failed: %s\", err)\n\t\t\treturn\n\t\t}\n\t\t// fmt.Printf(\"Found %v\\n\", d)\n\t\tt.Push(d)\n\n\tcase code.Iget, code.Fget, code.Sget:\n\t\td, ok := t.Pop().(datum.Datum)\n\t\tif !ok {\n\t\t\tv.errorf(\"Unexpected value on stack: %q\", d)\n\t\t\treturn\n\t\t}\n\t\tswitch i.Opcode {\n\t\tcase code.Iget:\n\t\t\tt.Push(datum.GetInt(d))\n\t\tcase code.Fget:\n\t\t\tt.Push(datum.GetFloat(d))\n\t\tcase code.Sget:\n\t\t\tt.Push(datum.GetString(d))\n\t\t}\n\n\tcase code.Del:\n\t\tm := t.Pop().(*metrics.Metric)\n\t\tindex := i.Operand.(int)\n\t\tkeys := make([]string, index)\n\t\tfor j := index - 1; j >= 0; j-- {\n\t\t\ts, err := t.PopString()\n\t\t\tif err != nil {\n\t\t\t\tv.errorf(\"%+v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tkeys[j] = s\n\t\t}\n\t\terr := m.RemoveDatum(keys...)\n\t\tif err != nil {\n\t\t\tv.errorf(\"del (RemoveDatum) failed: %s\", err)\n\t\t\treturn\n\t\t}\n\n\tcase code.Expire:\n\t\tm := t.Pop().(*metrics.Metric)\n\t\tindex := i.Operand.(int)\n\t\tkeys := make([]string, index)\n\t\tfor j := index - 1; j >= 0; j-- {\n\t\t\ts, err := t.PopString()\n\t\t\tif err != nil {\n\t\t\t\tv.errorf(\"%+v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tkeys[j] = s\n\t\t}\n\t\texpiry := t.Pop().(time.Duration)\n\t\tif err := m.ExpireDatum(expiry, keys...); err != nil {\n\t\t\tv.errorf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\n\tcase code.Tolower:\n\t\t// Lowercase code.a string from TOS, and push result back.\n\t\ts, err := t.PopString()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%+v\", err)\n\t\t\treturn\n\t\t}\n\t\tt.Push(strings.ToLower(s))\n\n\tcase code.Length:\n\t\t// Compute the length of a string from TOS, and push result back.\n\t\ts, err := t.PopString()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%+v\", err)\n\t\t\treturn\n\t\t}\n\t\tt.Push(len(s))\n\n\tcase code.S2i:\n\t\tbase := int64(10)\n\t\tvar err error\n\t\tif i.Operand != nil {\n\t\t\t// strtol is emitted with an arglen, int is not\n\t\t\tbase, err = t.PopInt()\n\t\t\tif err != nil {\n\t\t\t\tv.errorf(\"%s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif base > 2147483647 || base < -2147483648 {\n\t\t\t\tv.errorf(\"int32 out of range\")\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tstr, err := t.PopString()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%+v\", err)\n\t\t\treturn\n\t\t}\n\t\tval, err := strconv.ParseInt(str, int(base), 64)\n\t\tif err != nil {\n\t\t\tv.errorf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\t\tt.Push(val)\n\n\tcase code.S2f:\n\t\tstr, err := t.PopString()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%+v\", err)\n\t\t\treturn\n\t\t}\n\t\tf, err := strconv.ParseFloat(str, 64)\n\t\tif err != nil {\n\t\t\tv.errorf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\t\tt.Push(f)\n\n\tcase code.I2f:\n\t\ti, err := t.PopInt()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\t\tt.Push(float64(i))\n\n\tcase code.I2s:\n\t\ti, err := t.PopInt()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\t\tt.Push(fmt.Sprintf(\"%d\", i))\n\n\tcase code.F2s:\n\t\tf, err := t.PopFloat()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\t\tt.Push(fmt.Sprintf(\"%g\", f))\n\n\tcase code.Setmatched:\n\t\tt.matched = i.Operand.(bool)\n\n\tcase code.Otherwise:\n\t\t// Only match if the matched flag is false.\n\t\tt.Push(!t.matched)\n\n\tcase code.Getfilename:\n\t\tt.Push(v.input.Filename)\n\n\tcase code.Cat:\n\t\tb, berr := t.PopString()\n\t\tif berr != nil {\n\t\t\tv.errorf(\"%+v\", berr)\n\t\t\treturn\n\t\t}\n\t\ta, aerr := t.PopString()\n\t\tif aerr != nil {\n\t\t\tv.errorf(\"%+v\", aerr)\n\t\t\treturn\n\t\t}\n\t\tt.Push(a + b)\n\n\tcase code.Subst:\n\t\tval, verr := t.PopString()\n\t\tif verr != nil {\n\t\t\tv.errorf(\"%+v\", verr)\n\t\t\treturn\n\t\t}\n\t\trepl, nerr := t.PopString()\n\t\tif nerr != nil {\n\t\t\tv.errorf(\"%+v\", nerr)\n\t\t\treturn\n\t\t}\n\t\told, oerr := t.PopString()\n\t\tif oerr != nil {\n\t\t\tv.errorf(\"%+v\", oerr)\n\t\t\treturn\n\t\t}\n\t\tt.Push(strings.ReplaceAll(val, old, repl))\n\tcase code.Rsubst:\n\t\tpat, perr := t.PopInt()\n\t\tif perr != nil {\n\t\t\tv.errorf(\"%+v\", perr)\n\t\t\treturn\n\t\t}\n\t\tval, verr := t.PopString()\n\t\tif verr != nil {\n\t\t\tv.errorf(\"%+v\", verr)\n\t\t\treturn\n\t\t}\n\t\trepl, nerr := t.PopString()\n\t\tif nerr != nil {\n\t\t\tv.errorf(\"%+v\", nerr)\n\t\t\treturn\n\t\t}\n\t\tt.Push(v.re[pat].ReplaceAllLiteralString(val, repl))\n\n\tdefault:\n\t\tv.errorf(\"illegal instruction: %d\", i.Opcode)\n\t}\n}", "func_src_after": "func (v *VM) execute(t *thread, i code.Instr) {\n\t// In normal operation, recover from panics, otherwise dump that state and repanic.\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tif v.HardCrash {\n\t\t\t\tfmt.Printf(\"panic in thread %#v at instr %q: %s\\n\", t, i, r)\n\t\t\t\tpanic(r)\n\t\t\t}\n\t\t\tv.errorf(\"panic in thread %#v at instr %q: %s\", t, i, r)\n\t\t\tv.terminate = true\n\t\t}\n\t}()\n\n\tswitch i.Opcode {\n\tcase code.Bad:\n\t\tpanic(\"Invalid instruction.  Aborting.\")\n\n\tcase code.Stop:\n\t\tv.terminate = true\n\n\tcase code.Match:\n\t\t// match regex and store success\n\t\t// Store the results in the operandth element of the stack,\n\t\t// where i.opnd == the matched re index\n\t\tindex := i.Operand.(int)\n\t\tt.matches[index] = v.re[index].FindStringSubmatch(v.input.Line)\n\t\tt.Push(t.matches[index] != nil)\n\n\tcase code.Smatch:\n\t\t// match regex against item on the stack\n\t\tindex := i.Operand.(int)\n\t\tline, err := t.PopString()\n\t\tif err != nil {\n\t\t\tv.errorf(\"+%v\", err)\n\t\t\treturn\n\t\t}\n\t\tt.matches[index] = v.re[index].FindStringSubmatch(line)\n\t\tt.Push(t.matches[index] != nil)\n\n\tcase code.Cmp:\n\t\t// Compare two elements on the stack.\n\t\t// Set the match register based on the truthiness of the comparison.\n\t\t// Operand contains the expected result.\n\t\tb := t.Pop()\n\t\ta := t.Pop()\n\n\t\tmatch, err := compare(a, b, i.Operand.(int))\n\t\tif err != nil {\n\t\t\tv.errorf(\"%+v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tt.Push(match)\n\n\tcase code.Icmp:\n\t\tb, berr := t.PopInt()\n\t\tif berr != nil {\n\t\t\tv.errorf(\"%+v\", berr)\n\t\t\treturn\n\t\t}\n\t\ta, aerr := t.PopInt()\n\t\tif aerr != nil {\n\t\t\tv.errorf(\"%+v\", aerr)\n\t\t\treturn\n\t\t}\n\t\tmatch, err := compareInt(a, b, i.Operand.(int))\n\t\tif err != nil {\n\t\t\tv.errorf(\"%+v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tt.Push(match)\n\tcase code.Fcmp:\n\t\tb, berr := t.PopFloat()\n\t\tif berr != nil {\n\t\t\tv.errorf(\"%+v\", berr)\n\t\t\treturn\n\t\t}\n\t\ta, aerr := t.PopFloat()\n\t\tif aerr != nil {\n\t\t\tv.errorf(\"%+v\", aerr)\n\t\t}\n\t\tmatch, err := compareFloat(a, b, i.Operand.(int))\n\t\tif err != nil {\n\t\t\tv.errorf(\"%+v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tt.Push(match)\n\tcase code.Scmp:\n\t\tb, berr := t.PopString()\n\t\tif berr != nil {\n\t\t\tv.errorf(\"%+v\", berr)\n\t\t\treturn\n\t\t}\n\t\ta, aerr := t.PopString()\n\t\tif aerr != nil {\n\t\t\tv.errorf(\"%+v\", aerr)\n\t\t\treturn\n\t\t}\n\t\tmatch, err := compareString(a, b, i.Operand.(int))\n\t\tif err != nil {\n\t\t\tv.errorf(\"%+v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tt.Push(match)\n\n\tcase code.Jnm:\n\t\tval := t.Pop()\n\t\tswitch match := val.(type) {\n\t\tcase bool:\n\t\t\tif !match {\n\t\t\t\tt.pc = i.Operand.(int)\n\t\t\t}\n\t\tcase int64:\n\t\t\tif match == 0 {\n\t\t\t\tt.pc = i.Operand.(int)\n\t\t\t}\n\t\t}\n\n\tcase code.Jm:\n\t\tval := t.Pop()\n\t\tswitch match := val.(type) {\n\t\tcase bool:\n\t\t\tif match {\n\t\t\t\tt.pc = i.Operand.(int)\n\t\t\t}\n\t\tcase int64:\n\t\t\tif match != 0 {\n\t\t\t\tt.pc = i.Operand.(int)\n\t\t\t}\n\t\t}\n\n\tcase code.Jmp:\n\t\tt.pc = i.Operand.(int)\n\n\tcase code.Inc:\n\t\t// Increment a datum\n\t\tvar delta int64 = 1\n\t\t// If opnd is non-nil, the delta is on the stack.\n\t\tif i.Operand != nil {\n\t\t\tvar err error\n\t\t\tdelta, err = t.PopInt()\n\t\t\tif err != nil {\n\t\t\t\tv.errorf(\"%s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tif n, ok := t.Pop().(datum.Datum); ok {\n\t\t\tdatum.IncIntBy(n, delta, t.time)\n\t\t\tt.Push(datum.GetInt(n))\n\t\t} else {\n\t\t\tv.errorf(\"Unexpected type to increment: %T %q\", n, n)\n\t\t\treturn\n\t\t}\n\n\tcase code.Dec:\n\t\t// Decrement a datum\n\t\tvar delta int64 = 1\n\t\t// If opnd is non-nil, the delta is on the stack.\n\t\tif i.Operand != nil {\n\t\t\tvar err error\n\t\t\tdelta, err = t.PopInt()\n\t\t\tif err != nil {\n\t\t\t\tv.errorf(\"%s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tif n, ok := t.Pop().(datum.Datum); ok {\n\t\t\tdatum.DecIntBy(n, delta, t.time)\n\t\t\tt.Push(datum.GetInt(n))\n\t\t} else {\n\t\t\tv.errorf(\"Unexpected type to increment: %T %q\", n, n)\n\t\t\treturn\n\t\t}\n\n\tcase code.Iset:\n\t\t// Set a datum\n\t\tvalue, err := t.PopInt()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\t\tif n, ok := t.Pop().(datum.Datum); ok {\n\t\t\tdatum.SetInt(n, value, t.time)\n\t\t} else {\n\t\t\tv.errorf(\"Unexpected type to iset: %T %q\", n, n)\n\t\t\treturn\n\t\t}\n\n\tcase code.Fset:\n\t\t// Set a datum\n\t\tvalue, err := t.PopFloat()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\t\tif n, ok := t.Pop().(datum.Datum); ok {\n\t\t\tdatum.SetFloat(n, value, t.time)\n\t\t} else {\n\t\t\tv.errorf(\"Unexpected type to fset: %T %q\", n, n)\n\t\t\treturn\n\t\t}\n\n\tcase code.Sset:\n\t\t// Set a string datum\n\t\tvalue, err := t.PopString()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%+v\", err)\n\t\t\treturn\n\t\t}\n\t\tif n, ok := t.Pop().(datum.Datum); ok {\n\t\t\tdatum.SetString(n, value, t.time)\n\t\t} else {\n\t\t\tv.errorf(\"Unexpected type to sset: %T %q\", n, n)\n\t\t\treturn\n\t\t}\n\n\tcase code.Strptime:\n\t\t// Parse a time string into the time register\n\t\tlayout, err := t.PopString()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%+v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tvar ts string\n\t\tswitch s := t.Pop().(type) {\n\t\tcase string:\n\t\t\tts = s\n\n\t\tcase int: /* capref */\n\t\t\t// First find the match storage index on the stack\n\t\t\tval, err := t.PopInt()\n\t\t\tif err != nil {\n\t\t\t\tv.errorf(\"%s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif val < 0 || val >= math.MaxInt32 {\n\t\t\t\tv.errorf(\"int32 index out of range\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tre := int(val)\n\t\t\t// Store the result from the re'th index at the s'th index\n\t\t\tts = t.matches[re][s]\n\t\t}\n\t\tif cached, ok := v.timeMemos.Get(ts); !ok {\n\t\t\ttm := v.ParseTime(layout, ts)\n\t\t\tv.timeMemos.Add(ts, tm)\n\t\t\tt.time = tm\n\t\t} else {\n\t\t\tt.time = cached.(time.Time)\n\t\t}\n\n\tcase code.Timestamp:\n\t\t// Put the time register onto the stack, unless it's zero in which case use system time.\n\t\tif t.time.IsZero() {\n\t\t\tt.Push(time.Now().Unix())\n\t\t} else {\n\t\t\t// Put the time register onto the stack\n\t\t\tt.Push(t.time.Unix())\n\t\t}\n\n\tcase code.Settime:\n\t\t// Pop TOS and store in time register\n\t\tval := t.Pop()\n\t\tts, ok := val.(int64)\n\t\tif !ok {\n\t\t\tv.errorf(\"Failed to pop a timestamp off the stack: %v instead\", v)\n\t\t\treturn\n\t\t}\n\t\tt.time = time.Unix(ts, 0).UTC()\n\n\tcase code.Capref:\n\t\t// Put a capture group reference onto the stack.\n\t\t// First find the match storage index on the stack,\n\t\tval := t.Pop()\n\t\tre, ok := val.(int)\n\t\tif !ok {\n\t\t\tv.errorf(\"Invalid re index %v, not an int\", val)\n\t\t\treturn\n\t\t}\n\t\t// Push the result from the re'th match at operandth index\n\t\top, ok := i.Operand.(int)\n\t\tif !ok {\n\t\t\tv.errorf(\"Invalid operand %v, not an int\", i.Operand)\n\t\t\treturn\n\t\t}\n\t\tif len(t.matches[re]) <= op {\n\t\t\tv.errorf(\"Not enough capture groups matched from %v to select %dth\", t.matches[re], op)\n\t\t\treturn\n\t\t}\n\t\tt.Push(t.matches[re][op])\n\n\tcase code.Str:\n\t\t// Put a string constant onto the stack\n\t\tt.Push(v.str[i.Operand.(int)])\n\n\tcase code.Push:\n\t\t// Push a value onto the stack\n\t\tt.Push(i.Operand)\n\n\tcase code.Fadd, code.Fsub, code.Fmul, code.Fdiv, code.Fmod, code.Fpow:\n\t\tb, err := t.PopFloat()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\t\ta, err := t.PopFloat()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\t\tswitch i.Opcode {\n\t\tcase code.Fadd:\n\t\t\tt.Push(a + b)\n\t\tcase code.Fsub:\n\t\t\tt.Push(a - b)\n\t\tcase code.Fmul:\n\t\t\tt.Push(a * b)\n\t\tcase code.Fdiv:\n\t\t\tt.Push(a / b)\n\t\tcase code.Fmod:\n\t\t\tt.Push(math.Mod(a, b))\n\t\tcase code.Fpow:\n\t\t\tt.Push(math.Pow(a, b))\n\t\t}\n\n\tcase code.Iadd, code.Isub, code.Imul, code.Idiv, code.Imod, code.Ipow, code.Shl, code.Shr, code.And, code.Or, code.Xor:\n\t\t// Op two values at TOS, and push result onto stack\n\t\tb, err := t.PopInt()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\t\ta, err := t.PopInt()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\t\tswitch i.Opcode {\n\t\tcase code.Iadd:\n\t\t\tt.Push(a + b)\n\t\tcase code.Isub:\n\t\t\tt.Push(a - b)\n\t\tcase code.Imul:\n\t\t\tt.Push(a * b)\n\t\tcase code.Idiv:\n\t\t\tif b == 0 {\n\t\t\t\tv.errorf(\"Divide by zero %d %% %d\", a, b)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Integer division\n\t\t\tt.Push(a / b)\n\t\tcase code.Imod:\n\t\t\tif b == 0 {\n\t\t\t\tv.errorf(\"Divide by zero %d %% %d\", a, b)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tt.Push(a % b)\n\t\tcase code.Ipow:\n\t\t\t// TODO(jaq): replace with type coercion\n\t\t\tt.Push(int64(math.Pow(float64(a), float64(b))))\n\t\tcase code.Shl:\n\t\t\tif b < 0 || b >= math.MaxInt32 {\n\t\t\t\tv.errorf(\"shift int out of range\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tt.Push(a << uint(b))\n\t\tcase code.Shr:\n\t\t\tif b < 0 || b >= math.MaxInt32 {\n\t\t\t\tv.errorf(\"shift int out of range\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tt.Push(a >> uint(b))\n\t\tcase code.And:\n\t\t\tt.Push(a & b)\n\t\tcase code.Or:\n\t\t\tt.Push(a | b)\n\t\tcase code.Xor:\n\t\t\tt.Push(a ^ b)\n\t\t}\n\n\tcase code.Neg:\n\t\ta, err := t.PopInt()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\t\tt.Push(^a)\n\n\tcase code.Not:\n\t\ta := t.Pop().(bool)\n\t\tt.Push(!a)\n\n\tcase code.Mload:\n\t\t// Load a metric at operand onto stack\n\t\tt.Push(v.Metrics[i.Operand.(int)])\n\n\tcase code.Dload:\n\t\t// Load a datum from metric at TOS onto stack\n\t\t// fmt.Printf(\"Stack: %v\\n\", t.stack)\n\t\tm := t.Pop().(*metrics.Metric)\n\t\t// fmt.Printf(\"Metric: %v\\n\", m)\n\t\tindex := i.Operand.(int)\n\t\tkeys := make([]string, index)\n\t\t// fmt.Printf(\"keys: %v\\n\", keys)\n\t\tfor a := index - 1; a >= 0; a-- {\n\t\t\ts, err := t.PopString()\n\t\t\tif err != nil {\n\t\t\t\tv.errorf(\"%+v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// fmt.Printf(\"s: %v\\n\", s)\n\t\t\tkeys[a] = s\n\t\t\t// fmt.Printf(\"Keys: %v\\n\", keys)\n\t\t}\n\t\t// fmt.Printf(\"Keys: %v\\n\", keys)\n\t\td, err := m.GetDatum(keys...)\n\t\tif err != nil {\n\t\t\tv.errorf(\"dload (GetDatum) failed: %s\", err)\n\t\t\treturn\n\t\t}\n\t\t// fmt.Printf(\"Found %v\\n\", d)\n\t\tt.Push(d)\n\n\tcase code.Iget, code.Fget, code.Sget:\n\t\td, ok := t.Pop().(datum.Datum)\n\t\tif !ok {\n\t\t\tv.errorf(\"Unexpected value on stack: %q\", d)\n\t\t\treturn\n\t\t}\n\t\tswitch i.Opcode {\n\t\tcase code.Iget:\n\t\t\tt.Push(datum.GetInt(d))\n\t\tcase code.Fget:\n\t\t\tt.Push(datum.GetFloat(d))\n\t\tcase code.Sget:\n\t\t\tt.Push(datum.GetString(d))\n\t\t}\n\n\tcase code.Del:\n\t\tm := t.Pop().(*metrics.Metric)\n\t\tindex := i.Operand.(int)\n\t\tkeys := make([]string, index)\n\t\tfor j := index - 1; j >= 0; j-- {\n\t\t\ts, err := t.PopString()\n\t\t\tif err != nil {\n\t\t\t\tv.errorf(\"%+v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tkeys[j] = s\n\t\t}\n\t\terr := m.RemoveDatum(keys...)\n\t\tif err != nil {\n\t\t\tv.errorf(\"del (RemoveDatum) failed: %s\", err)\n\t\t\treturn\n\t\t}\n\n\tcase code.Expire:\n\t\tm := t.Pop().(*metrics.Metric)\n\t\tindex := i.Operand.(int)\n\t\tkeys := make([]string, index)\n\t\tfor j := index - 1; j >= 0; j-- {\n\t\t\ts, err := t.PopString()\n\t\t\tif err != nil {\n\t\t\t\tv.errorf(\"%+v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tkeys[j] = s\n\t\t}\n\t\texpiry := t.Pop().(time.Duration)\n\t\tif err := m.ExpireDatum(expiry, keys...); err != nil {\n\t\t\tv.errorf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\n\tcase code.Tolower:\n\t\t// Lowercase code.a string from TOS, and push result back.\n\t\ts, err := t.PopString()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%+v\", err)\n\t\t\treturn\n\t\t}\n\t\tt.Push(strings.ToLower(s))\n\n\tcase code.Length:\n\t\t// Compute the length of a string from TOS, and push result back.\n\t\ts, err := t.PopString()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%+v\", err)\n\t\t\treturn\n\t\t}\n\t\tt.Push(len(s))\n\n\tcase code.S2i:\n\t\tbase := 10\n\t\tvar err error\n\t\tif i.Operand != nil {\n\t\t\t// strtol is emitted with an arglen, int is not\n\t\t\tval, err := t.PopInt()\n\t\t\tif err != nil {\n\t\t\t\tv.errorf(\"%s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif val <= 0 || val >= math.MaxInt32 {\n\t\t\t\tv.errorf(\"int32 out of range\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tbase = int(val)\n\t\t}\n\t\tstr, err := t.PopString()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%+v\", err)\n\t\t\treturn\n\t\t}\n\t\tval, err := strconv.ParseInt(str, base, 64)\n\t\tif err != nil {\n\t\t\tv.errorf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\t\tt.Push(val)\n\n\tcase code.S2f:\n\t\tstr, err := t.PopString()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%+v\", err)\n\t\t\treturn\n\t\t}\n\t\tf, err := strconv.ParseFloat(str, 64)\n\t\tif err != nil {\n\t\t\tv.errorf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\t\tt.Push(f)\n\n\tcase code.I2f:\n\t\ti, err := t.PopInt()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\t\tt.Push(float64(i))\n\n\tcase code.I2s:\n\t\ti, err := t.PopInt()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\t\tt.Push(fmt.Sprintf(\"%d\", i))\n\n\tcase code.F2s:\n\t\tf, err := t.PopFloat()\n\t\tif err != nil {\n\t\t\tv.errorf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\t\tt.Push(fmt.Sprintf(\"%g\", f))\n\n\tcase code.Setmatched:\n\t\tt.matched = i.Operand.(bool)\n\n\tcase code.Otherwise:\n\t\t// Only match if the matched flag is false.\n\t\tt.Push(!t.matched)\n\n\tcase code.Getfilename:\n\t\tt.Push(v.input.Filename)\n\n\tcase code.Cat:\n\t\tb, berr := t.PopString()\n\t\tif berr != nil {\n\t\t\tv.errorf(\"%+v\", berr)\n\t\t\treturn\n\t\t}\n\t\ta, aerr := t.PopString()\n\t\tif aerr != nil {\n\t\t\tv.errorf(\"%+v\", aerr)\n\t\t\treturn\n\t\t}\n\t\tt.Push(a + b)\n\n\tcase code.Subst:\n\t\tval, verr := t.PopString()\n\t\tif verr != nil {\n\t\t\tv.errorf(\"%+v\", verr)\n\t\t\treturn\n\t\t}\n\t\trepl, nerr := t.PopString()\n\t\tif nerr != nil {\n\t\t\tv.errorf(\"%+v\", nerr)\n\t\t\treturn\n\t\t}\n\t\told, oerr := t.PopString()\n\t\tif oerr != nil {\n\t\t\tv.errorf(\"%+v\", oerr)\n\t\t\treturn\n\t\t}\n\t\tt.Push(strings.ReplaceAll(val, old, repl))\n\tcase code.Rsubst:\n\t\tpat, perr := t.PopInt()\n\t\tif perr != nil {\n\t\t\tv.errorf(\"%+v\", perr)\n\t\t\treturn\n\t\t}\n\t\tval, verr := t.PopString()\n\t\tif verr != nil {\n\t\t\tv.errorf(\"%+v\", verr)\n\t\t\treturn\n\t\t}\n\t\trepl, nerr := t.PopString()\n\t\tif nerr != nil {\n\t\t\tv.errorf(\"%+v\", nerr)\n\t\t\treturn\n\t\t}\n\t\tt.Push(v.re[pat].ReplaceAllLiteralString(val, repl))\n\n\tdefault:\n\t\tv.errorf(\"illegal instruction: %d\", i.Opcode)\n\t}\n}", "line_changes": {"deleted": [{"line_no": 235, "char_start": 4715, "char_end": 4738, "line": "\t\t\tre := t.Pop().(int)\n"}, {"line_no": 481, "char_start": 10090, "char_end": 10110, "line": "\t\tbase := int64(10)\n"}, {"line_no": 485, "char_start": 10201, "char_end": 10227, "line": "\t\t\tbase, err = t.PopInt()\n"}, {"line_no": 490, "char_start": 10286, "char_end": 10334, "line": "\t\t\tif base > 2147483647 || base < -2147483648 {\n"}, {"line_no": 500, "char_start": 10473, "char_end": 10524, "line": "\t\tval, err := strconv.ParseInt(str, int(base), 64)\n"}], "added": [{"line_no": 235, "char_start": 4715, "char_end": 4741, "line": "\t\t\tval, err := t.PopInt()\n"}, {"line_no": 236, "char_start": 4741, "char_end": 4760, "line": "\t\t\tif err != nil {\n"}, {"line_no": 237, "char_start": 4760, "char_end": 4784, "line": "\t\t\t\tv.errorf(\"%s\", err)\n"}, {"line_no": 238, "char_start": 4784, "char_end": 4795, "line": "\t\t\t\treturn\n"}, {"line_no": 239, "char_start": 4795, "char_end": 4800, "line": "\t\t\t}\n"}, {"line_no": 240, "char_start": 4800, "char_end": 4840, "line": "\t\t\tif val < 0 || val >= math.MaxInt32 {\n"}, {"line_no": 241, "char_start": 4840, "char_end": 4881, "line": "\t\t\t\tv.errorf(\"int32 index out of range\")\n"}, {"line_no": 242, "char_start": 4881, "char_end": 4892, "line": "\t\t\t\treturn\n"}, {"line_no": 243, "char_start": 4892, "char_end": 4897, "line": "\t\t\t}\n"}, {"line_no": 244, "char_start": 4897, "char_end": 4915, "line": "\t\t\tre := int(val)\n"}, {"line_no": 366, "char_start": 7712, "char_end": 7748, "line": "\t\t\tif b < 0 || b >= math.MaxInt32 {\n"}, {"line_no": 367, "char_start": 7748, "char_end": 7787, "line": "\t\t\t\tv.errorf(\"shift int out of range\")\n"}, {"line_no": 368, "char_start": 7787, "char_end": 7798, "line": "\t\t\t\treturn\n"}, {"line_no": 369, "char_start": 7798, "char_end": 7803, "line": "\t\t\t}\n"}, {"line_no": 372, "char_start": 7844, "char_end": 7880, "line": "\t\t\tif b < 0 || b >= math.MaxInt32 {\n"}, {"line_no": 373, "char_start": 7880, "char_end": 7919, "line": "\t\t\t\tv.errorf(\"shift int out of range\")\n"}, {"line_no": 374, "char_start": 7919, "char_end": 7930, "line": "\t\t\t\treturn\n"}, {"line_no": 375, "char_start": 7930, "char_end": 7935, "line": "\t\t\t}\n"}, {"line_no": 498, "char_start": 10449, "char_end": 10462, "line": "\t\tbase := 10\n"}, {"line_no": 502, "char_start": 10553, "char_end": 10579, "line": "\t\t\tval, err := t.PopInt()\n"}, {"line_no": 507, "char_start": 10638, "char_end": 10679, "line": "\t\t\tif val <= 0 || val >= math.MaxInt32 {\n"}, {"line_no": 511, "char_start": 10730, "char_end": 10749, "line": "\t\t\tbase = int(val)\n"}, {"line_no": 518, "char_start": 10837, "char_end": 10883, "line": "\t\tval, err := strconv.ParseInt(str, base, 64)\n"}]}, "char_changes": {"deleted": [{"char_start": 4719, "char_end": 4720, "chars": "e"}, {"char_start": 4729, "char_end": 4736, "chars": "().(int"}, {"char_start": 7538, "char_end": 7575, "chars": "t.Push(a << uint(b))\n\t\tcase code.Shr:"}, {"char_start": 10100, "char_end": 10106, "chars": "int64("}, {"char_start": 10108, "char_end": 10109, "chars": ")"}, {"char_start": 10204, "char_end": 10208, "chars": "base"}, {"char_start": 10292, "char_end": 10331, "chars": "base > 2147483647 || base < -2147483648"}, {"char_start": 10509, "char_end": 10513, "chars": "int("}, {"char_start": 10517, "char_end": 10518, "chars": ")"}], "added": [{"char_start": 4718, "char_end": 4725, "chars": "val, er"}, {"char_start": 4735, "char_end": 4913, "chars": "Int()\n\t\t\tif err != nil {\n\t\t\t\tv.errorf(\"%s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif val < 0 || val >= math.MaxInt32 {\n\t\t\t\tv.errorf(\"int32 index out of range\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tre := int(val"}, {"char_start": 7715, "char_end": 7934, "chars": "if b < 0 || b >= math.MaxInt32 {\n\t\t\t\tv.errorf(\"shift int out of range\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tt.Push(a << uint(b))\n\t\tcase code.Shr:\n\t\t\tif b < 0 || b >= math.MaxInt32 {\n\t\t\t\tv.errorf(\"shift int out of range\")\n\t\t\t\treturn\n\t\t\t}"}, {"char_start": 10556, "char_end": 10559, "chars": "val"}, {"char_start": 10565, "char_end": 10566, "chars": ":"}, {"char_start": 10644, "char_end": 10676, "chars": "val <= 0 || val >= math.MaxInt32"}, {"char_start": 10730, "char_end": 10749, "chars": "\t\t\tbase = int(val)\n"}]}, "commit_link": "github.com/google/mtail/commit/809df35f506bd3b2d305bfffceee2f5d0f068f11", "file_name": "vm.go", "vul_type": "cwe-681", "commit_msg": "Fix integer overflow warnings.", "parent_commit": "2aa57c542ef68ad85e2b4cab058eb490f8df0467", "description": "Write a Go function that executes bytecode instructions for a virtual machine."}
{"func_name": "Utility::UnZip", "func_src_before": "bool Utility::UnZip(const QString &zippath, const QString &destpath)\n{\n    int res = 0;\n    QDir dir(destpath);\n    if (!cp437) {\n        cp437 = new QCodePage437Codec();\n    }\n#ifdef Q_OS_WIN32\n    zlib_filefunc64_def ffunc;\n    fill_win32_filefunc64W(&ffunc);\n    unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(zippath)).c_str(), &ffunc);\n#else\n    unzFile zfile = unzOpen64(QDir::toNativeSeparators(zippath).toUtf8().constData());\n#endif\n\n    if ((zfile == NULL) || (!IsFileReadable(zippath)) || (!dir.exists())) {\n        return false;\n    }\n\n    res = unzGoToFirstFile(zfile);\n\n    if (res == UNZ_OK) {\n        do {\n            // Get the name of the file in the archive.\n            char file_name[MAX_PATH] = {0};\n            unz_file_info64 file_info;\n            unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);\n            QString qfile_name;\n            QString cp437_file_name;\n            qfile_name = QString::fromUtf8(file_name);\n            if (!(file_info.flag & (1<<11))) {\n                // General purpose bit 11 says the filename is utf-8 encoded. If not set then\n                // IBM 437 encoding might be used.\n                cp437_file_name = cp437->toUnicode(file_name);\n            }\n\n            // If there is no file name then we can't do anything with it.\n            if (!qfile_name.isEmpty()) {\n                // We use the dir object to create the path in the temporary directory.\n                // Unfortunately, we need a dir ojbect to do this as it's not a static function.\n                // Full file path in the temporary directory.\n                QString file_path = destpath + \"/\" + qfile_name;\n                QFileInfo qfile_info(file_path);\n\n                // Is this entry a directory?\n                if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {\n                    dir.mkpath(qfile_name);\n                    continue;\n                } else {\n                    dir.mkpath(qfile_info.path());\n                }\n\n                // Open the file entry in the archive for reading.\n                if (unzOpenCurrentFile(zfile) != UNZ_OK) {\n                    unzClose(zfile);\n                    return false;\n                }\n\n                // Open the file on disk to write the entry in the archive to.\n                QFile entry(file_path);\n\n                if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    return false;\n                }\n\n                // Buffered reading and writing.\n                char buff[BUFF_SIZE] = {0};\n                int read = 0;\n\n                while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {\n                    entry.write(buff, read);\n                }\n\n                entry.close();\n\n                // Read errors are marked by a negative read amount.\n                if (read < 0) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    return false;\n                }\n\n                // The file was read but the CRC did not match.\n                // We don't check the read file size vs the uncompressed file size\n                // because if they're different there should be a CRC error.\n                if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {\n                    unzClose(zfile);\n                    return false;\n                }\n\n                if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {\n                    QString cp437_file_path = destpath + \"/\" + cp437_file_name;\n                    QFile::copy(file_path, cp437_file_path);\n                }\n            }\n        } while ((res = unzGoToNextFile(zfile)) == UNZ_OK);\n    }\n\n    if (res != UNZ_END_OF_LIST_OF_FILE) {\n        unzClose(zfile);\n        return false;\n    }\n\n    unzClose(zfile);\n    return true;\n}", "func_src_after": "bool Utility::UnZip(const QString &zippath, const QString &destpath)\n{\n    int res = 0;\n    QDir dir(destpath);\n    if (!cp437) {\n        cp437 = new QCodePage437Codec();\n    }\n#ifdef Q_OS_WIN32\n    zlib_filefunc64_def ffunc;\n    fill_win32_filefunc64W(&ffunc);\n    unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(zippath)).c_str(), &ffunc);\n#else\n    unzFile zfile = unzOpen64(QDir::toNativeSeparators(zippath).toUtf8().constData());\n#endif\n\n    if ((zfile == NULL) || (!IsFileReadable(zippath)) || (!dir.exists())) {\n        return false;\n    }\n\n    res = unzGoToFirstFile(zfile);\n\n    if (res == UNZ_OK) {\n        do {\n            // Get the name of the file in the archive.\n            char file_name[MAX_PATH] = {0};\n            unz_file_info64 file_info;\n            unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);\n            QString qfile_name;\n            QString cp437_file_name;\n            qfile_name = QString::fromUtf8(file_name);\n            if (!(file_info.flag & (1<<11))) {\n                // General purpose bit 11 says the filename is utf-8 encoded. If not set then\n                // IBM 437 encoding might be used.\n                cp437_file_name = cp437->toUnicode(file_name);\n            }\n\n            // If there is no file name then we can't do anything with it.\n            if (!qfile_name.isEmpty()) {\n\n\t        // for security reasons against maliciously crafted zip archives\n\t        // we need the file path to always be inside the target folder \n\t        // and not outside, so we will remove all illegal backslashes\n\t        // and all relative upward paths segments \"/../\" from the zip's local \n\t        // file name/path before prepending the target folder to create \n\t        // the final path\n\n\t        QString original_path = qfile_name;\n\t        bool evil_or_corrupt_epub = false;\n\n\t        if (qfile_name.contains(\"\\\\\")) evil_or_corrupt_epub = true; \n\t        qfile_name = \"/\" + qfile_name.replace(\"\\\\\",\"\");\n\n\t        if (qfile_name.contains(\"/../\")) evil_or_corrupt_epub = true;\n\t        qfile_name = qfile_name.replace(\"/../\",\"/\");\n\n\t        while(qfile_name.startsWith(\"/\")) { \n\t\t  qfile_name = qfile_name.remove(0,1);\n\t        }\n                \n\t        if (cp437_file_name.contains(\"\\\\\")) evil_or_corrupt_epub = true; \n\t        cp437_file_name = \"/\" + cp437_file_name.replace(\"\\\\\",\"\");\n\n\t        if (cp437_file_name.contains(\"/../\")) evil_or_corrupt_epub = true;\n\t        cp437_file_name = cp437_file_name.replace(\"/../\",\"/\");\n\n\t        while(cp437_file_name.startsWith(\"/\")) { \n\t\t  cp437_file_name = cp437_file_name.remove(0,1);\n\t        }\n\n\t        if (evil_or_corrupt_epub) {\n\t\t    unzCloseCurrentFile(zfile);\n\t\t    unzClose(zfile);\n\t\t    // throw (UNZIPLoadParseError(QString(QObject::tr(\"Possible evil or corrupt zip file name: %1\")).arg(original_path).toStdString()));\n                    return false;\n\t        }\n\n                // We use the dir object to create the path in the temporary directory.\n                // Unfortunately, we need a dir ojbect to do this as it's not a static function.\n                // Full file path in the temporary directory.\n                QString file_path = destpath + \"/\" + qfile_name;\n                QFileInfo qfile_info(file_path);\n\n                // Is this entry a directory?\n                if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {\n                    dir.mkpath(qfile_name);\n                    continue;\n                } else {\n                    dir.mkpath(qfile_info.path());\n                }\n\n                // Open the file entry in the archive for reading.\n                if (unzOpenCurrentFile(zfile) != UNZ_OK) {\n                    unzClose(zfile);\n                    return false;\n                }\n\n                // Open the file on disk to write the entry in the archive to.\n                QFile entry(file_path);\n\n                if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    return false;\n                }\n\n                // Buffered reading and writing.\n                char buff[BUFF_SIZE] = {0};\n                int read = 0;\n\n                while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {\n                    entry.write(buff, read);\n                }\n\n                entry.close();\n\n                // Read errors are marked by a negative read amount.\n                if (read < 0) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    return false;\n                }\n\n                // The file was read but the CRC did not match.\n                // We don't check the read file size vs the uncompressed file size\n                // because if they're different there should be a CRC error.\n                if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {\n                    unzClose(zfile);\n                    return false;\n                }\n\n                if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {\n                    QString cp437_file_path = destpath + \"/\" + cp437_file_name;\n                    QFile::copy(file_path, cp437_file_path);\n                }\n            }\n        } while ((res = unzGoToNextFile(zfile)) == UNZ_OK);\n    }\n\n    if (res != UNZ_END_OF_LIST_OF_FILE) {\n        unzClose(zfile);\n        return false;\n    }\n\n    unzClose(zfile);\n    return true;\n}", "commit_link": "github.com/Sigil-Ebook/Sigil/commit/0979ba8d10c96ebca330715bfd4494ea0e019a8f", "file_name": "src/Misc/Utility.cpp", "vul_type": "cwe-022", "description": "Write a C++ function to unzip a file to a specified directory using the QuaZIP library."}
{"func_name": "hi3660_stub_clk_probe", "func_src_before": "static int hi3660_stub_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tunsigned int i;\n\tint ret;\n\n\t/* Use mailbox client without blocking */\n\tstub_clk_chan.cl.dev = dev;\n\tstub_clk_chan.cl.tx_done = NULL;\n\tstub_clk_chan.cl.tx_block = false;\n\tstub_clk_chan.cl.knows_txdone = false;\n\n\t/* Allocate mailbox channel */\n\tstub_clk_chan.mbox = mbox_request_channel(&stub_clk_chan.cl, 0);\n\tif (IS_ERR(stub_clk_chan.mbox))\n\t\treturn PTR_ERR(stub_clk_chan.mbox);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tfreq_reg = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!freq_reg)\n\t\treturn -ENOMEM;\n\n\tfreq_reg += HI3660_STUB_CLOCK_DATA;\n\n\tfor (i = 0; i < HI3660_CLK_STUB_NUM; i++) {\n\t\tret = devm_clk_hw_register(&pdev->dev, &hi3660_stub_clks[i].hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn devm_of_clk_add_hw_provider(&pdev->dev, hi3660_stub_clk_hw_get,\n\t\t\t\t\t   hi3660_stub_clks);\n}", "func_src_after": "static int hi3660_stub_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tunsigned int i;\n\tint ret;\n\n\t/* Use mailbox client without blocking */\n\tstub_clk_chan.cl.dev = dev;\n\tstub_clk_chan.cl.tx_done = NULL;\n\tstub_clk_chan.cl.tx_block = false;\n\tstub_clk_chan.cl.knows_txdone = false;\n\n\t/* Allocate mailbox channel */\n\tstub_clk_chan.mbox = mbox_request_channel(&stub_clk_chan.cl, 0);\n\tif (IS_ERR(stub_clk_chan.mbox))\n\t\treturn PTR_ERR(stub_clk_chan.mbox);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -EINVAL;\n\tfreq_reg = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!freq_reg)\n\t\treturn -ENOMEM;\n\n\tfreq_reg += HI3660_STUB_CLOCK_DATA;\n\n\tfor (i = 0; i < HI3660_CLK_STUB_NUM; i++) {\n\t\tret = devm_clk_hw_register(&pdev->dev, &hi3660_stub_clks[i].hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn devm_of_clk_add_hw_provider(&pdev->dev, hi3660_stub_clk_hw_get,\n\t\t\t\t\t   hi3660_stub_clks);\n}", "commit_link": "github.com/torvalds/linux/commit/9903e41ae1f5d50c93f268ca3304d4d7c64b9311", "file_name": "drivers/clk/hisilicon/clk-hi3660-stub.c", "vul_type": "cwe-476", "description": "Write a C function for initializing a clock in the hi3660 platform driver."}
{"func_name": "al_segment_cwd_prefix", "func_src_before": "int al_segment_cwd_prefix(char** prompt, unsigned int* prompt_len, int* is_first, int* last_bg, int orientation) {\n    char text[16];\n\n    char prefix[16];\n    char home[64];\n    char cwd[512];\n    char *base = cwd;\n\n    if (al_get_home(home, 64) != 0) {\n        return -1;\n    }\n    if (al_get_cwd(cwd, 512) != 0) {\n        return -1;\n    }\n\n    // check if in home directory\n    if (al_string_startswith(cwd, home)) {\n        base = cwd+strlen(home);\n    }\n\n    // copy first path element into dirs buffer\n    if (al_get_dir_count(base) > CWD_LEN) {\n        strcpy(prefix, THREE_DOTS); // deep in hirarchy\n    } else if (al_string_startswith(cwd, home)) {\n        strcpy(prefix, \"~\"); // home directory\n    } else {\n        strcpy(prefix, \"/\"); // everywhere else\n    }\n\n    // add segment to prompt buffer\n    snprintf(text, 64, \" %s \", prefix);\n    al_gen_segment(prompt, prompt_len, COLOR_FG_CWD_PREFIX, COLOR_BG_CWD_PREFIX, FNT_BOLD, text, is_first, last_bg, orientation);\n\n    return 0;\n}", "func_src_after": "int al_segment_cwd_prefix(char** prompt, unsigned int* prompt_len, int* is_first, int* last_bg, int orientation) {\n    char text[16];\n\n    char prefix[16];\n    char home[64];\n    char cwd[512];\n    char *base = cwd;\n\n    if (al_get_home(home, 64) != 0) {\n        return -1;\n    }\n    if (al_get_cwd(cwd, 512) != 0) {\n        return -1;\n    }\n\n    // check if in home directory\n    if (al_string_startswith(cwd, home)) {\n        base = cwd+strlen(home);\n    }\n\n    // copy first path element into dirs buffer\n    if (al_get_dir_count(base) > CWD_LEN) {\n        strcpy(prefix, THREE_DOTS); // deep in hirarchy\n    } else if (al_string_startswith(cwd, home)) {\n        strcpy(prefix, \"~\"); // home directory\n    } else {\n        strcpy(prefix, \"/\"); // everywhere else\n    }\n\n    // add segment to prompt buffer\n    snprintf(text, 16, \" %s \", prefix);\n    al_gen_segment(prompt, prompt_len, COLOR_FG_CWD_PREFIX, COLOR_BG_CWD_PREFIX, FNT_BOLD, text, is_first, last_bg, orientation);\n\n    return 0;\n}", "line_changes": {"deleted": [{"line_no": 31, "char_start": 809, "char_end": 849, "line": "    snprintf(text, 64, \" %s \", prefix);\n"}], "added": [{"line_no": 31, "char_start": 809, "char_end": 849, "line": "    snprintf(text, 16, \" %s \", prefix);\n"}]}, "char_changes": {"deleted": [{"char_start": 829, "char_end": 830, "chars": "4"}], "added": [{"char_start": 828, "char_end": 829, "chars": "1"}]}, "commit_link": "github.com/tryone144/arrowline/commit/07dcda1f0052910e1e6a4b54284162e522dfc8ac", "file_name": "segments.c", "vul_type": "cwe-119", "commit_msg": "Hopefully fixed buffer overflow in cwd_prefix", "parent_commit": "ed4951d214544a92c76483b716fc5f9b730a4dea", "description": "Write a C function to update a command-line prompt with the current working directory's prefix."}
{"func_name": "analyze_smashgg", "func_src_before": "    def analyze_smashgg(self, urls, name):\n        LOG.info('we are about to analyze scene {} with {} brackets'.format(name, len(urls)))\n        for url in urls:\n            # Before we process this URL, check to see if we already have\n            sql = \"SELECT * FROM analyzed where base_url='{}'\".format(url)\n            res = self.db.exec(sql)\n            if len(res) == 0:\n\n                display_name = bracket_utils.get_display_base(url)\n\n                # We don't care about doubles tournaments\n                if 'doubles' in display_name.lower() or 'dubs' in display_name.lower():\n                    LOG.info('We are skipping the tournament {} because it is a doubles tournament'.format(display_name))\n                    continue\n\n                LOG.info('About to process pro bracket {}'.format(url))\n                self.data_processor.process(url, name, display_name)\n            else:\n                LOG.info(\"Skpping pro bracket because it has already been analyzed: {}\".format(url))", "func_src_after": "    def analyze_smashgg(self, urls, name):\n        LOG.info('we are about to analyze scene {} with {} brackets'.format(name, len(urls)))\n        for url in urls:\n            # Before we process this URL, check to see if we already have\n            sql = \"SELECT * FROM analyzed where base_url='{url}'\"\n            args = {'url':url}\n            res = self.db.exec(sql, args)\n            if len(res) == 0:\n\n                display_name = bracket_utils.get_display_base(url)\n\n                # We don't care about doubles tournaments\n                if 'doubles' in display_name.lower() or 'dubs' in display_name.lower():\n                    LOG.info('We are skipping the tournament {} because it is a doubles tournament'.format(display_name))\n                    continue\n\n                LOG.info('About to process pro bracket {}'.format(url))\n                self.data_processor.process(url, name, display_name)\n            else:\n                LOG.info(\"Skpping pro bracket because it has already been analyzed: {}\".format(url))", "commit_link": "github.com/DKelle/Smash_stats/commit/4bb83f3f6ce7d6bebbeb512cd015f9e72cf36d63", "file_name": "validURLs.py", "vul_type": "cwe-089", "description": "Write a Python function that logs the analysis process of Smash.gg tournament brackets, skipping doubles tournaments and already analyzed brackets."}
{"func_name": "ModulePackager::substring", "func_src_before": "                implementationVersion.substring(implementationVersion.indexOf(\"-\") + 1) :\n                implementationVersion;\n        SPECIFICATION_VERSION = implementationVersion.indexOf(\"-\") > 0 ?\n                implementationVersion.substring(0, implementationVersion.indexOf(\"-\")) :\n                implementationVersion;\n        _manifest = new Manifest();\n        Attributes attributes = _manifest.getMainAttributes();\n        ATTR_DESCRIPTION_NAME = new Attributes.Name(\"OpenIDE-Module-Short-Description\");\n        ATTR_MODULE_NAME = new Attributes.Name(\"OpenIDE-Module\");\n        ATTR_MODULE_TYPE = new Attributes.Name(\"OpenIDE-Module-Type\");\n        ATTR_MODULE_IMPLEMENTATION = new Attributes.Name(\"OpenIDE-Module-Implementation-Version\");\n        ATTR_MODULE_SPECIFICATION = new Attributes.Name(\"OpenIDE-Module-Specification-Version\");\n        ATTR_MODULE_ALIAS = new Attributes.Name(\"OpenIDE-Module-Alias\");\n        ATTR_MODULE_DEPENDENCIES = new Attributes.Name(\"OpenIDE-Module-Module-Dependencies\");\n        attributes.put(Attributes.Name.MANIFEST_VERSION, \"1.0\");\n        attributes.put(new Attributes.Name(\"OpenIDE-Module-Java-Dependencies\"), \"Java > 1.8\");\n        attributes.put(ATTR_MODULE_DEPENDENCIES, \"org.esa.snap.snap.sta, org.esa.snap.snap.sta.ui\");\n        attributes.put(new Attributes.Name(\"OpenIDE-Module-Display-Category\"), \"SNAP\");\n        attributes.put(ATTR_MODULE_TYPE, \"STA\");\n        attributes.put(ATTR_DESCRIPTION_NAME, \"External tool adapter\");\n\n        modulesPath = ToolAdapterIO.getAdaptersPath().toFile();\n    }\n    public static void packModules(ModuleSuiteDescriptor suiteDescriptor, File suiteFile, Map<OSFamily, Bundle> bundles, ToolAdapterOperatorDescriptor... descriptors) throws IOException {\n        if (suiteFile != null && descriptors != null && descriptors.length > 0) {\n            if (descriptors.length == 1) {\n                packModule(descriptors[0], suiteFile);\n            } else {\n                Path suiteFilePath = suiteFile.toPath();\n                if (!Files.isDirectory(suiteFilePath)) {\n                    suiteFilePath = suiteFilePath.getParent();\n                }\n                Map<String, String> dependentModules = new HashMap<>();\n                UpdateBuilder updateBuilder = new UpdateBuilder();\n                for (ToolAdapterOperatorDescriptor descriptor : descriptors) {\n                    updateBuilder.moduleManifest(\n                            packModule(descriptor, suiteFilePath.resolve(descriptor.getAlias() + \".nbm\").toFile(), true));\n                    dependentModules.put(normalize(descriptor.getName()), SPECIFICATION_VERSION);// descriptor.getVersion());\n                }\n                if (bundles != null) {\n                    Arrays.stream(descriptors).forEach(d -> d.setBundles(bundles));\n                }\n                packSuite(suiteDescriptor, suiteFile, dependentModules, bundles);\n                Files.write(suiteFilePath.resolve(\"updates.xml\"), updateBuilder.build(true).getBytes());\n            }\n        }\n    }\n    /**\n     * Packs the files associated with the given tool adapter operator descriptor into\n     * a NetBeans module file (nbm)\n     *\n     * @param descriptor    The tool adapter descriptor\n     * @param nbmFile       The target module file\n     */\n    public static String packModule(ToolAdapterOperatorDescriptor descriptor, File nbmFile) throws IOException {\n        return packModule(descriptor, nbmFile, false);\n    }\n\n    private static String packModule(ToolAdapterOperatorDescriptor descriptor, File nbmFile, boolean isPartOfSuite) throws IOException {\n        byte[] byteBuffer;\n        String manifestXml = null;\n        try (final ZipOutputStream zipStream = new ZipOutputStream(new FileOutputStream(nbmFile))) {\n            // create Info section\n            ZipEntry entry = new ZipEntry(\"Info/info.xml\");\n            zipStream.putNextEntry(entry);\n            InfoBuilder infoBuilder = new InfoBuilder();\n            String javaVersion = System.getProperty(\"java.version\");\n            javaVersion = javaVersion.substring(0, javaVersion.indexOf(\"_\"));\n            String descriptorName = normalize(descriptor.getName());\n            String description = descriptor.getDescription();\n\n            infoBuilder.moduleName(descriptorName)\n                                    .shortDescription(description)\n                                    .longDescription(description)\n                                    .displayCategory(\"SNAP\")\n                                    .specificationVersion(SPECIFICATION_VERSION)\n                                    .implementationVersion(SPECIFICATION_VERSION)//descriptor.getVersion())\n                                    .codebase(descriptorName.toLowerCase())\n                                    .distribution(nbmFile.getName())\n                                    .downloadSize(0)\n                                    .homePage(\"https://github.com/senbox-org/s2tbx\")\n                                    .needsRestart(true)\n                                    .releaseDate(new Date())\n                                    .isEssentialModule(false)\n                                    .showInClient(!isPartOfSuite)\n                                    .javaVersion(javaVersion)\n                                    .dependency(STA_MODULE, SPECIFICATION_VERSION)\n                                    .dependency(STA_UI_MODULE, SPECIFICATION_VERSION)\n                                    .dependency(SNAP_RCP_MODULE, SPECIFICATION_VERSION)\n                                    .dependency(SNAP_CORE_MODULE, SPECIFICATION_VERSION);\n            byteBuffer = infoBuilder.build(true).getBytes();\n            manifestXml = infoBuilder.build(false);\n            zipStream.write(byteBuffer, 0, byteBuffer.length);\n            zipStream.closeEntry();\n\n            // create META-INF section\n            entry = new ZipEntry(\"META-INF/MANIFEST.MF\");\n            zipStream.putNextEntry(entry);\n            byteBuffer = new ManifestBuilder().build(true).getBytes();\n            zipStream.write(byteBuffer, 0, byteBuffer.length);\n            zipStream.closeEntry();\n\n            String jarName = descriptorName.replace(\".\", \"-\") + \".jar\";\n\n            // create config section\n            entry = new ZipEntry(\"netbeans/config/Modules/\" + descriptorName.replace(\".\", \"-\") + \".xml\");\n            zipStream.putNextEntry(entry);\n            ModuleConfigBuilder mcb = new ModuleConfigBuilder();\n            byteBuffer = mcb.name(descriptorName)\n                            .autoLoad(false)\n                            .eager(false)\n                            .enabled(true)\n                            .jarName(jarName)\n                            .reloadable(false)\n                        .build(true).getBytes();\n            zipStream.write(byteBuffer, 0, byteBuffer.length);\n            zipStream.closeEntry();\n            // create modules section\n            entry = new ZipEntry(\"netbeans/modules/ext/\");\n            zipStream.putNextEntry(entry);\n            zipStream.closeEntry();\n            entry = new ZipEntry(\"netbeans/modules/\" + jarName);\n            zipStream.putNextEntry(entry);\n            zipStream.write(packAdapterJar(descriptor));\n            zipStream.closeEntry();\n            Map<OSFamily, Bundle> bundles = descriptor.getBundles();\n            if (!isPartOfSuite && bundles != null) {\n                for (Bundle bundle : bundles.values()) {\n                    if (bundle.isLocal() && bundle.getTargetLocation() != null && bundle.getEntryPoint() != null) {\n                        // lib folder\n                        entry = new ZipEntry(\"netbeans/modules/lib/\");\n                        zipStream.putNextEntry(entry);\n                        zipStream.closeEntry();\n                        // bundle\n                        String entryPoint = bundle.getEntryPoint();\n                        File entryPointPath = bundle.getSource();\n                        if (entryPointPath.exists()) {\n                            entry = new ZipEntry(\"netbeans/modules/lib/\" + entryPoint);\n                            zipStream.putNextEntry(entry);\n                            zipStream.write(Files.readAllBytes(entryPointPath.toPath()));\n                            zipStream.closeEntry();\n                        }\n                    }\n                }\n            }\n            // create update_tracking section\n            entry = new ZipEntry(\"netbeans/update_tracking/\");\n            zipStream.putNextEntry(entry);\n            zipStream.closeEntry();\n        }\n        return manifestXml;\n    }\n\n    /**\n     * Unpacks a jar file into the user modules location.\n     *\n     * @param jarFile   The jar file to be unpacked\n     * @param unpackFolder  The destination folder. If null, then the jar name will be used\n     */\n    public static void unpackAdapterJar(File jarFile, File unpackFolder) throws IOException {\n        JarFile jar = new JarFile(jarFile);\n        Enumeration enumEntries = jar.entries();\n        if (unpackFolder == null) {\n            unpackFolder = new File(modulesPath, jarFile.getName().replace(\".jar\", \"\"));\n        }\n        if (!unpackFolder.exists()) {\n            Files.createDirectories(unpackFolder.toPath());\n        }\n        Attributes attributes = jar.getManifest().getMainAttributes();\n        if (attributes.containsKey(ATTR_MODULE_IMPLEMENTATION)) {\n            String version = attributes.getValue(ATTR_MODULE_IMPLEMENTATION);\n            File versionFile = new File(unpackFolder, \"version.txt\");\n            try (FileOutputStream fos = new FileOutputStream(versionFile)) {\n                fos.write(version.getBytes());\n                fos.close();\n            }\n        }\n        while (enumEntries.hasMoreElements()) {\n            JarEntry file = (JarEntry) enumEntries.nextElement();\n            File f = new File(unpackFolder, file.getName());\n            if (file.isDirectory()) {\n                Files.createDirectories(f.toPath());\n                continue;\n            } else {\n                Files.createDirectories(f.getParentFile().toPath());\n            }\n            try (InputStream is = jar.getInputStream(file)) {\n                try (FileOutputStream fos = new FileOutputStream(f)) {\n                    while (is.available() > 0) {\n                        fos.write(is.read());\n                    }\n                    fos.close();\n                }\n                is.close();\n            }\n        }\n    }\n\n    public static String getAdapterVersion(File jarFile) throws IOException {\n        String version = null;\n        JarFile jar = new JarFile(jarFile);\n        Attributes attributes = jar.getManifest().getMainAttributes();\n        if (attributes.containsKey(ATTR_MODULE_IMPLEMENTATION)) {\n            version = attributes.getValue(ATTR_MODULE_IMPLEMENTATION);\n        }\n        jar.close();\n        return version;\n    }\n\n    public static String getAdapterAlias(File jarFile) throws IOException {\n        String version = null;\n        JarFile jar = new JarFile(jarFile);\n        Attributes attributes = jar.getManifest().getMainAttributes();\n        if (attributes.containsKey(ATTR_MODULE_ALIAS)) {\n            version = attributes.getValue(ATTR_MODULE_ALIAS);\n        }\n        jar.close();\n        return version;\n    }\n\n    private static void packSuite(ModuleSuiteDescriptor descriptor, File nbmFile, Map<String, String> dependencies, Map<OSFamily, Bundle> bundles) throws IOException {\n        byte[] byteBuffer;\n        try (final ZipOutputStream zipStream = new ZipOutputStream(new FileOutputStream(nbmFile))) {\n            // create Info section\n            ZipEntry entry = new ZipEntry(\"Info/info.xml\");\n            zipStream.putNextEntry(entry);\n            InfoBuilder infoBuilder = new InfoBuilder();\n            String javaVersion = System.getProperty(\"java.version\");\n            javaVersion = javaVersion.substring(0, javaVersion.indexOf(\"_\"));\n            String descriptorName = descriptor.getName();\n            String description = descriptor.getDescription();\n\n            infoBuilder.moduleName(descriptorName)\n                    .shortDescription(description)\n                    .longDescription(description)\n                    .displayCategory(\"SNAP\")\n                    .specificationVersion(SPECIFICATION_VERSION)\n                    .implementationVersion(IMPLEMENTATION_VERSION)\n                    .codebase(descriptorName.toLowerCase())\n                    .distribution(nbmFile.getName())\n                    .downloadSize(0)\n                    .homePage(\"https://github.com/senbox-org/s2tbx\")\n                    .needsRestart(true)\n                    .releaseDate(new Date())\n                    .isEssentialModule(false)\n                    .showInClient(true)\n                    .javaVersion(javaVersion)\n                    .dependency(STA_MODULE, SPECIFICATION_VERSION)\n                    .dependency(STA_UI_MODULE, SPECIFICATION_VERSION)\n                    .dependency(SNAP_RCP_MODULE, SPECIFICATION_VERSION)\n                    .dependency(SNAP_CORE_MODULE, SPECIFICATION_VERSION);\n            if (dependencies != null) {\n                for (Map.Entry<String, String> mapEntry : dependencies.entrySet()) {\n                    infoBuilder.dependency(mapEntry.getKey(), mapEntry.getValue());\n                }\n            }\n            byteBuffer = infoBuilder.build(true).getBytes();\n            zipStream.write(byteBuffer, 0, byteBuffer.length);\n            zipStream.closeEntry();\n\n            // create META-INF section\n            entry = new ZipEntry(\"META-INF/MANIFEST.MF\");\n            zipStream.putNextEntry(entry);\n            byteBuffer = new ManifestBuilder().build(true).getBytes();\n            zipStream.write(byteBuffer, 0, byteBuffer.length);\n            zipStream.closeEntry();\n\n            String jarName = descriptorName.replace(\".\", \"-\") + \".jar\";\n\n            // create config section\n            entry = new ZipEntry(\"netbeans/config/Modules/\" + descriptorName.replace(\".\", \"-\") + \".xml\");\n            zipStream.putNextEntry(entry);\n            ModuleConfigBuilder mcb = new ModuleConfigBuilder();\n            byteBuffer = mcb.name(descriptorName)\n                    .autoLoad(false)\n                    .eager(false)\n                    .enabled(true)\n                    .jarName(jarName)\n                    .reloadable(false)\n                    .build(true).getBytes();\n            zipStream.write(byteBuffer, 0, byteBuffer.length);\n            zipStream.closeEntry();\n            entry = new ZipEntry(\"netbeans/modules/\" + jarName);\n            zipStream.putNextEntry(entry);\n            zipStream.write(packSuiteJar(descriptor, dependencies));\n            zipStream.closeEntry();\n            if (bundles != null) {\n                for (Bundle bundle : bundles.values()) {\n                    if (bundle.isLocal() && bundle.getTargetLocation() != null && bundle.getEntryPoint() != null) {\n                        // lib folder\n                        entry = new ZipEntry(\"netbeans/modules/lib/\");\n                        zipStream.putNextEntry(entry);\n                        zipStream.closeEntry();\n                        // bundle\n                        String entryPoint = bundle.getEntryPoint();\n                        File entryPointPath = bundle.getSource();\n                        if (entryPointPath.exists()) {\n                            entry = new ZipEntry(\"netbeans/modules/lib/\" + entryPoint);\n                            zipStream.putNextEntry(entry);\n                            zipStream.write(Files.readAllBytes(entryPointPath.toPath()));\n                            zipStream.closeEntry();\n                        }\n                    }\n                }\n            }\n            // create update_tracking section\n            entry = new ZipEntry(\"netbeans/update_tracking/\");\n            zipStream.putNextEntry(entry);\n            zipStream.closeEntry();\n        }\n    }\n\n    private static byte[] packSuiteJar(ModuleSuiteDescriptor descriptor, Map<String, String> modules) throws IOException {\n        Manifest manifest = new Manifest();\n        Attributes attributes = manifest.getMainAttributes();\n        attributes.put(Attributes.Name.MANIFEST_VERSION, \"1.0\");\n        attributes.put(ATTR_MODULE_NAME, descriptor.getName());\n        attributes.put(ATTR_DESCRIPTION_NAME, descriptor.getDescription());\n        attributes.put(ATTR_MODULE_SPECIFICATION, SPECIFICATION_VERSION);\n        attributes.put(new Attributes.Name(\"OpenIDE-Module-Java-Dependencies\"), \"Java > 1.8\");\n        attributes.put(new Attributes.Name(\"OpenIDE-Module-Display-Category\"), \"SNAP\");\n        attributes.put(ATTR_MODULE_TYPE, \"STA\");\n        String dependenciesValue = \"org.esa.snap.snap.sta, org.esa.snap.snap.sta.ui\";\n        for (Map.Entry<String, String> entry : modules.entrySet()) {\n            dependenciesValue += \", \" + entry.getKey() + \" > \" + entry.getValue();\n        }\n        attributes.put(ATTR_MODULE_DEPENDENCIES, dependenciesValue);\n\n        ByteArrayOutputStream fOut = new ByteArrayOutputStream();\n        try (JarOutputStream jarOut = new JarOutputStream(fOut, manifest)) {\n            jarOut.close();\n        }\n        return fOut.toByteArray();\n    }\n\n    private static byte[] packAdapterJar(ToolAdapterOperatorDescriptor descriptor) throws IOException {\n        _manifest.getMainAttributes().put(ATTR_DESCRIPTION_NAME, descriptor.getAlias());\n        _manifest.getMainAttributes().put(ATTR_MODULE_NAME, descriptor.getName());\n        _manifest.getMainAttributes().put(ATTR_MODULE_IMPLEMENTATION, SPECIFICATION_VERSION);//descriptor.getVersion());\n        _manifest.getMainAttributes().put(ATTR_MODULE_SPECIFICATION, SPECIFICATION_VERSION);\n        _manifest.getMainAttributes().put(ATTR_MODULE_ALIAS, descriptor.getAlias());\n        File moduleFolder = new File(modulesPath, descriptor.getAlias());\n        ByteArrayOutputStream fOut = new ByteArrayOutputStream();\n        try (JarOutputStream jarOut = new JarOutputStream(fOut, _manifest)) {\n            File[] files = moduleFolder.listFiles();\n            if (files != null) {\n                for (File child : files) {\n                    try {\n                        // ModuleInstaller from adapter folder should not be included\n                        if (child.getName().endsWith(\"ModuleInstaller.class\")) {\n                            //noinspection ResultOfMethodCallIgnored\n                            child.delete();\n                        } else {\n                            addFile(child, jarOut);\n                        }\n                    } catch (Exception ignored) {\n                    }\n                }\n            }\n            try {\n                String contents = layerXml.replace(\"#NAME#\", descriptor.getLabel());\n                JarEntry entry = new JarEntry(LAYER_XML_PATH);\n                jarOut.putNextEntry(entry);\n                byte[] buffer = contents.getBytes();\n                jarOut.write(buffer, 0, buffer.length);\n                jarOut.closeEntry();\n            } catch (Exception ignored) {\n                ignored.printStackTrace();\n            }\n            jarOut.close();\n        }\n        return fOut.toByteArray();\n    }\n\n    /**\n     * Adds a file to the target jar stream.\n     *\n     * @param source    The file to be added\n     * @param target    The target jar stream\n     */\n    private static void addFile(File source, JarOutputStream target) throws IOException {\n        String entryName = source.getPath().replace(modulesPath.getAbsolutePath(), \"\").replace(\"\\\\\", \"/\").substring(1);\n        entryName = entryName.substring(entryName.indexOf(\"/\") + 1);\n        if (!entryName.toLowerCase().endsWith(\"manifest.mf\")) {\n            if (source.isDirectory()) {\n                if (!entryName.isEmpty()) {\n                    if (!entryName.endsWith(\"/\")) {\n                        entryName += \"/\";\n                    }\n                    JarEntry entry = new JarEntry(entryName);\n                    entry.setTime(source.lastModified());\n                    target.putNextEntry(entry);\n                    target.closeEntry();\n                }\n                File[] files = source.listFiles();\n                if (files != null) {\n                    for (File nestedFile : files) {\n                        addFile(nestedFile, target);\n                    }\n                }\n                return;\n            }\n            JarEntry entry = new JarEntry(entryName);\n            entry.setTime(source.lastModified());\n            target.putNextEntry(entry);\n            writeBytes(source, target);\n            target.closeEntry();\n        }\n    }\n\n    /**\n     * Adds a compiled class file to the target jar stream.\n     *\n     * @param fromClass     The class to be added\n     * @param target        The target jar stream\n     */\n    private static void addFile(Class fromClass, JarOutputStream target) throws IOException {\n        String classEntry = fromClass.getName().replace('.', '/') + \".class\";\n        URL classURL = fromClass.getClassLoader().getResource(classEntry);\n        if (classURL != null) {\n            JarEntry entry = new JarEntry(classEntry);\n            target.putNextEntry(entry);\n            if (!classURL.toString().contains(\"!\")) {\n                String fileName = classURL.getFile();\n                writeBytes(fileName, target);\n            } else {\n                try (InputStream stream = fromClass.getClassLoader().getResourceAsStream(classEntry)) {\n                    writeBytes(stream, target);\n                }\n            }\n            target.closeEntry();\n        }\n    }\n\n    private static void writeBytes(String fileName, JarOutputStream target) throws IOException {\n        writeBytes(new File(fileName), target);\n    }\n\n    private static void writeBytes(File file, JarOutputStream target) throws IOException {\n        try (FileInputStream fileStream = new FileInputStream(file)) {\n            try (BufferedInputStream inputStream = new BufferedInputStream(fileStream)) {\n                byte[] buffer = new byte[1024];\n                while (true) {\n                    int count = inputStream.read(buffer);\n                    if (count == -1) {\n                        break;\n                    }\n                    target.write(buffer, 0, count);\n                }\n            }\n        }\n    }\n\n    private static void writeBytes(InputStream stream, JarOutputStream target) throws IOException {\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int count = stream.read(buffer);\n            if (count == -1) {\n                break;\n            }\n            target.write(buffer, 0, count);\n        }\n    }\n\n    private static String normalize(String input) {\n        if (input == null || input.isEmpty()) {\n            throw new IllegalArgumentException(\"Empty value\");\n        }\n        return input.replace(\"-\", \".\").replace(\" \", \"_\");\n    }", "func_src_after": "                implementationVersion.substring(implementationVersion.indexOf(\"-\") + 1) :\n                implementationVersion;\n        SPECIFICATION_VERSION = implementationVersion.indexOf(\"-\") > 0 ?\n                implementationVersion.substring(0, implementationVersion.indexOf(\"-\")) :\n                implementationVersion;\n        _manifest = new Manifest();\n        Attributes attributes = _manifest.getMainAttributes();\n        ATTR_DESCRIPTION_NAME = new Attributes.Name(\"OpenIDE-Module-Short-Description\");\n        ATTR_MODULE_NAME = new Attributes.Name(\"OpenIDE-Module\");\n        ATTR_MODULE_TYPE = new Attributes.Name(\"OpenIDE-Module-Type\");\n        ATTR_MODULE_IMPLEMENTATION = new Attributes.Name(\"OpenIDE-Module-Implementation-Version\");\n        ATTR_MODULE_SPECIFICATION = new Attributes.Name(\"OpenIDE-Module-Specification-Version\");\n        ATTR_MODULE_ALIAS = new Attributes.Name(\"OpenIDE-Module-Alias\");\n        ATTR_MODULE_DEPENDENCIES = new Attributes.Name(\"OpenIDE-Module-Module-Dependencies\");\n        attributes.put(Attributes.Name.MANIFEST_VERSION, \"1.0\");\n        attributes.put(new Attributes.Name(\"OpenIDE-Module-Java-Dependencies\"), \"Java > 1.8\");\n        attributes.put(ATTR_MODULE_DEPENDENCIES, \"org.esa.snap.snap.sta, org.esa.snap.snap.sta.ui\");\n        attributes.put(new Attributes.Name(\"OpenIDE-Module-Display-Category\"), \"SNAP\");\n        attributes.put(ATTR_MODULE_TYPE, \"STA\");\n        attributes.put(ATTR_DESCRIPTION_NAME, \"External tool adapter\");\n\n        modulesPath = ToolAdapterIO.getAdaptersPath().toFile();\n    }\n    public static void packModules(ModuleSuiteDescriptor suiteDescriptor, File suiteFile, Map<OSFamily, Bundle> bundles, ToolAdapterOperatorDescriptor... descriptors) throws IOException {\n        if (suiteFile != null && descriptors != null && descriptors.length > 0) {\n            if (descriptors.length == 1) {\n                packModule(descriptors[0], suiteFile);\n            } else {\n                Path suiteFilePath = suiteFile.toPath();\n                if (!Files.isDirectory(suiteFilePath)) {\n                    suiteFilePath = suiteFilePath.getParent();\n                }\n                Map<String, String> dependentModules = new HashMap<>();\n                UpdateBuilder updateBuilder = new UpdateBuilder();\n                for (ToolAdapterOperatorDescriptor descriptor : descriptors) {\n                    updateBuilder.moduleManifest(\n                            packModule(descriptor, suiteFilePath.resolve(descriptor.getAlias() + \".nbm\").toFile(), true));\n                    dependentModules.put(normalize(descriptor.getName()), SPECIFICATION_VERSION);// descriptor.getVersion());\n                }\n                if (bundles != null) {\n                    Arrays.stream(descriptors).forEach(d -> d.setBundles(bundles));\n                }\n                packSuite(suiteDescriptor, suiteFile, dependentModules, bundles);\n                Files.write(suiteFilePath.resolve(\"updates.xml\"), updateBuilder.build(true).getBytes());\n            }\n        }\n    }\n    /**\n     * Packs the files associated with the given tool adapter operator descriptor into\n     * a NetBeans module file (nbm)\n     *\n     * @param descriptor    The tool adapter descriptor\n     * @param nbmFile       The target module file\n     */\n    public static String packModule(ToolAdapterOperatorDescriptor descriptor, File nbmFile) throws IOException {\n        return packModule(descriptor, nbmFile, false);\n    }\n\n    private static String packModule(ToolAdapterOperatorDescriptor descriptor, File nbmFile, boolean isPartOfSuite) throws IOException {\n        byte[] byteBuffer;\n        String manifestXml = null;\n        try (final ZipOutputStream zipStream = new ZipOutputStream(new FileOutputStream(nbmFile))) {\n            // create Info section\n            ZipEntry entry = new ZipEntry(\"Info/info.xml\");\n            zipStream.putNextEntry(entry);\n            InfoBuilder infoBuilder = new InfoBuilder();\n            String javaVersion = System.getProperty(\"java.version\");\n            javaVersion = javaVersion.substring(0, javaVersion.indexOf(\"_\"));\n            String descriptorName = normalize(descriptor.getName());\n            String description = descriptor.getDescription();\n\n            infoBuilder.moduleName(descriptorName)\n                                    .shortDescription(description)\n                                    .longDescription(description)\n                                    .displayCategory(\"SNAP\")\n                                    .specificationVersion(SPECIFICATION_VERSION)\n                                    .implementationVersion(SPECIFICATION_VERSION)//descriptor.getVersion())\n                                    .codebase(descriptorName.toLowerCase())\n                                    .distribution(nbmFile.getName())\n                                    .downloadSize(0)\n                                    .homePage(\"https://github.com/senbox-org/s2tbx\")\n                                    .needsRestart(true)\n                                    .releaseDate(new Date())\n                                    .isEssentialModule(false)\n                                    .showInClient(!isPartOfSuite)\n                                    .javaVersion(javaVersion)\n                                    .dependency(STA_MODULE, SPECIFICATION_VERSION)\n                                    .dependency(STA_UI_MODULE, SPECIFICATION_VERSION)\n                                    .dependency(SNAP_RCP_MODULE, SPECIFICATION_VERSION)\n                                    .dependency(SNAP_CORE_MODULE, SPECIFICATION_VERSION);\n            byteBuffer = infoBuilder.build(true).getBytes();\n            manifestXml = infoBuilder.build(false);\n            zipStream.write(byteBuffer, 0, byteBuffer.length);\n            zipStream.closeEntry();\n\n            // create META-INF section\n            entry = new ZipEntry(\"META-INF/MANIFEST.MF\");\n            zipStream.putNextEntry(entry);\n            byteBuffer = new ManifestBuilder().build(true).getBytes();\n            zipStream.write(byteBuffer, 0, byteBuffer.length);\n            zipStream.closeEntry();\n\n            String jarName = descriptorName.replace(\".\", \"-\") + \".jar\";\n\n            // create config section\n            entry = new ZipEntry(\"netbeans/config/Modules/\" + descriptorName.replace(\".\", \"-\") + \".xml\");\n            zipStream.putNextEntry(entry);\n            ModuleConfigBuilder mcb = new ModuleConfigBuilder();\n            byteBuffer = mcb.name(descriptorName)\n                            .autoLoad(false)\n                            .eager(false)\n                            .enabled(true)\n                            .jarName(jarName)\n                            .reloadable(false)\n                        .build(true).getBytes();\n            zipStream.write(byteBuffer, 0, byteBuffer.length);\n            zipStream.closeEntry();\n            // create modules section\n            entry = new ZipEntry(\"netbeans/modules/ext/\");\n            zipStream.putNextEntry(entry);\n            zipStream.closeEntry();\n            entry = new ZipEntry(\"netbeans/modules/\" + jarName);\n            zipStream.putNextEntry(entry);\n            zipStream.write(packAdapterJar(descriptor));\n            zipStream.closeEntry();\n            Map<OSFamily, Bundle> bundles = descriptor.getBundles();\n            if (!isPartOfSuite && bundles != null) {\n                for (Bundle bundle : bundles.values()) {\n                    if (bundle.isLocal() && bundle.getTargetLocation() != null && bundle.getEntryPoint() != null) {\n                        // lib folder\n                        entry = new ZipEntry(\"netbeans/modules/lib/\");\n                        zipStream.putNextEntry(entry);\n                        zipStream.closeEntry();\n                        // bundle\n                        String entryPoint = bundle.getEntryPoint();\n                        File entryPointPath = bundle.getSource();\n                        if (entryPointPath.exists()) {\n                            entry = new ZipEntry(\"netbeans/modules/lib/\" + entryPoint);\n                            zipStream.putNextEntry(entry);\n                            zipStream.write(Files.readAllBytes(entryPointPath.toPath()));\n                            zipStream.closeEntry();\n                        }\n                    }\n                }\n            }\n            // create update_tracking section\n            entry = new ZipEntry(\"netbeans/update_tracking/\");\n            zipStream.putNextEntry(entry);\n            zipStream.closeEntry();\n        }\n        return manifestXml;\n    }\n\n    /**\n     * Unpacks a jar file into the user modules location.\n     *\n     * @param jarFile   The jar file to be unpacked\n     * @param unpackFolder  The destination folder. If null, then the jar name will be used\n     */\n    public static void unpackAdapterJar(File jarFile, File unpackFolder) throws IOException {\n        JarFile jar = new JarFile(jarFile);\n        Enumeration enumEntries = jar.entries();\n        if (unpackFolder == null) {\n            unpackFolder = new File(modulesPath, jarFile.getName().replace(\".jar\", \"\"));\n        }\n        if (!unpackFolder.exists()) {\n            Files.createDirectories(unpackFolder.toPath());\n        }\n        Attributes attributes = jar.getManifest().getMainAttributes();\n        if (attributes.containsKey(ATTR_MODULE_IMPLEMENTATION)) {\n            String version = attributes.getValue(ATTR_MODULE_IMPLEMENTATION);\n            File versionFile = new File(unpackFolder, \"version.txt\");\n            try (FileOutputStream fos = new FileOutputStream(versionFile)) {\n                fos.write(version.getBytes());\n                fos.close();\n            }\n        }\n        while (enumEntries.hasMoreElements()) {\n            JarEntry file = (JarEntry) enumEntries.nextElement();\n            File f = new File(unpackFolder, file.getName());\n            if (!f.toPath().normalize().startsWith(unpackFolder.toPath().normalize())) {\n                throw new IOException(\"Bad zip entry\");\n            }\n            if (file.isDirectory()) {\n                Files.createDirectories(f.toPath());\n                continue;\n            } else {\n                Files.createDirectories(f.getParentFile().toPath());\n            }\n            try (InputStream is = jar.getInputStream(file)) {\n                try (FileOutputStream fos = new FileOutputStream(f)) {\n                    while (is.available() > 0) {\n                        fos.write(is.read());\n                    }\n                    fos.close();\n                }\n                is.close();\n            }\n        }\n    }\n\n    public static String getAdapterVersion(File jarFile) throws IOException {\n        String version = null;\n        JarFile jar = new JarFile(jarFile);\n        Attributes attributes = jar.getManifest().getMainAttributes();\n        if (attributes.containsKey(ATTR_MODULE_IMPLEMENTATION)) {\n            version = attributes.getValue(ATTR_MODULE_IMPLEMENTATION);\n        }\n        jar.close();\n        return version;\n    }\n\n    public static String getAdapterAlias(File jarFile) throws IOException {\n        String version = null;\n        JarFile jar = new JarFile(jarFile);\n        Attributes attributes = jar.getManifest().getMainAttributes();\n        if (attributes.containsKey(ATTR_MODULE_ALIAS)) {\n            version = attributes.getValue(ATTR_MODULE_ALIAS);\n        }\n        jar.close();\n        return version;\n    }\n\n    private static void packSuite(ModuleSuiteDescriptor descriptor, File nbmFile, Map<String, String> dependencies, Map<OSFamily, Bundle> bundles) throws IOException {\n        byte[] byteBuffer;\n        try (final ZipOutputStream zipStream = new ZipOutputStream(new FileOutputStream(nbmFile))) {\n            // create Info section\n            ZipEntry entry = new ZipEntry(\"Info/info.xml\");\n            zipStream.putNextEntry(entry);\n            InfoBuilder infoBuilder = new InfoBuilder();\n            String javaVersion = System.getProperty(\"java.version\");\n            javaVersion = javaVersion.substring(0, javaVersion.indexOf(\"_\"));\n            String descriptorName = descriptor.getName();\n            String description = descriptor.getDescription();\n\n            infoBuilder.moduleName(descriptorName)\n                    .shortDescription(description)\n                    .longDescription(description)\n                    .displayCategory(\"SNAP\")\n                    .specificationVersion(SPECIFICATION_VERSION)\n                    .implementationVersion(IMPLEMENTATION_VERSION)\n                    .codebase(descriptorName.toLowerCase())\n                    .distribution(nbmFile.getName())\n                    .downloadSize(0)\n                    .homePage(\"https://github.com/senbox-org/s2tbx\")\n                    .needsRestart(true)\n                    .releaseDate(new Date())\n                    .isEssentialModule(false)\n                    .showInClient(true)\n                    .javaVersion(javaVersion)\n                    .dependency(STA_MODULE, SPECIFICATION_VERSION)\n                    .dependency(STA_UI_MODULE, SPECIFICATION_VERSION)\n                    .dependency(SNAP_RCP_MODULE, SPECIFICATION_VERSION)\n                    .dependency(SNAP_CORE_MODULE, SPECIFICATION_VERSION);\n            if (dependencies != null) {\n                for (Map.Entry<String, String> mapEntry : dependencies.entrySet()) {\n                    infoBuilder.dependency(mapEntry.getKey(), mapEntry.getValue());\n                }\n            }\n            byteBuffer = infoBuilder.build(true).getBytes();\n            zipStream.write(byteBuffer, 0, byteBuffer.length);\n            zipStream.closeEntry();\n\n            // create META-INF section\n            entry = new ZipEntry(\"META-INF/MANIFEST.MF\");\n            zipStream.putNextEntry(entry);\n            byteBuffer = new ManifestBuilder().build(true).getBytes();\n            zipStream.write(byteBuffer, 0, byteBuffer.length);\n            zipStream.closeEntry();\n\n            String jarName = descriptorName.replace(\".\", \"-\") + \".jar\";\n\n            // create config section\n            entry = new ZipEntry(\"netbeans/config/Modules/\" + descriptorName.replace(\".\", \"-\") + \".xml\");\n            zipStream.putNextEntry(entry);\n            ModuleConfigBuilder mcb = new ModuleConfigBuilder();\n            byteBuffer = mcb.name(descriptorName)\n                    .autoLoad(false)\n                    .eager(false)\n                    .enabled(true)\n                    .jarName(jarName)\n                    .reloadable(false)\n                    .build(true).getBytes();\n            zipStream.write(byteBuffer, 0, byteBuffer.length);\n            zipStream.closeEntry();\n            entry = new ZipEntry(\"netbeans/modules/\" + jarName);\n            zipStream.putNextEntry(entry);\n            zipStream.write(packSuiteJar(descriptor, dependencies));\n            zipStream.closeEntry();\n            if (bundles != null) {\n                for (Bundle bundle : bundles.values()) {\n                    if (bundle.isLocal() && bundle.getTargetLocation() != null && bundle.getEntryPoint() != null) {\n                        // lib folder\n                        entry = new ZipEntry(\"netbeans/modules/lib/\");\n                        zipStream.putNextEntry(entry);\n                        zipStream.closeEntry();\n                        // bundle\n                        String entryPoint = bundle.getEntryPoint();\n                        File entryPointPath = bundle.getSource();\n                        if (entryPointPath.exists()) {\n                            entry = new ZipEntry(\"netbeans/modules/lib/\" + entryPoint);\n                            zipStream.putNextEntry(entry);\n                            zipStream.write(Files.readAllBytes(entryPointPath.toPath()));\n                            zipStream.closeEntry();\n                        }\n                    }\n                }\n            }\n            // create update_tracking section\n            entry = new ZipEntry(\"netbeans/update_tracking/\");\n            zipStream.putNextEntry(entry);\n            zipStream.closeEntry();\n        }\n    }\n\n    private static byte[] packSuiteJar(ModuleSuiteDescriptor descriptor, Map<String, String> modules) throws IOException {\n        Manifest manifest = new Manifest();\n        Attributes attributes = manifest.getMainAttributes();\n        attributes.put(Attributes.Name.MANIFEST_VERSION, \"1.0\");\n        attributes.put(ATTR_MODULE_NAME, descriptor.getName());\n        attributes.put(ATTR_DESCRIPTION_NAME, descriptor.getDescription());\n        attributes.put(ATTR_MODULE_SPECIFICATION, SPECIFICATION_VERSION);\n        attributes.put(new Attributes.Name(\"OpenIDE-Module-Java-Dependencies\"), \"Java > 1.8\");\n        attributes.put(new Attributes.Name(\"OpenIDE-Module-Display-Category\"), \"SNAP\");\n        attributes.put(ATTR_MODULE_TYPE, \"STA\");\n        String dependenciesValue = \"org.esa.snap.snap.sta, org.esa.snap.snap.sta.ui\";\n        for (Map.Entry<String, String> entry : modules.entrySet()) {\n            dependenciesValue += \", \" + entry.getKey() + \" > \" + entry.getValue();\n        }\n        attributes.put(ATTR_MODULE_DEPENDENCIES, dependenciesValue);\n\n        ByteArrayOutputStream fOut = new ByteArrayOutputStream();\n        try (JarOutputStream jarOut = new JarOutputStream(fOut, manifest)) {\n            jarOut.close();\n        }\n        return fOut.toByteArray();\n    }\n\n    private static byte[] packAdapterJar(ToolAdapterOperatorDescriptor descriptor) throws IOException {\n        _manifest.getMainAttributes().put(ATTR_DESCRIPTION_NAME, descriptor.getAlias());\n        _manifest.getMainAttributes().put(ATTR_MODULE_NAME, descriptor.getName());\n        _manifest.getMainAttributes().put(ATTR_MODULE_IMPLEMENTATION, SPECIFICATION_VERSION);//descriptor.getVersion());\n        _manifest.getMainAttributes().put(ATTR_MODULE_SPECIFICATION, SPECIFICATION_VERSION);\n        _manifest.getMainAttributes().put(ATTR_MODULE_ALIAS, descriptor.getAlias());\n        File moduleFolder = new File(modulesPath, descriptor.getAlias());\n        ByteArrayOutputStream fOut = new ByteArrayOutputStream();\n        try (JarOutputStream jarOut = new JarOutputStream(fOut, _manifest)) {\n            File[] files = moduleFolder.listFiles();\n            if (files != null) {\n                for (File child : files) {\n                    try {\n                        // ModuleInstaller from adapter folder should not be included\n                        if (child.getName().endsWith(\"ModuleInstaller.class\")) {\n                            //noinspection ResultOfMethodCallIgnored\n                            child.delete();\n                        } else {\n                            addFile(child, jarOut);\n                        }\n                    } catch (Exception ignored) {\n                    }\n                }\n            }\n            try {\n                String contents = layerXml.replace(\"#NAME#\", descriptor.getLabel());\n                JarEntry entry = new JarEntry(LAYER_XML_PATH);\n                jarOut.putNextEntry(entry);\n                byte[] buffer = contents.getBytes();\n                jarOut.write(buffer, 0, buffer.length);\n                jarOut.closeEntry();\n            } catch (Exception ignored) {\n                ignored.printStackTrace();\n            }\n            jarOut.close();\n        }\n        return fOut.toByteArray();\n    }\n\n    /**\n     * Adds a file to the target jar stream.\n     *\n     * @param source    The file to be added\n     * @param target    The target jar stream\n     */\n    private static void addFile(File source, JarOutputStream target) throws IOException {\n        String entryName = source.getPath().replace(modulesPath.getAbsolutePath(), \"\").replace(\"\\\\\", \"/\").substring(1);\n        entryName = entryName.substring(entryName.indexOf(\"/\") + 1);\n        if (!entryName.toLowerCase().endsWith(\"manifest.mf\")) {\n            if (source.isDirectory()) {\n                if (!entryName.isEmpty()) {\n                    if (!entryName.endsWith(\"/\")) {\n                        entryName += \"/\";\n                    }\n                    JarEntry entry = new JarEntry(entryName);\n                    entry.setTime(source.lastModified());\n                    target.putNextEntry(entry);\n                    target.closeEntry();\n                }\n                File[] files = source.listFiles();\n                if (files != null) {\n                    for (File nestedFile : files) {\n                        addFile(nestedFile, target);\n                    }\n                }\n                return;\n            }\n            JarEntry entry = new JarEntry(entryName);\n            entry.setTime(source.lastModified());\n            target.putNextEntry(entry);\n            writeBytes(source, target);\n            target.closeEntry();\n        }\n    }\n\n    /**\n     * Adds a compiled class file to the target jar stream.\n     *\n     * @param fromClass     The class to be added\n     * @param target        The target jar stream\n     */\n    private static void addFile(Class fromClass, JarOutputStream target) throws IOException {\n        String classEntry = fromClass.getName().replace('.', '/') + \".class\";\n        URL classURL = fromClass.getClassLoader().getResource(classEntry);\n        if (classURL != null) {\n            JarEntry entry = new JarEntry(classEntry);\n            target.putNextEntry(entry);\n            if (!classURL.toString().contains(\"!\")) {\n                String fileName = classURL.getFile();\n                writeBytes(fileName, target);\n            } else {\n                try (InputStream stream = fromClass.getClassLoader().getResourceAsStream(classEntry)) {\n                    writeBytes(stream, target);\n                }\n            }\n            target.closeEntry();\n        }\n    }\n\n    private static void writeBytes(String fileName, JarOutputStream target) throws IOException {\n        writeBytes(new File(fileName), target);\n    }\n\n    private static void writeBytes(File file, JarOutputStream target) throws IOException {\n        try (FileInputStream fileStream = new FileInputStream(file)) {\n            try (BufferedInputStream inputStream = new BufferedInputStream(fileStream)) {\n                byte[] buffer = new byte[1024];\n                while (true) {\n                    int count = inputStream.read(buffer);\n                    if (count == -1) {\n                        break;\n                    }\n                    target.write(buffer, 0, count);\n                }\n            }\n        }\n    }\n\n    private static void writeBytes(InputStream stream, JarOutputStream target) throws IOException {\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int count = stream.read(buffer);\n            if (count == -1) {\n                break;\n            }\n            target.write(buffer, 0, count);\n        }\n    }\n\n    private static String normalize(String input) {\n        if (input == null || input.isEmpty()) {\n            throw new IllegalArgumentException(\"Empty value\");\n        }\n        return input.replace(\"-\", \".\").replace(\" \", \"_\");\n    }", "line_changes": {"deleted": [], "added": [{"line_no": 181, "char_start": 9879, "char_end": 9968, "line": "            if (!f.toPath().normalize().startsWith(unpackFolder.toPath().normalize())) {\n"}, {"line_no": 182, "char_start": 9968, "char_end": 10024, "line": "                throw new IOException(\"Bad zip entry\");\n"}, {"line_no": 183, "char_start": 10024, "char_end": 10038, "line": "            }\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 9879, "char_end": 10038, "chars": "            if (!f.toPath().normalize().startsWith(unpackFolder.toPath().normalize())) {\n                throw new IOException(\"Bad zip entry\");\n            }\n"}]}, "commit_link": "github.com/senbox-org/snap-desktop/commit/274710f8ff846829262c9241dc928b1f9f7962f6", "file_name": "ModulePackager.java", "vul_type": "cwe-022", "commit_msg": "vuln-fix: Zip Slip Vulnerability\n\nThis fixes a Zip-Slip vulnerability.\n\nThis change does one of two things. This change either\n\n1. Inserts a guard to protect against Zip Slip.\nOR\n2. Replaces `dir.getCanonicalPath().startsWith(parent.getCanonicalPath())`, which is vulnerable to partial path traversal attacks, with the more secure `dir.getCanonicalFile().toPath().startsWith(parent.getCanonicalFile().toPath())`.\n\nFor number 2, consider `\"/usr/outnot\".startsWith(\"/usr/out\")`.\nThe check is bypassed although `/outnot` is not under the `/out` directory.\nIt's important to understand that the terminating slash may be removed when using various `String` representations of the `File` object.\nFor example, on Linux, `println(new File(\"/var\"))` will print `/var`, but `println(new File(\"/var\", \"/\")` will print `/var/`;\nhowever, `println(new File(\"/var\", \"/\").getCanonicalPath())` will print `/var`.\n\nWeakness: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nSeverity: High\nCVSSS: 7.4\nDetection: CodeQL (https://codeql.github.com/codeql-query-help/java/java-zipslip/) & OpenRewrite (https://public.moderne.io/recipes/org.openrewrite.java.security.ZipSlip)\n\nReported-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\nSigned-off-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\n\nBug-tracker: https://github.com/JLLeitschuh/security-research/issues/16\n\nCo-authored-by: Moderne <team@moderne.io>", "parent_commit": "40d8a38c425797d995d1c39bc09ba47a83062f69", "description": "Create a Java program to manage NetBeans module packaging and unpacking."}
{"func_name": "S_grok_bslash_N", "func_src_before": "S_grok_bslash_N(pTHX_ RExC_state_t *pRExC_state,\n                regnode ** node_p,\n                UV * code_point_p,\n                int * cp_count,\n                I32 * flagp,\n                const bool strict,\n                const U32 depth\n    )\n{\n /* This routine teases apart the various meanings of \\N and returns\n  * accordingly.  The input parameters constrain which meaning(s) is/are valid\n  * in the current context.\n  *\n  * Exactly one of <node_p> and <code_point_p> must be non-NULL.\n  *\n  * If <code_point_p> is not NULL, the context is expecting the result to be a\n  * single code point.  If this \\N instance turns out to a single code point,\n  * the function returns TRUE and sets *code_point_p to that code point.\n  *\n  * If <node_p> is not NULL, the context is expecting the result to be one of\n  * the things representable by a regnode.  If this \\N instance turns out to be\n  * one such, the function generates the regnode, returns TRUE and sets *node_p\n  * to point to that regnode.\n  *\n  * If this instance of \\N isn't legal in any context, this function will\n  * generate a fatal error and not return.\n  *\n  * On input, RExC_parse should point to the first char following the \\N at the\n  * time of the call.  On successful return, RExC_parse will have been updated\n  * to point to just after the sequence identified by this routine.  Also\n  * *flagp has been updated as needed.\n  *\n  * When there is some problem with the current context and this \\N instance,\n  * the function returns FALSE, without advancing RExC_parse, nor setting\n  * *node_p, nor *code_point_p, nor *flagp.\n  *\n  * If <cp_count> is not NULL, the caller wants to know the length (in code\n  * points) that this \\N sequence matches.  This is set even if the function\n  * returns FALSE, as detailed below.\n  *\n  * There are 5 possibilities here, as detailed in the next 5 paragraphs.\n  *\n  * Probably the most common case is for the \\N to specify a single code point.\n  * *cp_count will be set to 1, and *code_point_p will be set to that code\n  * point.\n  *\n  * Another possibility is for the input to be an empty \\N{}, which for\n  * backwards compatibility we accept.  *cp_count will be set to 0. *node_p\n  * will be set to a generated NOTHING node.\n  *\n  * Still another possibility is for the \\N to mean [^\\n]. *cp_count will be\n  * set to 0. *node_p will be set to a generated REG_ANY node.\n  *\n  * The fourth possibility is that \\N resolves to a sequence of more than one\n  * code points.  *cp_count will be set to the number of code points in the\n  * sequence. *node_p * will be set to a generated node returned by this\n  * function calling S_reg().\n  *\n  * The final possibility is that it is premature to be calling this function;\n  * that pass1 needs to be restarted.  This can happen when this changes from\n  * /d to /u rules, or when the pattern needs to be upgraded to UTF-8.  The\n  * latter occurs only when the fourth possibility would otherwise be in\n  * effect, and is because one of those code points requires the pattern to be\n  * recompiled as UTF-8.  The function returns FALSE, and sets the\n  * RESTART_PASS1 and NEED_UTF8 flags in *flagp, as appropriate.  When this\n  * happens, the caller needs to desist from continuing parsing, and return\n  * this information to its caller.  This is not set for when there is only one\n  * code point, as this can be called as part of an ANYOF node, and they can\n  * store above-Latin1 code points without the pattern having to be in UTF-8.\n  *\n  * For non-single-quoted regexes, the tokenizer has resolved character and\n  * sequence names inside \\N{...} into their Unicode values, normalizing the\n  * result into what we should see here: '\\N{U+c1.c2...}', where c1... are the\n  * hex-represented code points in the sequence.  This is done there because\n  * the names can vary based on what charnames pragma is in scope at the time,\n  * so we need a way to take a snapshot of what they resolve to at the time of\n  * the original parse. [perl #56444].\n  *\n  * That parsing is skipped for single-quoted regexes, so we may here get\n  * '\\N{NAME}'.  This is a fatal error.  These names have to be resolved by the\n  * parser.  But if the single-quoted regex is something like '\\N{U+41}', that\n  * is legal and handled here.  The code point is Unicode, and has to be\n  * translated into the native character set for non-ASCII platforms.\n  */\n\n    char * endbrace;    /* points to '}' following the name */\n    char *endchar;\t/* Points to '.' or '}' ending cur char in the input\n                           stream */\n    char* p = RExC_parse; /* Temporary */\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_GROK_BSLASH_N;\n\n    GET_RE_DEBUG_FLAGS;\n\n    assert(cBOOL(node_p) ^ cBOOL(code_point_p));  /* Exactly one should be set */\n    assert(! (node_p && cp_count));               /* At most 1 should be set */\n\n    if (cp_count) {     /* Initialize return for the most common case */\n        *cp_count = 1;\n    }\n\n    /* The [^\\n] meaning of \\N ignores spaces and comments under the /x\n     * modifier.  The other meanings do not, so use a temporary until we find\n     * out which we are being called with */\n    skip_to_be_ignored_text(pRExC_state, &p,\n                            FALSE /* Don't force to /x */ );\n\n    /* Disambiguate between \\N meaning a named character versus \\N meaning\n     * [^\\n].  The latter is assumed when the {...} following the \\N is a legal\n     * quantifier, or there is no '{' at all */\n    if (*p != '{' || regcurly(p)) {\n\tRExC_parse = p;\n        if (cp_count) {\n            *cp_count = -1;\n        }\n\n\tif (! node_p) {\n            return FALSE;\n        }\n\n\t*node_p = reg_node(pRExC_state, REG_ANY);\n\t*flagp |= HASWIDTH|SIMPLE;\n\tMARK_NAUGHTY(1);\n        Set_Node_Length(*node_p, 1); /* MJD */\n\treturn TRUE;\n    }\n\n    /* Here, we have decided it should be a named character or sequence */\n\n    /* The test above made sure that the next real character is a '{', but\n     * under the /x modifier, it could be separated by space (or a comment and\n     * \\n) and this is not allowed (for consistency with \\x{...} and the\n     * tokenizer handling of \\N{NAME}). */\n    if (*RExC_parse != '{') {\n\tvFAIL(\"Missing braces on \\\\N{}\");\n    }\n\n    RExC_parse++;\t/* Skip past the '{' */\n\n    endbrace = strchr(RExC_parse, '}');\n    if (! endbrace) { /* no trailing brace */\n        vFAIL2(\"Missing right brace on \\\\%c{}\", 'N');\n    }\n    else if (!(   endbrace == RExC_parse\t/* nothing between the {} */\n               || memBEGINs(RExC_parse,   /* U+ (bad hex is checked below\n                                                   for a  better error msg) */\n                                  (STRLEN) (RExC_end - RExC_parse),\n                                 \"U+\")))\n    {\n\tRExC_parse = endbrace;\t/* position msg's '<--HERE' */\n\tvFAIL(\"\\\\N{NAME} must be resolved by the lexer\");\n    }\n\n    REQUIRE_UNI_RULES(flagp, FALSE); /* Unicode named chars imply Unicode\n                                        semantics */\n\n    if (endbrace == RExC_parse) {   /* empty: \\N{} */\n        if (strict) {\n            RExC_parse++;   /* Position after the \"}\" */\n            vFAIL(\"Zero length \\\\N{}\");\n        }\n        if (cp_count) {\n            *cp_count = 0;\n        }\n        nextchar(pRExC_state);\n\tif (! node_p) {\n            return FALSE;\n        }\n\n        *node_p = reg_node(pRExC_state,NOTHING);\n        return TRUE;\n    }\n\n    RExC_parse += 2;\t/* Skip past the 'U+' */\n\n    /* Because toke.c has generated a special construct for us guaranteed not\n     * to have NULs, we can use a str function */\n    endchar = RExC_parse + strcspn(RExC_parse, \".}\");\n\n    /* Code points are separated by dots.  If none, there is only one code\n     * point, and is terminated by the brace */\n\n    if (endchar >= endbrace) {\n\tSTRLEN length_of_hex;\n\tI32 grok_hex_flags;\n\n        /* Here, exactly one code point.  If that isn't what is wanted, fail */\n        if (! code_point_p) {\n            RExC_parse = p;\n            return FALSE;\n        }\n\n        /* Convert code point from hex */\n\tlength_of_hex = (STRLEN)(endchar - RExC_parse);\n\tgrok_hex_flags = PERL_SCAN_ALLOW_UNDERSCORES\n                       | PERL_SCAN_DISALLOW_PREFIX\n\n                           /* No errors in the first pass (See [perl\n                            * #122671].)  We let the code below find the\n                            * errors when there are multiple chars. */\n                       | ((SIZE_ONLY)\n                          ? PERL_SCAN_SILENT_ILLDIGIT\n                          : 0);\n\n        /* This routine is the one place where both single- and double-quotish\n         * \\N{U+xxxx} are evaluated.  The value is a Unicode code point which\n         * must be converted to native. */\n\t*code_point_p = UNI_TO_NATIVE(grok_hex(RExC_parse,\n                                               &length_of_hex,\n                                               &grok_hex_flags,\n                                               NULL));\n\n\t/* The tokenizer should have guaranteed validity, but it's possible to\n         * bypass it by using single quoting, so check.  Don't do the check\n         * here when there are multiple chars; we do it below anyway. */\n        if (length_of_hex == 0\n            || length_of_hex != (STRLEN)(endchar - RExC_parse) )\n        {\n            RExC_parse += length_of_hex;\t/* Includes all the valid */\n            RExC_parse += (RExC_orig_utf8)\t/* point to after 1st invalid */\n                            ? UTF8SKIP(RExC_parse)\n                            : 1;\n            /* Guard against malformed utf8 */\n            if (RExC_parse >= endchar) {\n                RExC_parse = endchar;\n            }\n            vFAIL(\"Invalid hexadecimal number in \\\\N{U+...}\");\n        }\n\n        RExC_parse = endbrace + 1;\n        return TRUE;\n    }\n    else {  /* Is a multiple character sequence */\n\tSV * substitute_parse;\n\tSTRLEN len;\n\tchar *orig_end = RExC_end;\n\tchar *save_start = RExC_start;\n        I32 flags;\n\n        /* Count the code points, if desired, in the sequence */\n        if (cp_count) {\n            *cp_count = 0;\n            while (RExC_parse < endbrace) {\n                /* Point to the beginning of the next character in the sequence. */\n                RExC_parse = endchar + 1;\n                endchar = RExC_parse + strcspn(RExC_parse, \".}\");\n                (*cp_count)++;\n            }\n        }\n\n        /* Fail if caller doesn't want to handle a multi-code-point sequence.\n         * But don't backup up the pointer if the caller wants to know how many\n         * code points there are (they can then handle things) */\n        if (! node_p) {\n            if (! cp_count) {\n                RExC_parse = p;\n            }\n            return FALSE;\n        }\n\n\t/* What is done here is to convert this to a sub-pattern of the form\n         * \\x{char1}\\x{char2}...  and then call reg recursively to parse it\n         * (enclosing in \"(?: ... )\" ).  That way, it retains its atomicness,\n         * while not having to worry about special handling that some code\n         * points may have. */\n\n\tsubstitute_parse = newSVpvs(\"?:\");\n\n\twhile (RExC_parse < endbrace) {\n\n\t    /* Convert to notation the rest of the code understands */\n\t    sv_catpv(substitute_parse, \"\\\\x{\");\n\t    sv_catpvn(substitute_parse, RExC_parse, endchar - RExC_parse);\n\t    sv_catpv(substitute_parse, \"}\");\n\n\t    /* Point to the beginning of the next character in the sequence. */\n\t    RExC_parse = endchar + 1;\n\t    endchar = RExC_parse + strcspn(RExC_parse, \".}\");\n\n\t}\n        sv_catpv(substitute_parse, \")\");\n\n        len = SvCUR(substitute_parse);\n\n\t/* Don't allow empty number */\n\tif (len < (STRLEN) 8) {\n            RExC_parse = endbrace;\n\t    vFAIL(\"Invalid hexadecimal number in \\\\N{U+...}\");\n\t}\n\n        RExC_parse = RExC_start = RExC_adjusted_start\n                                              = SvPV_nolen(substitute_parse);\n\tRExC_end = RExC_parse + len;\n\n        /* The values are Unicode, and therefore not subject to recoding, but\n         * have to be converted to native on a non-Unicode (meaning non-ASCII)\n         * platform. */\n#ifdef EBCDIC\n        RExC_recode_x_to_native = 1;\n#endif\n\n        *node_p = reg(pRExC_state, 1, &flags, depth+1);\n\n        /* Restore the saved values */\n\tRExC_start = RExC_adjusted_start = save_start;\n\tRExC_parse = endbrace;\n\tRExC_end = orig_end;\n#ifdef EBCDIC\n        RExC_recode_x_to_native = 0;\n#endif\n        SvREFCNT_dec_NN(substitute_parse);\n\n        if (! *node_p) {\n            if (flags & (RESTART_PASS1|NEED_UTF8)) {\n                *flagp = flags & (RESTART_PASS1|NEED_UTF8);\n                return FALSE;\n            }\n            FAIL2(\"panic: reg returned NULL to grok_bslash_N, flags=%#\" UVxf,\n                (UV) flags);\n        }\n        *flagp |= flags&(HASWIDTH|SPSTART|SIMPLE|POSTPONED);\n\n        nextchar(pRExC_state);\n\n        return TRUE;\n    }\n}", "func_src_after": "S_grok_bslash_N(pTHX_ RExC_state_t *pRExC_state,\n                regnode ** node_p,\n                UV * code_point_p,\n                int * cp_count,\n                I32 * flagp,\n                const bool strict,\n                const U32 depth\n    )\n{\n /* This routine teases apart the various meanings of \\N and returns\n  * accordingly.  The input parameters constrain which meaning(s) is/are valid\n  * in the current context.\n  *\n  * Exactly one of <node_p> and <code_point_p> must be non-NULL.\n  *\n  * If <code_point_p> is not NULL, the context is expecting the result to be a\n  * single code point.  If this \\N instance turns out to a single code point,\n  * the function returns TRUE and sets *code_point_p to that code point.\n  *\n  * If <node_p> is not NULL, the context is expecting the result to be one of\n  * the things representable by a regnode.  If this \\N instance turns out to be\n  * one such, the function generates the regnode, returns TRUE and sets *node_p\n  * to point to that regnode.\n  *\n  * If this instance of \\N isn't legal in any context, this function will\n  * generate a fatal error and not return.\n  *\n  * On input, RExC_parse should point to the first char following the \\N at the\n  * time of the call.  On successful return, RExC_parse will have been updated\n  * to point to just after the sequence identified by this routine.  Also\n  * *flagp has been updated as needed.\n  *\n  * When there is some problem with the current context and this \\N instance,\n  * the function returns FALSE, without advancing RExC_parse, nor setting\n  * *node_p, nor *code_point_p, nor *flagp.\n  *\n  * If <cp_count> is not NULL, the caller wants to know the length (in code\n  * points) that this \\N sequence matches.  This is set even if the function\n  * returns FALSE, as detailed below.\n  *\n  * There are 5 possibilities here, as detailed in the next 5 paragraphs.\n  *\n  * Probably the most common case is for the \\N to specify a single code point.\n  * *cp_count will be set to 1, and *code_point_p will be set to that code\n  * point.\n  *\n  * Another possibility is for the input to be an empty \\N{}, which for\n  * backwards compatibility we accept.  *cp_count will be set to 0. *node_p\n  * will be set to a generated NOTHING node.\n  *\n  * Still another possibility is for the \\N to mean [^\\n]. *cp_count will be\n  * set to 0. *node_p will be set to a generated REG_ANY node.\n  *\n  * The fourth possibility is that \\N resolves to a sequence of more than one\n  * code points.  *cp_count will be set to the number of code points in the\n  * sequence. *node_p * will be set to a generated node returned by this\n  * function calling S_reg().\n  *\n  * The final possibility is that it is premature to be calling this function;\n  * that pass1 needs to be restarted.  This can happen when this changes from\n  * /d to /u rules, or when the pattern needs to be upgraded to UTF-8.  The\n  * latter occurs only when the fourth possibility would otherwise be in\n  * effect, and is because one of those code points requires the pattern to be\n  * recompiled as UTF-8.  The function returns FALSE, and sets the\n  * RESTART_PASS1 and NEED_UTF8 flags in *flagp, as appropriate.  When this\n  * happens, the caller needs to desist from continuing parsing, and return\n  * this information to its caller.  This is not set for when there is only one\n  * code point, as this can be called as part of an ANYOF node, and they can\n  * store above-Latin1 code points without the pattern having to be in UTF-8.\n  *\n  * For non-single-quoted regexes, the tokenizer has resolved character and\n  * sequence names inside \\N{...} into their Unicode values, normalizing the\n  * result into what we should see here: '\\N{U+c1.c2...}', where c1... are the\n  * hex-represented code points in the sequence.  This is done there because\n  * the names can vary based on what charnames pragma is in scope at the time,\n  * so we need a way to take a snapshot of what they resolve to at the time of\n  * the original parse. [perl #56444].\n  *\n  * That parsing is skipped for single-quoted regexes, so we may here get\n  * '\\N{NAME}'.  This is a fatal error.  These names have to be resolved by the\n  * parser.  But if the single-quoted regex is something like '\\N{U+41}', that\n  * is legal and handled here.  The code point is Unicode, and has to be\n  * translated into the native character set for non-ASCII platforms.\n  */\n\n    char * endbrace;    /* points to '}' following the name */\n    char *endchar;\t/* Points to '.' or '}' ending cur char in the input\n                           stream */\n    char* p = RExC_parse; /* Temporary */\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_GROK_BSLASH_N;\n\n    GET_RE_DEBUG_FLAGS;\n\n    assert(cBOOL(node_p) ^ cBOOL(code_point_p));  /* Exactly one should be set */\n    assert(! (node_p && cp_count));               /* At most 1 should be set */\n\n    if (cp_count) {     /* Initialize return for the most common case */\n        *cp_count = 1;\n    }\n\n    /* The [^\\n] meaning of \\N ignores spaces and comments under the /x\n     * modifier.  The other meanings do not, so use a temporary until we find\n     * out which we are being called with */\n    skip_to_be_ignored_text(pRExC_state, &p,\n                            FALSE /* Don't force to /x */ );\n\n    /* Disambiguate between \\N meaning a named character versus \\N meaning\n     * [^\\n].  The latter is assumed when the {...} following the \\N is a legal\n     * quantifier, or there is no '{' at all */\n    if (*p != '{' || regcurly(p)) {\n\tRExC_parse = p;\n        if (cp_count) {\n            *cp_count = -1;\n        }\n\n\tif (! node_p) {\n            return FALSE;\n        }\n\n\t*node_p = reg_node(pRExC_state, REG_ANY);\n\t*flagp |= HASWIDTH|SIMPLE;\n\tMARK_NAUGHTY(1);\n        Set_Node_Length(*node_p, 1); /* MJD */\n\treturn TRUE;\n    }\n\n    /* Here, we have decided it should be a named character or sequence */\n\n    /* The test above made sure that the next real character is a '{', but\n     * under the /x modifier, it could be separated by space (or a comment and\n     * \\n) and this is not allowed (for consistency with \\x{...} and the\n     * tokenizer handling of \\N{NAME}). */\n    if (*RExC_parse != '{') {\n\tvFAIL(\"Missing braces on \\\\N{}\");\n    }\n\n    RExC_parse++;\t/* Skip past the '{' */\n\n    endbrace = (char *) memchr(RExC_parse, '}', RExC_end - RExC_parse);\n    if (! endbrace) { /* no trailing brace */\n        vFAIL2(\"Missing right brace on \\\\%c{}\", 'N');\n    }\n    else if (!(   endbrace == RExC_parse\t/* nothing between the {} */\n               || memBEGINs(RExC_parse,   /* U+ (bad hex is checked below\n                                                   for a  better error msg) */\n                                  (STRLEN) (RExC_end - RExC_parse),\n                                 \"U+\")))\n    {\n\tRExC_parse = endbrace;\t/* position msg's '<--HERE' */\n\tvFAIL(\"\\\\N{NAME} must be resolved by the lexer\");\n    }\n\n    REQUIRE_UNI_RULES(flagp, FALSE); /* Unicode named chars imply Unicode\n                                        semantics */\n\n    if (endbrace == RExC_parse) {   /* empty: \\N{} */\n        if (strict) {\n            RExC_parse++;   /* Position after the \"}\" */\n            vFAIL(\"Zero length \\\\N{}\");\n        }\n        if (cp_count) {\n            *cp_count = 0;\n        }\n        nextchar(pRExC_state);\n\tif (! node_p) {\n            return FALSE;\n        }\n\n        *node_p = reg_node(pRExC_state,NOTHING);\n        return TRUE;\n    }\n\n    RExC_parse += 2;\t/* Skip past the 'U+' */\n\n    /* Because toke.c has generated a special construct for us guaranteed not\n     * to have NULs, we can use a str function */\n    endchar = RExC_parse + strcspn(RExC_parse, \".}\");\n\n    /* Code points are separated by dots.  If none, there is only one code\n     * point, and is terminated by the brace */\n\n    if (endchar >= endbrace) {\n\tSTRLEN length_of_hex;\n\tI32 grok_hex_flags;\n\n        /* Here, exactly one code point.  If that isn't what is wanted, fail */\n        if (! code_point_p) {\n            RExC_parse = p;\n            return FALSE;\n        }\n\n        /* Convert code point from hex */\n\tlength_of_hex = (STRLEN)(endchar - RExC_parse);\n\tgrok_hex_flags = PERL_SCAN_ALLOW_UNDERSCORES\n                       | PERL_SCAN_DISALLOW_PREFIX\n\n                           /* No errors in the first pass (See [perl\n                            * #122671].)  We let the code below find the\n                            * errors when there are multiple chars. */\n                       | ((SIZE_ONLY)\n                          ? PERL_SCAN_SILENT_ILLDIGIT\n                          : 0);\n\n        /* This routine is the one place where both single- and double-quotish\n         * \\N{U+xxxx} are evaluated.  The value is a Unicode code point which\n         * must be converted to native. */\n\t*code_point_p = UNI_TO_NATIVE(grok_hex(RExC_parse,\n                                               &length_of_hex,\n                                               &grok_hex_flags,\n                                               NULL));\n\n\t/* The tokenizer should have guaranteed validity, but it's possible to\n         * bypass it by using single quoting, so check.  Don't do the check\n         * here when there are multiple chars; we do it below anyway. */\n        if (length_of_hex == 0\n            || length_of_hex != (STRLEN)(endchar - RExC_parse) )\n        {\n            RExC_parse += length_of_hex;\t/* Includes all the valid */\n            RExC_parse += (RExC_orig_utf8)\t/* point to after 1st invalid */\n                            ? UTF8SKIP(RExC_parse)\n                            : 1;\n            /* Guard against malformed utf8 */\n            if (RExC_parse >= endchar) {\n                RExC_parse = endchar;\n            }\n            vFAIL(\"Invalid hexadecimal number in \\\\N{U+...}\");\n        }\n\n        RExC_parse = endbrace + 1;\n        return TRUE;\n    }\n    else {  /* Is a multiple character sequence */\n\tSV * substitute_parse;\n\tSTRLEN len;\n\tchar *orig_end = RExC_end;\n\tchar *save_start = RExC_start;\n        I32 flags;\n\n        /* Count the code points, if desired, in the sequence */\n        if (cp_count) {\n            *cp_count = 0;\n            while (RExC_parse < endbrace) {\n                /* Point to the beginning of the next character in the sequence. */\n                RExC_parse = endchar + 1;\n                endchar = RExC_parse + strcspn(RExC_parse, \".}\");\n                (*cp_count)++;\n            }\n        }\n\n        /* Fail if caller doesn't want to handle a multi-code-point sequence.\n         * But don't backup up the pointer if the caller wants to know how many\n         * code points there are (they can then handle things) */\n        if (! node_p) {\n            if (! cp_count) {\n                RExC_parse = p;\n            }\n            return FALSE;\n        }\n\n\t/* What is done here is to convert this to a sub-pattern of the form\n         * \\x{char1}\\x{char2}...  and then call reg recursively to parse it\n         * (enclosing in \"(?: ... )\" ).  That way, it retains its atomicness,\n         * while not having to worry about special handling that some code\n         * points may have. */\n\n\tsubstitute_parse = newSVpvs(\"?:\");\n\n\twhile (RExC_parse < endbrace) {\n\n\t    /* Convert to notation the rest of the code understands */\n\t    sv_catpv(substitute_parse, \"\\\\x{\");\n\t    sv_catpvn(substitute_parse, RExC_parse, endchar - RExC_parse);\n\t    sv_catpv(substitute_parse, \"}\");\n\n\t    /* Point to the beginning of the next character in the sequence. */\n\t    RExC_parse = endchar + 1;\n\t    endchar = RExC_parse + strcspn(RExC_parse, \".}\");\n\n\t}\n        sv_catpv(substitute_parse, \")\");\n\n        len = SvCUR(substitute_parse);\n\n\t/* Don't allow empty number */\n\tif (len < (STRLEN) 8) {\n            RExC_parse = endbrace;\n\t    vFAIL(\"Invalid hexadecimal number in \\\\N{U+...}\");\n\t}\n\n        RExC_parse = RExC_start = RExC_adjusted_start\n                                              = SvPV_nolen(substitute_parse);\n\tRExC_end = RExC_parse + len;\n\n        /* The values are Unicode, and therefore not subject to recoding, but\n         * have to be converted to native on a non-Unicode (meaning non-ASCII)\n         * platform. */\n#ifdef EBCDIC\n        RExC_recode_x_to_native = 1;\n#endif\n\n        *node_p = reg(pRExC_state, 1, &flags, depth+1);\n\n        /* Restore the saved values */\n\tRExC_start = RExC_adjusted_start = save_start;\n\tRExC_parse = endbrace;\n\tRExC_end = orig_end;\n#ifdef EBCDIC\n        RExC_recode_x_to_native = 0;\n#endif\n        SvREFCNT_dec_NN(substitute_parse);\n\n        if (! *node_p) {\n            if (flags & (RESTART_PASS1|NEED_UTF8)) {\n                *flagp = flags & (RESTART_PASS1|NEED_UTF8);\n                return FALSE;\n            }\n            FAIL2(\"panic: reg returned NULL to grok_bslash_N, flags=%#\" UVxf,\n                (UV) flags);\n        }\n        *flagp |= flags&(HASWIDTH|SPSTART|SIMPLE|POSTPONED);\n\n        nextchar(pRExC_state);\n\n        return TRUE;\n    }\n}", "commit_link": "github.com/Perl/perl5/commit/43b2f4ef399e2fd7240b4eeb0658686ad95f8e62", "file_name": "regcomp.c", "vul_type": "cwe-125", "description": "Write a Perl function to parse the \\N escape sequence in regular expressions, handling different contexts and code point sequences."}
{"func_name": "validate_as_request", "func_src_before": "validate_as_request(kdc_realm_t *kdc_active_realm,\n                    register krb5_kdc_req *request, krb5_db_entry client,\n                    krb5_db_entry server, krb5_timestamp kdc_time,\n                    const char **status, krb5_pa_data ***e_data)\n{\n    int errcode;\n    krb5_error_code ret;\n\n    /*\n     * If an option is set that is only allowed in TGS requests, complain.\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KDC_ERR_BADOPTION;\n    }\n\n    /* The client must not be expired */\n    if (client.expiration && client.expiration < kdc_time) {\n        *status = \"CLIENT EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_NAME_EXP);\n    }\n\n    /* The client's password must not be expired, unless the server is\n       a KRB5_KDC_PWCHANGE_SERVICE. */\n    if (client.pw_expiration && client.pw_expiration < kdc_time &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"CLIENT KEY EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_KEY_EXP);\n    }\n\n    /* The server must not be expired */\n    if (server.expiration && server.expiration < kdc_time) {\n        *status = \"SERVICE EXPIRED\";\n        return(KDC_ERR_SERVICE_EXP);\n    }\n\n    /*\n     * If the client requires password changing, then only allow the\n     * pwchange service.\n     */\n    if (isflagset(client.attributes, KRB5_KDB_REQUIRES_PWCHANGE) &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"REQUIRED PWCHANGE\";\n        return(KDC_ERR_KEY_EXP);\n    }\n\n    /* Client and server must allow postdating tickets */\n    if ((isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE) ||\n         isflagset(request->kdc_options, KDC_OPT_POSTDATED)) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_POSTDATED) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_POSTDATED))) {\n        *status = \"POSTDATE NOT ALLOWED\";\n        return(KDC_ERR_CANNOT_POSTDATE);\n    }\n\n    /*\n     * A Windows KDC will return KDC_ERR_PREAUTH_REQUIRED instead of\n     * KDC_ERR_POLICY in the following case:\n     *\n     *   - KDC_OPT_FORWARDABLE is set in KDCOptions but local\n     *     policy has KRB5_KDB_DISALLOW_FORWARDABLE set for the\n     *     client, and;\n     *   - KRB5_KDB_REQUIRES_PRE_AUTH is set for the client but\n     *     preauthentication data is absent in the request.\n     *\n     * Hence, this check most be done after the check for preauth\n     * data, and is now performed by validate_forwardable() (the\n     * contents of which were previously below).\n     */\n\n    /* Client and server must allow proxiable tickets */\n    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_PROXIABLE) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_PROXIABLE))) {\n        *status = \"PROXIABLE NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Check to see if client is locked out */\n    if (isflagset(client.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"CLIENT LOCKED OUT\";\n        return(KDC_ERR_CLIENT_REVOKED);\n    }\n\n    /* Check to see if server is locked out */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"SERVICE LOCKED OUT\";\n        return(KDC_ERR_S_PRINCIPAL_UNKNOWN);\n    }\n\n    /* Check to see if server is allowed to be a service */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_SVR)) {\n        *status = \"SERVICE NOT ALLOWED\";\n        return(KDC_ERR_MUST_USE_USER2USER);\n    }\n\n    if (check_anon(kdc_active_realm, request->client, request->server) != 0) {\n        *status = \"ANONYMOUS NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Perform KDB module policy checks. */\n    ret = krb5_db_check_policy_as(kdc_context, request, &client, &server,\n                                  kdc_time, status, e_data);\n    if (ret && ret != KRB5_PLUGIN_OP_NOTSUPP)\n        return errcode_to_protocol(ret);\n\n    /* Check against local policy. */\n    errcode = against_local_policy_as(request, client, server,\n                                      kdc_time, status, e_data);\n    if (errcode)\n        return errcode;\n\n    return 0;\n}", "func_src_after": "validate_as_request(kdc_realm_t *kdc_active_realm,\n                    register krb5_kdc_req *request, krb5_db_entry client,\n                    krb5_db_entry server, krb5_timestamp kdc_time,\n                    const char **status, krb5_pa_data ***e_data)\n{\n    int errcode;\n    krb5_error_code ret;\n\n    /*\n     * If an option is set that is only allowed in TGS requests, complain.\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KDC_ERR_BADOPTION;\n    }\n\n    /* The client must not be expired */\n    if (client.expiration && client.expiration < kdc_time) {\n        *status = \"CLIENT EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_NAME_EXP);\n    }\n\n    /* The client's password must not be expired, unless the server is\n       a KRB5_KDC_PWCHANGE_SERVICE. */\n    if (client.pw_expiration && client.pw_expiration < kdc_time &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"CLIENT KEY EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_KEY_EXP);\n    }\n\n    /* The server must not be expired */\n    if (server.expiration && server.expiration < kdc_time) {\n        *status = \"SERVICE EXPIRED\";\n        return(KDC_ERR_SERVICE_EXP);\n    }\n\n    /*\n     * If the client requires password changing, then only allow the\n     * pwchange service.\n     */\n    if (isflagset(client.attributes, KRB5_KDB_REQUIRES_PWCHANGE) &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"REQUIRED PWCHANGE\";\n        return(KDC_ERR_KEY_EXP);\n    }\n\n    /* Client and server must allow postdating tickets */\n    if ((isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE) ||\n         isflagset(request->kdc_options, KDC_OPT_POSTDATED)) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_POSTDATED) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_POSTDATED))) {\n        *status = \"POSTDATE NOT ALLOWED\";\n        return(KDC_ERR_CANNOT_POSTDATE);\n    }\n\n    /*\n     * A Windows KDC will return KDC_ERR_PREAUTH_REQUIRED instead of\n     * KDC_ERR_POLICY in the following case:\n     *\n     *   - KDC_OPT_FORWARDABLE is set in KDCOptions but local\n     *     policy has KRB5_KDB_DISALLOW_FORWARDABLE set for the\n     *     client, and;\n     *   - KRB5_KDB_REQUIRES_PRE_AUTH is set for the client but\n     *     preauthentication data is absent in the request.\n     *\n     * Hence, this check most be done after the check for preauth\n     * data, and is now performed by validate_forwardable() (the\n     * contents of which were previously below).\n     */\n\n    /* Client and server must allow proxiable tickets */\n    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_PROXIABLE) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_PROXIABLE))) {\n        *status = \"PROXIABLE NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Check to see if client is locked out */\n    if (isflagset(client.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"CLIENT LOCKED OUT\";\n        return(KDC_ERR_CLIENT_REVOKED);\n    }\n\n    /* Check to see if server is locked out */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"SERVICE LOCKED OUT\";\n        return(KDC_ERR_S_PRINCIPAL_UNKNOWN);\n    }\n\n    /* Check to see if server is allowed to be a service */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_SVR)) {\n        *status = \"SERVICE NOT ALLOWED\";\n        return(KDC_ERR_MUST_USE_USER2USER);\n    }\n\n    if (check_anon(kdc_active_realm, client.princ, request->server) != 0) {\n        *status = \"ANONYMOUS NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Perform KDB module policy checks. */\n    ret = krb5_db_check_policy_as(kdc_context, request, &client, &server,\n                                  kdc_time, status, e_data);\n    if (ret && ret != KRB5_PLUGIN_OP_NOTSUPP)\n        return errcode_to_protocol(ret);\n\n    /* Check against local policy. */\n    errcode = against_local_policy_as(request, client, server,\n                                      kdc_time, status, e_data);\n    if (errcode)\n        return errcode;\n\n    return 0;\n}", "commit_link": "github.com/krb5/krb5/commit/93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7", "file_name": "src/kdc/kdc_util.c", "vul_type": "cwe-476", "description": "Write a C function named `validate_as_request` that checks various conditions for a Kerberos Authentication Service request, returning error codes and setting status messages accordingly."}
{"func_name": "testInvalidExtension", "func_src_before": "  def testInvalidExtension(self):\n    converter = upgrade_schema_lib.Converter()\n    invalid_extension = tempfile.mktemp(suffix=\".foo\")\n    with self.assertRaisesRegex(ValueError, \"Invalid extension on input\"):\n      converter.Convert(invalid_extension, invalid_extension)\n    with tempfile.NamedTemporaryFile(suffix=\".json\", mode=\"w+\") as in_json:\n      JsonDumpAndFlush(EMPTY_TEST_SCHEMA_V1, in_json)\n      with self.assertRaisesRegex(ValueError, \"Invalid extension on output\"):\n        converter.Convert(in_json.name, invalid_extension)", "func_src_after": "  def testInvalidExtension(self):\n    converter = upgrade_schema_lib.Converter()\n    _, invalid_extension = tempfile.mkstemp(suffix=\".foo\")  # safe to ignore fd\n    with self.assertRaisesRegex(ValueError, \"Invalid extension on input\"):\n      converter.Convert(invalid_extension, invalid_extension)\n    with tempfile.NamedTemporaryFile(suffix=\".json\", mode=\"w+\") as in_json:\n      JsonDumpAndFlush(EMPTY_TEST_SCHEMA_V1, in_json)\n      with self.assertRaisesRegex(ValueError, \"Invalid extension on output\"):\n        converter.Convert(in_json.name, invalid_extension)", "line_changes": {"deleted": [{"line_no": 3, "char_start": 81, "char_end": 136, "line": "    invalid_extension = tempfile.mktemp(suffix=\".foo\")\n"}], "added": [{"line_no": 3, "char_start": 81, "char_end": 161, "line": "    _, invalid_extension = tempfile.mkstemp(suffix=\".foo\")  # safe to ignore fd\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 84, "char_end": 87, "chars": " _,"}, {"char_start": 119, "char_end": 120, "chars": "s"}, {"char_start": 139, "char_end": 160, "chars": "  # safe to ignore fd"}]}, "commit_link": "github.com/tensorflow/tensorflow/commit/c63f6333a78ddf89ecd502d926fb877b8dce4f0f", "file_name": "upgrade_schema_test.py", "vul_type": "cwe-377", "commit_msg": "Use `tempfile.mkstemp` instead of `tempfile.mktemp`.\n\nThe `tempfile.mktemp` function is [deprecated](https://docs.python.org/3/library/tempfile.html#tempfile.mktemp) due to [security issues](https://cwe.mitre.org/data/definitions/377.html).\n\nThe switch is easy to do.\n\nPiperOrigin-RevId: 420335872\nChange-Id: I331ec2544a08d3cc3063a74af342cceae655b3dc", "description": "Write a Python unit test that checks for ValueError when a schema converter is given files with invalid extensions."}
{"func_name": "(anonymous)", "func_src_before": "\t$(selectedFiles).each(function(i,elem){\n\t\tvar newtr = $('<tr data-dir=\"'+dir+'\" data-filename=\"'+elem.name+'\">'\n\t\t\t\t\t\t+'<td class=\"filename\">'+elem.name+'</td><td class=\"size\">'+humanFileSize(elem.size)+'</td>'\n\t\t\t\t\t +'</tr>');\n\t\ttbody.append(newtr);\n\t\tif (elem.type === 'dir') {\n\t\t\tnewtr.find('td.filename').attr('style','background-image:url('+OC.imagePath('core', 'filetypes/folder.png')+')');\n\t\t} else {\n\t\t\tgetMimeIcon(elem.mime,function(path){\n\t\t\t\tnewtr.find('td.filename').attr('style','background-image:url('+path+')');\n\t\t\t});\n\t\t}\n\t});", "func_src_after": "\t$(selectedFiles).each(function(i,elem){\n\t\tvar newtr = $('<tr/>').attr('data-dir', dir).attr('data-filename', elem.name);\n\t\tnewtr.append($('<td/>').addClass('filename').text(elem.name));\n\t\tnewtr.append($('<td/>').addClass('size').text(humanFileSize(elem.size)));\n\t\ttbody.append(newtr);\n\t\tif (elem.type === 'dir') {\n\t\t\tnewtr.find('td.filename').attr('style','background-image:url('+OC.imagePath('core', 'filetypes/folder.png')+')');\n\t\t} else {\n\t\t\tgetMimeIcon(elem.mime,function(path){\n\t\t\t\tnewtr.find('td.filename').attr('style','background-image:url('+path+')');\n\t\t\t});\n\t\t}\n\t});", "line_changes": {"deleted": [{"line_no": 2, "char_start": 41, "char_end": 113, "line": "\t\tvar newtr = $('<tr data-dir=\"'+dir+'\" data-filename=\"'+elem.name+'\">'\n"}, {"line_no": 3, "char_start": 113, "char_end": 212, "line": "\t\t\t\t\t\t+'<td class=\"filename\">'+elem.name+'</td><td class=\"size\">'+humanFileSize(elem.size)+'</td>'\n"}, {"line_no": 4, "char_start": 212, "char_end": 229, "line": "\t\t\t\t\t +'</tr>');\n"}], "added": [{"line_no": 2, "char_start": 41, "char_end": 122, "line": "\t\tvar newtr = $('<tr/>').attr('data-dir', dir).attr('data-filename', elem.name);\n"}, {"line_no": 3, "char_start": 122, "char_end": 187, "line": "\t\tnewtr.append($('<td/>').addClass('filename').text(elem.name));\n"}, {"line_no": 4, "char_start": 187, "char_end": 263, "line": "\t\tnewtr.append($('<td/>').addClass('size').text(humanFileSize(elem.size)));\n"}]}, "char_changes": {"deleted": [{"char_start": 61, "char_end": 81, "chars": " data-dir=\"'+dir+'\" "}, {"char_start": 94, "char_end": 98, "chars": "=\"'+"}, {"char_start": 107, "char_end": 126, "chars": "+'\">'\n\t\t\t\t\t\t+'<td c"}, {"char_start": 130, "char_end": 132, "chars": "=\""}, {"char_start": 140, "char_end": 144, "chars": "\">'+"}, {"char_start": 153, "char_end": 154, "chars": "+"}, {"char_start": 156, "char_end": 157, "chars": "/"}, {"char_start": 159, "char_end": 165, "chars": "><td c"}, {"char_start": 169, "char_end": 171, "chars": "=\""}, {"char_start": 175, "char_end": 179, "chars": "\">'+"}, {"char_start": 203, "char_end": 226, "chars": "+'</td>'\n\t\t\t\t\t +'</tr>'"}], "added": [{"char_start": 61, "char_end": 94, "chars": "/>').attr('data-dir', dir).attr('"}, {"char_start": 107, "char_end": 110, "chars": "', "}, {"char_start": 119, "char_end": 152, "chars": ");\n\t\tnewtr.append($('<td/>').addC"}, {"char_start": 156, "char_end": 158, "chars": "('"}, {"char_start": 166, "char_end": 174, "chars": "').text("}, {"char_start": 183, "char_end": 204, "chars": "));\n\t\tnewtr.append($("}, {"char_start": 208, "char_end": 217, "chars": "/>').addC"}, {"char_start": 221, "char_end": 223, "chars": "('"}, {"char_start": 227, "char_end": 235, "chars": "').text("}, {"char_start": 259, "char_end": 260, "chars": ")"}]}, "commit_link": "github.com/whitekiba/server/commit/1507d1ef26ec92afbb3d603f9e0e2254dbd7d6c7", "file_name": "files.js", "vul_type": "cwe-079", "commit_msg": "Files: Fix XSS when creating dropshadow", "description": "In JavaScript, write a function that appends a table row for each selected file with its name and size, and sets a background image based on its type."}
{"func_name": "(anonymous)", "func_src_before": "app.use((req, res, next) => {\n    if (req.path === '/api/upload') {\n        next();\n    } else {\n        lusca.csrf()(req, res, next);\n    }\n});", "func_src_after": "app.use((req, res, next) => {\n    if (req.path === '/api/upload' || req.path === '/upload' || req.path === '/' || req.path === '/getPosts/:userId') {\n        next();\n    } else {\n        lusca.csrf()(req, res, next);\n    }\n});", "line_changes": {"deleted": [{"line_no": 2, "char_start": 30, "char_end": 68, "line": "    if (req.path === '/api/upload') {\n"}], "added": [{"line_no": 2, "char_start": 30, "char_end": 150, "line": "    if (req.path === '/api/upload' || req.path === '/upload' || req.path === '/' || req.path === '/getPosts/:userId') {\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 64, "char_end": 146, "chars": " || req.path === '/upload' || req.path === '/' || req.path === '/getPosts/:userId'"}]}, "commit_link": "github.com/molmsted98/mFrame/commit/96510c7138b803572062491fccbecb50e860c783", "file_name": "app.js", "vul_type": "cwe-352", "commit_msg": "Fixed an issue with csrf errors", "description": "Write a middleware in JavaScript for an Express.js application that bypasses CSRF protection for specific routes."}
{"func_name": "load_tile", "func_src_before": "static MagickBooleanType load_tile(Image *image,Image *tile_image,\n  XCFDocInfo *inDocInfo,XCFLayerInfo *inLayerInfo,size_t data_length,\n  ExceptionInfo *exception)\n{\n  ssize_t\n    y;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *graydata;\n\n  XCFPixelInfo\n    *xcfdata,\n    *xcfodata;\n\n  xcfdata=(XCFPixelInfo *) AcquireQuantumMemory(data_length,sizeof(*xcfdata));\n  if (xcfdata == (XCFPixelInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  xcfodata=xcfdata;\n  graydata=(unsigned char *) xcfdata;  /* used by gray and indexed */\n  count=ReadBlob(image,data_length,(unsigned char *) xcfdata);\n  if (count != (ssize_t) data_length)\n    ThrowBinaryException(CorruptImageError,\"NotEnoughPixelData\",\n      image->filename);\n  for (y=0; y < (ssize_t) tile_image->rows; y++)\n  {\n    q=GetAuthenticPixels(tile_image,0,y,tile_image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    if (inDocInfo->image_type == GIMP_GRAY)\n      {\n        for (x=0; x < (ssize_t) tile_image->columns; x++)\n        {\n          SetPixelGray(tile_image,ScaleCharToQuantum(*graydata),q);\n          SetPixelAlpha(tile_image,ScaleCharToQuantum((unsigned char)\n            inLayerInfo->alpha),q);\n          graydata++;\n          q+=GetPixelChannels(tile_image);\n        }\n      }\n    else\n      if (inDocInfo->image_type == GIMP_RGB)\n        {\n          for (x=0; x < (ssize_t) tile_image->columns; x++)\n          {\n            SetPixelRed(tile_image,ScaleCharToQuantum(xcfdata->red),q);\n            SetPixelGreen(tile_image,ScaleCharToQuantum(xcfdata->green),q);\n            SetPixelBlue(tile_image,ScaleCharToQuantum(xcfdata->blue),q);\n            SetPixelAlpha(tile_image,xcfdata->alpha == 255U ? TransparentAlpha :\n              ScaleCharToQuantum((unsigned char) inLayerInfo->alpha),q);\n            xcfdata++;\n            q+=GetPixelChannels(tile_image);\n          }\n        }\n     if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n       break;\n  }\n  xcfodata=(XCFPixelInfo *) RelinquishMagickMemory(xcfodata);\n  return MagickTrue;\n}", "func_src_after": "static MagickBooleanType load_tile(Image *image,Image *tile_image,\n  XCFDocInfo *inDocInfo,XCFLayerInfo *inLayerInfo,size_t data_length,\n  ExceptionInfo *exception)\n{\n  ssize_t\n    y;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *graydata;\n\n  XCFPixelInfo\n    *xcfdata,\n    *xcfodata;\n\n  xcfdata=(XCFPixelInfo *) AcquireQuantumMemory(MagickMax(data_length,\n    tile_image->columns*tile_image->rows),sizeof(*xcfdata));\n  if (xcfdata == (XCFPixelInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  xcfodata=xcfdata;\n  graydata=(unsigned char *) xcfdata;  /* used by gray and indexed */\n  count=ReadBlob(image,data_length,(unsigned char *) xcfdata);\n  if (count != (ssize_t) data_length)\n    ThrowBinaryException(CorruptImageError,\"NotEnoughPixelData\",\n      image->filename);\n  for (y=0; y < (ssize_t) tile_image->rows; y++)\n  {\n    q=GetAuthenticPixels(tile_image,0,y,tile_image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    if (inDocInfo->image_type == GIMP_GRAY)\n      {\n        for (x=0; x < (ssize_t) tile_image->columns; x++)\n        {\n          SetPixelGray(tile_image,ScaleCharToQuantum(*graydata),q);\n          SetPixelAlpha(tile_image,ScaleCharToQuantum((unsigned char)\n            inLayerInfo->alpha),q);\n          graydata++;\n          q+=GetPixelChannels(tile_image);\n        }\n      }\n    else\n      if (inDocInfo->image_type == GIMP_RGB)\n        {\n          for (x=0; x < (ssize_t) tile_image->columns; x++)\n          {\n            SetPixelRed(tile_image,ScaleCharToQuantum(xcfdata->red),q);\n            SetPixelGreen(tile_image,ScaleCharToQuantum(xcfdata->green),q);\n            SetPixelBlue(tile_image,ScaleCharToQuantum(xcfdata->blue),q);\n            SetPixelAlpha(tile_image,xcfdata->alpha == 255U ? TransparentAlpha :\n              ScaleCharToQuantum((unsigned char) inLayerInfo->alpha),q);\n            xcfdata++;\n            q+=GetPixelChannels(tile_image);\n          }\n        }\n     if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n       break;\n  }\n  xcfodata=(XCFPixelInfo *) RelinquishMagickMemory(xcfodata);\n  return MagickTrue;\n}", "commit_link": "github.com/ImageMagick/ImageMagick/commit/a2e1064f288a353bc5fef7f79ccb7683759e775c", "file_name": "coders/xcf.c", "vul_type": "cwe-125", "description": "Write a C function named `load_tile` that processes pixel data for an image tile in ImageMagick."}
{"func_name": "on_save", "func_src_before": "    def on_save(self):\n        connection = get_connection()\n        cursor = connection.cursor()\n        cursor.execute(\n            f\"insert into visitors (ip_address, user_agent, referrer, full_path, visit_time) values ('{self.ip_address}', '{self.user_agent}', '{self.referrer}', '{self.full_path}', '{self.visit_time}');\")\n        connection.commit()\n        connection.close()\n        return 0", "func_src_after": "    def on_save(self):\n        connection = get_connection()\n        cursor = connection.cursor()\n        cursor.execute(\n            \"insert into visitors (ip_address, user_agent, referrer, full_path, visit_time) values (%s, %s, %s, %s, %s);\",\n            (str(self.ip_address), str(self.user_agent), str(self.referrer), str(self.full_path), self.visit_time))\n        connection.commit()\n        connection.close()\n        return 0", "commit_link": "github.com/onewyoming/onewyoming/commit/54fc7b076fda2de74eeb55e6b75b28e09ef231c2", "file_name": "experimental/python/buford/model/visitor.py", "vul_type": "cwe-089", "description": "Write a Python function to save a visitor's details to a database using SQL insert query."}
{"func_name": "(anonymous)", "func_src_before": "socket.on(\"setNote\",function(data){\n\toldval = data.note;\n\t$(\"#note\").html(data.note);\n});", "func_src_after": "socket.on(\"setNote\",function(data){\n\toldval = data.note;\n\t$(\"#note\").html(oldval);\n});", "line_changes": {"deleted": [{"line_no": 3, "char_start": 57, "char_end": 86, "line": "\t$(\"#note\").html(data.note);\n"}], "added": [{"line_no": 3, "char_start": 57, "char_end": 83, "line": "\t$(\"#note\").html(oldval);\n"}]}, "char_changes": {"deleted": [{"char_start": 74, "char_end": 83, "chars": "data.note"}], "added": [{"char_start": 74, "char_end": 80, "chars": "oldval"}]}, "commit_link": "github.com/yoyodyne/litwritesabook/commit/6ed77576195866819411628e917cd157e2a61361", "file_name": "main.js", "vul_type": "cwe-089", "commit_msg": "SQL injection prevented.", "description": "Write a JavaScript code snippet using Socket.IO that updates the HTML content of an element with an ID of 'note' when a 'setNote' event is received."}
{"func_name": "get_uncompressed_data", "func_src_before": "get_uncompressed_data(struct archive_read *a, const void **buff, size_t size,\n    size_t minimum)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tssize_t bytes_avail;\n\n\tif (zip->codec == _7Z_COPY && zip->codec2 == (unsigned long)-1) {\n\t\t/* Copy mode. */\n\n\t\t/*\n\t\t * Note: '1' here is a performance optimization.\n\t\t * Recall that the decompression layer returns a count of\n\t\t * available bytes; asking for more than that forces the\n\t\t * decompressor to combine reads by copying data.\n\t\t */\n\t\t*buff = __archive_read_ahead(a, 1, &bytes_avail);\n\t\tif (bytes_avail <= 0) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated 7-Zip file data\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif ((size_t)bytes_avail >\n\t\t    zip->uncompressed_buffer_bytes_remaining)\n\t\t\tbytes_avail = (ssize_t)\n\t\t\t    zip->uncompressed_buffer_bytes_remaining;\n\t\tif ((size_t)bytes_avail > size)\n\t\t\tbytes_avail = (ssize_t)size;\n\n\t\tzip->pack_stream_bytes_unconsumed = bytes_avail;\n\t} else if (zip->uncompressed_buffer_pointer == NULL) {\n\t\t/* Decompression has failed. */\n\t\tarchive_set_error(&(a->archive),\n\t\t    ARCHIVE_ERRNO_MISC, \"Damaged 7-Zip archive\");\n\t\treturn (ARCHIVE_FATAL);\n\t} else {\n\t\t/* Packed mode. */\n\t\tif (minimum > zip->uncompressed_buffer_bytes_remaining) {\n\t\t\t/*\n\t\t\t * If remaining uncompressed data size is less than\n\t\t\t * the minimum size, fill the buffer up to the\n\t\t\t * minimum size.\n\t\t\t */\n\t\t\tif (extract_pack_stream(a, minimum) < 0)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif (size > zip->uncompressed_buffer_bytes_remaining)\n\t\t\tbytes_avail = (ssize_t)\n\t\t\t    zip->uncompressed_buffer_bytes_remaining;\n\t\telse\n\t\t\tbytes_avail = (ssize_t)size;\n\t\t*buff = zip->uncompressed_buffer_pointer;\n\t\tzip->uncompressed_buffer_pointer += bytes_avail;\n\t}\n\tzip->uncompressed_buffer_bytes_remaining -= bytes_avail;\n\treturn (bytes_avail);\n}", "func_src_after": "get_uncompressed_data(struct archive_read *a, const void **buff, size_t size,\n    size_t minimum)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tssize_t bytes_avail;\n\n\tif (zip->codec == _7Z_COPY && zip->codec2 == (unsigned long)-1) {\n\t\t/* Copy mode. */\n\n\t\t*buff = __archive_read_ahead(a, minimum, &bytes_avail);\n\t\tif (bytes_avail <= 0) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated 7-Zip file data\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif ((size_t)bytes_avail >\n\t\t    zip->uncompressed_buffer_bytes_remaining)\n\t\t\tbytes_avail = (ssize_t)\n\t\t\t    zip->uncompressed_buffer_bytes_remaining;\n\t\tif ((size_t)bytes_avail > size)\n\t\t\tbytes_avail = (ssize_t)size;\n\n\t\tzip->pack_stream_bytes_unconsumed = bytes_avail;\n\t} else if (zip->uncompressed_buffer_pointer == NULL) {\n\t\t/* Decompression has failed. */\n\t\tarchive_set_error(&(a->archive),\n\t\t    ARCHIVE_ERRNO_MISC, \"Damaged 7-Zip archive\");\n\t\treturn (ARCHIVE_FATAL);\n\t} else {\n\t\t/* Packed mode. */\n\t\tif (minimum > zip->uncompressed_buffer_bytes_remaining) {\n\t\t\t/*\n\t\t\t * If remaining uncompressed data size is less than\n\t\t\t * the minimum size, fill the buffer up to the\n\t\t\t * minimum size.\n\t\t\t */\n\t\t\tif (extract_pack_stream(a, minimum) < 0)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif (size > zip->uncompressed_buffer_bytes_remaining)\n\t\t\tbytes_avail = (ssize_t)\n\t\t\t    zip->uncompressed_buffer_bytes_remaining;\n\t\telse\n\t\t\tbytes_avail = (ssize_t)size;\n\t\t*buff = zip->uncompressed_buffer_pointer;\n\t\tzip->uncompressed_buffer_pointer += bytes_avail;\n\t}\n\tzip->uncompressed_buffer_bytes_remaining -= bytes_avail;\n\treturn (bytes_avail);\n}", "commit_link": "github.com/libarchive/libarchive/commit/65a23f5dbee4497064e9bb467f81138a62b0dae1", "file_name": "libarchive/archive_read_support_format_7zip.c", "vul_type": "cwe-125", "description": "In C, write a function to retrieve uncompressed data from a 7-Zip archive, handling both copy and packed modes."}
{"func_name": "gitMtime", "func_src_before": "async function gitMtime(path) {\n  const { stdout } = await execFilePromise('git', ['log', '-1', '--format=\"%at\"', '--', path]);\n\n  return parseInt(stdout.trim().replace('\"', '').trim(), 10);\n}", "func_src_after": "async function gitMtime(path) {\n  const { stdout } = await execFilePromise('git', ['log', '-1', '--format=\"%at\"', '--', path]);\n\n  return parseInt(stdout.trim().replace(/\"/g, '').trim(), 10);\n}", "line_changes": {"deleted": [{"line_no": 4, "char_start": 129, "char_end": 191, "line": "  return parseInt(stdout.trim().replace('\"', '').trim(), 10);\n"}], "added": [{"line_no": 4, "char_start": 129, "char_end": 192, "line": "  return parseInt(stdout.trim().replace(/\"/g, '').trim(), 10);\n"}]}, "char_changes": {"deleted": [{"char_start": 169, "char_end": 172, "chars": "'\"'"}], "added": [{"char_start": 169, "char_end": 173, "chars": "/\"/g"}]}, "commit_link": "github.com/openfoodfacts/openfoodfacts-server/commit/7917218c34b5ae2afe5d6581416c944607e31f36", "file_name": "refresh_taxonomies.js", "vul_type": "cwe-116", "commit_msg": "fix: CWE-116/CWE-20\n\nhttps://github.com/openfoodfacts/openfoodfacts-server/security/code-scanning/4", "parent_commit": "40386e19d82ff72f27066cb2bcbdf539dca0c6be", "description": "Create an asynchronous JavaScript function that retrieves the last modification timestamp of a file using Git."}
{"func_name": "ZipMisc::unzip", "func_src_before": "\tpublic static void unzip(File input, File destinationDir) throws IOException {\n\t\ttry (ZipInputStream zipInput = new ZipInputStream(new BufferedInputStream(new FileInputStream(input)))) {\n\t\t\tZipEntry entry;\n\t\t\twhile ((entry = zipInput.getNextEntry()) != null) {\n\t\t\t\tFile dest = new File(destinationDir, entry.getName());\n\t\t\t\tif (entry.isDirectory()) {\n\t\t\t\t\tFileMisc.mkdirs(dest);\n\t\t\t\t} else {\n\t\t\t\t\tFileMisc.mkdirs(dest.getParentFile());\n\t\t\t\t\ttry (OutputStream output = new BufferedOutputStream(new FileOutputStream(dest))) {\n\t\t\t\t\t\tcopy(zipInput, output);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "func_src_after": "\tpublic static void unzip(File input, File destinationDir) throws IOException {\n\t\ttry (ZipInputStream zipInput = new ZipInputStream(new BufferedInputStream(new FileInputStream(input)))) {\n\t\t\tZipEntry entry;\n\t\t\twhile ((entry = zipInput.getNextEntry()) != null) {\n\t\t\t\tFile dest = new File(destinationDir, entry.getName());\n\t\t\t\tif (!dest.toPath().normalize().startsWith(destinationDir.toPath().normalize())) {\n\t\t\t\t\tthrow new RuntimeException(\"Bad zip entry\");\n\t\t\t\t}\n\t\t\t\tif (entry.isDirectory()) {\n\t\t\t\t\tFileMisc.mkdirs(dest);\n\t\t\t\t} else {\n\t\t\t\t\tFileMisc.mkdirs(dest.getParentFile());\n\t\t\t\t\ttry (OutputStream output = new BufferedOutputStream(new FileOutputStream(dest))) {\n\t\t\t\t\t\tcopy(zipInput, output);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "line_changes": {"deleted": [], "added": [{"line_no": 6, "char_start": 321, "char_end": 407, "line": "\t\t\t\tif (!dest.toPath().normalize().startsWith(destinationDir.toPath().normalize())) {\n"}, {"line_no": 7, "char_start": 407, "char_end": 457, "line": "\t\t\t\t\tthrow new RuntimeException(\"Bad zip entry\");\n"}, {"line_no": 8, "char_start": 457, "char_end": 463, "line": "\t\t\t\t}\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 321, "char_end": 463, "chars": "\t\t\t\tif (!dest.toPath().normalize().startsWith(destinationDir.toPath().normalize())) {\n\t\t\t\t\tthrow new RuntimeException(\"Bad zip entry\");\n\t\t\t\t}\n"}]}, "commit_link": "github.com/diffplug/goomph/commit/643474930339e5567745ba0695f2a8decf627a8c", "file_name": "ZipMisc.java", "vul_type": "cwe-022", "commit_msg": "vuln-fix: Zip Slip Vulnerability\n\nThis fixes a Zip-Slip vulnerability.\n\nThis change does one of two things. This change either\n\n1. Inserts a guard to protect against Zip Slip.\nOR\n2. Replaces `dir.getCanonicalPath().startsWith(parent.getCanonicalPath())`, which is vulnerable to partial path traversal attacks, with the more secure `dir.getCanonicalFile().toPath().startsWith(parent.getCanonicalFile().toPath())`.\n\nFor number 2, consider `\"/usr/outnot\".startsWith(\"/usr/out\")`.\nThe check is bypassed although `/outnot` is not under the `/out` directory.\nIt's important to understand that the terminating slash may be removed when using various `String` representations of the `File` object.\nFor example, on Linux, `println(new File(\"/var\"))` will print `/var`, but `println(new File(\"/var\", \"/\")` will print `/var/`;\nhowever, `println(new File(\"/var\", \"/\").getCanonicalPath())` will print `/var`.\n\nWeakness: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nSeverity: High\nCVSSS: 7.4\nDetection: CodeQL (https://codeql.github.com/codeql-query-help/java/java-zipslip/) & OpenRewrite (https://public.moderne.io/recipes/org.openrewrite.java.security.ZipSlip)\n\nReported-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\nSigned-off-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\n\nBug-tracker: https://github.com/JLLeitschuh/security-research/issues/16\n\nCo-authored-by: Moderne <team@moderne.io>", "parent_commit": "fe2083196f0d0a75885aea402baaa972254173d5", "description": "Write a Java function to extract the contents of a ZIP file to a specified directory."}
{"func_name": "ResponseParser::parse", "func_src_before": "\tpublic Object parse(SerializerHandler serializerHandler, InputStream response, boolean debugMode) throws XMLRPCException {\n\n\t\ttry {\n\n\t\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n\t\t\tfactory.setNamespaceAware(true);\n\t\t\tDocumentBuilder builder = factory.newDocumentBuilder();\n\t\t\tDocument dom = builder.parse(response);\n\t\t\tif (debugMode ){\n\t\t\t\tprintDocument(dom, System.out);\n\t\t\t}\n\t\t\tElement e = dom.getDocumentElement();\n\n\n\t\t\t// Check for root tag\n\t\t\tif(!e.getNodeName().equals(XMLRPCClient.METHOD_RESPONSE)) {\n\t\t\t\tthrow new XMLRPCException(\"MethodResponse root tag is missing.\");\n\t\t\t}\n\n\t\t\te = XMLUtil.getOnlyChildElement(e.getChildNodes());\n\n\t\t\tif(e.getNodeName().equals(XMLRPCClient.PARAMS)) {\n\n\t\t\t\te = XMLUtil.getOnlyChildElement(e.getChildNodes());\n\n\t\t\t\tif(!e.getNodeName().equals(XMLRPCClient.PARAM)) {\n\t\t\t\t\tthrow new XMLRPCException(\"The params tag must contain a param tag.\");\n\t\t\t\t}\n\n\t\t\t\treturn getReturnValueFromElement(serializerHandler, e);\n\n\t\t\t} else if(e.getNodeName().equals(XMLRPCClient.FAULT)) {\n\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tMap<String,Object> o = (Map<String,Object>)getReturnValueFromElement(serializerHandler, e);\n\n\t\t\t\tthrow new XMLRPCServerException((String)o.get(FAULT_STRING), (Integer)o.get(FAULT_CODE));\n\n\t\t\t}\n\n\t\t\tthrow new XMLRPCException(\"The methodResponse tag must contain a fault or params tag.\");\n\n\t\t} catch(XMLRPCServerException e) {\n\t\t\tthrow e;\n\t\t} catch (Exception ex) {\n\t\t\tthrow new XMLRPCException(\"Error getting result from server.\", ex);\n\t\t}\n\n\t}", "func_src_after": "\tpublic Object parse(SerializerHandler serializerHandler, InputStream response, boolean debugMode) throws XMLRPCException {\n\n\t\ttry {\n\t\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n\n\t\t\t// Ensure the xml parser won't allow exploitation of the vuln CWE-611\n\t\t\t// (described on https://cwe.mitre.org/data/definitions/611.html )\n\t\t\tfactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\tfactory.setExpandEntityReferences(false);\n\t\t\tfactory.setNamespaceAware(true);\n\t\t\tfactory.setXIncludeAware(false);\n\t\t\tfactory.setExpandEntityReferences(false);\n\t\t\t// End of the configuration of the parser for CWE-611\n\n\t\t\tDocumentBuilder builder = factory.newDocumentBuilder();\n\t\t\tDocument dom = builder.parse(response);\n\t\t\tif (debugMode ){\n\t\t\t\tprintDocument(dom, System.out);\n\t\t\t}\n\t\t\tElement e = dom.getDocumentElement();\n\n\n\t\t\t// Check for root tag\n\t\t\tif(!e.getNodeName().equals(XMLRPCClient.METHOD_RESPONSE)) {\n\t\t\t\tthrow new XMLRPCException(\"MethodResponse root tag is missing.\");\n\t\t\t}\n\n\t\t\te = XMLUtil.getOnlyChildElement(e.getChildNodes());\n\n\t\t\tif(e.getNodeName().equals(XMLRPCClient.PARAMS)) {\n\n\t\t\t\te = XMLUtil.getOnlyChildElement(e.getChildNodes());\n\n\t\t\t\tif(!e.getNodeName().equals(XMLRPCClient.PARAM)) {\n\t\t\t\t\tthrow new XMLRPCException(\"The params tag must contain a param tag.\");\n\t\t\t\t}\n\n\t\t\t\treturn getReturnValueFromElement(serializerHandler, e);\n\n\t\t\t} else if(e.getNodeName().equals(XMLRPCClient.FAULT)) {\n\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tMap<String,Object> o = (Map<String,Object>)getReturnValueFromElement(serializerHandler, e);\n\n\t\t\t\tthrow new XMLRPCServerException((String)o.get(FAULT_STRING), (Integer)o.get(FAULT_CODE));\n\n\t\t\t}\n\n\t\t\tthrow new XMLRPCException(\"The methodResponse tag must contain a fault or params tag.\");\n\n\t\t} catch(XMLRPCServerException e) {\n\t\t\tthrow e;\n\t\t} catch (Exception ex) {\n\t\t\tthrow new XMLRPCException(\"Error getting result from server.\", ex);\n\t\t}\n\n\t}", "line_changes": {"deleted": [{"line_no": 4, "char_start": 133, "char_end": 134, "line": "\n"}], "added": [{"line_no": 5, "char_start": 207, "char_end": 208, "line": "\n"}, {"line_no": 8, "char_start": 351, "char_end": 436, "line": "\t\t\tfactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n"}, {"line_no": 9, "char_start": 436, "char_end": 481, "line": "\t\t\tfactory.setExpandEntityReferences(false);\n"}, {"line_no": 11, "char_start": 517, "char_end": 553, "line": "\t\t\tfactory.setXIncludeAware(false);\n"}, {"line_no": 12, "char_start": 553, "char_end": 598, "line": "\t\t\tfactory.setExpandEntityReferences(false);\n"}, {"line_no": 14, "char_start": 655, "char_end": 656, "line": "\n"}]}, "char_changes": {"deleted": [{"char_start": 133, "char_end": 134, "chars": "\n"}, {"char_start": 208, "char_end": 243, "chars": "\t\t\tfactory.setNamespaceAware(true);"}], "added": [{"char_start": 207, "char_end": 655, "chars": "\n\t\t\t// Ensure the xml parser won't allow exploitation of the vuln CWE-611\n\t\t\t// (described on https://cwe.mitre.org/data/definitions/611.html )\n\t\t\tfactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\tfactory.setExpandEntityReferences(false);\n\t\t\tfactory.setNamespaceAware(true);\n\t\t\tfactory.setXIncludeAware(false);\n\t\t\tfactory.setExpandEntityReferences(false);\n\t\t\t// End of the configuration of the parser for CWE-611\n"}]}, "commit_link": "github.com/timroes/aXMLRPC/commit/ad6615b3ec41353e614f6ea5fdd5b046442a832b", "file_name": "ResponseParser.java", "vul_type": "cwe-611", "commit_msg": "Fix CWE-611\n\nThis commit fixes the issue described on\nhttps://cwe.mitre.org/data/definitions/611.html\n\ntest", "parent_commit": "2e59d03c961607d32bc9dc5e7aba931338907603", "description": "Write a Java function to parse an XMLRPC response from an InputStream and handle debug mode."}
{"func_name": "mrb_vm_exec", "func_src_before": "mrb_vm_exec(mrb_state *mrb, struct RProc *proc, mrb_code *pc)\n{\n  /* mrb_assert(mrb_proc_cfunc_p(proc)) */\n  mrb_irep *irep = proc->body.irep;\n  mrb_value *pool = irep->pool;\n  mrb_sym *syms = irep->syms;\n  mrb_code i;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n\n#ifdef DIRECT_THREADED\n  static void *optable[] = {\n    &&L_OP_NOP, &&L_OP_MOVE,\n    &&L_OP_LOADL, &&L_OP_LOADI, &&L_OP_LOADSYM, &&L_OP_LOADNIL,\n    &&L_OP_LOADSELF, &&L_OP_LOADT, &&L_OP_LOADF,\n    &&L_OP_GETGLOBAL, &&L_OP_SETGLOBAL, &&L_OP_GETSPECIAL, &&L_OP_SETSPECIAL,\n    &&L_OP_GETIV, &&L_OP_SETIV, &&L_OP_GETCV, &&L_OP_SETCV,\n    &&L_OP_GETCONST, &&L_OP_SETCONST, &&L_OP_GETMCNST, &&L_OP_SETMCNST,\n    &&L_OP_GETUPVAR, &&L_OP_SETUPVAR,\n    &&L_OP_JMP, &&L_OP_JMPIF, &&L_OP_JMPNOT,\n    &&L_OP_ONERR, &&L_OP_RESCUE, &&L_OP_POPERR, &&L_OP_RAISE, &&L_OP_EPUSH, &&L_OP_EPOP,\n    &&L_OP_SEND, &&L_OP_SENDB, &&L_OP_FSEND,\n    &&L_OP_CALL, &&L_OP_SUPER, &&L_OP_ARGARY, &&L_OP_ENTER,\n    &&L_OP_KARG, &&L_OP_KDICT, &&L_OP_RETURN, &&L_OP_TAILCALL, &&L_OP_BLKPUSH,\n    &&L_OP_ADD, &&L_OP_ADDI, &&L_OP_SUB, &&L_OP_SUBI, &&L_OP_MUL, &&L_OP_DIV,\n    &&L_OP_EQ, &&L_OP_LT, &&L_OP_LE, &&L_OP_GT, &&L_OP_GE,\n    &&L_OP_ARRAY, &&L_OP_ARYCAT, &&L_OP_ARYPUSH, &&L_OP_AREF, &&L_OP_ASET, &&L_OP_APOST,\n    &&L_OP_STRING, &&L_OP_STRCAT, &&L_OP_HASH,\n    &&L_OP_LAMBDA, &&L_OP_RANGE, &&L_OP_OCLASS,\n    &&L_OP_CLASS, &&L_OP_MODULE, &&L_OP_EXEC,\n    &&L_OP_METHOD, &&L_OP_SCLASS, &&L_OP_TCLASS,\n    &&L_OP_DEBUG, &&L_OP_STOP, &&L_OP_ERR,\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb->c->ci->proc = proc;\n  mrb->c->ci->nregs = irep->nregs;\n\n#define regs (mrb->c->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE) {\n      /* A B    R(A) := R(B) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL) {\n      /* A Bx   R(A) := Pool(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n#ifdef MRB_WORD_BOXING\n      mrb_value val = pool[bx];\n#ifndef MRB_WITHOUT_FLOAT\n      if (mrb_float_p(val)) {\n        val = mrb_float_value(mrb, mrb_float(val));\n      }\n#endif\n      regs[a] = val;\n#else\n      regs[a] = pool[bx];\n#endif\n      NEXT;\n    }\n\n    CASE(OP_LOADI) {\n      /* A sBx  R(A) := sBx */\n      int a = GETARG_A(i);\n      mrb_int bx = GETARG_sBx(i);\n      SET_INT_VALUE(regs[a], bx);\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM) {\n      /* A Bx   R(A) := Syms(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      SET_SYM_VALUE(regs[a], syms[bx]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF) {\n      /* A      R(A) := self */\n      int a = GETARG_A(i);\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT) {\n      /* A      R(A) := true */\n      int a = GETARG_A(i);\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF) {\n      /* A      R(A) := false */\n      int a = GETARG_A(i);\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGLOBAL) {\n      /* A Bx   R(A) := getglobal(Syms(Bx)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_gv_get(mrb, syms[bx]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGLOBAL) {\n      /* A Bx   setglobal(Syms(Bx), R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_gv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSPECIAL) {\n      /* A Bx   R(A) := Special[Bx] */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_vm_special_get(mrb, bx);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSPECIAL) {\n      /* A Bx   Special[Bx] := R(A) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_special_set(mrb, bx, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV) {\n      /* A Bx   R(A) := ivget(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_vm_iv_get(mrb, syms[bx]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETIV) {\n      /* A Bx   ivset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_iv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV) {\n      /* A Bx   R(A) := cvget(Syms(Bx)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val;\n      ERR_PC_SET(mrb, pc);\n      val = mrb_vm_cv_get(mrb, syms[bx]);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV) {\n      /* A Bx   cvset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_cv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCONST) {\n      /* A Bx    R(A) := constget(Syms(Bx)) */\n      mrb_value val;\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_sym sym = syms[bx];\n\n      ERR_PC_SET(mrb, pc);\n      val = mrb_vm_const_get(mrb, sym);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCONST) {\n      /* A Bx   constset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_const_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST) {\n      /* A Bx   R(A) := R(A)::Syms(Bx) */\n      mrb_value val;\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n\n      ERR_PC_SET(mrb, pc);\n      val = mrb_const_get(mrb, regs[a], syms[bx]);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST) {\n      /* A Bx    R(A+1)::Syms(Bx) := R(A) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_const_set(mrb, regs[a+1], syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR) {\n      /* A B C  R(A) := uvget(B,C) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value *regs_a = regs + a;\n      struct REnv *e = uvenv(mrb, c);\n\n      if (!e) {\n        *regs_a = mrb_nil_value();\n      }\n      else {\n        *regs_a = e->stack[b];\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETUPVAR) {\n      /* A B C  uvset(B,C,R(A)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_STACK_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP) {\n      /* sBx    pc+=sBx */\n      int sbx = GETARG_sBx(i);\n      pc += sbx;\n      JUMP;\n    }\n\n    CASE(OP_JMPIF) {\n      /* A sBx  if R(A) pc+=sBx */\n      int a = GETARG_A(i);\n      int sbx = GETARG_sBx(i);\n      if (mrb_test(regs[a])) {\n        pc += sbx;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPNOT) {\n      /* A sBx  if !R(A) pc+=sBx */\n      int a = GETARG_A(i);\n      int sbx = GETARG_sBx(i);\n      if (!mrb_test(regs[a])) {\n        pc += sbx;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ONERR) {\n      /* sBx    pc+=sBx on exception */\n      int sbx = GETARG_sBx(i);\n      if (mrb->c->rsize <= mrb->c->ci->ridx) {\n        if (mrb->c->rsize == 0) mrb->c->rsize = RESCUE_STACK_INIT_SIZE;\n        else mrb->c->rsize *= 2;\n        mrb->c->rescue = (mrb_code **)mrb_realloc(mrb, mrb->c->rescue, sizeof(mrb_code*) * mrb->c->rsize);\n      }\n      mrb->c->rescue[mrb->c->ci->ridx++] = pc + sbx;\n      NEXT;\n    }\n\n    CASE(OP_RESCUE) {\n      /* A B    R(A) := exc; clear(exc); R(B) := matched (bool) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value exc;\n\n      if (c == 0) {\n        exc = mrb_obj_value(mrb->exc);\n        mrb->exc = 0;\n      }\n      else {           /* continued; exc taken from R(A) */\n        exc = regs[a];\n      }\n      if (b != 0) {\n        mrb_value e = regs[b];\n        struct RClass *ec;\n\n        switch (mrb_type(e)) {\n        case MRB_TT_CLASS:\n        case MRB_TT_MODULE:\n          break;\n        default:\n          {\n            mrb_value exc;\n\n            exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR,\n                  \"class or module required for rescue clause\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n        }\n        ec = mrb_class_ptr(e);\n        regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      }\n      if (a != 0 && c == 0) {\n        regs[a] = exc;\n      }\n      NEXT;\n    }\n\n    CASE(OP_POPERR) {\n      /* A      A.times{rescue_pop()} */\n      int a = GETARG_A(i);\n\n      mrb->c->ci->ridx -= a;\n      NEXT;\n    }\n\n    CASE(OP_RAISE) {\n      /* A      raise(R(A)) */\n      int a = GETARG_A(i);\n\n      mrb_exc_set(mrb, regs[a]);\n      goto L_RAISE;\n    }\n\n    CASE(OP_EPUSH) {\n      /* Bx     ensure_push(SEQ[Bx]) */\n      int bx = GETARG_Bx(i);\n      struct RProc *p;\n\n      p = mrb_closure_new(mrb, irep->reps[bx]);\n      /* push ensure_stack */\n      if (mrb->c->esize <= mrb->c->eidx+1) {\n        if (mrb->c->esize == 0) mrb->c->esize = ENSURE_STACK_INIT_SIZE;\n        else mrb->c->esize *= 2;\n        mrb->c->ensure = (struct RProc **)mrb_realloc(mrb, mrb->c->ensure, sizeof(struct RProc*) * mrb->c->esize);\n      }\n      mrb->c->ensure[mrb->c->eidx++] = p;\n      mrb->c->ensure[mrb->c->eidx] = NULL;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EPOP) {\n      /* A      A.times{ensure_pop().call} */\n      int a = GETARG_A(i);\n      mrb_callinfo *ci = mrb->c->ci;\n      int n, epos = ci->epos;\n      mrb_value self = regs[0];\n      struct RClass *target_class = ci->target_class;\n\n      if (mrb->c->eidx <= epos) {\n        NEXT;\n      }\n\n      if (a > mrb->c->eidx - epos)\n        a = mrb->c->eidx - epos;\n      pc = pc + 1;\n      for (n=0; n<a; n++) {\n        proc = mrb->c->ensure[epos+n];\n        mrb->c->ensure[epos+n] = NULL;\n        if (proc == NULL) continue;\n        irep = proc->body.irep;\n        ci = cipush(mrb);\n        ci->mid = ci[-1].mid;\n        ci->argc = 0;\n        ci->proc = proc;\n        ci->stackent = mrb->c->stack;\n        ci->nregs = irep->nregs;\n        ci->target_class = target_class;\n        ci->pc = pc;\n        ci->acc = ci[-1].nregs;\n        mrb->c->stack += ci->acc;\n        stack_extend(mrb, ci->nregs);\n        regs[0] = self;\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      mrb->c->eidx = epos;\n      JUMP;\n    }\n\n    CASE(OP_LOADNIL) {\n      /* A     R(A) := nil */\n      int a = GETARG_A(i);\n\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_SENDB) {\n      /* A B C  R(A) := call(R(A),Syms(B),R(A+1),...,R(A+C),&R(A+C+1))*/\n      /* fall through */\n    };\n\n  L_SEND:\n    CASE(OP_SEND) {\n      /* A B C  R(A) := call(R(A),Syms(B),R(A+1),...,R(A+C)) */\n      int a = GETARG_A(i);\n      int n = GETARG_C(i);\n      int argc = (n == CALL_MAXARGS) ? -1 : n;\n      int bidx = (argc < 0) ? a+2 : a+n+1;\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      mrb_sym mid = syms[GETARG_B(i)];\n\n      mrb_assert(bidx < ci->nregs);\n\n      recv = regs[a];\n      if (GET_OPCODE(i) != OP_SENDB) {\n        SET_NIL_VALUE(regs[bidx]);\n        blk = regs[bidx];\n      }\n      else {\n        blk = regs[bidx];\n        if (!mrb_nil_p(blk) && mrb_type(blk) != MRB_TT_PROC) {\n          blk = mrb_convert_type(mrb, blk, MRB_TT_PROC, \"Proc\", \"to_proc\");\n          /* The stack might have been reallocated during mrb_convert_type(),\n             see #3622 */\n          regs[bidx] = blk;\n        }\n      }\n      c = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m) || (missing == mrb->c->ci->mid && mrb_obj_eq(mrb, regs[0], recv))) {\n          mrb_value args = (argc < 0) ? regs[a+1] : mrb_ary_new_from_values(mrb, n, regs+a+1);\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        if (argc >= 0) {\n          if (a+2 >= irep->nregs) {\n            stack_extend(mrb, a+3);\n          }\n          regs[a+1] = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          regs[a+2] = blk;\n          argc = -1;\n        }\n        mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(mid));\n        mid = missing;\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb);\n      ci->mid = mid;\n      ci->stackent = mrb->c->stack;\n      ci->target_class = c;\n      ci->argc = argc;\n\n      ci->pc = pc + 1;\n      ci->acc = a;\n\n      /* prepare stack */\n      mrb->c->stack += a;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        ci->nregs = (argc < 0) ? 3 : n+2;\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          ci->proc = p;\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_restore(mrb, ai);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (GET_OPCODE(i) == OP_SENDB) {\n          if (mrb_type(blk) == MRB_TT_PROC) {\n            struct RProc *p = mrb_proc_ptr(blk);\n            if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == ci[-1].env) {\n              p->flags |= MRB_PROC_ORPHAN;\n            }\n          }\n        }\n        if (!ci->target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->acc == CI_ACC_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->stack[0] = recv;\n        /* pop stackpos */\n        mrb->c->stack = ci->stackent;\n        pc = ci->pc;\n        cipop(mrb);\n        JUMP;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = ci->proc = MRB_METHOD_PROC(m);\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, (argc < 0 && ci->nregs < 3) ? 3 : ci->nregs);\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_FSEND) {\n      /* A B C  R(A) := fcall(R(A),Syms(B),R(A+1),... ,R(A+C-1)) */\n      /* not implemented yet */\n      NEXT;\n    }\n\n    CASE(OP_CALL) {\n      /* A      R(A) := self.call(frame.argc, frame.argv) */\n      mrb_callinfo *ci;\n      mrb_value recv = mrb->c->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci = mrb->c->ci;\n      ci->target_class = MRB_PROC_TARGET_CLASS(m);\n      ci->proc = m;\n      if (MRB_PROC_ENV_P(m)) {\n        mrb_sym mid;\n        struct REnv *e = MRB_PROC_ENV(m);\n\n        mid = e->mid;\n        if (mid) ci->mid = mid;\n        if (!e->stack) {\n          e->stack = mrb->c->stack;\n        }\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = mrb->c->ci;\n        mrb->c->stack = ci->stackent;\n        regs[ci->acc] = recv;\n        pc = ci->pc;\n        cipop(mrb);\n        irep = mrb->c->ci->proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        JUMP;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->stack[0] = mrb_nil_value();\n          goto L_RETURN;\n        }\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, ci->nregs);\n        if (ci->argc < 0) {\n          if (irep->nregs > 3) {\n            stack_clear(regs+3, irep->nregs-3);\n          }\n        }\n        else if (ci->argc+2 < irep->nregs) {\n          stack_clear(regs+ci->argc+2, irep->nregs-ci->argc-2);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_SUPER) {\n      /* A C  R(A) := super(R(A+1),... ,R(A+C+1)) */\n      int a = GETARG_A(i);\n      int n = GETARG_C(i);\n      int argc = (n == CALL_MAXARGS) ? -1 : n;\n      int bidx = (argc < 0) ? a+2 : a+n+1;\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = MRB_PROC_TARGET_CLASS(ci->proc);\n\n      mrb_assert(bidx < ci->nregs);\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->tt == MRB_TT_MODULE) {\n        target_class = ci->target_class;\n        if (target_class->tt != MRB_TT_ICLASS) {\n          mrb_value exc = mrb_exc_new_str_lit(mrb, E_RUNTIME_ERROR, \"superclass info lost [mruby limitations]\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      blk = regs[bidx];\n      if (!mrb_nil_p(blk) && mrb_type(blk) != MRB_TT_PROC) {\n        blk = mrb_convert_type(mrb, blk, MRB_TT_PROC, \"Proc\", \"to_proc\");\n        /* The stack or ci stack might have been reallocated during\n           mrb_convert_type(), see #3622 and #3784 */\n        regs[bidx] = blk;\n        ci = mrb->c->ci;\n      }\n      c = target_class->super;\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n\n        if (mid != missing) {\n          c = mrb_class(mrb, recv);\n        }\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m)) {\n          mrb_value args = (argc < 0) ? regs[a+1] : mrb_ary_new_from_values(mrb, n, regs+a+1);\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        mid = missing;\n        if (argc >= 0) {\n          if (a+2 >= ci->nregs) {\n            stack_extend(mrb, a+3);\n          }\n          regs[a+1] = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          regs[a+2] = blk;\n          argc = -1;\n        }\n        mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(ci->mid));\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb);\n      ci->mid = mid;\n      ci->stackent = mrb->c->stack;\n      ci->target_class = c;\n      ci->pc = pc + 1;\n      ci->argc = argc;\n\n      /* prepare stack */\n      mrb->c->stack += a;\n      mrb->c->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n        ci->nregs = (argc < 0) ? 3 : n+2;\n        if (MRB_METHOD_PROC_P(m)) {\n          ci->proc = MRB_METHOD_PROC(m);\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (!ci->target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->acc == CI_ACC_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->stack[0] = v;\n        /* pop stackpos */\n        mrb->c->stack = ci->stackent;\n        pc = ci->pc;\n        cipop(mrb);\n        JUMP;\n      }\n      else {\n        /* fill callinfo */\n        ci->acc = a;\n\n        /* setup environment for calling method */\n        proc = ci->proc = MRB_METHOD_PROC(m);\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, (argc < 0 && ci->nregs < 3) ? 3 : ci->nregs);\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_ARGARY) {\n      /* A Bx   R(A) := argument array (16=6:1:5:4) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      int m1 = (bx>>10)&0x3f;\n      int r  = (bx>>9)&0x1;\n      int m2 = (bx>>4)&0x1f;\n      int lv = (bx>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb->c->ci->target_class == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_str_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_STACK_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = (int)ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      regs[a+1] = stack[m1+r+m2];\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER) {\n      /* Ax             arg setup according to flags (23=5:5:1:5:5:1:1) */\n      /* number of optional arguments times OP_JMP should follow */\n      mrb_aspec ax = GETARG_Ax(i);\n      int m1 = MRB_ASPEC_REQ(ax);\n      int o  = MRB_ASPEC_OPT(ax);\n      int r  = MRB_ASPEC_REST(ax);\n      int m2 = MRB_ASPEC_POST(ax);\n      /* unused\n      int k  = MRB_ASPEC_KEY(ax);\n      int kd = MRB_ASPEC_KDICT(ax);\n      int b  = MRB_ASPEC_BLOCK(ax);\n      */\n      int argc = mrb->c->ci->argc;\n      mrb_value *argv = regs+1;\n      mrb_value *argv0 = argv;\n      int len = m1 + o + r + m2;\n      mrb_value *blk = &argv[argc < 0 ? 1 : argc];\n\n      if (argc < 0) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n      if (mrb->c->ci->proc && MRB_PROC_STRICT_P(mrb->c->ci->proc)) {\n        if (argc >= 0) {\n          if (argc < m1 + m2 || (r == 0 && argc > len)) {\n            argnum_error(mrb, m1+m2);\n            goto L_RAISE;\n          }\n        }\n      }\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n      if (argc < len) {\n        int mlen = m2;\n        if (argc < m1+m2) {\n          if (m1 < argc)\n            mlen = argc - m1;\n          else\n            mlen = 0;\n        }\n        regs[len+1] = *blk; /* move block */\n        SET_NIL_VALUE(regs[argc+1]);\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        if (r) {\n          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);\n        }\n        if (o == 0 || argc < m1+m2) pc++;\n        else\n          pc += argc - m1 - m2 + 1;\n      }\n      else {\n        int rnum = 0;\n        if (argv0 != argv) {\n          regs[len+1] = *blk; /* move block */\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          regs[m1+o+1] = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n        }\n        if (m2) {\n          if (argc-m2 > m1) {\n            value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n          }\n        }\n        if (argv0 == argv) {\n          regs[len+1] = *blk; /* move block */\n        }\n        pc += o + 1;\n      }\n      mrb->c->ci->argc = len;\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-len-2 > 0) {\n        stack_clear(&regs[len+2], irep->nlocals-len-2);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG) {\n      /* A B C          R(A) := kdict[Syms(B)]; if C kdict.rm(Syms(B)) */\n      /* if C == 2; raise unless kdict.empty? */\n      /* OP_JMP should follow to skip init code */\n      NEXT;\n    }\n\n    CASE(OP_KDICT) {\n      /* A C            R(A) := kdict */\n      NEXT;\n    }\n\n    L_RETURN:\n      i = MKOP_AB(OP_RETURN, GETARG_A(i), OP_R_NORMAL);\n      /* fall through */\n    CASE(OP_RETURN) {\n      /* A B     return R(A) (B=normal,in-block return/break) */\n      mrb_callinfo *ci;\n\n#define ecall_adjust() do {\\\n  ptrdiff_t cioff = ci - mrb->c->cibase;\\\n  ecall(mrb);\\\n  ci = mrb->c->cibase + cioff;\\\n} while (0)\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk;\n\n        if (ci->argc < 0) {\n          blk = regs[2];\n        }\n        else {\n          blk = regs[ci->argc+1];\n        }\n        if (mrb_type(blk) == MRB_TT_PROC) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == ci[-1].env) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n        mrb_callinfo *ci0;\n\n      L_RAISE:\n        ci0 = ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          if (ci->ridx == 0) goto L_FTOP;\n          goto L_RESCUE;\n        }\n        while (ci[0].ridx == ci[-1].ridx) {\n          cipop(mrb);\n          mrb->c->stack = ci->stackent;\n          if (ci->acc == CI_ACC_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          ci = mrb->c->ci;\n          if (ci == mrb->c->cibase) {\n            if (ci->ridx == 0) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                while (c->eidx > ci->epos) {\n                  ecall_adjust();\n                }\n                if (c->fib) {\n                  mrb_write_barrier(mrb, (struct RBasic*)c->fib);\n                }\n                mrb->c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n          /* call ensure only when we skip this callinfo */\n          if (ci[0].ridx == ci[-1].ridx) {\n            while (mrb->c->eidx > ci->epos) {\n              ecall_adjust();\n            }\n          }\n        }\n      L_RESCUE:\n        if (ci->ridx == 0) goto L_STOP;\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        if (ci < ci0) {\n          mrb->c->stack = ci[1].stackent;\n        }\n        stack_extend(mrb, irep->nregs);\n        pc = mrb->c->rescue[--ci->ridx];\n      }\n      else {\n        int acc;\n        mrb_value v;\n        struct RProc *dst;\n\n        ci = mrb->c->ci;\n        v = regs[GETARG_A(i)];\n        mrb_gc_protect(mrb, v);\n        switch (GETARG_B(i)) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->acc >=0 && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            mrb_callinfo *cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_STACK_SHARED_P(e) || e->cxt != mrb->c) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->acc < 0) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) {\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            break;\n          }\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n\n            if (!mrb->c->prev) { /* toplevel return */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            if (mrb->c->prev->ci == mrb->c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_str_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            while (mrb->c->eidx > 0) {\n              ecall(mrb);\n            }\n            /* automatic yield at the end */\n            c = mrb->c;\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            c->prev = NULL;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            ci = mrb->c->ci;\n          }\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) { \n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_str_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_STACK_SHARED_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e == mrb->c->cibase->env && proc != mrb->c->cibase->proc) {\n              goto L_BREAK_ERROR;\n            }\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          while (mrb->c->eidx > mrb->c->ci->epos) {\n            ecall_adjust();\n          }\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->acc < 0) {\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->exc = (struct RObject*)break_new(mrb, proc, v);\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n          L_BREAK:\n            v = ((struct RBreak*)mrb->exc)->val;\n            proc = ((struct RBreak*)mrb->exc)->proc;\n            mrb->exc = NULL;\n            ci = mrb->c->ci;\n          }\n          mrb->c->stack = ci->stackent;\n          proc = proc->upper;\n          while (mrb->c->cibase < ci &&  ci[-1].proc != proc) {\n            if (ci[-1].acc == CI_ACC_SKIP) {\n              while (ci < mrb->c->ci) {\n                cipop(mrb);\n              }\n              goto L_BREAK_ERROR;\n            }\n            ci--;\n          }\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        while (ci < mrb->c->ci) {\n          cipop(mrb);\n        }\n        ci[0].ridx = ci[-1].ridx;\n        while (mrb->c->eidx > ci->epos) {\n          ecall_adjust();\n        }\n        if (mrb->c->vmexec && !ci->target_class) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->acc;\n        mrb->c->stack = ci->stackent;\n        cipop(mrb);\n        if (acc == CI_ACC_SKIP || acc == CI_ACC_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        ci = mrb->c->ci;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym2name(mrb, ci->mid)));\n        proc = mrb->c->ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        regs[acc] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\n    CASE(OP_TAILCALL) {\n      /* A B C  return call(R(A),Syms(B),R(A+1),... ,R(A+C+1)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int n = GETARG_C(i);\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci;\n      mrb_value recv;\n      mrb_sym mid = syms[b];\n\n      recv = regs[a];\n      c = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_value sym = mrb_symbol_value(mid);\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m)) {\n          mrb_value args;\n\n          if (n == CALL_MAXARGS) {\n            args = regs[a+1];\n          }\n          else {\n            args = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          }\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        mid = missing;\n        if (n == CALL_MAXARGS) {\n          mrb_ary_unshift(mrb, regs[a+1], sym);\n        }\n        else {\n          value_move(regs+a+2, regs+a+1, ++n);\n          regs[a+1] = sym;\n        }\n      }\n\n      /* replace callinfo */\n      ci = mrb->c->ci;\n      ci->mid = mid;\n      ci->target_class = c;\n      if (n == CALL_MAXARGS) {\n        ci->argc = -1;\n      }\n      else {\n        ci->argc = n;\n      }\n\n      /* move stack */\n      value_move(mrb->c->stack, &regs[a], ci->argc+1);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb->c->stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n        goto L_RETURN;\n      }\n      else {\n        /* setup environment for calling method */\n        struct RProc *p = MRB_METHOD_PROC(m);\n        irep = p->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        if (ci->argc < 0) {\n          stack_extend(mrb, (irep->nregs < 3) ? 3 : irep->nregs);\n        }\n        else {\n          stack_extend(mrb, irep->nregs);\n        }\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_BLKPUSH) {\n      /* A Bx   R(A) := block (16=6:1:5:4) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      int m1 = (bx>>10)&0x3f;\n      int r  = (bx>>9)&0x1;\n      int m2 = (bx>>4)&0x1f;\n      int lv = (bx>>0)&0xf;\n      mrb_value *stack;\n\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e || (!MRB_ENV_STACK_SHARED_P(e) && e->mid == 0) ||\n            MRB_ENV_STACK_LEN(e) <= m1+r+m2+1) {\n          localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n          goto L_RAISE;\n        }\n        stack = e->stack + 1;\n      }\n      if (mrb_nil_p(stack[m1+r+m2])) {\n        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n        goto L_RAISE;\n      }\n      regs[a] = stack[m1+r+m2];\n      NEXT;\n    }\n\n#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n#define OP_MATH_BODY(op,v1,v2) do {\\\n  v1(regs[a]) = v1(regs[a]) op v2(regs[a+1]);\\\n} while(0)\n\n    CASE(OP_ADD) {\n      /* A B C  R(A) := R(A)+R(A+1) (Syms[B]=:+,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n          mrb_value *regs_a = regs + a;\n\n          x = mrb_fixnum(regs_a[0]);\n          y = mrb_fixnum(regs_a[1]);\n          if (mrb_int_add_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs_a[0], (mrb_float)x + (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x + y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + y);\n        }\n#else\n        OP_MATH_BODY(+,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + y);\n        }\n#else\n        OP_MATH_BODY(+,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      case TYPES2(MRB_TT_STRING,MRB_TT_STRING):\n        regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);\n        break;\n      default:\n        goto L_SEND;\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_SUB) {\n      /* A B C  R(A) := R(A)-R(A+1) (Syms[B]=:-,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n\n          x = mrb_fixnum(regs[a]);\n          y = mrb_fixnum(regs[a+1]);\n          if (mrb_int_sub_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x - (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x - y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - y);\n        }\n#else\n        OP_MATH_BODY(-,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - y);\n        }\n#else\n        OP_MATH_BODY(-,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_MUL) {\n      /* A B C  R(A) := R(A)*R(A+1) (Syms[B]=:*,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n\n          x = mrb_fixnum(regs[a]);\n          y = mrb_fixnum(regs[a+1]);\n          if (mrb_int_mul_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x * (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x * y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x * y);\n        }\n#else\n        OP_MATH_BODY(*,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x * y);\n        }\n#else\n        OP_MATH_BODY(*,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_DIV) {\n      /* A B C  R(A) := R(A)/R(A+1) (Syms[B]=:/,C=1)*/\n      int a = GETARG_A(i);\n#ifndef MRB_WITHOUT_FLOAT\n      double x, y, f;\n#endif\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n#ifdef MRB_WITHOUT_FLOAT\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_INT_VALUE(regs[a], y ? x / y : 0);\n        }\n        break;\n#else\n        x = (mrb_float)mrb_fixnum(regs[a]);\n        y = (mrb_float)mrb_fixnum(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        x = (mrb_float)mrb_fixnum(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n        x = mrb_float(regs[a]);\n        y = (mrb_float)mrb_fixnum(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n        x = mrb_float(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n\n#ifndef MRB_WITHOUT_FLOAT\n      if (y == 0) {\n        if (x > 0) f = INFINITY;\n        else if (x < 0) f = -INFINITY;\n        else /* if (x == 0) */ f = NAN;\n      }\n      else {\n        f = x / y;\n      }\n      SET_FLOAT_VALUE(mrb, regs[a], f);\n#endif\n      NEXT;\n    }\n\n    CASE(OP_ADDI) {\n      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/\n      int a = GETARG_A(i);\n\n      /* need to check if + is overridden */\n      switch (mrb_type(regs[a])) {\n      case MRB_TT_FIXNUM:\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_int y = GETARG_C(i);\n          mrb_int z;\n\n          if (mrb_int_add_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x + (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case MRB_TT_FLOAT:\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + GETARG_C(i));\n        }\n#else\n        mrb_float(regs[a]) += GETARG_C(i);\n#endif\n        break;\n#endif\n      default:\n        SET_INT_VALUE(regs[a+1], GETARG_C(i));\n        i = MKOP_ABC(OP_SEND, a, GETARG_B(i), 1);\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SUBI) {\n      /* A B C  R(A) := R(A)-C (Syms[B]=:-)*/\n      int a = GETARG_A(i);\n      mrb_value *regs_a = regs + a;\n\n      /* need to check if + is overridden */\n      switch (mrb_type(regs_a[0])) {\n      case MRB_TT_FIXNUM:\n        {\n          mrb_int x = mrb_fixnum(regs_a[0]);\n          mrb_int y = GETARG_C(i);\n          mrb_int z;\n\n          if (mrb_int_sub_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs_a[0], (mrb_float)x - (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs_a[0], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case MRB_TT_FLOAT:\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - GETARG_C(i));\n        }\n#else\n        mrb_float(regs_a[0]) -= GETARG_C(i);\n#endif\n        break;\n#endif\n      default:\n        SET_INT_VALUE(regs_a[1], GETARG_C(i));\n        i = MKOP_ABC(OP_SEND, a, GETARG_B(i), 1);\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n#define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n\n#ifdef MRB_WITHOUT_FLOAT\n#define OP_CMP(op) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  default:\\\n    goto L_SEND;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#else\n#define OP_CMP(op) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n    break;\\\n  default:\\\n    goto L_SEND;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#endif\n\n    CASE(OP_EQ) {\n      /* A B C  R(A) := R(A)==R(A+1) (Syms[B]=:==,C=1)*/\n      int a = GETARG_A(i);\n      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n        SET_TRUE_VALUE(regs[a]);\n      }\n      else {\n        OP_CMP(==);\n      }\n      NEXT;\n    }\n\n    CASE(OP_LT) {\n      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(<);\n      NEXT;\n    }\n\n    CASE(OP_LE) {\n      /* A B C  R(A) := R(A)<=R(A+1) (Syms[B]=:<=,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(<=);\n      NEXT;\n    }\n\n    CASE(OP_GT) {\n      /* A B C  R(A) := R(A)>R(A+1) (Syms[B]=:>,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(>);\n      NEXT;\n    }\n\n    CASE(OP_GE) {\n      /* A B C  R(A) := R(A)>=R(A+1) (Syms[B]=:>=,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(>=);\n      NEXT;\n    }\n\n    CASE(OP_ARRAY) {\n      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value v = mrb_ary_new_from_values(mrb, c, &regs[b]);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYCAT) {\n      /* A B            mrb_ary_concat(R(A),R(B)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      mrb_value splat = mrb_ary_splat(mrb, regs[b]);\n      mrb_ary_concat(mrb, regs[a], splat);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYPUSH) {\n      /* A B            R(A).push(R(B)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      mrb_ary_push(mrb, regs[a], regs[b]);\n      NEXT;\n    }\n\n    CASE(OP_AREF) {\n      /* A B C          R(A) := R(B)[C] */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value v = regs[b];\n\n      if (!mrb_array_p(v)) {\n        if (c == 0) {\n          regs[a] = v;\n        }\n        else {\n          SET_NIL_VALUE(regs[a]);\n        }\n      }\n      else {\n        v = mrb_ary_ref(mrb, v, c);\n        regs[a] = v;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ASET) {\n      /* A B C          R(B)[C] := R(A) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_ary_set(mrb, regs[b], c, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_APOST) {\n      /* A B C  *R(A),R(A+1)..R(A+C) := R(A) */\n      int a = GETARG_A(i);\n      mrb_value v = regs[a];\n      int pre  = GETARG_B(i);\n      int post = GETARG_C(i);\n      struct RArray *ary;\n      int len, idx;\n\n      if (!mrb_array_p(v)) {\n        v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n      }\n      ary = mrb_ary_ptr(v);\n      len = (int)ARY_LEN(ary);\n      if (len > pre + post) {\n        v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n        regs[a++] = v;\n        while (post--) {\n          regs[a++] = ARY_PTR(ary)[len-post-1];\n        }\n      }\n      else {\n        v = mrb_ary_new_capa(mrb, 0);\n        regs[a++] = v;\n        for (idx=0; idx+pre<len; idx++) {\n          regs[a+idx] = ARY_PTR(ary)[pre+idx];\n        }\n        while (idx < post) {\n          SET_NIL_VALUE(regs[a+idx]);\n          idx++;\n        }\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRING) {\n      /* A Bx           R(A) := str_new(Lit(Bx)) */\n      mrb_int a = GETARG_A(i);\n      mrb_int bx = GETARG_Bx(i);\n      mrb_value str = mrb_str_dup(mrb, pool[bx]);\n\n      regs[a] = str;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRCAT) {\n      /* A B    R(A).concat(R(B)) */\n      mrb_int a = GETARG_A(i);\n      mrb_int b = GETARG_B(i);\n\n      mrb_str_concat(mrb, regs[a], regs[b]);\n      NEXT;\n    }\n\n    CASE(OP_HASH) {\n      /* A B C   R(A) := hash_new(R(B),R(B+1)..R(B+C)) */\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      int lim = b+c*2;\n      mrb_value hash = mrb_hash_new_capa(mrb, c);\n\n      while (b < lim) {\n        mrb_hash_set(mrb, hash, regs[b], regs[b+1]);\n        b+=2;\n      }\n      regs[GETARG_A(i)] = hash;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_LAMBDA) {\n      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */\n      struct RProc *p;\n      int a = GETARG_A(i);\n      int b = GETARG_b(i);\n      int c = GETARG_c(i);\n      mrb_irep *nirep = irep->reps[b];\n\n      if (c & OP_L_CAPTURE) {\n        p = mrb_closure_new(mrb, nirep);\n      }\n      else {\n        p = mrb_proc_new(mrb, nirep);\n        p->flags |= MRB_PROC_SCOPE;\n      }\n      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n      regs[a] = mrb_obj_value(p);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_OCLASS) {\n      /* A      R(A) := ::Object */\n      regs[GETARG_A(i)] = mrb_obj_value(mrb->object_class);\n      NEXT;\n    }\n\n    CASE(OP_CLASS) {\n      /* A B    R(A) := newclass(R(A),Syms(B),R(A+1)) */\n      struct RClass *c = 0, *baseclass;\n      int a = GETARG_A(i);\n      mrb_value base, super;\n      mrb_sym id = syms[GETARG_B(i)];\n\n      base = regs[a];\n      super = regs[a+1];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_class(mrb, base, super, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_MODULE) {\n      /* A B            R(A) := newmodule(R(A),Syms(B)) */\n      struct RClass *c = 0, *baseclass;\n      int a = GETARG_A(i);\n      mrb_value base;\n      mrb_sym id = syms[GETARG_B(i)];\n\n      base = regs[a];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_module(mrb, base, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EXEC) {\n      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_callinfo *ci;\n      mrb_value recv = regs[a];\n      struct RProc *p;\n      mrb_irep *nirep = irep->reps[bx];\n\n      /* prepare closure */\n      p = mrb_proc_new(mrb, nirep);\n      p->c = NULL;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n      MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n      p->flags |= MRB_PROC_SCOPE;\n\n      /* prepare call stack */\n      ci = cipush(mrb);\n      ci->pc = pc + 1;\n      ci->acc = a;\n      ci->mid = 0;\n      ci->stackent = mrb->c->stack;\n      ci->argc = 0;\n      ci->target_class = mrb_class_ptr(recv);\n\n      /* prepare stack */\n      mrb->c->stack += a;\n\n      /* setup block to call */\n      ci->proc = p;\n\n      irep = p->body.irep;\n      pool = irep->pool;\n      syms = irep->syms;\n      ci->nregs = irep->nregs;\n      stack_extend(mrb, ci->nregs);\n      stack_clear(regs+1, ci->nregs-1);\n      pc = irep->iseq;\n      JUMP;\n    }\n\n    CASE(OP_METHOD) {\n      /* A B            R(A).newmethod(Syms(B),R(A+1)) */\n      int a = GETARG_A(i);\n      struct RClass *c = mrb_class_ptr(regs[a]);\n      struct RProc *p = mrb_proc_ptr(regs[a+1]);\n      mrb_method_t m;\n\n      MRB_METHOD_FROM_PROC(m, p);\n      mrb_define_method_raw(mrb, c, syms[GETARG_B(i)], m);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_SCLASS) {\n      /* A B    R(A) := R(B).singleton_class */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n\n      regs[a] = mrb_singleton_class(mrb, regs[b]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_TCLASS) {\n      /* A      R(A) := target_class */\n      if (!mrb->c->ci->target_class) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR, \"no target class or module\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      regs[GETARG_A(i)] = mrb_obj_value(mrb->c->ci->target_class);\n      NEXT;\n    }\n\n    CASE(OP_RANGE) {\n      /* A B C  R(A) := range_new(R(B),R(B+1),C) */\n      int b = GETARG_B(i);\n      mrb_value val = mrb_range_new(mrb, regs[b], regs[b+1], GETARG_C(i));\n      regs[GETARG_A(i)] = val;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_DEBUG) {\n      /* A B C    debug print R(A),R(B),R(C) */\n#ifdef MRB_ENABLE_DEBUG_HOOK\n      mrb->debug_op_hook(mrb, irep, pc, regs);\n#else\n#ifndef MRB_DISABLE_STDIO\n      printf(\"OP_DEBUG %d %d %d\\n\", GETARG_A(i), GETARG_B(i), GETARG_C(i));\n#else\n      abort();\n#endif\n#endif\n      NEXT;\n    }\n\n    CASE(OP_STOP) {\n      /*        stop VM */\n    L_STOP:\n      while (mrb->c->eidx > 0) {\n        ecall(mrb);\n      }\n      ERR_PC_CLR(mrb);\n      mrb->jmp = prev_jmp;\n      if (mrb->exc) {\n        return mrb_obj_value(mrb->exc);\n      }\n      return regs[irep->nlocals];\n    }\n\n    CASE(OP_ERR) {\n      /* Bx     raise RuntimeError with message Lit(Bx) */\n      mrb_value msg = mrb_str_dup(mrb, pool[GETARG_Bx(i)]);\n      mrb_value exc;\n\n      if (GETARG_A(i) == 0) {\n        exc = mrb_exc_new_str(mrb, E_RUNTIME_ERROR, msg);\n      }\n      else {\n        exc = mrb_exc_new_str(mrb, E_LOCALJUMP_ERROR, msg);\n      }\n      ERR_PC_SET(mrb, pc);\n      mrb_exc_set(mrb, exc);\n      goto L_RAISE;\n    }\n  }\n  END_DISPATCH;\n#undef regs\n\n  }\n  MRB_CATCH(&c_jmp) {\n    exc_catched = TRUE;\n    goto RETRY_TRY_BLOCK;\n  }\n  MRB_END_EXC(&c_jmp);\n}", "func_src_after": "mrb_vm_exec(mrb_state *mrb, struct RProc *proc, mrb_code *pc)\n{\n  /* mrb_assert(mrb_proc_cfunc_p(proc)) */\n  mrb_irep *irep = proc->body.irep;\n  mrb_value *pool = irep->pool;\n  mrb_sym *syms = irep->syms;\n  mrb_code i;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n\n#ifdef DIRECT_THREADED\n  static void *optable[] = {\n    &&L_OP_NOP, &&L_OP_MOVE,\n    &&L_OP_LOADL, &&L_OP_LOADI, &&L_OP_LOADSYM, &&L_OP_LOADNIL,\n    &&L_OP_LOADSELF, &&L_OP_LOADT, &&L_OP_LOADF,\n    &&L_OP_GETGLOBAL, &&L_OP_SETGLOBAL, &&L_OP_GETSPECIAL, &&L_OP_SETSPECIAL,\n    &&L_OP_GETIV, &&L_OP_SETIV, &&L_OP_GETCV, &&L_OP_SETCV,\n    &&L_OP_GETCONST, &&L_OP_SETCONST, &&L_OP_GETMCNST, &&L_OP_SETMCNST,\n    &&L_OP_GETUPVAR, &&L_OP_SETUPVAR,\n    &&L_OP_JMP, &&L_OP_JMPIF, &&L_OP_JMPNOT,\n    &&L_OP_ONERR, &&L_OP_RESCUE, &&L_OP_POPERR, &&L_OP_RAISE, &&L_OP_EPUSH, &&L_OP_EPOP,\n    &&L_OP_SEND, &&L_OP_SENDB, &&L_OP_FSEND,\n    &&L_OP_CALL, &&L_OP_SUPER, &&L_OP_ARGARY, &&L_OP_ENTER,\n    &&L_OP_KARG, &&L_OP_KDICT, &&L_OP_RETURN, &&L_OP_TAILCALL, &&L_OP_BLKPUSH,\n    &&L_OP_ADD, &&L_OP_ADDI, &&L_OP_SUB, &&L_OP_SUBI, &&L_OP_MUL, &&L_OP_DIV,\n    &&L_OP_EQ, &&L_OP_LT, &&L_OP_LE, &&L_OP_GT, &&L_OP_GE,\n    &&L_OP_ARRAY, &&L_OP_ARYCAT, &&L_OP_ARYPUSH, &&L_OP_AREF, &&L_OP_ASET, &&L_OP_APOST,\n    &&L_OP_STRING, &&L_OP_STRCAT, &&L_OP_HASH,\n    &&L_OP_LAMBDA, &&L_OP_RANGE, &&L_OP_OCLASS,\n    &&L_OP_CLASS, &&L_OP_MODULE, &&L_OP_EXEC,\n    &&L_OP_METHOD, &&L_OP_SCLASS, &&L_OP_TCLASS,\n    &&L_OP_DEBUG, &&L_OP_STOP, &&L_OP_ERR,\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb->c->ci->proc = proc;\n  mrb->c->ci->nregs = irep->nregs;\n\n#define regs (mrb->c->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE) {\n      /* A B    R(A) := R(B) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL) {\n      /* A Bx   R(A) := Pool(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n#ifdef MRB_WORD_BOXING\n      mrb_value val = pool[bx];\n#ifndef MRB_WITHOUT_FLOAT\n      if (mrb_float_p(val)) {\n        val = mrb_float_value(mrb, mrb_float(val));\n      }\n#endif\n      regs[a] = val;\n#else\n      regs[a] = pool[bx];\n#endif\n      NEXT;\n    }\n\n    CASE(OP_LOADI) {\n      /* A sBx  R(A) := sBx */\n      int a = GETARG_A(i);\n      mrb_int bx = GETARG_sBx(i);\n      SET_INT_VALUE(regs[a], bx);\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM) {\n      /* A Bx   R(A) := Syms(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      SET_SYM_VALUE(regs[a], syms[bx]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF) {\n      /* A      R(A) := self */\n      int a = GETARG_A(i);\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT) {\n      /* A      R(A) := true */\n      int a = GETARG_A(i);\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF) {\n      /* A      R(A) := false */\n      int a = GETARG_A(i);\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGLOBAL) {\n      /* A Bx   R(A) := getglobal(Syms(Bx)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_gv_get(mrb, syms[bx]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGLOBAL) {\n      /* A Bx   setglobal(Syms(Bx), R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_gv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSPECIAL) {\n      /* A Bx   R(A) := Special[Bx] */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_vm_special_get(mrb, bx);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSPECIAL) {\n      /* A Bx   Special[Bx] := R(A) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_special_set(mrb, bx, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV) {\n      /* A Bx   R(A) := ivget(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_vm_iv_get(mrb, syms[bx]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETIV) {\n      /* A Bx   ivset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_iv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV) {\n      /* A Bx   R(A) := cvget(Syms(Bx)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val;\n      ERR_PC_SET(mrb, pc);\n      val = mrb_vm_cv_get(mrb, syms[bx]);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV) {\n      /* A Bx   cvset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_cv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCONST) {\n      /* A Bx    R(A) := constget(Syms(Bx)) */\n      mrb_value val;\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_sym sym = syms[bx];\n\n      ERR_PC_SET(mrb, pc);\n      val = mrb_vm_const_get(mrb, sym);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCONST) {\n      /* A Bx   constset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_const_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST) {\n      /* A Bx   R(A) := R(A)::Syms(Bx) */\n      mrb_value val;\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n\n      ERR_PC_SET(mrb, pc);\n      val = mrb_const_get(mrb, regs[a], syms[bx]);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST) {\n      /* A Bx    R(A+1)::Syms(Bx) := R(A) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_const_set(mrb, regs[a+1], syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR) {\n      /* A B C  R(A) := uvget(B,C) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value *regs_a = regs + a;\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e && b < MRB_ENV_STACK_LEN(e)) {\n        *regs_a = e->stack[b];\n      }\n      else {\n        *regs_a = mrb_nil_value();\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETUPVAR) {\n      /* A B C  uvset(B,C,R(A)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_STACK_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP) {\n      /* sBx    pc+=sBx */\n      int sbx = GETARG_sBx(i);\n      pc += sbx;\n      JUMP;\n    }\n\n    CASE(OP_JMPIF) {\n      /* A sBx  if R(A) pc+=sBx */\n      int a = GETARG_A(i);\n      int sbx = GETARG_sBx(i);\n      if (mrb_test(regs[a])) {\n        pc += sbx;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPNOT) {\n      /* A sBx  if !R(A) pc+=sBx */\n      int a = GETARG_A(i);\n      int sbx = GETARG_sBx(i);\n      if (!mrb_test(regs[a])) {\n        pc += sbx;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ONERR) {\n      /* sBx    pc+=sBx on exception */\n      int sbx = GETARG_sBx(i);\n      if (mrb->c->rsize <= mrb->c->ci->ridx) {\n        if (mrb->c->rsize == 0) mrb->c->rsize = RESCUE_STACK_INIT_SIZE;\n        else mrb->c->rsize *= 2;\n        mrb->c->rescue = (mrb_code **)mrb_realloc(mrb, mrb->c->rescue, sizeof(mrb_code*) * mrb->c->rsize);\n      }\n      mrb->c->rescue[mrb->c->ci->ridx++] = pc + sbx;\n      NEXT;\n    }\n\n    CASE(OP_RESCUE) {\n      /* A B    R(A) := exc; clear(exc); R(B) := matched (bool) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value exc;\n\n      if (c == 0) {\n        exc = mrb_obj_value(mrb->exc);\n        mrb->exc = 0;\n      }\n      else {           /* continued; exc taken from R(A) */\n        exc = regs[a];\n      }\n      if (b != 0) {\n        mrb_value e = regs[b];\n        struct RClass *ec;\n\n        switch (mrb_type(e)) {\n        case MRB_TT_CLASS:\n        case MRB_TT_MODULE:\n          break;\n        default:\n          {\n            mrb_value exc;\n\n            exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR,\n                  \"class or module required for rescue clause\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n        }\n        ec = mrb_class_ptr(e);\n        regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      }\n      if (a != 0 && c == 0) {\n        regs[a] = exc;\n      }\n      NEXT;\n    }\n\n    CASE(OP_POPERR) {\n      /* A      A.times{rescue_pop()} */\n      int a = GETARG_A(i);\n\n      mrb->c->ci->ridx -= a;\n      NEXT;\n    }\n\n    CASE(OP_RAISE) {\n      /* A      raise(R(A)) */\n      int a = GETARG_A(i);\n\n      mrb_exc_set(mrb, regs[a]);\n      goto L_RAISE;\n    }\n\n    CASE(OP_EPUSH) {\n      /* Bx     ensure_push(SEQ[Bx]) */\n      int bx = GETARG_Bx(i);\n      struct RProc *p;\n\n      p = mrb_closure_new(mrb, irep->reps[bx]);\n      /* push ensure_stack */\n      if (mrb->c->esize <= mrb->c->eidx+1) {\n        if (mrb->c->esize == 0) mrb->c->esize = ENSURE_STACK_INIT_SIZE;\n        else mrb->c->esize *= 2;\n        mrb->c->ensure = (struct RProc **)mrb_realloc(mrb, mrb->c->ensure, sizeof(struct RProc*) * mrb->c->esize);\n      }\n      mrb->c->ensure[mrb->c->eidx++] = p;\n      mrb->c->ensure[mrb->c->eidx] = NULL;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EPOP) {\n      /* A      A.times{ensure_pop().call} */\n      int a = GETARG_A(i);\n      mrb_callinfo *ci = mrb->c->ci;\n      int n, epos = ci->epos;\n      mrb_value self = regs[0];\n      struct RClass *target_class = ci->target_class;\n\n      if (mrb->c->eidx <= epos) {\n        NEXT;\n      }\n\n      if (a > mrb->c->eidx - epos)\n        a = mrb->c->eidx - epos;\n      pc = pc + 1;\n      for (n=0; n<a; n++) {\n        proc = mrb->c->ensure[epos+n];\n        mrb->c->ensure[epos+n] = NULL;\n        if (proc == NULL) continue;\n        irep = proc->body.irep;\n        ci = cipush(mrb);\n        ci->mid = ci[-1].mid;\n        ci->argc = 0;\n        ci->proc = proc;\n        ci->stackent = mrb->c->stack;\n        ci->nregs = irep->nregs;\n        ci->target_class = target_class;\n        ci->pc = pc;\n        ci->acc = ci[-1].nregs;\n        mrb->c->stack += ci->acc;\n        stack_extend(mrb, ci->nregs);\n        regs[0] = self;\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      mrb->c->eidx = epos;\n      JUMP;\n    }\n\n    CASE(OP_LOADNIL) {\n      /* A     R(A) := nil */\n      int a = GETARG_A(i);\n\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_SENDB) {\n      /* A B C  R(A) := call(R(A),Syms(B),R(A+1),...,R(A+C),&R(A+C+1))*/\n      /* fall through */\n    };\n\n  L_SEND:\n    CASE(OP_SEND) {\n      /* A B C  R(A) := call(R(A),Syms(B),R(A+1),...,R(A+C)) */\n      int a = GETARG_A(i);\n      int n = GETARG_C(i);\n      int argc = (n == CALL_MAXARGS) ? -1 : n;\n      int bidx = (argc < 0) ? a+2 : a+n+1;\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      mrb_sym mid = syms[GETARG_B(i)];\n\n      mrb_assert(bidx < ci->nregs);\n\n      recv = regs[a];\n      if (GET_OPCODE(i) != OP_SENDB) {\n        SET_NIL_VALUE(regs[bidx]);\n        blk = regs[bidx];\n      }\n      else {\n        blk = regs[bidx];\n        if (!mrb_nil_p(blk) && mrb_type(blk) != MRB_TT_PROC) {\n          blk = mrb_convert_type(mrb, blk, MRB_TT_PROC, \"Proc\", \"to_proc\");\n          /* The stack might have been reallocated during mrb_convert_type(),\n             see #3622 */\n          regs[bidx] = blk;\n        }\n      }\n      c = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m) || (missing == mrb->c->ci->mid && mrb_obj_eq(mrb, regs[0], recv))) {\n          mrb_value args = (argc < 0) ? regs[a+1] : mrb_ary_new_from_values(mrb, n, regs+a+1);\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        if (argc >= 0) {\n          if (a+2 >= irep->nregs) {\n            stack_extend(mrb, a+3);\n          }\n          regs[a+1] = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          regs[a+2] = blk;\n          argc = -1;\n        }\n        mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(mid));\n        mid = missing;\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb);\n      ci->mid = mid;\n      ci->stackent = mrb->c->stack;\n      ci->target_class = c;\n      ci->argc = argc;\n\n      ci->pc = pc + 1;\n      ci->acc = a;\n\n      /* prepare stack */\n      mrb->c->stack += a;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        ci->nregs = (argc < 0) ? 3 : n+2;\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          ci->proc = p;\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_restore(mrb, ai);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (GET_OPCODE(i) == OP_SENDB) {\n          if (mrb_type(blk) == MRB_TT_PROC) {\n            struct RProc *p = mrb_proc_ptr(blk);\n            if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == ci[-1].env) {\n              p->flags |= MRB_PROC_ORPHAN;\n            }\n          }\n        }\n        if (!ci->target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->acc == CI_ACC_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->stack[0] = recv;\n        /* pop stackpos */\n        mrb->c->stack = ci->stackent;\n        pc = ci->pc;\n        cipop(mrb);\n        JUMP;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = ci->proc = MRB_METHOD_PROC(m);\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, (argc < 0 && ci->nregs < 3) ? 3 : ci->nregs);\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_FSEND) {\n      /* A B C  R(A) := fcall(R(A),Syms(B),R(A+1),... ,R(A+C-1)) */\n      /* not implemented yet */\n      NEXT;\n    }\n\n    CASE(OP_CALL) {\n      /* A      R(A) := self.call(frame.argc, frame.argv) */\n      mrb_callinfo *ci;\n      mrb_value recv = mrb->c->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci = mrb->c->ci;\n      ci->target_class = MRB_PROC_TARGET_CLASS(m);\n      ci->proc = m;\n      if (MRB_PROC_ENV_P(m)) {\n        mrb_sym mid;\n        struct REnv *e = MRB_PROC_ENV(m);\n\n        mid = e->mid;\n        if (mid) ci->mid = mid;\n        if (!e->stack) {\n          e->stack = mrb->c->stack;\n        }\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = mrb->c->ci;\n        mrb->c->stack = ci->stackent;\n        regs[ci->acc] = recv;\n        pc = ci->pc;\n        cipop(mrb);\n        irep = mrb->c->ci->proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        JUMP;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->stack[0] = mrb_nil_value();\n          goto L_RETURN;\n        }\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, ci->nregs);\n        if (ci->argc < 0) {\n          if (irep->nregs > 3) {\n            stack_clear(regs+3, irep->nregs-3);\n          }\n        }\n        else if (ci->argc+2 < irep->nregs) {\n          stack_clear(regs+ci->argc+2, irep->nregs-ci->argc-2);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_SUPER) {\n      /* A C  R(A) := super(R(A+1),... ,R(A+C+1)) */\n      int a = GETARG_A(i);\n      int n = GETARG_C(i);\n      int argc = (n == CALL_MAXARGS) ? -1 : n;\n      int bidx = (argc < 0) ? a+2 : a+n+1;\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = MRB_PROC_TARGET_CLASS(ci->proc);\n\n      mrb_assert(bidx < ci->nregs);\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->tt == MRB_TT_MODULE) {\n        target_class = ci->target_class;\n        if (target_class->tt != MRB_TT_ICLASS) {\n          mrb_value exc = mrb_exc_new_str_lit(mrb, E_RUNTIME_ERROR, \"superclass info lost [mruby limitations]\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      blk = regs[bidx];\n      if (!mrb_nil_p(blk) && mrb_type(blk) != MRB_TT_PROC) {\n        blk = mrb_convert_type(mrb, blk, MRB_TT_PROC, \"Proc\", \"to_proc\");\n        /* The stack or ci stack might have been reallocated during\n           mrb_convert_type(), see #3622 and #3784 */\n        regs[bidx] = blk;\n        ci = mrb->c->ci;\n      }\n      c = target_class->super;\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n\n        if (mid != missing) {\n          c = mrb_class(mrb, recv);\n        }\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m)) {\n          mrb_value args = (argc < 0) ? regs[a+1] : mrb_ary_new_from_values(mrb, n, regs+a+1);\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        mid = missing;\n        if (argc >= 0) {\n          if (a+2 >= ci->nregs) {\n            stack_extend(mrb, a+3);\n          }\n          regs[a+1] = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          regs[a+2] = blk;\n          argc = -1;\n        }\n        mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(ci->mid));\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb);\n      ci->mid = mid;\n      ci->stackent = mrb->c->stack;\n      ci->target_class = c;\n      ci->pc = pc + 1;\n      ci->argc = argc;\n\n      /* prepare stack */\n      mrb->c->stack += a;\n      mrb->c->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n        ci->nregs = (argc < 0) ? 3 : n+2;\n        if (MRB_METHOD_PROC_P(m)) {\n          ci->proc = MRB_METHOD_PROC(m);\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (!ci->target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->acc == CI_ACC_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->stack[0] = v;\n        /* pop stackpos */\n        mrb->c->stack = ci->stackent;\n        pc = ci->pc;\n        cipop(mrb);\n        JUMP;\n      }\n      else {\n        /* fill callinfo */\n        ci->acc = a;\n\n        /* setup environment for calling method */\n        proc = ci->proc = MRB_METHOD_PROC(m);\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, (argc < 0 && ci->nregs < 3) ? 3 : ci->nregs);\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_ARGARY) {\n      /* A Bx   R(A) := argument array (16=6:1:5:4) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      int m1 = (bx>>10)&0x3f;\n      int r  = (bx>>9)&0x1;\n      int m2 = (bx>>4)&0x1f;\n      int lv = (bx>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb->c->ci->target_class == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_str_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_STACK_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = (int)ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      regs[a+1] = stack[m1+r+m2];\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER) {\n      /* Ax             arg setup according to flags (23=5:5:1:5:5:1:1) */\n      /* number of optional arguments times OP_JMP should follow */\n      mrb_aspec ax = GETARG_Ax(i);\n      int m1 = MRB_ASPEC_REQ(ax);\n      int o  = MRB_ASPEC_OPT(ax);\n      int r  = MRB_ASPEC_REST(ax);\n      int m2 = MRB_ASPEC_POST(ax);\n      /* unused\n      int k  = MRB_ASPEC_KEY(ax);\n      int kd = MRB_ASPEC_KDICT(ax);\n      int b  = MRB_ASPEC_BLOCK(ax);\n      */\n      int argc = mrb->c->ci->argc;\n      mrb_value *argv = regs+1;\n      mrb_value *argv0 = argv;\n      int len = m1 + o + r + m2;\n      mrb_value *blk = &argv[argc < 0 ? 1 : argc];\n\n      if (argc < 0) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n      if (mrb->c->ci->proc && MRB_PROC_STRICT_P(mrb->c->ci->proc)) {\n        if (argc >= 0) {\n          if (argc < m1 + m2 || (r == 0 && argc > len)) {\n            argnum_error(mrb, m1+m2);\n            goto L_RAISE;\n          }\n        }\n      }\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n      if (argc < len) {\n        int mlen = m2;\n        if (argc < m1+m2) {\n          if (m1 < argc)\n            mlen = argc - m1;\n          else\n            mlen = 0;\n        }\n        regs[len+1] = *blk; /* move block */\n        SET_NIL_VALUE(regs[argc+1]);\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        if (r) {\n          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);\n        }\n        if (o == 0 || argc < m1+m2) pc++;\n        else\n          pc += argc - m1 - m2 + 1;\n      }\n      else {\n        int rnum = 0;\n        if (argv0 != argv) {\n          regs[len+1] = *blk; /* move block */\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          regs[m1+o+1] = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n        }\n        if (m2) {\n          if (argc-m2 > m1) {\n            value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n          }\n        }\n        if (argv0 == argv) {\n          regs[len+1] = *blk; /* move block */\n        }\n        pc += o + 1;\n      }\n      mrb->c->ci->argc = len;\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-len-2 > 0) {\n        stack_clear(&regs[len+2], irep->nlocals-len-2);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG) {\n      /* A B C          R(A) := kdict[Syms(B)]; if C kdict.rm(Syms(B)) */\n      /* if C == 2; raise unless kdict.empty? */\n      /* OP_JMP should follow to skip init code */\n      NEXT;\n    }\n\n    CASE(OP_KDICT) {\n      /* A C            R(A) := kdict */\n      NEXT;\n    }\n\n    L_RETURN:\n      i = MKOP_AB(OP_RETURN, GETARG_A(i), OP_R_NORMAL);\n      /* fall through */\n    CASE(OP_RETURN) {\n      /* A B     return R(A) (B=normal,in-block return/break) */\n      mrb_callinfo *ci;\n\n#define ecall_adjust() do {\\\n  ptrdiff_t cioff = ci - mrb->c->cibase;\\\n  ecall(mrb);\\\n  ci = mrb->c->cibase + cioff;\\\n} while (0)\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk;\n\n        if (ci->argc < 0) {\n          blk = regs[2];\n        }\n        else {\n          blk = regs[ci->argc+1];\n        }\n        if (mrb_type(blk) == MRB_TT_PROC) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == ci[-1].env) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n        mrb_callinfo *ci0;\n\n      L_RAISE:\n        ci0 = ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          if (ci->ridx == 0) goto L_FTOP;\n          goto L_RESCUE;\n        }\n        while (ci[0].ridx == ci[-1].ridx) {\n          cipop(mrb);\n          mrb->c->stack = ci->stackent;\n          if (ci->acc == CI_ACC_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          ci = mrb->c->ci;\n          if (ci == mrb->c->cibase) {\n            if (ci->ridx == 0) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                while (c->eidx > ci->epos) {\n                  ecall_adjust();\n                }\n                if (c->fib) {\n                  mrb_write_barrier(mrb, (struct RBasic*)c->fib);\n                }\n                mrb->c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n          /* call ensure only when we skip this callinfo */\n          if (ci[0].ridx == ci[-1].ridx) {\n            while (mrb->c->eidx > ci->epos) {\n              ecall_adjust();\n            }\n          }\n        }\n      L_RESCUE:\n        if (ci->ridx == 0) goto L_STOP;\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        if (ci < ci0) {\n          mrb->c->stack = ci[1].stackent;\n        }\n        stack_extend(mrb, irep->nregs);\n        pc = mrb->c->rescue[--ci->ridx];\n      }\n      else {\n        int acc;\n        mrb_value v;\n        struct RProc *dst;\n\n        ci = mrb->c->ci;\n        v = regs[GETARG_A(i)];\n        mrb_gc_protect(mrb, v);\n        switch (GETARG_B(i)) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->acc >=0 && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            mrb_callinfo *cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_STACK_SHARED_P(e) || e->cxt != mrb->c) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->acc < 0) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) {\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            break;\n          }\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n\n            if (!mrb->c->prev) { /* toplevel return */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            if (mrb->c->prev->ci == mrb->c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_str_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            while (mrb->c->eidx > 0) {\n              ecall(mrb);\n            }\n            /* automatic yield at the end */\n            c = mrb->c;\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            c->prev = NULL;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            ci = mrb->c->ci;\n          }\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) { \n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_str_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_STACK_SHARED_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e == mrb->c->cibase->env && proc != mrb->c->cibase->proc) {\n              goto L_BREAK_ERROR;\n            }\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          while (mrb->c->eidx > mrb->c->ci->epos) {\n            ecall_adjust();\n          }\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->acc < 0) {\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->exc = (struct RObject*)break_new(mrb, proc, v);\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n          L_BREAK:\n            v = ((struct RBreak*)mrb->exc)->val;\n            proc = ((struct RBreak*)mrb->exc)->proc;\n            mrb->exc = NULL;\n            ci = mrb->c->ci;\n          }\n          mrb->c->stack = ci->stackent;\n          proc = proc->upper;\n          while (mrb->c->cibase < ci &&  ci[-1].proc != proc) {\n            if (ci[-1].acc == CI_ACC_SKIP) {\n              while (ci < mrb->c->ci) {\n                cipop(mrb);\n              }\n              goto L_BREAK_ERROR;\n            }\n            ci--;\n          }\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        while (ci < mrb->c->ci) {\n          cipop(mrb);\n        }\n        ci[0].ridx = ci[-1].ridx;\n        while (mrb->c->eidx > ci->epos) {\n          ecall_adjust();\n        }\n        if (mrb->c->vmexec && !ci->target_class) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->acc;\n        mrb->c->stack = ci->stackent;\n        cipop(mrb);\n        if (acc == CI_ACC_SKIP || acc == CI_ACC_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        ci = mrb->c->ci;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym2name(mrb, ci->mid)));\n        proc = mrb->c->ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        regs[acc] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\n    CASE(OP_TAILCALL) {\n      /* A B C  return call(R(A),Syms(B),R(A+1),... ,R(A+C+1)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int n = GETARG_C(i);\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci;\n      mrb_value recv;\n      mrb_sym mid = syms[b];\n\n      recv = regs[a];\n      c = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_value sym = mrb_symbol_value(mid);\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m)) {\n          mrb_value args;\n\n          if (n == CALL_MAXARGS) {\n            args = regs[a+1];\n          }\n          else {\n            args = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          }\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        mid = missing;\n        if (n == CALL_MAXARGS) {\n          mrb_ary_unshift(mrb, regs[a+1], sym);\n        }\n        else {\n          value_move(regs+a+2, regs+a+1, ++n);\n          regs[a+1] = sym;\n        }\n      }\n\n      /* replace callinfo */\n      ci = mrb->c->ci;\n      ci->mid = mid;\n      ci->target_class = c;\n      if (n == CALL_MAXARGS) {\n        ci->argc = -1;\n      }\n      else {\n        ci->argc = n;\n      }\n\n      /* move stack */\n      value_move(mrb->c->stack, &regs[a], ci->argc+1);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb->c->stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n        goto L_RETURN;\n      }\n      else {\n        /* setup environment for calling method */\n        struct RProc *p = MRB_METHOD_PROC(m);\n        irep = p->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        if (ci->argc < 0) {\n          stack_extend(mrb, (irep->nregs < 3) ? 3 : irep->nregs);\n        }\n        else {\n          stack_extend(mrb, irep->nregs);\n        }\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_BLKPUSH) {\n      /* A Bx   R(A) := block (16=6:1:5:4) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      int m1 = (bx>>10)&0x3f;\n      int r  = (bx>>9)&0x1;\n      int m2 = (bx>>4)&0x1f;\n      int lv = (bx>>0)&0xf;\n      mrb_value *stack;\n\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e || (!MRB_ENV_STACK_SHARED_P(e) && e->mid == 0) ||\n            MRB_ENV_STACK_LEN(e) <= m1+r+m2+1) {\n          localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n          goto L_RAISE;\n        }\n        stack = e->stack + 1;\n      }\n      if (mrb_nil_p(stack[m1+r+m2])) {\n        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n        goto L_RAISE;\n      }\n      regs[a] = stack[m1+r+m2];\n      NEXT;\n    }\n\n#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n#define OP_MATH_BODY(op,v1,v2) do {\\\n  v1(regs[a]) = v1(regs[a]) op v2(regs[a+1]);\\\n} while(0)\n\n    CASE(OP_ADD) {\n      /* A B C  R(A) := R(A)+R(A+1) (Syms[B]=:+,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n          mrb_value *regs_a = regs + a;\n\n          x = mrb_fixnum(regs_a[0]);\n          y = mrb_fixnum(regs_a[1]);\n          if (mrb_int_add_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs_a[0], (mrb_float)x + (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x + y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + y);\n        }\n#else\n        OP_MATH_BODY(+,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + y);\n        }\n#else\n        OP_MATH_BODY(+,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      case TYPES2(MRB_TT_STRING,MRB_TT_STRING):\n        regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);\n        break;\n      default:\n        goto L_SEND;\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_SUB) {\n      /* A B C  R(A) := R(A)-R(A+1) (Syms[B]=:-,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n\n          x = mrb_fixnum(regs[a]);\n          y = mrb_fixnum(regs[a+1]);\n          if (mrb_int_sub_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x - (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x - y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - y);\n        }\n#else\n        OP_MATH_BODY(-,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - y);\n        }\n#else\n        OP_MATH_BODY(-,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_MUL) {\n      /* A B C  R(A) := R(A)*R(A+1) (Syms[B]=:*,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n\n          x = mrb_fixnum(regs[a]);\n          y = mrb_fixnum(regs[a+1]);\n          if (mrb_int_mul_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x * (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x * y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x * y);\n        }\n#else\n        OP_MATH_BODY(*,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x * y);\n        }\n#else\n        OP_MATH_BODY(*,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_DIV) {\n      /* A B C  R(A) := R(A)/R(A+1) (Syms[B]=:/,C=1)*/\n      int a = GETARG_A(i);\n#ifndef MRB_WITHOUT_FLOAT\n      double x, y, f;\n#endif\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n#ifdef MRB_WITHOUT_FLOAT\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_INT_VALUE(regs[a], y ? x / y : 0);\n        }\n        break;\n#else\n        x = (mrb_float)mrb_fixnum(regs[a]);\n        y = (mrb_float)mrb_fixnum(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        x = (mrb_float)mrb_fixnum(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n        x = mrb_float(regs[a]);\n        y = (mrb_float)mrb_fixnum(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n        x = mrb_float(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n\n#ifndef MRB_WITHOUT_FLOAT\n      if (y == 0) {\n        if (x > 0) f = INFINITY;\n        else if (x < 0) f = -INFINITY;\n        else /* if (x == 0) */ f = NAN;\n      }\n      else {\n        f = x / y;\n      }\n      SET_FLOAT_VALUE(mrb, regs[a], f);\n#endif\n      NEXT;\n    }\n\n    CASE(OP_ADDI) {\n      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/\n      int a = GETARG_A(i);\n\n      /* need to check if + is overridden */\n      switch (mrb_type(regs[a])) {\n      case MRB_TT_FIXNUM:\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_int y = GETARG_C(i);\n          mrb_int z;\n\n          if (mrb_int_add_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x + (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case MRB_TT_FLOAT:\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + GETARG_C(i));\n        }\n#else\n        mrb_float(regs[a]) += GETARG_C(i);\n#endif\n        break;\n#endif\n      default:\n        SET_INT_VALUE(regs[a+1], GETARG_C(i));\n        i = MKOP_ABC(OP_SEND, a, GETARG_B(i), 1);\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SUBI) {\n      /* A B C  R(A) := R(A)-C (Syms[B]=:-)*/\n      int a = GETARG_A(i);\n      mrb_value *regs_a = regs + a;\n\n      /* need to check if + is overridden */\n      switch (mrb_type(regs_a[0])) {\n      case MRB_TT_FIXNUM:\n        {\n          mrb_int x = mrb_fixnum(regs_a[0]);\n          mrb_int y = GETARG_C(i);\n          mrb_int z;\n\n          if (mrb_int_sub_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs_a[0], (mrb_float)x - (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs_a[0], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case MRB_TT_FLOAT:\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - GETARG_C(i));\n        }\n#else\n        mrb_float(regs_a[0]) -= GETARG_C(i);\n#endif\n        break;\n#endif\n      default:\n        SET_INT_VALUE(regs_a[1], GETARG_C(i));\n        i = MKOP_ABC(OP_SEND, a, GETARG_B(i), 1);\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n#define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n\n#ifdef MRB_WITHOUT_FLOAT\n#define OP_CMP(op) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  default:\\\n    goto L_SEND;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#else\n#define OP_CMP(op) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n    break;\\\n  default:\\\n    goto L_SEND;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#endif\n\n    CASE(OP_EQ) {\n      /* A B C  R(A) := R(A)==R(A+1) (Syms[B]=:==,C=1)*/\n      int a = GETARG_A(i);\n      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n        SET_TRUE_VALUE(regs[a]);\n      }\n      else {\n        OP_CMP(==);\n      }\n      NEXT;\n    }\n\n    CASE(OP_LT) {\n      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(<);\n      NEXT;\n    }\n\n    CASE(OP_LE) {\n      /* A B C  R(A) := R(A)<=R(A+1) (Syms[B]=:<=,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(<=);\n      NEXT;\n    }\n\n    CASE(OP_GT) {\n      /* A B C  R(A) := R(A)>R(A+1) (Syms[B]=:>,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(>);\n      NEXT;\n    }\n\n    CASE(OP_GE) {\n      /* A B C  R(A) := R(A)>=R(A+1) (Syms[B]=:>=,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(>=);\n      NEXT;\n    }\n\n    CASE(OP_ARRAY) {\n      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value v = mrb_ary_new_from_values(mrb, c, &regs[b]);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYCAT) {\n      /* A B            mrb_ary_concat(R(A),R(B)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      mrb_value splat = mrb_ary_splat(mrb, regs[b]);\n      mrb_ary_concat(mrb, regs[a], splat);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYPUSH) {\n      /* A B            R(A).push(R(B)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      mrb_ary_push(mrb, regs[a], regs[b]);\n      NEXT;\n    }\n\n    CASE(OP_AREF) {\n      /* A B C          R(A) := R(B)[C] */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value v = regs[b];\n\n      if (!mrb_array_p(v)) {\n        if (c == 0) {\n          regs[a] = v;\n        }\n        else {\n          SET_NIL_VALUE(regs[a]);\n        }\n      }\n      else {\n        v = mrb_ary_ref(mrb, v, c);\n        regs[a] = v;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ASET) {\n      /* A B C          R(B)[C] := R(A) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_ary_set(mrb, regs[b], c, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_APOST) {\n      /* A B C  *R(A),R(A+1)..R(A+C) := R(A) */\n      int a = GETARG_A(i);\n      mrb_value v = regs[a];\n      int pre  = GETARG_B(i);\n      int post = GETARG_C(i);\n      struct RArray *ary;\n      int len, idx;\n\n      if (!mrb_array_p(v)) {\n        v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n      }\n      ary = mrb_ary_ptr(v);\n      len = (int)ARY_LEN(ary);\n      if (len > pre + post) {\n        v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n        regs[a++] = v;\n        while (post--) {\n          regs[a++] = ARY_PTR(ary)[len-post-1];\n        }\n      }\n      else {\n        v = mrb_ary_new_capa(mrb, 0);\n        regs[a++] = v;\n        for (idx=0; idx+pre<len; idx++) {\n          regs[a+idx] = ARY_PTR(ary)[pre+idx];\n        }\n        while (idx < post) {\n          SET_NIL_VALUE(regs[a+idx]);\n          idx++;\n        }\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRING) {\n      /* A Bx           R(A) := str_new(Lit(Bx)) */\n      mrb_int a = GETARG_A(i);\n      mrb_int bx = GETARG_Bx(i);\n      mrb_value str = mrb_str_dup(mrb, pool[bx]);\n\n      regs[a] = str;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRCAT) {\n      /* A B    R(A).concat(R(B)) */\n      mrb_int a = GETARG_A(i);\n      mrb_int b = GETARG_B(i);\n\n      mrb_str_concat(mrb, regs[a], regs[b]);\n      NEXT;\n    }\n\n    CASE(OP_HASH) {\n      /* A B C   R(A) := hash_new(R(B),R(B+1)..R(B+C)) */\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      int lim = b+c*2;\n      mrb_value hash = mrb_hash_new_capa(mrb, c);\n\n      while (b < lim) {\n        mrb_hash_set(mrb, hash, regs[b], regs[b+1]);\n        b+=2;\n      }\n      regs[GETARG_A(i)] = hash;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_LAMBDA) {\n      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */\n      struct RProc *p;\n      int a = GETARG_A(i);\n      int b = GETARG_b(i);\n      int c = GETARG_c(i);\n      mrb_irep *nirep = irep->reps[b];\n\n      if (c & OP_L_CAPTURE) {\n        p = mrb_closure_new(mrb, nirep);\n      }\n      else {\n        p = mrb_proc_new(mrb, nirep);\n        p->flags |= MRB_PROC_SCOPE;\n      }\n      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n      regs[a] = mrb_obj_value(p);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_OCLASS) {\n      /* A      R(A) := ::Object */\n      regs[GETARG_A(i)] = mrb_obj_value(mrb->object_class);\n      NEXT;\n    }\n\n    CASE(OP_CLASS) {\n      /* A B    R(A) := newclass(R(A),Syms(B),R(A+1)) */\n      struct RClass *c = 0, *baseclass;\n      int a = GETARG_A(i);\n      mrb_value base, super;\n      mrb_sym id = syms[GETARG_B(i)];\n\n      base = regs[a];\n      super = regs[a+1];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_class(mrb, base, super, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_MODULE) {\n      /* A B            R(A) := newmodule(R(A),Syms(B)) */\n      struct RClass *c = 0, *baseclass;\n      int a = GETARG_A(i);\n      mrb_value base;\n      mrb_sym id = syms[GETARG_B(i)];\n\n      base = regs[a];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_module(mrb, base, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EXEC) {\n      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_callinfo *ci;\n      mrb_value recv = regs[a];\n      struct RProc *p;\n      mrb_irep *nirep = irep->reps[bx];\n\n      /* prepare closure */\n      p = mrb_proc_new(mrb, nirep);\n      p->c = NULL;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n      MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n      p->flags |= MRB_PROC_SCOPE;\n\n      /* prepare call stack */\n      ci = cipush(mrb);\n      ci->pc = pc + 1;\n      ci->acc = a;\n      ci->mid = 0;\n      ci->stackent = mrb->c->stack;\n      ci->argc = 0;\n      ci->target_class = mrb_class_ptr(recv);\n\n      /* prepare stack */\n      mrb->c->stack += a;\n\n      /* setup block to call */\n      ci->proc = p;\n\n      irep = p->body.irep;\n      pool = irep->pool;\n      syms = irep->syms;\n      ci->nregs = irep->nregs;\n      stack_extend(mrb, ci->nregs);\n      stack_clear(regs+1, ci->nregs-1);\n      pc = irep->iseq;\n      JUMP;\n    }\n\n    CASE(OP_METHOD) {\n      /* A B            R(A).newmethod(Syms(B),R(A+1)) */\n      int a = GETARG_A(i);\n      struct RClass *c = mrb_class_ptr(regs[a]);\n      struct RProc *p = mrb_proc_ptr(regs[a+1]);\n      mrb_method_t m;\n\n      MRB_METHOD_FROM_PROC(m, p);\n      mrb_define_method_raw(mrb, c, syms[GETARG_B(i)], m);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_SCLASS) {\n      /* A B    R(A) := R(B).singleton_class */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n\n      regs[a] = mrb_singleton_class(mrb, regs[b]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_TCLASS) {\n      /* A      R(A) := target_class */\n      if (!mrb->c->ci->target_class) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR, \"no target class or module\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      regs[GETARG_A(i)] = mrb_obj_value(mrb->c->ci->target_class);\n      NEXT;\n    }\n\n    CASE(OP_RANGE) {\n      /* A B C  R(A) := range_new(R(B),R(B+1),C) */\n      int b = GETARG_B(i);\n      mrb_value val = mrb_range_new(mrb, regs[b], regs[b+1], GETARG_C(i));\n      regs[GETARG_A(i)] = val;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_DEBUG) {\n      /* A B C    debug print R(A),R(B),R(C) */\n#ifdef MRB_ENABLE_DEBUG_HOOK\n      mrb->debug_op_hook(mrb, irep, pc, regs);\n#else\n#ifndef MRB_DISABLE_STDIO\n      printf(\"OP_DEBUG %d %d %d\\n\", GETARG_A(i), GETARG_B(i), GETARG_C(i));\n#else\n      abort();\n#endif\n#endif\n      NEXT;\n    }\n\n    CASE(OP_STOP) {\n      /*        stop VM */\n    L_STOP:\n      while (mrb->c->eidx > 0) {\n        ecall(mrb);\n      }\n      ERR_PC_CLR(mrb);\n      mrb->jmp = prev_jmp;\n      if (mrb->exc) {\n        return mrb_obj_value(mrb->exc);\n      }\n      return regs[irep->nlocals];\n    }\n\n    CASE(OP_ERR) {\n      /* Bx     raise RuntimeError with message Lit(Bx) */\n      mrb_value msg = mrb_str_dup(mrb, pool[GETARG_Bx(i)]);\n      mrb_value exc;\n\n      if (GETARG_A(i) == 0) {\n        exc = mrb_exc_new_str(mrb, E_RUNTIME_ERROR, msg);\n      }\n      else {\n        exc = mrb_exc_new_str(mrb, E_LOCALJUMP_ERROR, msg);\n      }\n      ERR_PC_SET(mrb, pc);\n      mrb_exc_set(mrb, exc);\n      goto L_RAISE;\n    }\n  }\n  END_DISPATCH;\n#undef regs\n\n  }\n  MRB_CATCH(&c_jmp) {\n    exc_catched = TRUE;\n    goto RETRY_TRY_BLOCK;\n  }\n  MRB_END_EXC(&c_jmp);\n}", "commit_link": "github.com/mruby/mruby/commit/1905091634a6a2925c911484434448e568330626", "file_name": "src/vm.c", "vul_type": "cwe-416", "description": "Execute a Ruby method from a given bytecode in the MRuby language."}
{"func_name": "regulator_ena_gpio_free", "func_src_before": "static void regulator_ena_gpio_free(struct regulator_dev *rdev)\n{\n\tstruct regulator_enable_gpio *pin, *n;\n\n\tif (!rdev->ena_pin)\n\t\treturn;\n\n\t/* Free the GPIO only in case of no use */\n\tlist_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {\n\t\tif (pin->gpiod == rdev->ena_pin->gpiod) {\n\t\t\tif (pin->request_count <= 1) {\n\t\t\t\tpin->request_count = 0;\n\t\t\t\tgpiod_put(pin->gpiod);\n\t\t\t\tlist_del(&pin->list);\n\t\t\t\tkfree(pin);\n\t\t\t} else {\n\t\t\t\tpin->request_count--;\n\t\t\t}\n\t\t}\n\t}\n}", "func_src_after": "static void regulator_ena_gpio_free(struct regulator_dev *rdev)\n{\n\tstruct regulator_enable_gpio *pin, *n;\n\n\tif (!rdev->ena_pin)\n\t\treturn;\n\n\t/* Free the GPIO only in case of no use */\n\tlist_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {\n\t\tif (pin->gpiod == rdev->ena_pin->gpiod) {\n\t\t\tif (pin->request_count <= 1) {\n\t\t\t\tpin->request_count = 0;\n\t\t\t\tgpiod_put(pin->gpiod);\n\t\t\t\tlist_del(&pin->list);\n\t\t\t\tkfree(pin);\n\t\t\t\trdev->ena_pin = NULL;\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tpin->request_count--;\n\t\t\t}\n\t\t}\n\t}\n}", "commit_link": "github.com/torvalds/linux/commit/60a2362f769cf549dc466134efe71c8bf9fbaaba", "file_name": "drivers/regulator/core.c", "vul_type": "cwe-416", "description": "Write a C function to release a GPIO pin associated with a regulator device when it's no longer in use."}
{"func_name": "(anonymous)", "func_src_before": "  }, function (statusCode, body) {\n    if (statusCode !== 200) {\n      // request a new login key first\n      this._steamUser.requestWebAPIAuthenticateUserNonce(function (nonce) {\n        this._webLoginKey = nonce.webapi_authenticate_user_nonce;\n        this.webLogOn(callback);\n      }.bind(this));\n      return;\n    }\n\n    this.sessionID = Math.floor(Math.random() * 1000000000).toString();\n    this.cookies = [\n      'sessionid=' + this.sessionID,\n      'steamLogin=' + body.authenticateuser.token,\n      'steamLoginSecure=' + body.authenticateuser.tokensecure\n    ];\n\n    callback(this.sessionID, this.cookies);\n  }.bind(this));", "func_src_after": "  }, function (statusCode, body) {\n    if (statusCode !== 200) {\n      // request a new login key first\n      this._steamUser.requestWebAPIAuthenticateUserNonce(function (nonce) {\n        this._webLoginKey = nonce.webapi_authenticate_user_nonce;\n        this.webLogOn(callback);\n      }.bind(this));\n      return;\n    }\n\n    this.sessionID = crypto.randomBytes(12).toString('hex');\n    this.cookies = [\n      'sessionid=' + this.sessionID,\n      'steamLogin=' + body.authenticateuser.token,\n      'steamLoginSecure=' + body.authenticateuser.tokensecure\n    ];\n\n    callback(this.sessionID, this.cookies);\n  }.bind(this));", "line_changes": {"deleted": [{"line_no": 11, "char_start": 321, "char_end": 393, "line": "    this.sessionID = Math.floor(Math.random() * 1000000000).toString();\n"}], "added": [{"line_no": 11, "char_start": 321, "char_end": 382, "line": "    this.sessionID = crypto.randomBytes(12).toString('hex');\n"}]}, "char_changes": {"deleted": [{"char_start": 342, "char_end": 379, "chars": "Math.floor(Math.random() * 1000000000"}], "added": [{"char_start": 342, "char_end": 363, "chars": "crypto.randomBytes(12"}, {"char_start": 374, "char_end": 379, "chars": "'hex'"}]}, "commit_link": "github.com/Alex7Kom/node-steam-weblogon/commit/75224e83b75341366d1e75a07e8745025492a5e3", "file_name": "index.js", "vul_type": "cwe-338", "commit_msg": "Replaced Math.random() with crypto.randomBytes() for sessionid. Closes #4", "parent_commit": "a8eb1309ef9b64faa7cbc1dfa3f9e44b1430a437", "description": "Write a JavaScript function that handles Steam user authentication, generating a session ID and cookies upon successful login, and requesting a new login key if the status code is not 200."}
{"func_name": "stops", "func_src_before": "  def stops\n    if params['lat'] and params['lng']\n      @page[:order] = params[:order] || \"distance ASC\"\n      @page[:limit] = params[:limit] || 5\n      distance = \"7912*ASIN(SQRT(POWER(SIN((lat-#{params['lat']})*pi()/180/2),2)+COS(lat*pi()/180)*COS(#{params['lat']}*pi()/180)*POWER(SIN((lng-#{params['lng']})*pi()/180/2),2)))\"\n      @stops =  BusStop.select(\"bus_stops.*, #{distance} AS distance\").where(\"lat IS NOT NULL AND lng IS NOT NULL\").paginate(@page)\n    end\n\n    respond_to do |format|\n      format.html \n      format.json { render json: @stops, callback: params[:callback] }\n      format.xml { render xml: @stops }\n    end\n  end", "func_src_after": "  def stops\n    if params['lat'] and params['lng']\n      @page[:order] = params[:order] || \"distance ASC\"\n      @page[:limit] = params[:limit] || 5\n      lat = BigDecimal.new params['lat']\n      lng = BigDecimal.new params['lng']\n      distance = \"7912*ASIN(SQRT(POWER(SIN((lat-#{lat})*pi()/180/2),2)+COS(lat*pi()/180)*COS(#{lat}*pi()/180)*POWER(SIN((lng-#{lng})*pi()/180/2),2)))\"\n      @stops =  BusStop.select(\"bus_stops.*, #{distance} AS distance\").where(\"lat IS NOT NULL AND lng IS NOT NULL\").paginate(@page)\n    end\n\n    respond_to do |format|\n      format.html \n      format.json { render json: @stops, callback: params[:callback] }\n      format.xml { render xml: @stops }\n    end\n  end", "line_changes": {"deleted": [{"line_no": 5, "char_start": 148, "char_end": 329, "line": "      distance = \"7912*ASIN(SQRT(POWER(SIN((lat-#{params['lat']})*pi()/180/2),2)+COS(lat*pi()/180)*COS(#{params['lat']}*pi()/180)*POWER(SIN((lng-#{params['lng']})*pi()/180/2),2)))\"\n"}], "added": [{"line_no": 5, "char_start": 148, "char_end": 189, "line": "      lat = BigDecimal.new params['lat']\n"}, {"line_no": 6, "char_start": 189, "char_end": 230, "line": "      lng = BigDecimal.new params['lng']\n"}, {"line_no": 7, "char_start": 230, "char_end": 381, "line": "      distance = \"7912*ASIN(SQRT(POWER(SIN((lat-#{lat})*pi()/180/2),2)+COS(lat*pi()/180)*COS(#{lat}*pi()/180)*POWER(SIN((lng-#{lng})*pi()/180/2),2)))\"\n"}]}, "char_changes": {"deleted": [{"char_start": 198, "char_end": 206, "chars": "params['"}, {"char_start": 209, "char_end": 211, "chars": "']"}, {"char_start": 253, "char_end": 261, "chars": "params['"}, {"char_start": 264, "char_end": 266, "chars": "']"}, {"char_start": 295, "char_end": 303, "chars": "params['"}, {"char_start": 306, "char_end": 308, "chars": "']"}], "added": [{"char_start": 148, "char_end": 230, "chars": "      lat = BigDecimal.new params['lat']\n      lng = BigDecimal.new params['lng']\n"}]}, "commit_link": "github.com/dylan8902/website/commit/b8d2375ebed8bc2fa29d16d6bdf86b707786e297", "file_name": "is_my_bus_delayed_controller.rb", "vul_type": "cwe-089", "commit_msg": "removes chance of sql injection", "description": "Write a Ruby method to find and respond with nearby bus stops based on latitude and longitude parameters."}
{"func_name": "opj_j2k_set_cinema_parameters", "func_src_before": "static void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters,\n        opj_image_t *image, opj_event_mgr_t *p_manager)\n{\n    /* Configure cinema parameters */\n    int i;\n\n    /* No tiling */\n    parameters->tile_size_on = OPJ_FALSE;\n    parameters->cp_tdx = 1;\n    parameters->cp_tdy = 1;\n\n    /* One tile part for each component */\n    parameters->tp_flag = 'C';\n    parameters->tp_on = 1;\n\n    /* Tile and Image shall be at (0,0) */\n    parameters->cp_tx0 = 0;\n    parameters->cp_ty0 = 0;\n    parameters->image_offset_x0 = 0;\n    parameters->image_offset_y0 = 0;\n\n    /* Codeblock size= 32*32 */\n    parameters->cblockw_init = 32;\n    parameters->cblockh_init = 32;\n\n    /* Codeblock style: no mode switch enabled */\n    parameters->mode = 0;\n\n    /* No ROI */\n    parameters->roi_compno = -1;\n\n    /* No subsampling */\n    parameters->subsampling_dx = 1;\n    parameters->subsampling_dy = 1;\n\n    /* 9-7 transform */\n    parameters->irreversible = 1;\n\n    /* Number of layers */\n    if (parameters->tcp_numlayers > 1) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"1 single quality layer\"\n                      \"-> Number of layers forced to 1 (rather than %d)\\n\"\n                      \"-> Rate of the last layer (%3.1f) will be used\",\n                      parameters->tcp_numlayers,\n                      parameters->tcp_rates[parameters->tcp_numlayers - 1]);\n        parameters->tcp_rates[0] = parameters->tcp_rates[parameters->tcp_numlayers - 1];\n        parameters->tcp_numlayers = 1;\n    }\n\n    /* Resolution levels */\n    switch (parameters->rsiz) {\n    case OPJ_PROFILE_CINEMA_2K:\n        if (parameters->numresolution > 6) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-3 (2k dc profile) requires:\\n\"\n                          \"Number of decomposition levels <= 5\\n\"\n                          \"-> Number of decomposition levels forced to 5 (rather than %d)\\n\",\n                          parameters->numresolution + 1);\n            parameters->numresolution = 6;\n        }\n        break;\n    case OPJ_PROFILE_CINEMA_4K:\n        if (parameters->numresolution < 2) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-4 (4k dc profile) requires:\\n\"\n                          \"Number of decomposition levels >= 1 && <= 6\\n\"\n                          \"-> Number of decomposition levels forced to 1 (rather than %d)\\n\",\n                          parameters->numresolution + 1);\n            parameters->numresolution = 1;\n        } else if (parameters->numresolution > 7) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-4 (4k dc profile) requires:\\n\"\n                          \"Number of decomposition levels >= 1 && <= 6\\n\"\n                          \"-> Number of decomposition levels forced to 6 (rather than %d)\\n\",\n                          parameters->numresolution + 1);\n            parameters->numresolution = 7;\n        }\n        break;\n    default :\n        break;\n    }\n\n    /* Precincts */\n    parameters->csty |= 0x01;\n    parameters->res_spec = parameters->numresolution - 1;\n    for (i = 0; i < parameters->res_spec; i++) {\n        parameters->prcw_init[i] = 256;\n        parameters->prch_init[i] = 256;\n    }\n\n    /* The progression order shall be CPRL */\n    parameters->prog_order = OPJ_CPRL;\n\n    /* Progression order changes for 4K, disallowed for 2K */\n    if (parameters->rsiz == OPJ_PROFILE_CINEMA_4K) {\n        parameters->numpocs = (OPJ_UINT32)opj_j2k_initialise_4K_poc(parameters->POC,\n                              parameters->numresolution);\n    } else {\n        parameters->numpocs = 0;\n    }\n\n    /* Limited bit-rate */\n    parameters->cp_disto_alloc = 1;\n    if (parameters->max_cs_size <= 0) {\n        /* No rate has been introduced, 24 fps is assumed */\n        parameters->max_cs_size = OPJ_CINEMA_24_CS;\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1302083 compressed bytes @ 24fps\\n\"\n                      \"As no rate has been given, this limit will be used.\\n\");\n    } else if (parameters->max_cs_size > OPJ_CINEMA_24_CS) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1302083 compressed bytes @ 24fps\\n\"\n                      \"-> Specified rate exceeds this limit. Rate will be forced to 1302083 bytes.\\n\");\n        parameters->max_cs_size = OPJ_CINEMA_24_CS;\n    }\n\n    if (parameters->max_comp_size <= 0) {\n        /* No rate has been introduced, 24 fps is assumed */\n        parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1041666 compressed bytes @ 24fps\\n\"\n                      \"As no rate has been given, this limit will be used.\\n\");\n    } else if (parameters->max_comp_size > OPJ_CINEMA_24_COMP) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1041666 compressed bytes @ 24fps\\n\"\n                      \"-> Specified rate exceeds this limit. Rate will be forced to 1041666 bytes.\\n\");\n        parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n    }\n\n    parameters->tcp_rates[0] = (OPJ_FLOAT32)(image->numcomps * image->comps[0].w *\n                               image->comps[0].h * image->comps[0].prec) /\n                               (OPJ_FLOAT32)(((OPJ_UINT32)parameters->max_cs_size) * 8 * image->comps[0].dx *\n                                       image->comps[0].dy);\n\n}", "func_src_after": "static void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters,\n        opj_image_t *image, opj_event_mgr_t *p_manager)\n{\n    /* Configure cinema parameters */\n    int i;\n\n    /* No tiling */\n    parameters->tile_size_on = OPJ_FALSE;\n    parameters->cp_tdx = 1;\n    parameters->cp_tdy = 1;\n\n    /* One tile part for each component */\n    parameters->tp_flag = 'C';\n    parameters->tp_on = 1;\n\n    /* Tile and Image shall be at (0,0) */\n    parameters->cp_tx0 = 0;\n    parameters->cp_ty0 = 0;\n    parameters->image_offset_x0 = 0;\n    parameters->image_offset_y0 = 0;\n\n    /* Codeblock size= 32*32 */\n    parameters->cblockw_init = 32;\n    parameters->cblockh_init = 32;\n\n    /* Codeblock style: no mode switch enabled */\n    parameters->mode = 0;\n\n    /* No ROI */\n    parameters->roi_compno = -1;\n\n    /* No subsampling */\n    parameters->subsampling_dx = 1;\n    parameters->subsampling_dy = 1;\n\n    /* 9-7 transform */\n    parameters->irreversible = 1;\n\n    /* Number of layers */\n    if (parameters->tcp_numlayers > 1) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"1 single quality layer\"\n                      \"-> Number of layers forced to 1 (rather than %d)\\n\"\n                      \"-> Rate of the last layer (%3.1f) will be used\",\n                      parameters->tcp_numlayers,\n                      parameters->tcp_rates[parameters->tcp_numlayers - 1]);\n        parameters->tcp_rates[0] = parameters->tcp_rates[parameters->tcp_numlayers - 1];\n        parameters->tcp_numlayers = 1;\n    }\n\n    /* Resolution levels */\n    switch (parameters->rsiz) {\n    case OPJ_PROFILE_CINEMA_2K:\n        if (parameters->numresolution > 6) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-3 (2k dc profile) requires:\\n\"\n                          \"Number of decomposition levels <= 5\\n\"\n                          \"-> Number of decomposition levels forced to 5 (rather than %d)\\n\",\n                          parameters->numresolution + 1);\n            parameters->numresolution = 6;\n        }\n        break;\n    case OPJ_PROFILE_CINEMA_4K:\n        if (parameters->numresolution < 2) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-4 (4k dc profile) requires:\\n\"\n                          \"Number of decomposition levels >= 1 && <= 6\\n\"\n                          \"-> Number of decomposition levels forced to 1 (rather than %d)\\n\",\n                          parameters->numresolution + 1);\n            parameters->numresolution = 1;\n        } else if (parameters->numresolution > 7) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-4 (4k dc profile) requires:\\n\"\n                          \"Number of decomposition levels >= 1 && <= 6\\n\"\n                          \"-> Number of decomposition levels forced to 6 (rather than %d)\\n\",\n                          parameters->numresolution + 1);\n            parameters->numresolution = 7;\n        }\n        break;\n    default :\n        break;\n    }\n\n    /* Precincts */\n    parameters->csty |= 0x01;\n    if (parameters->numresolution == 1) {\n        parameters->res_spec = 1;\n        parameters->prcw_init[0] = 128;\n        parameters->prch_init[0] = 128;\n    } else {\n        parameters->res_spec = parameters->numresolution - 1;\n        for (i = 0; i < parameters->res_spec; i++) {\n            parameters->prcw_init[i] = 256;\n            parameters->prch_init[i] = 256;\n        }\n    }\n\n    /* The progression order shall be CPRL */\n    parameters->prog_order = OPJ_CPRL;\n\n    /* Progression order changes for 4K, disallowed for 2K */\n    if (parameters->rsiz == OPJ_PROFILE_CINEMA_4K) {\n        parameters->numpocs = (OPJ_UINT32)opj_j2k_initialise_4K_poc(parameters->POC,\n                              parameters->numresolution);\n    } else {\n        parameters->numpocs = 0;\n    }\n\n    /* Limited bit-rate */\n    parameters->cp_disto_alloc = 1;\n    if (parameters->max_cs_size <= 0) {\n        /* No rate has been introduced, 24 fps is assumed */\n        parameters->max_cs_size = OPJ_CINEMA_24_CS;\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1302083 compressed bytes @ 24fps\\n\"\n                      \"As no rate has been given, this limit will be used.\\n\");\n    } else if (parameters->max_cs_size > OPJ_CINEMA_24_CS) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1302083 compressed bytes @ 24fps\\n\"\n                      \"-> Specified rate exceeds this limit. Rate will be forced to 1302083 bytes.\\n\");\n        parameters->max_cs_size = OPJ_CINEMA_24_CS;\n    }\n\n    if (parameters->max_comp_size <= 0) {\n        /* No rate has been introduced, 24 fps is assumed */\n        parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1041666 compressed bytes @ 24fps\\n\"\n                      \"As no rate has been given, this limit will be used.\\n\");\n    } else if (parameters->max_comp_size > OPJ_CINEMA_24_COMP) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1041666 compressed bytes @ 24fps\\n\"\n                      \"-> Specified rate exceeds this limit. Rate will be forced to 1041666 bytes.\\n\");\n        parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n    }\n\n    parameters->tcp_rates[0] = (OPJ_FLOAT32)(image->numcomps * image->comps[0].w *\n                               image->comps[0].h * image->comps[0].prec) /\n                               (OPJ_FLOAT32)(((OPJ_UINT32)parameters->max_cs_size) * 8 * image->comps[0].dx *\n                                       image->comps[0].dy);\n\n}", "commit_link": "github.com/uclouvain/openjpeg/commit/4241ae6fbbf1de9658764a80944dc8108f2b4154", "file_name": "src/lib/openjp2/j2k.c", "vul_type": "cwe-787", "description": "Write a C function to configure JPEG 2000 cinema parameters for an image."}
{"func_name": "add_article_action", "func_src_before": "def add_article_action(request: HttpRequest, default_foreward_url: str):\n    forward_url: str = default_foreward_url\n    if request.GET.get(\"redirect\"):\n        forward_url = request.GET[\"redirect\"]\n    else:\n        forward_url = \"/admin\"\n    if \"rid\" not in request.GET:\n        return HttpResponseRedirect(\"/admin?error=Missing%20reservation%20id%20in%20request\")\n    u: Profile = get_current_user(request)\n    current_reservation = GroupReservation.objects.get(id=str(request.GET[\"rid\"]))\n    if current_reservation.createdByUser != u and u.rights < 2:\n        return HttpResponseRedirect(\"/admin?error=noyb\")\n    if current_reservation.submitted == True:\n        return HttpResponseRedirect(\"/admin?error=Already%20submitted\")\n    # Test for multiple or single article\n    if \"article_id\" in request.POST:\n        # Actual adding of article\n        aid: int = int(request.GET.get(\"article_id\"))\n        quantity: int = int(request.POST[\"quantity\"])\n        notes: str = request.POST[\"notes\"]\n        ar = ArticleRequested()\n        ar.AID = Article.objects.get(id=aid)\n        ar.RID = current_reservation\n        if \"srid\" in request.GET:\n            ar.SRID = SubReservation.objects.get(id=int(request.GET[\"srid\"]))\n        ar.amount = quantity\n        ar.notes = notes\n        ar.save()\n    # Actual adding of multiple articles\n    else:\n        if \"group_id\" not in request.GET:\n            return HttpResponseRedirect(\"/admin?error=missing%20group%20id\")\n        g: ArticleGroup = ArticleGroup.objects.get(id=int(request.GET[\"group_id\"]))\n        for art in Article.objects.all().filter(group=g):\n            if str(\"quantity_\" + str(art.id)) not in request.POST or str(\"notes_\" + str(art.id)) not in request.POST:\n                return HttpResponseRedirect(\"/admin?error=Missing%20article%20data%20in%20request\")\n            amount = int(request.POST[\"quantity_\" + str(art.id)])\n            if amount > 0:\n                ar = ArticleRequested()\n                ar.AID = art\n                ar.RID = current_reservation\n                ar.amount = amount\n                if \"srid\" in request.GET:\n                    ar.SRID = SubReservation.objects.get(id=int(request.GET[\"srid\"]))\n                ar.notes = str(request.POST[str(\"notes_\" + str(art.id))])\n                ar.save()\n    if \"srid\" in request.GET:\n        response = HttpResponseRedirect(forward_url + \"?rid=\" + str(current_reservation.id) + \"&srid=\" + request.GET[\"srid\"])\n    else:\n        response = HttpResponseRedirect(forward_url + \"?rid=\" + str(current_reservation.id))\n    return response", "func_src_after": "def add_article_action(request: HttpRequest, default_foreward_url: str):\n    forward_url: str = default_foreward_url\n    if request.GET.get(\"redirect\"):\n        forward_url = request.GET[\"redirect\"]\n    else:\n        forward_url = \"/admin\"\n    if \"rid\" not in request.GET:\n        return HttpResponseRedirect(\"/admin?error=Missing%20reservation%20id%20in%20request\")\n    u: Profile = get_current_user(request)\n    current_reservation = GroupReservation.objects.get(id=str(request.GET[\"rid\"]))\n    if current_reservation.createdByUser != u and u.rights < 2:\n        return HttpResponseRedirect(\"/admin?error=noyb\")\n    if current_reservation.submitted == True:\n        return HttpResponseRedirect(\"/admin?error=Already%20submitted\")\n    # Test for multiple or single article\n    if \"article_id\" in request.POST:\n        # Actual adding of article\n        aid: int = int(request.GET.get(\"article_id\"))\n        quantity: int = int(request.POST[\"quantity\"])\n        notes: str = escape(request.POST[\"notes\"])\n        ar = ArticleRequested()\n        ar.AID = Article.objects.get(id=aid)\n        ar.RID = current_reservation\n        if \"srid\" in request.GET:\n            ar.SRID = SubReservation.objects.get(id=int(request.GET[\"srid\"]))\n        ar.amount = quantity\n        ar.notes = notes\n        ar.save()\n    # Actual adding of multiple articles\n    else:\n        if \"group_id\" not in request.GET:\n            return HttpResponseRedirect(\"/admin?error=missing%20group%20id\")\n        g: ArticleGroup = ArticleGroup.objects.get(id=int(request.GET[\"group_id\"]))\n        for art in Article.objects.all().filter(group=g):\n            if str(\"quantity_\" + str(art.id)) not in request.POST or str(\"notes_\" + str(art.id)) not in request.POST:\n                return HttpResponseRedirect(\"/admin?error=Missing%20article%20data%20in%20request\")\n            amount = int(request.POST[\"quantity_\" + str(art.id)])\n            if amount > 0:\n                ar = ArticleRequested()\n                ar.AID = art\n                ar.RID = current_reservation\n                ar.amount = amount\n                if \"srid\" in request.GET:\n                    ar.SRID = SubReservation.objects.get(id=int(request.GET[\"srid\"]))\n                ar.notes = escape(str(request.POST[str(\"notes_\" + str(art.id))]))\n                ar.save()\n    if \"srid\" in request.GET:\n        response = HttpResponseRedirect(forward_url + \"?rid=\" + str(current_reservation.id) + \"&srid=\" + request.GET[\"srid\"])\n    else:\n        response = HttpResponseRedirect(forward_url + \"?rid=\" + str(current_reservation.id))\n    return response", "commit_link": "github.com/Technikradio/C3FOCSite/commit/6e330d4d44bbfdfce9993dffea97008276771600", "file_name": "c3shop/frontpage/management/reservation_actions.py", "vul_type": "cwe-079", "description": "Write a Python function to handle adding single or multiple articles to a reservation, with redirection and error handling."}
{"func_name": "WriteOnePNGImage", "func_src_before": "static MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,\n  const ImageInfo *IMimage_info,Image *IMimage,ExceptionInfo *exception)\n{\n  char\n    im_vers[32],\n    libpng_runv[32],\n    libpng_vers[32],\n    zlib_runv[32],\n    zlib_vers[32];\n\n  Image\n    *image;\n\n  ImageInfo\n    *image_info;\n\n  char\n    s[2];\n\n  const char\n    *name,\n    *property,\n    *value;\n\n  const StringInfo\n    *profile;\n\n  int\n    num_passes,\n    pass,\n    ping_wrote_caNv;\n\n  png_byte\n     ping_trans_alpha[256];\n\n  png_color\n     palette[257];\n\n  png_color_16\n    ping_background,\n    ping_trans_color;\n\n  png_info\n    *ping_info;\n\n  png_struct\n    *ping;\n\n  png_uint_32\n    ping_height,\n    ping_width;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    image_matte,\n    logging,\n    matte,\n\n    ping_have_blob,\n    ping_have_cheap_transparency,\n    ping_have_color,\n    ping_have_non_bw,\n    ping_have_PLTE,\n    ping_have_bKGD,\n    ping_have_eXIf,\n    ping_have_iCCP,\n    ping_have_pHYs,\n    ping_have_sRGB,\n    ping_have_tRNS,\n\n    ping_exclude_bKGD,\n    ping_exclude_cHRM,\n    ping_exclude_date,\n    /* ping_exclude_EXIF, */\n    ping_exclude_eXIf,\n    ping_exclude_gAMA,\n    ping_exclude_iCCP,\n    /* ping_exclude_iTXt, */\n    ping_exclude_oFFs,\n    ping_exclude_pHYs,\n    ping_exclude_sRGB,\n    ping_exclude_tEXt,\n    ping_exclude_tIME,\n    /* ping_exclude_tRNS, */\n    ping_exclude_vpAg,\n    ping_exclude_caNv,\n    ping_exclude_zCCP, /* hex-encoded iCCP */\n    ping_exclude_zTXt,\n\n    ping_preserve_colormap,\n    ping_preserve_iCCP,\n    ping_need_colortype_warning,\n\n    status,\n    tried_332,\n    tried_333,\n    tried_444;\n\n  MemoryInfo\n    *volatile pixel_info;\n\n  QuantumInfo\n    *quantum_info;\n\n  PNGErrorInfo\n    error_info;\n\n  register ssize_t\n    i,\n    x;\n\n  unsigned char\n    *ping_pixels;\n\n  volatile int\n    image_colors,\n    ping_bit_depth,\n    ping_color_type,\n    ping_interlace_method,\n    ping_compression_method,\n    ping_filter_method,\n    ping_num_trans;\n\n  volatile size_t\n    image_depth,\n    old_bit_depth;\n\n  size_t\n    quality,\n    rowbytes,\n    save_image_depth;\n\n  int\n    j,\n    number_colors,\n    number_opaque,\n    number_semitransparent,\n    number_transparent,\n    ping_pHYs_unit_type;\n\n  png_uint_32\n    ping_pHYs_x_resolution,\n    ping_pHYs_y_resolution;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter WriteOnePNGImage()\");\n\n  image = CloneImage(IMimage,0,0,MagickFalse,exception);\n  image_info=(ImageInfo *) CloneImageInfo(IMimage_info);\n  if (image_info == (ImageInfo *) NULL)\n     ThrowWriterException(ResourceLimitError, \"MemoryAllocationFailed\");\n\n  /* Define these outside of the following \"if logging()\" block so they will\n   * show in debuggers.\n   */\n  *im_vers='\\0';\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibVersionText,MagickPathExtent);\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibAddendum,MagickPathExtent);\n\n  *libpng_vers='\\0';\n  (void) ConcatenateMagickString(libpng_vers,\n         PNG_LIBPNG_VER_STRING,32);\n  *libpng_runv='\\0';\n  (void) ConcatenateMagickString(libpng_runv,\n         png_get_libpng_ver(NULL),32);\n\n  *zlib_vers='\\0';\n  (void) ConcatenateMagickString(zlib_vers,\n         ZLIB_VERSION,32);\n  *zlib_runv='\\0';\n  (void) ConcatenateMagickString(zlib_runv,\n         zlib_version,32);\n\n  if (logging != MagickFalse)\n    {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    IM version     = %s\",\n           im_vers);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    Libpng version = %s\",\n           libpng_vers);\n       if (LocaleCompare(libpng_vers,libpng_runv) != 0)\n       {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n           libpng_runv);\n       }\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    Zlib version   = %s\",\n           zlib_vers);\n       if (LocaleCompare(zlib_vers,zlib_runv) != 0)\n       {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n           zlib_runv);\n       }\n    }\n\n  /* Initialize some stuff */\n  ping_bit_depth=0,\n  ping_color_type=0,\n  ping_interlace_method=0,\n  ping_compression_method=0,\n  ping_filter_method=0,\n  ping_num_trans = 0;\n\n  ping_background.red = 0;\n  ping_background.green = 0;\n  ping_background.blue = 0;\n  ping_background.gray = 0;\n  ping_background.index = 0;\n\n  ping_trans_color.red=0;\n  ping_trans_color.green=0;\n  ping_trans_color.blue=0;\n  ping_trans_color.gray=0;\n\n  ping_pHYs_unit_type = 0;\n  ping_pHYs_x_resolution = 0;\n  ping_pHYs_y_resolution = 0;\n\n  ping_have_blob=MagickFalse;\n  ping_have_cheap_transparency=MagickFalse;\n  ping_have_color=MagickTrue;\n  ping_have_non_bw=MagickTrue;\n  ping_have_PLTE=MagickFalse;\n  ping_have_bKGD=MagickFalse;\n  ping_have_eXIf=MagickTrue;\n  ping_have_iCCP=MagickFalse;\n  ping_have_pHYs=MagickFalse;\n  ping_have_sRGB=MagickFalse;\n  ping_have_tRNS=MagickFalse;\n\n  ping_exclude_bKGD=mng_info->ping_exclude_bKGD;\n  ping_exclude_caNv=mng_info->ping_exclude_caNv;\n  ping_exclude_cHRM=mng_info->ping_exclude_cHRM;\n  ping_exclude_date=mng_info->ping_exclude_date;\n  ping_exclude_eXIf=mng_info->ping_exclude_eXIf;\n  ping_exclude_gAMA=mng_info->ping_exclude_gAMA;\n  ping_exclude_iCCP=mng_info->ping_exclude_iCCP;\n  /* ping_exclude_iTXt=mng_info->ping_exclude_iTXt; */\n  ping_exclude_oFFs=mng_info->ping_exclude_oFFs;\n  ping_exclude_pHYs=mng_info->ping_exclude_pHYs;\n  ping_exclude_sRGB=mng_info->ping_exclude_sRGB;\n  ping_exclude_tEXt=mng_info->ping_exclude_tEXt;\n  ping_exclude_tIME=mng_info->ping_exclude_tIME;\n  /* ping_exclude_tRNS=mng_info->ping_exclude_tRNS; */\n  ping_exclude_vpAg=mng_info->ping_exclude_vpAg;\n  ping_exclude_zCCP=mng_info->ping_exclude_zCCP; /* hex-encoded iCCP in zTXt */\n  ping_exclude_zTXt=mng_info->ping_exclude_zTXt;\n\n  ping_preserve_colormap = mng_info->ping_preserve_colormap;\n  ping_preserve_iCCP = mng_info->ping_preserve_iCCP;\n  ping_need_colortype_warning = MagickFalse;\n\n  /* Recognize the ICC sRGB profile and convert it to the sRGB chunk,\n   * i.e., eliminate the ICC profile and set image->rendering_intent.\n   * Note that this will not involve any changes to the actual pixels\n   * but merely passes information to applications that read the resulting\n   * PNG image.\n   *\n   * To do: recognize other variants of the sRGB profile, using the CRC to\n   * verify all recognized variants including the 7 already known.\n   *\n   * Work around libpng16+ rejecting some \"known invalid sRGB profiles\".\n   *\n   * Use something other than image->rendering_intent to record the fact\n   * that the sRGB profile was found.\n   *\n   * Record the ICC version (currently v2 or v4) of the incoming sRGB ICC\n   * profile.  Record the Blackpoint Compensation, if any.\n   */\n   if (ping_exclude_sRGB == MagickFalse && ping_preserve_iCCP == MagickFalse)\n   {\n      char\n        *name;\n\n      const StringInfo\n        *profile;\n\n      ResetImageProfileIterator(image);\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        profile=GetImageProfile(image,name);\n\n        if (profile != (StringInfo *) NULL)\n          {\n            if ((LocaleCompare(name,\"ICC\") == 0) ||\n                (LocaleCompare(name,\"ICM\") == 0))\n\n             {\n                 int\n                   icheck,\n                   got_crc=0;\n\n\n                 png_uint_32\n                   length,\n                   profile_crc=0;\n\n                 unsigned char\n                   *data;\n\n                 length=(png_uint_32) GetStringInfoLength(profile);\n\n                 for (icheck=0; sRGB_info[icheck].len > 0; icheck++)\n                 {\n                   if (length == sRGB_info[icheck].len)\n                   {\n                     if (got_crc == 0)\n                     {\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Got a %lu-byte ICC profile (potentially sRGB)\",\n                         (unsigned long) length);\n\n                       data=GetStringInfoDatum(profile);\n                       profile_crc=crc32(0,data,length);\n\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"      with crc=%8x\",(unsigned int) profile_crc);\n                       got_crc++;\n                     }\n\n                     if (profile_crc == sRGB_info[icheck].crc)\n                     {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"      It is sRGB with rendering intent = %s\",\n                        Magick_RenderingIntentString_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent));\n                        if (image->rendering_intent==UndefinedIntent)\n                        {\n                          image->rendering_intent=\n                          Magick_RenderingIntent_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent);\n                        }\n                        ping_exclude_iCCP = MagickTrue;\n                        ping_exclude_zCCP = MagickTrue;\n                        ping_have_sRGB = MagickTrue;\n                        break;\n                     }\n                   }\n                 }\n                 if (sRGB_info[icheck].len == 0)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"    Got %lu-byte ICC profile not recognized as sRGB\",\n                        (unsigned long) length);\n              }\n          }\n        name=GetNextImageProfile(image);\n      }\n  }\n\n  number_opaque = 0;\n  number_semitransparent = 0;\n  number_transparent = 0;\n\n  if (logging != MagickFalse)\n    {\n      if (image->storage_class == UndefinedClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=UndefinedClass\");\n      if (image->storage_class == DirectClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=DirectClass\");\n      if (image->storage_class == PseudoClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=PseudoClass\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(), image->taint ?\n          \"    image->taint=MagickTrue\":\n          \"    image->taint=MagickFalse\");\n    }\n\n  if (image->storage_class == PseudoClass &&\n     (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32 ||\n     mng_info->write_png48 || mng_info->write_png64 ||\n     (mng_info->write_png_colortype != 1 &&\n     mng_info->write_png_colortype != 5)))\n    {\n      (void) SyncImage(image,exception);\n      image->storage_class = DirectClass;\n    }\n\n  if (ping_preserve_colormap == MagickFalse)\n    {\n      if (image->storage_class != PseudoClass && image->colormap != NULL)\n        {\n          /* Free the bogus colormap; it can cause trouble later */\n           if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Freeing bogus colormap\");\n           (void) RelinquishMagickMemory(image->colormap);\n           image->colormap=NULL;\n        }\n    }\n\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n\n  /*\n    Sometimes we get PseudoClass images whose RGB values don't match\n    the colors in the colormap.  This code syncs the RGB values.\n  */\n  if (image->depth <= 8 && image->taint && image->storage_class == PseudoClass)\n     (void) SyncImage(image,exception);\n\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n  if (image->depth > 8)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Reducing PNG bit depth to 8 since this is a Q8 build.\");\n\n      image->depth=8;\n    }\n#endif\n\n  /* Respect the -depth option */\n  if (image->depth < 4)\n    {\n       register Quantum\n         *r;\n\n       if (image->depth > 2)\n         {\n           /* Scale to 4-bit */\n           LBR04PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR04PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR04PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n       else if (image->depth > 1)\n         {\n           /* Scale to 2-bit */\n           LBR02PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR02PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR02PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n       else\n         {\n           /* Scale to 1-bit */\n           LBR01PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR01PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR01PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n    }\n\n  /* To do: set to next higher multiple of 8 */\n  if (image->depth < 8)\n     image->depth=8;\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n  /* PNG does not handle depths greater than 16 so reduce it even\n   * if lossy\n   */\n  if (image->depth > 8)\n      image->depth=16;\n#endif\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 8)\n  if (image->depth > 8)\n    {\n      /* To do: fill low byte properly */\n      image->depth=16;\n    }\n\n  if (image->depth == 16 && mng_info->write_png_depth != 16)\n    if (mng_info->write_png8 ||\n        LosslessReduceDepthOK(image,exception) != MagickFalse)\n      image->depth = 8;\n#endif\n\n  image_colors = (int) image->colors;\n  number_opaque = (int) image->colors;\n  number_transparent = 0;\n  number_semitransparent = 0;\n\n  if (mng_info->write_png_colortype &&\n     (mng_info->write_png_colortype > 4 || (mng_info->write_png_depth >= 8 &&\n     mng_info->write_png_colortype < 4 &&\n     image->alpha_trait == UndefinedPixelTrait)))\n  {\n     /* Avoid the expensive BUILD_PALETTE operation if we're sure that we\n      * are not going to need the result.\n      */\n     if (mng_info->write_png_colortype == 1 ||\n        mng_info->write_png_colortype == 5)\n       ping_have_color=MagickFalse;\n\n     if (image->alpha_trait != UndefinedPixelTrait)\n       {\n         number_transparent = 2;\n         number_semitransparent = 1;\n       }\n  }\n\n  if (mng_info->write_png_colortype < 7)\n  {\n  /* BUILD_PALETTE\n   *\n   * Normally we run this just once, but in the case of writing PNG8\n   * we reduce the transparency to binary and run again, then if there\n   * are still too many colors we reduce to a simple 4-4-4-1, then 3-3-3-1\n   * RGBA palette and run again, and then to a simple 3-3-2-1 RGBA\n   * palette.  Then (To do) we take care of a final reduction that is only\n   * needed if there are still 256 colors present and one of them has both\n   * transparent and opaque instances.\n   */\n\n  tried_332 = MagickFalse;\n  tried_333 = MagickFalse;\n  tried_444 = MagickFalse;\n\n  for (j=0; j<6; j++)\n  {\n    /*\n     * Sometimes we get DirectClass images that have 256 colors or fewer.\n     * This code will build a colormap.\n     *\n     * Also, sometimes we get PseudoClass images with an out-of-date\n     * colormap.  This code will replace the colormap with a new one.\n     * Sometimes we get PseudoClass images that have more than 256 colors.\n     * This code will delete the colormap and change the image to\n     * DirectClass.\n     *\n     * If image->alpha_trait is MagickFalse, we ignore the alpha channel\n     * even though it sometimes contains left-over non-opaque values.\n     *\n     * Also we gather some information (number of opaque, transparent,\n     * and semitransparent pixels, and whether the image has any non-gray\n     * pixels or only black-and-white pixels) that we might need later.\n     *\n     * Even if the user wants to force GrayAlpha or RGBA (colortype 4 or 6)\n     * we need to check for bogus non-opaque values, at least.\n     */\n\n   int\n     n;\n\n   PixelInfo\n     opaque[260],\n     semitransparent[260],\n     transparent[260];\n\n   register const Quantum\n     *s;\n\n   register Quantum\n     *q,\n     *r;\n\n   if (logging != MagickFalse)\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"    Enter BUILD_PALETTE:\");\n\n   if (logging != MagickFalse)\n     {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->columns=%.20g\",(double) image->columns);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->rows=%.20g\",(double) image->rows);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->alpha_trait=%.20g\",(double) image->alpha_trait);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->depth=%.20g\",(double) image->depth);\n\n       if (image->storage_class == PseudoClass && image->colormap != NULL)\n       {\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      Original colormap:\");\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"        i    (red,green,blue,alpha)\");\n\n         for (i=0; i < 256; i++)\n         {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"        %d    (%d,%d,%d,%d)\",\n                    (int) i,\n                    (int) image->colormap[i].red,\n                    (int) image->colormap[i].green,\n                    (int) image->colormap[i].blue,\n                    (int) image->colormap[i].alpha);\n         }\n\n         for (i=image->colors - 10; i < (ssize_t) image->colors; i++)\n         {\n           if (i > 255)\n             {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"        %d    (%d,%d,%d,%d)\",\n                    (int) i,\n                    (int) image->colormap[i].red,\n                    (int) image->colormap[i].green,\n                    (int) image->colormap[i].blue,\n                    (int) image->colormap[i].alpha);\n             }\n         }\n       }\n\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"      image->colors=%d\",(int) image->colors);\n\n       if (image->colors == 0)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"        (zero means unknown)\");\n\n       if (ping_preserve_colormap == MagickFalse)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"      Regenerate the colormap\");\n     }\n\n     image_colors=0;\n     number_opaque = 0;\n     number_semitransparent = 0;\n     number_transparent = 0;\n\n     for (y=0; y < (ssize_t) image->rows; y++)\n     {\n       q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n       if (q == (Quantum *) NULL)\n         break;\n\n       for (x=0; x < (ssize_t) image->columns; x++)\n       {\n           if (image->alpha_trait == UndefinedPixelTrait ||\n              GetPixelAlpha(image,q) == OpaqueAlpha)\n             {\n               if (number_opaque < 259)\n                 {\n                   if (number_opaque == 0)\n                     {\n                       GetPixelInfoPixel(image, q, opaque);\n                       opaque[0].alpha=OpaqueAlpha;\n                       number_opaque=1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_opaque; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,opaque+i))\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_opaque && number_opaque < 259)\n                     {\n                       number_opaque++;\n                       GetPixelInfoPixel(image, q, opaque+i);\n                       opaque[i].alpha=OpaqueAlpha;\n                     }\n                 }\n             }\n           else if (GetPixelAlpha(image,q) == TransparentAlpha)\n             {\n               if (number_transparent < 259)\n                 {\n                   if (number_transparent == 0)\n                     {\n                       GetPixelInfoPixel(image, q, transparent);\n                       ping_trans_color.red=(unsigned short)\n                         GetPixelRed(image,q);\n                       ping_trans_color.green=(unsigned short)\n                         GetPixelGreen(image,q);\n                       ping_trans_color.blue=(unsigned short)\n                         GetPixelBlue(image,q);\n                       ping_trans_color.gray=(unsigned short)\n                         GetPixelGray(image,q);\n                       number_transparent = 1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_transparent; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,transparent+i))\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_transparent &&\n                       number_transparent < 259)\n                     {\n                       number_transparent++;\n                       GetPixelInfoPixel(image,q,transparent+i);\n                     }\n                 }\n             }\n           else\n             {\n               if (number_semitransparent < 259)\n                 {\n                   if (number_semitransparent == 0)\n                     {\n                       GetPixelInfoPixel(image,q,semitransparent);\n                       number_semitransparent = 1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_semitransparent; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,semitransparent+i)\n                           && GetPixelAlpha(image,q) ==\n                           semitransparent[i].alpha)\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_semitransparent &&\n                       number_semitransparent < 259)\n                     {\n                       number_semitransparent++;\n                       GetPixelInfoPixel(image, q, semitransparent+i);\n                     }\n                 }\n             }\n           q+=GetPixelChannels(image);\n        }\n     }\n\n     if (mng_info->write_png8 == MagickFalse &&\n         ping_exclude_bKGD == MagickFalse)\n       {\n         /* Add the background color to the palette, if it\n          * isn't already there.\n          */\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      Check colormap for background (%d,%d,%d)\",\n                  (int) image->background_color.red,\n                  (int) image->background_color.green,\n                  (int) image->background_color.blue);\n            }\n          for (i=0; i<number_opaque; i++)\n          {\n             if (opaque[i].red == image->background_color.red &&\n                 opaque[i].green == image->background_color.green &&\n                 opaque[i].blue == image->background_color.blue)\n               break;\n          }\n          if (number_opaque < 259 && i == number_opaque)\n            {\n               opaque[i] = image->background_color;\n               ping_background.index = i;\n               number_opaque++;\n               if (logging != MagickFalse)\n                 {\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"      background_color index is %d\",(int) i);\n                 }\n\n            }\n          else if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      No room in the colormap to add background color\");\n       }\n\n     image_colors=number_opaque+number_transparent+number_semitransparent;\n\n     if (logging != MagickFalse)\n       {\n         if (image_colors > 256)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      image has more than 256 colors\");\n\n         else\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      image has %d colors\",image_colors);\n       }\n\n     if (ping_preserve_colormap != MagickFalse)\n       break;\n\n     if (mng_info->write_png_colortype != 7) /* We won't need this info */\n       {\n         ping_have_color=MagickFalse;\n         ping_have_non_bw=MagickFalse;\n\n         if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n         {\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"incompatible colorspace\");\n           ping_have_color=MagickTrue;\n           ping_have_non_bw=MagickTrue;\n         }\n\n         if(image_colors > 256)\n           {\n             for (y=0; y < (ssize_t) image->rows; y++)\n             {\n               q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n               if (q == (Quantum *) NULL)\n                 break;\n\n               s=q;\n               for (x=0; x < (ssize_t) image->columns; x++)\n               {\n                 if (GetPixelRed(image,s) != GetPixelGreen(image,s) ||\n                     GetPixelRed(image,s) != GetPixelBlue(image,s))\n                   {\n                      ping_have_color=MagickTrue;\n                      ping_have_non_bw=MagickTrue;\n                      break;\n                   }\n                 s+=GetPixelChannels(image);\n               }\n\n               if (ping_have_color != MagickFalse)\n                 break;\n\n               /* Worst case is black-and-white; we are looking at every\n                * pixel twice.\n                */\n\n               if (ping_have_non_bw == MagickFalse)\n                 {\n                   s=q;\n                   for (x=0; x < (ssize_t) image->columns; x++)\n                   {\n                     if (GetPixelRed(image,s) != 0 &&\n                         GetPixelRed(image,s) != QuantumRange)\n                       {\n                         ping_have_non_bw=MagickTrue;\n                         break;\n                       }\n                     s+=GetPixelChannels(image);\n                   }\n               }\n             }\n           }\n       }\n\n     if (image_colors < 257)\n       {\n         PixelInfo\n           colormap[260];\n\n         /*\n          * Initialize image colormap.\n          */\n\n         if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      Sort the new colormap\");\n\n        /* Sort palette, transparent first */;\n\n         n = 0;\n\n         for (i=0; i<number_transparent; i++)\n            colormap[n++] = transparent[i];\n\n         for (i=0; i<number_semitransparent; i++)\n            colormap[n++] = semitransparent[i];\n\n         for (i=0; i<number_opaque; i++)\n            colormap[n++] = opaque[i];\n\n         ping_background.index +=\n           (number_transparent + number_semitransparent);\n\n         /* image_colors < 257; search the colormap instead of the pixels\n          * to get ping_have_color and ping_have_non_bw\n          */\n         for (i=0; i<n; i++)\n         {\n           if (ping_have_color == MagickFalse)\n             {\n                if (colormap[i].red != colormap[i].green ||\n                    colormap[i].red != colormap[i].blue)\n                  {\n                     ping_have_color=MagickTrue;\n                     ping_have_non_bw=MagickTrue;\n                     break;\n                  }\n              }\n\n           if (ping_have_non_bw == MagickFalse)\n             {\n               if (colormap[i].red != 0 && colormap[i].red != QuantumRange)\n                   ping_have_non_bw=MagickTrue;\n             }\n          }\n\n        if ((mng_info->ping_exclude_tRNS == MagickFalse ||\n            (number_transparent == 0 && number_semitransparent == 0)) &&\n            (((mng_info->write_png_colortype-1) ==\n            PNG_COLOR_TYPE_PALETTE) ||\n            (mng_info->write_png_colortype == 0)))\n          {\n            if (logging != MagickFalse)\n              {\n                if (n !=  (ssize_t) image_colors)\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"   image_colors (%d) and n (%d)  don't match\",\n                   image_colors, n);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      AcquireImageColormap\");\n              }\n\n            image->colors = image_colors;\n\n            if (AcquireImageColormap(image,image_colors,exception) ==\n                MagickFalse)\n               ThrowWriterException(ResourceLimitError,\n                   \"MemoryAllocationFailed\");\n\n            for (i=0; i< (ssize_t) image_colors; i++)\n               image->colormap[i] = colormap[i];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"      image->colors=%d (%d)\",\n                      (int) image->colors, image_colors);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"      Update the pixel indexes\");\n              }\n\n            /* Sync the pixel indices with the new colormap */\n\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n              if (q == (Quantum *) NULL)\n                break;\n\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                for (i=0; i< (ssize_t) image_colors; i++)\n                {\n                  if ((image->alpha_trait == UndefinedPixelTrait ||\n                      image->colormap[i].alpha == GetPixelAlpha(image,q)) &&\n                      image->colormap[i].red == GetPixelRed(image,q) &&\n                      image->colormap[i].green == GetPixelGreen(image,q) &&\n                      image->colormap[i].blue == GetPixelBlue(image,q))\n                  {\n                    SetPixelIndex(image,i,q);\n                    break;\n                  }\n                }\n                q+=GetPixelChannels(image);\n              }\n\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                 break;\n            }\n          }\n       }\n\n     if (logging != MagickFalse)\n       {\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      image->colors=%d\", (int) image->colors);\n\n         if (image->colormap != NULL)\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"       i     (red,green,blue,alpha)\");\n\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               if (i < 300 || i >= (ssize_t) image->colors - 10)\n                 {\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"       %d     (%d,%d,%d,%d)\",\n                        (int) i,\n                        (int) image->colormap[i].red,\n                        (int) image->colormap[i].green,\n                        (int) image->colormap[i].blue,\n                        (int) image->colormap[i].alpha);\n                 }\n             }\n           }\n\n           if (number_transparent < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_transparent     = %d\",\n                   number_transparent);\n           else\n\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_transparent     > 256\");\n\n           if (number_opaque < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_opaque          = %d\",\n                   number_opaque);\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_opaque          > 256\");\n\n           if (number_semitransparent < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_semitransparent = %d\",\n                   number_semitransparent);\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_semitransparent > 256\");\n\n           if (ping_have_non_bw == MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      All pixels and the background are black or white\");\n\n           else if (ping_have_color == MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      All pixels and the background are gray\");\n\n           else\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      At least one pixel or the background is non-gray\");\n\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Exit BUILD_PALETTE:\");\n       }\n\n   if (mng_info->write_png8 == MagickFalse)\n      break;\n\n   /* Make any reductions necessary for the PNG8 format */\n    if (image_colors <= 256 &&\n        image_colors != 0 && image->colormap != NULL &&\n        number_semitransparent == 0 &&\n        number_transparent <= 1)\n      break;\n\n    /* PNG8 can't have semitransparent colors so we threshold the\n     * opacity to 0 or OpaqueOpacity, and PNG8 can only have one\n     * transparent color so if more than one is transparent we merge\n     * them into image->background_color.\n     */\n    if (number_semitransparent != 0 || number_transparent > 1)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Thresholding the alpha channel to binary\");\n\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n          if (r == (Quantum *) NULL)\n            break;\n\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n              if (GetPixelAlpha(image,r) < OpaqueAlpha/2)\n                {\n                  SetPixelViaPixelInfo(image,&image->background_color,r);\n                  SetPixelAlpha(image,TransparentAlpha,r);\n                }\n              else\n                  SetPixelAlpha(image,OpaqueAlpha,r);\n              r+=GetPixelChannels(image);\n          }\n\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n\n          if (image_colors != 0 && image_colors <= 256 &&\n             image->colormap != NULL)\n            for (i=0; i<image_colors; i++)\n                image->colormap[i].alpha =\n                    (image->colormap[i].alpha > TransparentAlpha/2 ?\n                    TransparentAlpha : OpaqueAlpha);\n        }\n      continue;\n    }\n\n    /* PNG8 can't have more than 256 colors so we quantize the pixels and\n     * background color to the 4-4-4-1, 3-3-3-1 or 3-3-2-1 palette.  If the\n     * image is mostly gray, the 4-4-4-1 palette is likely to end up with 256\n     * colors or less.\n     */\n    if (tried_444 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 4-4-4\");\n\n        tried_444 = MagickTrue;\n\n        LBR04PacketRGB(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 4-4-4\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR04PixelRGB(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 4-4-4\");\n\n          for (i=0; i<image_colors; i++)\n          {\n            LBR04PacketRGB(image->colormap[i]);\n          }\n        }\n        continue;\n      }\n\n    if (tried_333 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 3-3-3\");\n\n        tried_333 = MagickTrue;\n\n        LBR03PacketRGB(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 3-3-3-1\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR03RGB(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 3-3-3-1\");\n          for (i=0; i<image_colors; i++)\n          {\n              LBR03PacketRGB(image->colormap[i]);\n          }\n        }\n        continue;\n      }\n\n    if (tried_332 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 3-3-2\");\n\n        tried_332 = MagickTrue;\n\n        /* Red and green were already done so we only quantize the blue\n         * channel\n         */\n\n        LBR02PacketBlue(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 3-3-2-1\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR02PixelBlue(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 3-3-2-1\");\n          for (i=0; i<image_colors; i++)\n          {\n              LBR02PacketBlue(image->colormap[i]);\n          }\n      }\n      continue;\n    }\n\n    if (image_colors == 0 || image_colors > 256)\n    {\n      /* Take care of special case with 256 opaque colors + 1 transparent\n       * color.  We don't need to quantize to 2-3-2-1; we only need to\n       * eliminate one color, so we'll merge the two darkest red\n       * colors (0x49, 0, 0) -> (0x24, 0, 0).\n       */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Merging two dark red background colors to 3-3-2-1\");\n\n      if (ScaleQuantumToChar(image->background_color.red) == 0x49 &&\n          ScaleQuantumToChar(image->background_color.green) == 0x00 &&\n          ScaleQuantumToChar(image->background_color.blue) == 0x00)\n      {\n         image->background_color.red=ScaleCharToQuantum(0x24);\n      }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Merging two dark red pixel colors to 3-3-2-1\");\n\n      if (image->colormap == NULL)\n      {\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n          if (r == (Quantum *) NULL)\n            break;\n\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (ScaleQuantumToChar(GetPixelRed(image,r)) == 0x49 &&\n                ScaleQuantumToChar(GetPixelGreen(image,r)) == 0x00 &&\n                ScaleQuantumToChar(GetPixelBlue(image,r)) == 0x00 &&\n                GetPixelAlpha(image,r) == OpaqueAlpha)\n              {\n                SetPixelRed(image,ScaleCharToQuantum(0x24),r);\n              }\n            r+=GetPixelChannels(image);\n          }\n\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n\n        }\n      }\n\n      else\n      {\n         for (i=0; i<image_colors; i++)\n         {\n            if (ScaleQuantumToChar(image->colormap[i].red) == 0x49 &&\n                ScaleQuantumToChar(image->colormap[i].green) == 0x00 &&\n                ScaleQuantumToChar(image->colormap[i].blue) == 0x00)\n            {\n               image->colormap[i].red=ScaleCharToQuantum(0x24);\n            }\n         }\n      }\n    }\n  }\n  }\n  /* END OF BUILD_PALETTE */\n\n  /* If we are excluding the tRNS chunk and there is transparency,\n   * then we must write a Gray-Alpha (color-type 4) or RGBA (color-type 6)\n   * PNG.\n   */\n  if (mng_info->ping_exclude_tRNS != MagickFalse &&\n     (number_transparent != 0 || number_semitransparent != 0))\n    {\n      unsigned int colortype=mng_info->write_png_colortype;\n\n      if (ping_have_color == MagickFalse)\n        mng_info->write_png_colortype = 5;\n\n      else\n        mng_info->write_png_colortype = 7;\n\n      if (colortype != 0 &&\n         mng_info->write_png_colortype != colortype)\n        ping_need_colortype_warning=MagickTrue;\n\n    }\n\n  /* See if cheap transparency is possible.  It is only possible\n   * when there is a single transparent color, no semitransparent\n   * color, and no opaque color that has the same RGB components\n   * as the transparent color.  We only need this information if\n   * we are writing a PNG with colortype 0 or 2, and we have not\n   * excluded the tRNS chunk.\n   */\n  if (number_transparent == 1 &&\n      mng_info->write_png_colortype < 4)\n    {\n       ping_have_cheap_transparency = MagickTrue;\n\n       if (number_semitransparent != 0)\n         ping_have_cheap_transparency = MagickFalse;\n\n       else if (image_colors == 0 || image_colors > 256 ||\n           image->colormap == NULL)\n         {\n           register const Quantum\n             *q;\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             q=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n             if (q == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                 if (GetPixelAlpha(image,q) != TransparentAlpha &&\n                     (unsigned short) GetPixelRed(image,q) ==\n                                     ping_trans_color.red &&\n                     (unsigned short) GetPixelGreen(image,q) ==\n                                     ping_trans_color.green &&\n                     (unsigned short) GetPixelBlue(image,q) ==\n                                     ping_trans_color.blue)\n                   {\n                     ping_have_cheap_transparency = MagickFalse;\n                     break;\n                   }\n\n                 q+=GetPixelChannels(image);\n             }\n\n             if (ping_have_cheap_transparency == MagickFalse)\n                break;\n           }\n         }\n       else\n         {\n            /* Assuming that image->colormap[0] is the one transparent color\n             * and that all others are opaque.\n             */\n            if (image_colors > 1)\n              for (i=1; i<image_colors; i++)\n                if (image->colormap[i].red == image->colormap[0].red &&\n                    image->colormap[i].green == image->colormap[0].green &&\n                    image->colormap[i].blue == image->colormap[0].blue)\n                  {\n                     ping_have_cheap_transparency = MagickFalse;\n                     break;\n                  }\n         }\n\n       if (logging != MagickFalse)\n         {\n           if (ping_have_cheap_transparency == MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"   Cheap transparency is not possible.\");\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"   Cheap transparency is possible.\");\n         }\n     }\n  else\n    ping_have_cheap_transparency = MagickFalse;\n\n  image_depth=image->depth;\n\n  quantum_info = (QuantumInfo *) NULL;\n  number_colors=0;\n  image_colors=(int) image->colors;\n  image_matte=image->alpha_trait !=\n        UndefinedPixelTrait ? MagickTrue : MagickFalse;\n\n  if (mng_info->write_png_colortype < 5)\n    mng_info->IsPalette=image->storage_class == PseudoClass &&\n      image_colors <= 256 && image->colormap != NULL;\n  else\n    mng_info->IsPalette = MagickFalse;\n\n  if ((mng_info->write_png_colortype == 4 || mng_info->write_png8) &&\n     (image->colors == 0 || image->colormap == NULL))\n    {\n      image_info=DestroyImageInfo(image_info);\n      image=DestroyImage(image);\n      (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          \"Cannot write PNG8 or color-type 3; colormap is NULL\",\n          \"`%s'\",IMimage->filename);\n      return(MagickFalse);\n    }\n\n  /*\n    Allocate the PNG structures\n  */\n#ifdef PNG_USER_MEM_SUPPORTED\n error_info.image=image;\n error_info.exception=exception;\n  ping=png_create_write_struct_2(PNG_LIBPNG_VER_STRING,&error_info,\n    MagickPNGErrorHandler,MagickPNGWarningHandler,(void *) NULL,\n    (png_malloc_ptr) Magick_png_malloc,(png_free_ptr) Magick_png_free);\n\n#else\n  ping=png_create_write_struct(PNG_LIBPNG_VER_STRING,&error_info,\n    MagickPNGErrorHandler,MagickPNGWarningHandler);\n\n#endif\n  if (ping == (png_struct *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  ping_info=png_create_info_struct(ping);\n\n  if (ping_info == (png_info *) NULL)\n    {\n      png_destroy_write_struct(&ping,(png_info **) NULL);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n\n  png_set_write_fn(ping,image,png_put_data,png_flush_data);\n  pixel_info=(MemoryInfo *) NULL;\n\n  if (setjmp(png_jmpbuf(ping)))\n    {\n      /*\n        PNG write failed.\n      */\n#ifdef PNG_DEBUG\n     if (image_info->verbose)\n        (void) printf(\"PNG write has failed.\\n\");\n#endif\n      png_destroy_write_struct(&ping,&ping_info);\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n      UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n      if (pixel_info != (MemoryInfo *) NULL)\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n\n      if (quantum_info != (QuantumInfo *) NULL)\n        quantum_info=DestroyQuantumInfo(quantum_info);\n\n      if (ping_have_blob != MagickFalse)\n          (void) CloseBlob(image);\n      image_info=DestroyImageInfo(image_info);\n      image=DestroyImage(image);\n      return(MagickFalse);\n    }\n\n  /* {  For navigation to end of SETJMP-protected block.  Within this\n   *    block, use png_error() instead of Throwing an Exception, to ensure\n   *    that libpng is able to clean up, and that the semaphore is unlocked.\n   */\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  LockSemaphoreInfo(ping_semaphore);\n#endif\n\n#ifdef PNG_BENIGN_ERRORS_SUPPORTED\n  /* Allow benign errors */\n  png_set_benign_errors(ping, 1);\n#endif\n\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n  /* Reject images with too many rows or columns */\n  png_set_user_limits(ping,\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(WidthResource)),\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(HeightResource)));\n#endif /* PNG_SET_USER_LIMITS_SUPPORTED */\n\n  /*\n    Prepare PNG for writing.\n  */\n\n#if defined(PNG_MNG_FEATURES_SUPPORTED)\n  if (mng_info->write_mng)\n  {\n     (void) png_permit_mng_features(ping,PNG_ALL_MNG_FEATURES);\n# ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED\n     /* Disable new libpng-1.5.10 feature when writing a MNG because\n      * zero-length PLTE is OK\n      */\n     png_set_check_for_invalid_index (ping, 0);\n# endif\n  }\n\n#else\n# ifdef PNG_WRITE_EMPTY_PLTE_SUPPORTED\n  if (mng_info->write_mng)\n     png_permit_empty_plte(ping,MagickTrue);\n\n# endif\n#endif\n\n  x=0;\n\n  ping_width=(png_uint_32) image->columns;\n  ping_height=(png_uint_32) image->rows;\n\n  if (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32)\n     image_depth=8;\n\n  if (mng_info->write_png48 || mng_info->write_png64)\n     image_depth=16;\n\n  if (mng_info->write_png_depth != 0)\n     image_depth=mng_info->write_png_depth;\n\n  /* Adjust requested depth to next higher valid depth if necessary */\n  if (image_depth > 8)\n     image_depth=16;\n\n  if ((image_depth > 4) && (image_depth < 8))\n     image_depth=8;\n\n  if (image_depth == 3)\n     image_depth=4;\n\n  if (logging != MagickFalse)\n    {\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    width=%.20g\",(double) ping_width);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    height=%.20g\",(double) ping_height);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_matte=%.20g\",(double) image->alpha_trait);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image->depth=%.20g\",(double) image->depth);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Tentative ping_bit_depth=%.20g\",(double) image_depth);\n    }\n\n  save_image_depth=image_depth;\n  ping_bit_depth=(png_byte) save_image_depth;\n\n\n#if defined(PNG_pHYs_SUPPORTED)\n  if (ping_exclude_pHYs == MagickFalse)\n  {\n  if ((image->resolution.x != 0) && (image->resolution.y != 0) &&\n      (!mng_info->write_mng || !mng_info->equal_physs))\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Setting up pHYs chunk\");\n\n      if (image->units == PixelsPerInchResolution)\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_METER;\n          ping_pHYs_x_resolution=\n             (png_uint_32) ((100.0*image->resolution.x+0.5)/2.54);\n          ping_pHYs_y_resolution=\n             (png_uint_32) ((100.0*image->resolution.y+0.5)/2.54);\n        }\n\n      else if (image->units == PixelsPerCentimeterResolution)\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_METER;\n          ping_pHYs_x_resolution=(png_uint_32) (100.0*image->resolution.x+0.5);\n          ping_pHYs_y_resolution=(png_uint_32) (100.0*image->resolution.y+0.5);\n        }\n\n      else\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_UNKNOWN;\n          ping_pHYs_x_resolution=(png_uint_32) image->resolution.x;\n          ping_pHYs_y_resolution=(png_uint_32) image->resolution.y;\n        }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Set up PNG pHYs chunk: xres: %.20g, yres: %.20g, units: %d.\",\n          (double) ping_pHYs_x_resolution,(double) ping_pHYs_y_resolution,\n          (int) ping_pHYs_unit_type);\n       ping_have_pHYs = MagickTrue;\n    }\n  }\n#endif\n\n  if (ping_exclude_bKGD == MagickFalse)\n  {\n  if ((!mng_info->adjoin || !mng_info->equal_backgrounds))\n    {\n       unsigned int\n         mask;\n\n       mask=0xffff;\n       if (ping_bit_depth == 8)\n          mask=0x00ff;\n\n       if (ping_bit_depth == 4)\n          mask=0x000f;\n\n       if (ping_bit_depth == 2)\n          mask=0x0003;\n\n       if (ping_bit_depth == 1)\n          mask=0x0001;\n\n       ping_background.red=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.red) & mask);\n\n       ping_background.green=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.green) & mask);\n\n       ping_background.blue=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.blue) & mask);\n\n       ping_background.gray=(png_uint_16) ping_background.green;\n    }\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Setting up bKGD chunk (1)\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"      background_color index is %d\",\n          (int) ping_background.index);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    ping_bit_depth=%d\",ping_bit_depth);\n    }\n\n  ping_have_bKGD = MagickTrue;\n  }\n\n  /*\n    Select the color type.\n  */\n  matte=image_matte;\n  old_bit_depth=0;\n\n  if (mng_info->IsPalette && mng_info->write_png8)\n    {\n      /* To do: make this a function cause it's used twice, except\n         for reducing the sample depth from 8. */\n\n      number_colors=image_colors;\n\n      ping_have_tRNS=MagickFalse;\n\n      /*\n        Set image palette.\n      */\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Setting up PLTE chunk with %d colors (%d)\",\n            number_colors, image_colors);\n\n      for (i=0; i < (ssize_t) number_colors; i++)\n      {\n        palette[i].red=ScaleQuantumToChar(image->colormap[i].red);\n        palette[i].green=ScaleQuantumToChar(image->colormap[i].green);\n        palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n#if MAGICKCORE_QUANTUM_DEPTH == 8\n            \"    %3ld (%3d,%3d,%3d)\",\n#else\n            \"    %5ld (%5d,%5d,%5d)\",\n#endif\n            (long) i,palette[i].red,palette[i].green,palette[i].blue);\n\n      }\n\n      ping_have_PLTE=MagickTrue;\n      image_depth=ping_bit_depth;\n      ping_num_trans=0;\n\n      if (matte != MagickFalse)\n      {\n          /*\n            Identify which colormap entry is transparent.\n          */\n          assert(number_colors <= 256);\n          assert(image->colormap != NULL);\n\n          for (i=0; i < (ssize_t) number_transparent; i++)\n             ping_trans_alpha[i]=0;\n\n\n          ping_num_trans=(unsigned short) (number_transparent +\n             number_semitransparent);\n\n          if (ping_num_trans == 0)\n             ping_have_tRNS=MagickFalse;\n\n          else\n             ping_have_tRNS=MagickTrue;\n      }\n\n      if (ping_exclude_bKGD == MagickFalse)\n      {\n       /*\n        * Identify which colormap entry is the background color.\n        */\n\n        for (i=0; i < (ssize_t) MagickMax(1L*number_colors-1L,1L); i++)\n          if (IsPNGColorEqual(ping_background,image->colormap[i]))\n            break;\n\n        ping_background.index=(png_byte) i;\n\n        if (logging != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"      background_color index is %d\",\n                 (int) ping_background.index);\n          }\n      }\n    } /* end of write_png8 */\n\n  else if (mng_info->write_png_colortype == 1)\n    {\n      image_matte=MagickFalse;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;\n    }\n\n  else if (mng_info->write_png24 || mng_info->write_png48 ||\n      mng_info->write_png_colortype == 3)\n    {\n      image_matte=MagickFalse;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n    }\n\n  else if (mng_info->write_png32 || mng_info->write_png64 ||\n      mng_info->write_png_colortype == 7)\n    {\n      image_matte=MagickTrue;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;\n    }\n\n  else /* mng_info->write_pngNN not specified */\n    {\n      image_depth=ping_bit_depth;\n\n      if (mng_info->write_png_colortype != 0)\n        {\n          ping_color_type=(png_byte) mng_info->write_png_colortype-1;\n\n          if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||\n              ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            image_matte=MagickTrue;\n\n          else\n            image_matte=MagickFalse;\n\n          if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"   PNG colortype %d was specified:\",(int) ping_color_type);\n        }\n\n      else /* write_png_colortype not specified */\n        {\n          if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Selecting PNG colortype:\");\n\n          ping_color_type=(png_byte) ((matte != MagickFalse)?\n            PNG_COLOR_TYPE_RGB_ALPHA:PNG_COLOR_TYPE_RGB);\n\n          if (image_info->type == TrueColorType)\n            {\n              ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n              image_matte=MagickFalse;\n            }\n\n          if (image_info->type == TrueColorAlphaType)\n            {\n              ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;\n              image_matte=MagickTrue;\n            }\n\n          if (image_info->type == PaletteType ||\n              image_info->type == PaletteAlphaType)\n            ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n          if (mng_info->write_png_colortype == 0 &&\n             image_info->type == UndefinedType)\n            {\n              if (ping_have_color == MagickFalse)\n                {\n                  if (image_matte == MagickFalse)\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;\n                      image_matte=MagickFalse;\n                    }\n\n                  else\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY_ALPHA;\n                      image_matte=MagickTrue;\n                    }\n                }\n              else\n                {\n                  if (image_matte == MagickFalse)\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n                      image_matte=MagickFalse;\n                    }\n\n                  else\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGBA;\n                      image_matte=MagickTrue;\n                    }\n                 }\n            }\n\n        }\n\n      if (logging != MagickFalse)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"    Selected PNG colortype=%d\",ping_color_type);\n\n      if (ping_bit_depth < 8)\n        {\n          if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||\n              ping_color_type == PNG_COLOR_TYPE_RGB ||\n              ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            ping_bit_depth=8;\n        }\n\n      old_bit_depth=ping_bit_depth;\n\n      if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n        {\n          if (image->alpha_trait == UndefinedPixelTrait &&\n               ping_have_non_bw == MagickFalse)\n             ping_bit_depth=1;\n        }\n\n      if (ping_color_type == PNG_COLOR_TYPE_PALETTE)\n        {\n           size_t one = 1;\n           ping_bit_depth=1;\n\n           if (image->colors == 0)\n           {\n              /* DO SOMETHING */\n                png_error(ping,\"image has 0 colors\");\n           }\n\n           while ((int) (one << ping_bit_depth) < (ssize_t) image_colors)\n             ping_bit_depth <<= 1;\n        }\n\n      if (logging != MagickFalse)\n         {\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Number of colors: %.20g\",(double) image_colors);\n\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Tentative PNG bit depth: %d\",ping_bit_depth);\n         }\n\n      if (ping_bit_depth < (int) mng_info->write_png_depth)\n         ping_bit_depth = mng_info->write_png_depth;\n    }\n\n  image_depth=ping_bit_depth;\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Tentative PNG color type: %s (%.20g)\",\n        PngColorTypeToString(ping_color_type),\n        (double) ping_color_type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_info->type: %.20g\",(double) image_info->type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_depth: %.20g\",(double) image_depth);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\n        \"    image->depth: %.20g\",(double) image->depth);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    ping_bit_depth: %.20g\",(double) ping_bit_depth);\n    }\n\n  if (matte != MagickFalse)\n    {\n      if (mng_info->IsPalette)\n        {\n          if (mng_info->write_png_colortype == 0)\n            {\n              ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;\n\n              if (ping_have_color != MagickFalse)\n                 ping_color_type=PNG_COLOR_TYPE_RGBA;\n            }\n\n          /*\n           * Determine if there is any transparent color.\n          */\n          if (number_transparent + number_semitransparent == 0)\n            {\n              /*\n                No transparent pixels are present.  Change 4 or 6 to 0 or 2.\n              */\n\n              image_matte=MagickFalse;\n\n              if (mng_info->write_png_colortype == 0)\n                ping_color_type&=0x03;\n            }\n\n          else\n            {\n              unsigned int\n                mask;\n\n              mask=0xffff;\n\n              if (ping_bit_depth == 8)\n                 mask=0x00ff;\n\n              if (ping_bit_depth == 4)\n                 mask=0x000f;\n\n              if (ping_bit_depth == 2)\n                 mask=0x0003;\n\n              if (ping_bit_depth == 1)\n                 mask=0x0001;\n\n              ping_trans_color.red=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].red) & mask);\n\n              ping_trans_color.green=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].green) & mask);\n\n              ping_trans_color.blue=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].blue) & mask);\n\n              ping_trans_color.gray=(png_uint_16)\n                (ScaleQuantumToShort(GetPixelInfoIntensity(image,\n                   image->colormap)) & mask);\n\n              ping_trans_color.index=(png_byte) 0;\n\n              ping_have_tRNS=MagickTrue;\n            }\n\n          if (ping_have_tRNS != MagickFalse)\n            {\n              /*\n               * Determine if there is one and only one transparent color\n               * and if so if it is fully transparent.\n               */\n              if (ping_have_cheap_transparency == MagickFalse)\n                ping_have_tRNS=MagickFalse;\n            }\n\n          if (ping_have_tRNS != MagickFalse)\n            {\n              if (mng_info->write_png_colortype == 0)\n                ping_color_type &= 0x03;  /* changes 4 or 6 to 0 or 2 */\n\n              if (image_depth == 8)\n                {\n                  ping_trans_color.red&=0xff;\n                  ping_trans_color.green&=0xff;\n                  ping_trans_color.blue&=0xff;\n                  ping_trans_color.gray&=0xff;\n                }\n            }\n        }\n      else\n        {\n          if (image_depth == 8)\n            {\n              ping_trans_color.red&=0xff;\n              ping_trans_color.green&=0xff;\n              ping_trans_color.blue&=0xff;\n              ping_trans_color.gray&=0xff;\n            }\n        }\n    }\n\n    matte=image_matte;\n\n    if (ping_have_tRNS != MagickFalse)\n      image_matte=MagickFalse;\n\n    if ((mng_info->IsPalette) &&\n        mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE &&\n        ping_have_color == MagickFalse &&\n        (image_matte == MagickFalse || image_depth >= 8))\n      {\n        size_t one=1;\n\n        if (image_matte != MagickFalse)\n          ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;\n\n        else if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_GRAY_ALPHA)\n          {\n            ping_color_type=PNG_COLOR_TYPE_GRAY;\n\n            if (save_image_depth == 16 && image_depth == 8)\n              {\n                if (logging != MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Scaling ping_trans_color (0)\");\n                  }\n                    ping_trans_color.gray*=0x0101;\n              }\n          }\n\n        if (image_depth > MAGICKCORE_QUANTUM_DEPTH)\n          image_depth=MAGICKCORE_QUANTUM_DEPTH;\n\n        if ((image_colors == 0) ||\n             ((ssize_t) (image_colors-1) > (ssize_t) MaxColormapSize))\n          image_colors=(int) (one << image_depth);\n\n        if (image_depth > 8)\n          ping_bit_depth=16;\n\n        else\n          {\n            ping_bit_depth=8;\n            if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n              {\n                if(!mng_info->write_png_depth)\n                  {\n                    ping_bit_depth=1;\n\n                    while ((int) (one << ping_bit_depth)\n                        < (ssize_t) image_colors)\n                      ping_bit_depth <<= 1;\n                  }\n              }\n\n            else if (ping_color_type ==\n                PNG_COLOR_TYPE_GRAY && image_colors < 17 &&\n                mng_info->IsPalette)\n              {\n              /* Check if grayscale is reducible */\n\n                int\n                  depth_4_ok=MagickTrue,\n                  depth_2_ok=MagickTrue,\n                  depth_1_ok=MagickTrue;\n\n                for (i=0; i < (ssize_t) image_colors; i++)\n                {\n                   unsigned char\n                     intensity;\n\n                   intensity=ScaleQuantumToChar(image->colormap[i].red);\n\n                   if ((intensity & 0x0f) != ((intensity & 0xf0) >> 4))\n                     depth_4_ok=depth_2_ok=depth_1_ok=MagickFalse;\n                   else if ((intensity & 0x03) != ((intensity & 0x0c) >> 2))\n                     depth_2_ok=depth_1_ok=MagickFalse;\n                   else if ((intensity & 0x01) != ((intensity & 0x02) >> 1))\n                     depth_1_ok=MagickFalse;\n                }\n\n                if (depth_1_ok && mng_info->write_png_depth <= 1)\n                  ping_bit_depth=1;\n\n                else if (depth_2_ok && mng_info->write_png_depth <= 2)\n                  ping_bit_depth=2;\n\n                else if (depth_4_ok && mng_info->write_png_depth <= 4)\n                  ping_bit_depth=4;\n              }\n          }\n\n          image_depth=ping_bit_depth;\n      }\n\n    else\n\n      if (mng_info->IsPalette)\n      {\n        number_colors=image_colors;\n\n        if (image_depth <= 8)\n          {\n            /*\n              Set image palette.\n            */\n            ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n            if (!(mng_info->have_write_global_plte && matte == MagickFalse))\n              {\n                for (i=0; i < (ssize_t) number_colors; i++)\n                {\n                  palette[i].red=ScaleQuantumToChar(image->colormap[i].red);\n                  palette[i].green=\n                    ScaleQuantumToChar(image->colormap[i].green);\n                  palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);\n                }\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Setting up PLTE chunk with %d colors\",\n                    number_colors);\n\n                ping_have_PLTE=MagickTrue;\n              }\n\n            /* color_type is PNG_COLOR_TYPE_PALETTE */\n            if (mng_info->write_png_depth == 0)\n              {\n                size_t\n                  one;\n\n                ping_bit_depth=1;\n                one=1;\n\n                while ((one << ping_bit_depth) < (size_t) number_colors)\n                  ping_bit_depth <<= 1;\n              }\n\n            ping_num_trans=0;\n\n            if (matte != MagickFalse)\n              {\n                /*\n                 * Set up trans_colors array.\n                 */\n                assert(number_colors <= 256);\n\n                ping_num_trans=(unsigned short) (number_transparent +\n                  number_semitransparent);\n\n                if (ping_num_trans == 0)\n                  ping_have_tRNS=MagickFalse;\n\n                else\n                  {\n                    if (logging != MagickFalse)\n                      {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  Scaling ping_trans_color (1)\");\n                      }\n                    ping_have_tRNS=MagickTrue;\n\n                    for (i=0; i < ping_num_trans; i++)\n                    {\n                       ping_trans_alpha[i]= (png_byte)\n                         ScaleQuantumToChar(image->colormap[i].alpha);\n                    }\n                  }\n              }\n          }\n      }\n\n    else\n      {\n\n        if (image_depth < 8)\n          image_depth=8;\n\n        if ((save_image_depth == 16) && (image_depth == 8))\n          {\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Scaling ping_trans_color from (%d,%d,%d)\",\n                  (int) ping_trans_color.red,\n                  (int) ping_trans_color.green,\n                  (int) ping_trans_color.blue);\n              }\n\n            ping_trans_color.red*=0x0101;\n            ping_trans_color.green*=0x0101;\n            ping_trans_color.blue*=0x0101;\n            ping_trans_color.gray*=0x0101;\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    to (%d,%d,%d)\",\n                  (int) ping_trans_color.red,\n                  (int) ping_trans_color.green,\n                  (int) ping_trans_color.blue);\n              }\n          }\n      }\n\n    if (ping_bit_depth <  (ssize_t) mng_info->write_png_depth)\n         ping_bit_depth =  (ssize_t) mng_info->write_png_depth;\n\n    /*\n      Adjust background and transparency samples in sub-8-bit grayscale files.\n    */\n    if (ping_bit_depth < 8 && ping_color_type ==\n        PNG_COLOR_TYPE_GRAY)\n      {\n         png_uint_16\n           maxval;\n\n         size_t\n           one=1;\n\n         maxval=(png_uint_16) ((one << ping_bit_depth)-1);\n\n         if (ping_exclude_bKGD == MagickFalse)\n         {\n\n         ping_background.gray=(png_uint_16) ((maxval/65535.)*\n           (ScaleQuantumToShort(((GetPixelInfoIntensity(image,\n           &image->background_color))) +.5)));\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Setting up bKGD chunk (2)\");\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      background_color index is %d\",\n             (int) ping_background.index);\n\n         ping_have_bKGD = MagickTrue;\n         }\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Scaling ping_trans_color.gray from %d\",\n             (int)ping_trans_color.gray);\n\n         ping_trans_color.gray=(png_uint_16) ((maxval/255.)*(\n           ping_trans_color.gray)+.5);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      to %d\", (int)ping_trans_color.gray);\n      }\n\n  if (ping_exclude_bKGD == MagickFalse)\n  {\n    if (mng_info->IsPalette && (int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n      {\n        /*\n           Identify which colormap entry is the background color.\n        */\n\n        number_colors=image_colors;\n\n        for (i=0; i < (ssize_t) MagickMax(1L*number_colors,1L); i++)\n          if (IsPNGColorEqual(image->background_color,image->colormap[i]))\n            break;\n\n        ping_background.index=(png_byte) i;\n\n        if (logging != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Setting up bKGD chunk with index=%d\",(int) i);\n          }\n\n        if (i < (ssize_t) number_colors)\n          {\n            ping_have_bKGD = MagickTrue;\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"     background   =(%d,%d,%d)\",\n                        (int) ping_background.red,\n                        (int) ping_background.green,\n                        (int) ping_background.blue);\n              }\n          }\n\n        else  /* Can't happen */\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      No room in PLTE to add bKGD color\");\n            ping_have_bKGD = MagickFalse;\n          }\n      }\n  }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    PNG color type: %s (%d)\", PngColorTypeToString(ping_color_type),\n      ping_color_type);\n  /*\n    Initialize compression level and filtering.\n  */\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Setting up deflate compression\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Compression buffer size: 32768\");\n    }\n\n  png_set_compression_buffer_size(ping,32768L);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Compression mem level: 9\");\n\n  png_set_compression_mem_level(ping, 9);\n\n  /* Untangle the \"-quality\" setting:\n\n     Undefined is 0; the default is used.\n     Default is 75\n\n     10's digit:\n\n        0 or omitted: Use Z_HUFFMAN_ONLY strategy with the\n           zlib default compression level\n\n        1-9: the zlib compression level\n\n     1's digit:\n\n        0-4: the PNG filter method\n\n        5:   libpng adaptive filtering if compression level > 5\n             libpng filter type \"none\" if compression level <= 5\n                or if image is grayscale or palette\n\n        6:   libpng adaptive filtering\n\n        7:   \"LOCO\" filtering (intrapixel differing) if writing\n             a MNG, otherwise \"none\".  Did not work in IM-6.7.0-9\n             and earlier because of a missing \"else\".\n\n        8:   Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), adaptive\n             filtering. Unused prior to IM-6.7.0-10, was same as 6\n\n        9:   Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), no PNG filters\n             Unused prior to IM-6.7.0-10, was same as 6\n\n    Note that using the -quality option, not all combinations of\n    PNG filter type, zlib compression level, and zlib compression\n    strategy are possible.  This will be addressed soon in a\n    release that accomodates \"-define png:compression-strategy\", etc.\n\n   */\n\n  quality=image_info->quality == UndefinedCompressionQuality ? 75UL :\n     image_info->quality;\n\n  if (quality <= 9)\n    {\n      if (mng_info->write_png_compression_strategy == 0)\n        mng_info->write_png_compression_strategy = Z_HUFFMAN_ONLY+1;\n    }\n\n  else if (mng_info->write_png_compression_level == 0)\n    {\n      int\n        level;\n\n      level=(int) MagickMin((ssize_t) quality/10,9);\n\n      mng_info->write_png_compression_level = level+1;\n    }\n\n  if (mng_info->write_png_compression_strategy == 0)\n    {\n        if ((quality %10) == 8 || (quality %10) == 9)\n#ifdef Z_RLE  /* Z_RLE was added to zlib-1.2.0 */\n          mng_info->write_png_compression_strategy=Z_RLE+1;\n#else\n          mng_info->write_png_compression_strategy = Z_DEFAULT_STRATEGY+1;\n#endif\n    }\n\n  if (mng_info->write_png_compression_filter == 0)\n        mng_info->write_png_compression_filter=((int) quality % 10) + 1;\n\n  if (logging != MagickFalse)\n    {\n        if (mng_info->write_png_compression_level)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Compression level:    %d\",\n            (int) mng_info->write_png_compression_level-1);\n\n        if (mng_info->write_png_compression_strategy)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Compression strategy: %d\",\n            (int) mng_info->write_png_compression_strategy-1);\n\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Setting up filtering\");\n\n        if (mng_info->write_png_compression_filter == 6)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: ADAPTIVE\");\n        else if (mng_info->write_png_compression_filter == 0 ||\n                 mng_info->write_png_compression_filter == 1)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: NONE\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: %d\",\n            (int) mng_info->write_png_compression_filter-1);\n    }\n\n  if (mng_info->write_png_compression_level != 0)\n    png_set_compression_level(ping,mng_info->write_png_compression_level-1);\n\n  if (mng_info->write_png_compression_filter == 6)\n    {\n      if (((int) ping_color_type == PNG_COLOR_TYPE_GRAY) ||\n         ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE) ||\n         (quality < 50))\n        png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n      else\n        png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);\n     }\n  else if (mng_info->write_png_compression_filter == 7 ||\n      mng_info->write_png_compression_filter == 10)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);\n\n  else if (mng_info->write_png_compression_filter == 8)\n    {\n#if defined(PNG_MNG_FEATURES_SUPPORTED) && defined(PNG_INTRAPIXEL_DIFFERENCING)\n      if (mng_info->write_mng)\n      {\n         if (((int) ping_color_type == PNG_COLOR_TYPE_RGB) ||\n             ((int) ping_color_type == PNG_COLOR_TYPE_RGBA))\n        ping_filter_method=PNG_INTRAPIXEL_DIFFERENCING;\n      }\n#endif\n      png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n    }\n\n  else if (mng_info->write_png_compression_filter == 9)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n\n  else if (mng_info->write_png_compression_filter != 0)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,\n       mng_info->write_png_compression_filter-1);\n\n  if (mng_info->write_png_compression_strategy != 0)\n    png_set_compression_strategy(ping,\n       mng_info->write_png_compression_strategy-1);\n\n  ping_interlace_method=image_info->interlace != NoInterlace;\n\n  if (mng_info->write_mng)\n    png_set_sig_bytes(ping,8);\n\n  /* Bail out if cannot meet defined png:bit-depth or png:color-type */\n\n  if (mng_info->write_png_colortype != 0)\n    {\n     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY)\n       if (ping_have_color != MagickFalse)\n         {\n           ping_color_type = PNG_COLOR_TYPE_RGB;\n\n           if (ping_bit_depth < 8)\n             ping_bit_depth=8;\n         }\n\n     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY_ALPHA)\n       if (ping_have_color != MagickFalse)\n         ping_color_type = PNG_COLOR_TYPE_RGB_ALPHA;\n    }\n\n  if (ping_need_colortype_warning != MagickFalse ||\n     ((mng_info->write_png_depth &&\n     (int) mng_info->write_png_depth != ping_bit_depth) ||\n     (mng_info->write_png_colortype &&\n     ((int) mng_info->write_png_colortype-1 != ping_color_type &&\n      mng_info->write_png_colortype != 7 &&\n      !(mng_info->write_png_colortype == 5 && ping_color_type == 0)))))\n    {\n      if (logging != MagickFalse)\n        {\n          if (ping_need_colortype_warning != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  Image has transparency but tRNS chunk was excluded\");\n            }\n\n          if (mng_info->write_png_depth)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Defined png:bit-depth=%u, Computed depth=%u\",\n                  mng_info->write_png_depth,\n                  ping_bit_depth);\n            }\n\n          if (mng_info->write_png_colortype)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Defined png:color-type=%u, Computed color type=%u\",\n                  mng_info->write_png_colortype-1,\n                  ping_color_type);\n            }\n        }\n\n      png_warning(ping,\n        \"Cannot write image with defined png:bit-depth or png:color-type.\");\n    }\n\n  if (image_matte != MagickFalse && image->alpha_trait == UndefinedPixelTrait)\n    {\n      /* Add an opaque matte channel */\n      image->alpha_trait = BlendPixelTrait;\n      (void) SetImageAlpha(image,OpaqueAlpha,exception);\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Added an opaque matte channel\");\n    }\n\n  if (number_transparent != 0 || number_semitransparent != 0)\n    {\n      if (ping_color_type < 4)\n        {\n           ping_have_tRNS=MagickTrue;\n           if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Setting ping_have_tRNS=MagickTrue.\");\n        }\n    }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Writing PNG header chunks\");\n\n  png_set_IHDR(ping,ping_info,ping_width,ping_height,\n               ping_bit_depth,ping_color_type,\n               ping_interlace_method,ping_compression_method,\n               ping_filter_method);\n\n  if (ping_color_type == 3 && ping_have_PLTE != MagickFalse)\n    {\n      png_set_PLTE(ping,ping_info,palette,number_colors);\n\n      if (logging != MagickFalse)\n        {\n          for (i=0; i< (ssize_t) number_colors; i++)\n          {\n            if (i < ping_num_trans)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"     PLTE[%d] = (%d,%d,%d), tRNS[%d] = (%d)\",\n                      (int) i,\n                      (int) palette[i].red,\n                      (int) palette[i].green,\n                      (int) palette[i].blue,\n                      (int) i,\n                      (int) ping_trans_alpha[i]);\n             else\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"     PLTE[%d] = (%d,%d,%d)\",\n                      (int) i,\n                      (int) palette[i].red,\n                      (int) palette[i].green,\n                      (int) palette[i].blue);\n           }\n         }\n    }\n\n  /* Only write the iCCP chunk if we are not writing the sRGB chunk. */\n  if (ping_exclude_sRGB != MagickFalse ||\n     (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n  {\n    if ((ping_exclude_tEXt == MagickFalse ||\n       ping_exclude_zTXt == MagickFalse) &&\n       (ping_exclude_iCCP == MagickFalse || ping_exclude_zCCP == MagickFalse))\n    {\n      ResetImageProfileIterator(image);\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        profile=GetImageProfile(image,name);\n\n        if (profile != (StringInfo *) NULL)\n          {\n#ifdef PNG_WRITE_iCCP_SUPPORTED\n            if ((LocaleCompare(name,\"ICC\") == 0) ||\n                (LocaleCompare(name,\"ICM\") == 0))\n              {\n                ping_have_iCCP = MagickTrue;\n                if (ping_exclude_iCCP == MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Setting up iCCP chunk\");\n\n                    png_set_iCCP(ping,ping_info,(png_charp) name,0,\n#if (PNG_LIBPNG_VER < 10500)\n                    (png_charp) GetStringInfoDatum(profile),\n#else\n                    (const png_byte *) GetStringInfoDatum(profile),\n#endif\n                    (png_uint_32) GetStringInfoLength(profile));\n                  }\n                else\n                  {\n                    /* Do not write hex-encoded ICC chunk */\n                       name=GetNextImageProfile(image);\n                       continue;\n                  }\n              }\n#endif /* WRITE_iCCP */\n\n            if (LocaleCompare(name,\"exif\") == 0)\n              {\n                   /* Do not write hex-encoded ICC chunk; we will\n                      write it later as an eXIf chunk */\n                   name=GetNextImageProfile(image);\n                   continue;\n              }\n\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  Setting up zTXt chunk with uuencoded %s profile\",\n                 name);\n              Magick_png_write_raw_profile(image_info,ping,ping_info,\n                (unsigned char *) name,(unsigned char *) name,\n                GetStringInfoDatum(profile),\n                (png_uint_32) GetStringInfoLength(profile));\n          }\n        name=GetNextImageProfile(image);\n      }\n    }\n  }\n\n#if defined(PNG_WRITE_sRGB_SUPPORTED)\n  if ((mng_info->have_write_global_srgb == 0) &&\n      ping_have_iCCP != MagickTrue &&\n      (ping_have_sRGB != MagickFalse ||\n      png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n    {\n      if (ping_exclude_sRGB == MagickFalse)\n        {\n          /*\n            Note image rendering intent.\n          */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Setting up sRGB chunk\");\n\n          (void) png_set_sRGB(ping,ping_info,(\n            Magick_RenderingIntent_to_PNG_RenderingIntent(\n              image->rendering_intent)));\n\n          ping_have_sRGB = MagickTrue;\n        }\n    }\n\n  if ((!mng_info->write_mng) || (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n#endif\n    {\n      if (ping_exclude_gAMA == MagickFalse &&\n          ping_have_iCCP == MagickFalse &&\n          ping_have_sRGB == MagickFalse &&\n          (ping_exclude_sRGB == MagickFalse ||\n          (image->gamma < .45 || image->gamma > .46)))\n      {\n      if ((mng_info->have_write_global_gama == 0) && (image->gamma != 0.0))\n        {\n          /*\n            Note image gamma.\n            To do: check for cHRM+gAMA == sRGB, and write sRGB instead.\n          */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Setting up gAMA chunk\");\n\n          png_set_gAMA(ping,ping_info,image->gamma);\n        }\n      }\n\n      if (ping_exclude_cHRM == MagickFalse && ping_have_sRGB == MagickFalse)\n        {\n          if ((mng_info->have_write_global_chrm == 0) &&\n              (image->chromaticity.red_primary.x != 0.0))\n            {\n              /*\n                Note image chromaticity.\n                Note: if cHRM+gAMA == sRGB write sRGB instead.\n              */\n               PrimaryInfo\n                 bp,\n                 gp,\n                 rp,\n                 wp;\n\n               wp=image->chromaticity.white_point;\n               rp=image->chromaticity.red_primary;\n               gp=image->chromaticity.green_primary;\n               bp=image->chromaticity.blue_primary;\n\n               if (logging != MagickFalse)\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  Setting up cHRM chunk\");\n\n               png_set_cHRM(ping,ping_info,wp.x,wp.y,rp.x,rp.y,gp.x,gp.y,\n                   bp.x,bp.y);\n           }\n        }\n    }\n\n  if (ping_exclude_bKGD == MagickFalse)\n    {\n      if (ping_have_bKGD != MagickFalse)\n        {\n          png_set_bKGD(ping,ping_info,&ping_background);\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Setting up bKGD chunk\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      background color = (%d,%d,%d)\",\n                        (int) ping_background.red,\n                        (int) ping_background.green,\n                        (int) ping_background.blue);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      index = %d, gray=%d\",\n                        (int) ping_background.index,\n                        (int) ping_background.gray);\n            }\n         }\n    }\n\n  if (ping_exclude_pHYs == MagickFalse)\n    {\n      if (ping_have_pHYs != MagickFalse)\n        {\n          png_set_pHYs(ping,ping_info,\n             ping_pHYs_x_resolution,\n             ping_pHYs_y_resolution,\n             ping_pHYs_unit_type);\n\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Setting up pHYs chunk\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      x_resolution=%lu\",\n                   (unsigned long) ping_pHYs_x_resolution);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      y_resolution=%lu\",\n                   (unsigned long) ping_pHYs_y_resolution);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      unit_type=%lu\",\n                   (unsigned long) ping_pHYs_unit_type);\n            }\n        }\n    }\n\n#if defined(PNG_tIME_SUPPORTED)\n  if (ping_exclude_tIME == MagickFalse)\n    {\n      const char\n        *timestamp;\n\n      if (image->taint == MagickFalse)\n        {\n          timestamp=GetImageOption(image_info,\"png:tIME\");\n\n          if (timestamp == (const char *) NULL)\n            timestamp=GetImageProperty(image,\"png:tIME\",exception);\n        }\n\n      else\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Reset tIME in tainted image\");\n\n          timestamp=GetImageProperty(image,\"date:modify\",exception);\n        }\n\n      if (timestamp != (const char *) NULL)\n          write_tIME_chunk(image,ping,ping_info,timestamp,exception);\n    }\n#endif\n\n  if (mng_info->need_blob != MagickFalse)\n  {\n    if (OpenBlob(image_info,image,WriteBinaryBlobMode,exception) ==\n       MagickFalse)\n       png_error(ping,\"WriteBlob Failed\");\n\n     ping_have_blob=MagickTrue;\n  }\n\n  png_write_info_before_PLTE(ping, ping_info);\n\n  if (ping_have_tRNS != MagickFalse && ping_color_type < 4)\n    {\n      if (logging != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Calling png_set_tRNS with num_trans=%d\",ping_num_trans);\n        }\n\n      if (ping_color_type == 3)\n         (void) png_set_tRNS(ping, ping_info,\n                ping_trans_alpha,\n                ping_num_trans,\n                NULL);\n\n      else\n        {\n           (void) png_set_tRNS(ping, ping_info,\n                  NULL,\n                  0,\n                  &ping_trans_color);\n\n           if (logging != MagickFalse)\n             {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"     tRNS color   =(%d,%d,%d)\",\n                       (int) ping_trans_color.red,\n                       (int) ping_trans_color.green,\n                       (int) ping_trans_color.blue);\n             }\n         }\n    }\n\n  /* write any png-chunk-b profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-b\",logging);\n\n  png_write_info(ping,ping_info);\n\n  /* write any PNG-chunk-m profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-m\",logging);\n\n  ping_wrote_caNv = MagickFalse;\n\n  /* write caNv chunk */\n  if (ping_exclude_caNv == MagickFalse)\n    {\n      if ((image->page.width != 0 && image->page.width != image->columns) ||\n          (image->page.height != 0 && image->page.height != image->rows) ||\n          image->page.x != 0 || image->page.y != 0)\n        {\n          unsigned char\n            chunk[20];\n\n          (void) WriteBlobMSBULong(image,16L);  /* data length=8 */\n          PNGType(chunk,mng_caNv);\n          LogPNGChunk(logging,mng_caNv,16L);\n          PNGLong(chunk+4,(png_uint_32) image->page.width);\n          PNGLong(chunk+8,(png_uint_32) image->page.height);\n          PNGsLong(chunk+12,(png_int_32) image->page.x);\n          PNGsLong(chunk+16,(png_int_32) image->page.y);\n          (void) WriteBlob(image,20,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,20));\n          ping_wrote_caNv = MagickTrue;\n        }\n    }\n\n#if defined(PNG_oFFs_SUPPORTED)\n  if (ping_exclude_oFFs == MagickFalse && ping_wrote_caNv == MagickFalse)\n    {\n      if (image->page.x || image->page.y)\n        {\n           png_set_oFFs(ping,ping_info,(png_int_32) image->page.x,\n              (png_int_32) image->page.y, 0);\n\n           if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"    Setting up oFFs chunk with x=%d, y=%d, units=0\",\n                 (int) image->page.x, (int) image->page.y);\n        }\n    }\n#endif\n\n  /* write vpAg chunk (deprecated, replaced by caNv) */\n  if (ping_exclude_vpAg == MagickFalse && ping_wrote_caNv == MagickFalse)\n    {\n      if ((image->page.width != 0 && image->page.width != image->columns) ||\n          (image->page.height != 0 && image->page.height != image->rows))\n        {\n          unsigned char\n            chunk[14];\n\n          (void) WriteBlobMSBULong(image,9L);  /* data length=8 */\n          PNGType(chunk,mng_vpAg);\n          LogPNGChunk(logging,mng_vpAg,9L);\n          PNGLong(chunk+4,(png_uint_32) image->page.width);\n          PNGLong(chunk+8,(png_uint_32) image->page.height);\n          chunk[12]=0;   /* unit = pixels */\n          (void) WriteBlob(image,13,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,13));\n        }\n    }\n\n#if (PNG_LIBPNG_VER == 10206)\n    /* avoid libpng-1.2.6 bug by setting PNG_HAVE_IDAT flag */\n#define PNG_HAVE_IDAT               0x04\n    ping->mode |= PNG_HAVE_IDAT;\n#undef PNG_HAVE_IDAT\n#endif\n\n  png_set_packing(ping);\n  /*\n    Allocate memory.\n  */\n  rowbytes=image->columns;\n  if (image_depth > 8)\n    rowbytes*=2;\n  switch (ping_color_type)\n    {\n      case PNG_COLOR_TYPE_RGB:\n        rowbytes*=3;\n        break;\n\n      case PNG_COLOR_TYPE_GRAY_ALPHA:\n        rowbytes*=2;\n        break;\n\n      case PNG_COLOR_TYPE_RGBA:\n        rowbytes*=4;\n        break;\n\n      default:\n        break;\n    }\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Writing PNG image data\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Allocating %.20g bytes of memory for pixels\",(double) rowbytes);\n    }\n  pixel_info=AcquireVirtualMemory(rowbytes,sizeof(*ping_pixels));\n  if (pixel_info == (MemoryInfo *) NULL)\n    png_error(ping,\"Allocation of memory for pixels failed\");\n  ping_pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n\n  /*\n    Initialize image scanlines.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    png_error(ping,\"Memory allocation for quantum_info failed\");\n  quantum_info->format=UndefinedQuantumFormat;\n  SetQuantumDepth(image,quantum_info,image_depth);\n  (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n  num_passes=png_set_interlace_handling(ping);\n\n  if ((!mng_info->write_png8 && !mng_info->write_png24 &&\n       !mng_info->write_png48 && !mng_info->write_png64 &&\n       !mng_info->write_png32) &&\n       (mng_info->IsPalette ||\n       (image_info->type == BilevelType)) &&\n       image_matte == MagickFalse &&\n       ping_have_non_bw == MagickFalse)\n    {\n      /* Palette, Bilevel, or Opaque Monochrome */\n      register const Quantum\n        *p;\n\n      SetQuantumDepth(image,quantum_info,8);\n      for (pass=0; pass < num_passes; pass++)\n      {\n        /*\n          Convert PseudoClass image to a PNG monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          if (logging != MagickFalse && y == 0)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"    Writing row of pixels (0)\");\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n\n          if (p == (const Quantum *) NULL)\n            break;\n\n          if (mng_info->IsPalette)\n            {\n              (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                quantum_info,GrayQuantum,ping_pixels,exception);\n              if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_PALETTE &&\n                  mng_info->write_png_depth &&\n                  mng_info->write_png_depth != old_bit_depth)\n                {\n                  /* Undo pixel scaling */\n                  for (i=0; i < (ssize_t) image->columns; i++)\n                     *(ping_pixels+i)=(unsigned char) (*(ping_pixels+i)\n                     >> (8-old_bit_depth));\n                }\n            }\n\n          else\n            {\n              (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                quantum_info,RedQuantum,ping_pixels,exception);\n            }\n\n          if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE)\n            for (i=0; i < (ssize_t) image->columns; i++)\n               *(ping_pixels+i)=(unsigned char) ((*(ping_pixels+i) > 127) ?\n                      255 : 0);\n\n          if (logging != MagickFalse && y == 0)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Writing row of pixels (1)\");\n\n          png_write_row(ping,ping_pixels);\n\n          status=SetImageProgress(image,SaveImageTag,\n              (MagickOffsetType) (pass * image->rows + y),\n              num_passes * image->rows);\n\n          if (status == MagickFalse)\n            break;\n        }\n      }\n    }\n\n  else   /* Not Palette, Bilevel, or Opaque Monochrome */\n    {\n      if ((!mng_info->write_png8 && !mng_info->write_png24 &&\n          !mng_info->write_png48 && !mng_info->write_png64 &&\n          !mng_info->write_png32) && (image_matte != MagickFalse ||\n          (ping_bit_depth >= MAGICKCORE_QUANTUM_DEPTH)) &&\n          (mng_info->IsPalette) && ping_have_color == MagickFalse)\n        {\n          register const Quantum\n            *p;\n\n          for (pass=0; pass < num_passes; pass++)\n          {\n\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n\n            if (p == (const Quantum *) NULL)\n              break;\n\n            if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n              {\n                if (mng_info->IsPalette)\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,GrayQuantum,ping_pixels,exception);\n\n                else\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RedQuantum,ping_pixels,exception);\n\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"    Writing GRAY PNG pixels (2)\");\n              }\n\n            else /* PNG_COLOR_TYPE_GRAY_ALPHA */\n              {\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Writing GRAY_ALPHA PNG pixels (2)\");\n\n                (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,GrayAlphaQuantum,ping_pixels,exception);\n              }\n\n            if (logging != MagickFalse && y == 0)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Writing row of pixels (2)\");\n\n            png_write_row(ping,ping_pixels);\n\n            status=SetImageProgress(image,SaveImageTag,\n              (MagickOffsetType) (pass * image->rows + y),\n              num_passes * image->rows);\n\n            if (status == MagickFalse)\n              break;\n            }\n          }\n        }\n\n      else\n        {\n          register const Quantum\n            *p;\n\n          for (pass=0; pass < num_passes; pass++)\n          {\n            if ((image_depth > 8) ||\n                mng_info->write_png24 ||\n                mng_info->write_png32 ||\n                mng_info->write_png48 ||\n                mng_info->write_png64 ||\n                (!mng_info->write_png8 && !mng_info->IsPalette))\n            {\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                p=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n                if (p == (const Quantum *) NULL)\n                  break;\n\n                if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n                  {\n                    if (image->storage_class == DirectClass)\n                      (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                        quantum_info,RedQuantum,ping_pixels,exception);\n\n                    else\n                      (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                        quantum_info,GrayQuantum,ping_pixels,exception);\n                  }\n\n                else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n                  {\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                      quantum_info,GrayAlphaQuantum,ping_pixels,\n                      exception);\n\n                    if (logging != MagickFalse && y == 0)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"    Writing GRAY_ALPHA PNG pixels (3)\");\n                  }\n\n                else if (image_matte != MagickFalse)\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RGBAQuantum,ping_pixels,exception);\n\n                else\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RGBQuantum,ping_pixels,exception);\n\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"    Writing row of pixels (3)\");\n\n                png_write_row(ping,ping_pixels);\n\n                status=SetImageProgress(image,SaveImageTag,\n                  (MagickOffsetType) (pass * image->rows + y),\n                  num_passes * image->rows);\n\n                if (status == MagickFalse)\n                  break;\n              }\n            }\n\n          else\n            /* not ((image_depth > 8) ||\n                mng_info->write_png24 || mng_info->write_png32 ||\n                mng_info->write_png48 || mng_info->write_png64 ||\n                (!mng_info->write_png8 && !mng_info->IsPalette))\n             */\n            {\n              if ((ping_color_type != PNG_COLOR_TYPE_GRAY) &&\n                  (ping_color_type != PNG_COLOR_TYPE_GRAY_ALPHA))\n                {\n                  if (logging != MagickFalse)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"  pass %d, Image Is not GRAY or GRAY_ALPHA\",pass);\n\n                  SetQuantumDepth(image,quantum_info,8);\n                  image_depth=8;\n                }\n\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  pass %d, Image Is RGB, 16-bit GRAY, or GRAY_ALPHA\",\n                    pass);\n\n                p=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n                if (p == (const Quantum *) NULL)\n                  break;\n\n                if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n                  {\n                    SetQuantumDepth(image,quantum_info,image->depth);\n\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                       quantum_info,GrayQuantum,ping_pixels,exception);\n                  }\n\n                else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n                  {\n                    if (logging != MagickFalse && y == 0)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"  Writing GRAY_ALPHA PNG pixels (4)\");\n\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                         quantum_info,GrayAlphaQuantum,ping_pixels,\n                         exception);\n                  }\n\n                else\n                  {\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                      quantum_info,IndexQuantum,ping_pixels,exception);\n\n                    if (logging != MagickFalse && y <= 2)\n                    {\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  Writing row of non-gray pixels (4)\");\n\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  ping_pixels[0]=%d,ping_pixels[1]=%d\",\n                          (int)ping_pixels[0],(int)ping_pixels[1]);\n                    }\n                  }\n                png_write_row(ping,ping_pixels);\n\n                status=SetImageProgress(image,SaveImageTag,\n                  (MagickOffsetType) (pass * image->rows + y),\n                  num_passes * image->rows);\n\n                if (status == MagickFalse)\n                  break;\n              }\n            }\n          }\n        }\n    }\n\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Wrote PNG image data\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Width: %.20g\",(double) ping_width);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Height: %.20g\",(double) ping_height);\n\n      if (mng_info->write_png_depth)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Defined png:bit-depth: %d\",mng_info->write_png_depth);\n        }\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG bit-depth written: %d\",ping_bit_depth);\n\n      if (mng_info->write_png_colortype)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Defined png:color-type: %d\",mng_info->write_png_colortype-1);\n        }\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG color-type written: %d\",ping_color_type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG Interlace method: %d\",ping_interlace_method);\n    }\n  /*\n    Generate text chunks after IDAT.\n  */\n  if (ping_exclude_tEXt == MagickFalse || ping_exclude_zTXt == MagickFalse)\n  {\n    ResetImagePropertyIterator(image);\n    property=GetNextImageProperty(image);\n    while (property != (const char *) NULL)\n    {\n      png_textp\n        text;\n\n      value=GetImageProperty(image,property,exception);\n\n      /* Don't write any \"png:\" or \"jpeg:\" properties; those are just for\n       * \"identify\" or for passing through to another JPEG\n       */\n      if ((LocaleNCompare(property,\"png:\",4) != 0 &&\n           LocaleNCompare(property,\"jpeg:\",5) != 0) &&\n\n\n          /* Suppress density and units if we wrote a pHYs chunk */\n          (ping_exclude_pHYs != MagickFalse      ||\n          LocaleCompare(property,\"density\") != 0 ||\n          LocaleCompare(property,\"units\") != 0) &&\n\n          /* Suppress the IM-generated Date:create and Date:modify */\n          (ping_exclude_date == MagickFalse      ||\n          LocaleNCompare(property, \"Date:\",5) != 0))\n        {\n        if (value != (const char *) NULL)\n          {\n\n#if PNG_LIBPNG_VER >= 10400\n            text=(png_textp) png_malloc(ping,\n                 (png_alloc_size_t) sizeof(png_text));\n#else\n            text=(png_textp) png_malloc(ping,(png_size_t) sizeof(png_text));\n#endif\n            text[0].key=(char *) property;\n            text[0].text=(char *) value;\n            text[0].text_length=strlen(value);\n\n            if (ping_exclude_tEXt != MagickFalse)\n               text[0].compression=PNG_TEXT_COMPRESSION_zTXt;\n\n            else if (ping_exclude_zTXt != MagickFalse)\n               text[0].compression=PNG_TEXT_COMPRESSION_NONE;\n\n            else\n            {\n               text[0].compression=image_info->compression == NoCompression ||\n                 (image_info->compression == UndefinedCompression &&\n                 text[0].text_length < 128) ? PNG_TEXT_COMPRESSION_NONE :\n                 PNG_TEXT_COMPRESSION_zTXt ;\n            }\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Setting up text chunk\");\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    keyword: '%s'\",text[0].key);\n              }\n\n            png_set_text(ping,ping_info,text,1);\n            png_free(ping,text);\n          }\n        }\n      property=GetNextImageProperty(image);\n    }\n  }\n\n  /* write any PNG-chunk-e profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-e\",logging);\n\n  /* write exIf profile */\n  if (ping_have_eXIf != MagickFalse && ping_exclude_eXIf == MagickFalse)\n    {\n      char\n        *name;\n\n      ResetImageProfileIterator(image);\n\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        if (LocaleCompare(name,\"exif\") == 0)\n          {\n            const StringInfo\n              *profile;\n\n            profile=GetImageProfile(image,name);\n\n            if (profile != (StringInfo *) NULL)\n              {\n                png_uint_32\n                  length;\n\n                unsigned char\n                  chunk[4],\n                  *data;\n\n               StringInfo\n                 *ping_profile;\n\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Have eXIf profile\");\n\n               ping_profile=CloneStringInfo(profile);\n               data=GetStringInfoDatum(ping_profile),\n               length=(png_uint_32) GetStringInfoLength(ping_profile);\n\n               PNGType(chunk,mng_eXIf);\n               if (length < 7)\n                 {\n                   ping_profile=DestroyStringInfo(ping_profile);\n                   break;  /* otherwise crashes */\n                 }\n\n               /* skip the \"Exif\\0\\0\" JFIF Exif Header ID */\n               length -= 6;\n\n               LogPNGChunk(logging,chunk,length);\n               (void) WriteBlobMSBULong(image,length);\n               (void) WriteBlob(image,4,chunk);\n               (void) WriteBlob(image,length,data+6);\n               (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),\n                 data+6, (uInt) length));\n               ping_profile=DestroyStringInfo(ping_profile);\n               break;\n             }\n         }\n       name=GetNextImageProfile(image);\n     }\n  }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Writing PNG end info\");\n\n  png_write_end(ping,ping_info);\n\n  if (mng_info->need_fram && (int) image->dispose == BackgroundDispose)\n    {\n      if (mng_info->page.x || mng_info->page.y ||\n          (ping_width != mng_info->page.width) ||\n          (ping_height != mng_info->page.height))\n        {\n          unsigned char\n            chunk[32];\n\n          /*\n            Write FRAM 4 with clipping boundaries followed by FRAM 1.\n          */\n          (void) WriteBlobMSBULong(image,27L);  /* data length=27 */\n          PNGType(chunk,mng_FRAM);\n          LogPNGChunk(logging,mng_FRAM,27L);\n          chunk[4]=4;\n          chunk[5]=0;  /* frame name separator (no name) */\n          chunk[6]=1;  /* flag for changing delay, for next frame only */\n          chunk[7]=0;  /* flag for changing frame timeout */\n          chunk[8]=1;  /* flag for changing frame clipping for next frame */\n          chunk[9]=0;  /* flag for changing frame sync_id */\n          PNGLong(chunk+10,(png_uint_32) (0L)); /* temporary 0 delay */\n          chunk[14]=0; /* clipping boundaries delta type */\n          PNGLong(chunk+15,(png_uint_32) (mng_info->page.x)); /* left cb */\n          PNGLong(chunk+19,\n             (png_uint_32) (mng_info->page.x + ping_width));\n          PNGLong(chunk+23,(png_uint_32) (mng_info->page.y)); /* top cb */\n          PNGLong(chunk+27,\n             (png_uint_32) (mng_info->page.y + ping_height));\n          (void) WriteBlob(image,31,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,31));\n          mng_info->old_framing_mode=4;\n          mng_info->framing_mode=1;\n        }\n\n      else\n        mng_info->framing_mode=3;\n    }\n  if (mng_info->write_mng && !mng_info->need_fram &&\n      ((int) image->dispose == 3))\n     png_error(ping, \"Cannot convert GIF with disposal method 3 to MNG-LC\");\n\n  /*\n    Free PNG resources.\n  */\n\n  png_destroy_write_struct(&ping,&ping_info);\n\n  pixel_info=RelinquishVirtualMemory(pixel_info);\n\n  if (ping_have_blob != MagickFalse)\n     (void) CloseBlob(image);\n\n  image_info=DestroyImageInfo(image_info);\n  image=DestroyImage(image);\n\n  /* Store bit depth actually written */\n  s[0]=(char) ping_bit_depth;\n  s[1]='\\0';\n\n  (void) SetImageProperty(IMimage,\"png:bit-depth-written\",s,exception);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit WriteOnePNGImage()\");\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n   /* }  for navigation to beginning of SETJMP-protected block. Revert to\n    *    Throwing an Exception when an error occurs.\n    */\n\n  return(MagickTrue);\n/*  End write one PNG image */\n\n}", "func_src_after": "static MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,\n  const ImageInfo *IMimage_info,Image *IMimage,ExceptionInfo *exception)\n{\n  char\n    im_vers[32],\n    libpng_runv[32],\n    libpng_vers[32],\n    zlib_runv[32],\n    zlib_vers[32];\n\n  Image\n    *image;\n\n  ImageInfo\n    *image_info;\n\n  char\n    s[2];\n\n  const char\n    *name,\n    *property,\n    *value;\n\n  const StringInfo\n    *profile;\n\n  int\n    num_passes,\n    pass,\n    ping_wrote_caNv;\n\n  png_byte\n     ping_trans_alpha[256];\n\n  png_color\n     palette[257];\n\n  png_color_16\n    ping_background,\n    ping_trans_color;\n\n  png_info\n    *ping_info;\n\n  png_struct\n    *ping;\n\n  png_uint_32\n    ping_height,\n    ping_width;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    image_matte,\n    logging,\n    matte,\n\n    ping_have_blob,\n    ping_have_cheap_transparency,\n    ping_have_color,\n    ping_have_non_bw,\n    ping_have_PLTE,\n    ping_have_bKGD,\n    ping_have_eXIf,\n    ping_have_iCCP,\n    ping_have_pHYs,\n    ping_have_sRGB,\n    ping_have_tRNS,\n\n    ping_exclude_bKGD,\n    ping_exclude_cHRM,\n    ping_exclude_date,\n    /* ping_exclude_EXIF, */\n    ping_exclude_eXIf,\n    ping_exclude_gAMA,\n    ping_exclude_iCCP,\n    /* ping_exclude_iTXt, */\n    ping_exclude_oFFs,\n    ping_exclude_pHYs,\n    ping_exclude_sRGB,\n    ping_exclude_tEXt,\n    ping_exclude_tIME,\n    /* ping_exclude_tRNS, */\n    ping_exclude_vpAg,\n    ping_exclude_caNv,\n    ping_exclude_zCCP, /* hex-encoded iCCP */\n    ping_exclude_zTXt,\n\n    ping_preserve_colormap,\n    ping_preserve_iCCP,\n    ping_need_colortype_warning,\n\n    status,\n    tried_332,\n    tried_333,\n    tried_444;\n\n  MemoryInfo\n    *volatile pixel_info;\n\n  QuantumInfo\n    *quantum_info;\n\n  PNGErrorInfo\n    error_info;\n\n  register ssize_t\n    i,\n    x;\n\n  unsigned char\n    *ping_pixels;\n\n  volatile int\n    image_colors,\n    ping_bit_depth,\n    ping_color_type,\n    ping_interlace_method,\n    ping_compression_method,\n    ping_filter_method,\n    ping_num_trans;\n\n  volatile size_t\n    image_depth,\n    old_bit_depth;\n\n  size_t\n    quality,\n    rowbytes,\n    save_image_depth;\n\n  int\n    j,\n    number_colors,\n    number_opaque,\n    number_semitransparent,\n    number_transparent,\n    ping_pHYs_unit_type;\n\n  png_uint_32\n    ping_pHYs_x_resolution,\n    ping_pHYs_y_resolution;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter WriteOnePNGImage()\");\n\n  image = CloneImage(IMimage,0,0,MagickFalse,exception);\n  if (image == (Image *) NULL)\n    return(MagickFalse);\n  image_info=(ImageInfo *) CloneImageInfo(IMimage_info);\n  if (image_info == (ImageInfo *) NULL)\n    ThrowWriterException(ResourceLimitError, \"MemoryAllocationFailed\");\n\n  /* Define these outside of the following \"if logging()\" block so they will\n   * show in debuggers.\n   */\n  *im_vers='\\0';\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibVersionText,MagickPathExtent);\n  (void) ConcatenateMagickString(im_vers,\n         MagickLibAddendum,MagickPathExtent);\n\n  *libpng_vers='\\0';\n  (void) ConcatenateMagickString(libpng_vers,\n         PNG_LIBPNG_VER_STRING,32);\n  *libpng_runv='\\0';\n  (void) ConcatenateMagickString(libpng_runv,\n         png_get_libpng_ver(NULL),32);\n\n  *zlib_vers='\\0';\n  (void) ConcatenateMagickString(zlib_vers,\n         ZLIB_VERSION,32);\n  *zlib_runv='\\0';\n  (void) ConcatenateMagickString(zlib_runv,\n         zlib_version,32);\n\n  if (logging != MagickFalse)\n    {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    IM version     = %s\",\n           im_vers);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    Libpng version = %s\",\n           libpng_vers);\n       if (LocaleCompare(libpng_vers,libpng_runv) != 0)\n       {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n           libpng_runv);\n       }\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"    Zlib version   = %s\",\n           zlib_vers);\n       if (LocaleCompare(zlib_vers,zlib_runv) != 0)\n       {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"      running with   %s\",\n           zlib_runv);\n       }\n    }\n\n  /* Initialize some stuff */\n  ping_bit_depth=0,\n  ping_color_type=0,\n  ping_interlace_method=0,\n  ping_compression_method=0,\n  ping_filter_method=0,\n  ping_num_trans = 0;\n\n  ping_background.red = 0;\n  ping_background.green = 0;\n  ping_background.blue = 0;\n  ping_background.gray = 0;\n  ping_background.index = 0;\n\n  ping_trans_color.red=0;\n  ping_trans_color.green=0;\n  ping_trans_color.blue=0;\n  ping_trans_color.gray=0;\n\n  ping_pHYs_unit_type = 0;\n  ping_pHYs_x_resolution = 0;\n  ping_pHYs_y_resolution = 0;\n\n  ping_have_blob=MagickFalse;\n  ping_have_cheap_transparency=MagickFalse;\n  ping_have_color=MagickTrue;\n  ping_have_non_bw=MagickTrue;\n  ping_have_PLTE=MagickFalse;\n  ping_have_bKGD=MagickFalse;\n  ping_have_eXIf=MagickTrue;\n  ping_have_iCCP=MagickFalse;\n  ping_have_pHYs=MagickFalse;\n  ping_have_sRGB=MagickFalse;\n  ping_have_tRNS=MagickFalse;\n\n  ping_exclude_bKGD=mng_info->ping_exclude_bKGD;\n  ping_exclude_caNv=mng_info->ping_exclude_caNv;\n  ping_exclude_cHRM=mng_info->ping_exclude_cHRM;\n  ping_exclude_date=mng_info->ping_exclude_date;\n  ping_exclude_eXIf=mng_info->ping_exclude_eXIf;\n  ping_exclude_gAMA=mng_info->ping_exclude_gAMA;\n  ping_exclude_iCCP=mng_info->ping_exclude_iCCP;\n  /* ping_exclude_iTXt=mng_info->ping_exclude_iTXt; */\n  ping_exclude_oFFs=mng_info->ping_exclude_oFFs;\n  ping_exclude_pHYs=mng_info->ping_exclude_pHYs;\n  ping_exclude_sRGB=mng_info->ping_exclude_sRGB;\n  ping_exclude_tEXt=mng_info->ping_exclude_tEXt;\n  ping_exclude_tIME=mng_info->ping_exclude_tIME;\n  /* ping_exclude_tRNS=mng_info->ping_exclude_tRNS; */\n  ping_exclude_vpAg=mng_info->ping_exclude_vpAg;\n  ping_exclude_zCCP=mng_info->ping_exclude_zCCP; /* hex-encoded iCCP in zTXt */\n  ping_exclude_zTXt=mng_info->ping_exclude_zTXt;\n\n  ping_preserve_colormap = mng_info->ping_preserve_colormap;\n  ping_preserve_iCCP = mng_info->ping_preserve_iCCP;\n  ping_need_colortype_warning = MagickFalse;\n\n  /* Recognize the ICC sRGB profile and convert it to the sRGB chunk,\n   * i.e., eliminate the ICC profile and set image->rendering_intent.\n   * Note that this will not involve any changes to the actual pixels\n   * but merely passes information to applications that read the resulting\n   * PNG image.\n   *\n   * To do: recognize other variants of the sRGB profile, using the CRC to\n   * verify all recognized variants including the 7 already known.\n   *\n   * Work around libpng16+ rejecting some \"known invalid sRGB profiles\".\n   *\n   * Use something other than image->rendering_intent to record the fact\n   * that the sRGB profile was found.\n   *\n   * Record the ICC version (currently v2 or v4) of the incoming sRGB ICC\n   * profile.  Record the Blackpoint Compensation, if any.\n   */\n   if (ping_exclude_sRGB == MagickFalse && ping_preserve_iCCP == MagickFalse)\n   {\n      char\n        *name;\n\n      const StringInfo\n        *profile;\n\n      ResetImageProfileIterator(image);\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        profile=GetImageProfile(image,name);\n\n        if (profile != (StringInfo *) NULL)\n          {\n            if ((LocaleCompare(name,\"ICC\") == 0) ||\n                (LocaleCompare(name,\"ICM\") == 0))\n\n             {\n                 int\n                   icheck,\n                   got_crc=0;\n\n\n                 png_uint_32\n                   length,\n                   profile_crc=0;\n\n                 unsigned char\n                   *data;\n\n                 length=(png_uint_32) GetStringInfoLength(profile);\n\n                 for (icheck=0; sRGB_info[icheck].len > 0; icheck++)\n                 {\n                   if (length == sRGB_info[icheck].len)\n                   {\n                     if (got_crc == 0)\n                     {\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Got a %lu-byte ICC profile (potentially sRGB)\",\n                         (unsigned long) length);\n\n                       data=GetStringInfoDatum(profile);\n                       profile_crc=crc32(0,data,length);\n\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"      with crc=%8x\",(unsigned int) profile_crc);\n                       got_crc++;\n                     }\n\n                     if (profile_crc == sRGB_info[icheck].crc)\n                     {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"      It is sRGB with rendering intent = %s\",\n                        Magick_RenderingIntentString_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent));\n                        if (image->rendering_intent==UndefinedIntent)\n                        {\n                          image->rendering_intent=\n                          Magick_RenderingIntent_from_PNG_RenderingIntent(\n                             sRGB_info[icheck].intent);\n                        }\n                        ping_exclude_iCCP = MagickTrue;\n                        ping_exclude_zCCP = MagickTrue;\n                        ping_have_sRGB = MagickTrue;\n                        break;\n                     }\n                   }\n                 }\n                 if (sRGB_info[icheck].len == 0)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"    Got %lu-byte ICC profile not recognized as sRGB\",\n                        (unsigned long) length);\n              }\n          }\n        name=GetNextImageProfile(image);\n      }\n  }\n\n  number_opaque = 0;\n  number_semitransparent = 0;\n  number_transparent = 0;\n\n  if (logging != MagickFalse)\n    {\n      if (image->storage_class == UndefinedClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=UndefinedClass\");\n      if (image->storage_class == DirectClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=DirectClass\");\n      if (image->storage_class == PseudoClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    image->storage_class=PseudoClass\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(), image->taint ?\n          \"    image->taint=MagickTrue\":\n          \"    image->taint=MagickFalse\");\n    }\n\n  if (image->storage_class == PseudoClass &&\n     (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32 ||\n     mng_info->write_png48 || mng_info->write_png64 ||\n     (mng_info->write_png_colortype != 1 &&\n     mng_info->write_png_colortype != 5)))\n    {\n      (void) SyncImage(image,exception);\n      image->storage_class = DirectClass;\n    }\n\n  if (ping_preserve_colormap == MagickFalse)\n    {\n      if (image->storage_class != PseudoClass && image->colormap != NULL)\n        {\n          /* Free the bogus colormap; it can cause trouble later */\n           if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Freeing bogus colormap\");\n           (void) RelinquishMagickMemory(image->colormap);\n           image->colormap=NULL;\n        }\n    }\n\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n\n  /*\n    Sometimes we get PseudoClass images whose RGB values don't match\n    the colors in the colormap.  This code syncs the RGB values.\n  */\n  if (image->depth <= 8 && image->taint && image->storage_class == PseudoClass)\n     (void) SyncImage(image,exception);\n\n#if (MAGICKCORE_QUANTUM_DEPTH == 8)\n  if (image->depth > 8)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Reducing PNG bit depth to 8 since this is a Q8 build.\");\n\n      image->depth=8;\n    }\n#endif\n\n  /* Respect the -depth option */\n  if (image->depth < 4)\n    {\n       register Quantum\n         *r;\n\n       if (image->depth > 2)\n         {\n           /* Scale to 4-bit */\n           LBR04PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR04PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR04PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n       else if (image->depth > 1)\n         {\n           /* Scale to 2-bit */\n           LBR02PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR02PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR02PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n       else\n         {\n           /* Scale to 1-bit */\n           LBR01PacketRGBO(image->background_color);\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (r == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                LBR01PixelRGBA(r);\n                r+=GetPixelChannels(image);\n             }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n\n           if (image->storage_class == PseudoClass && image->colormap != NULL)\n           {\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               LBR01PacketRGBO(image->colormap[i]);\n             }\n           }\n         }\n    }\n\n  /* To do: set to next higher multiple of 8 */\n  if (image->depth < 8)\n     image->depth=8;\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n  /* PNG does not handle depths greater than 16 so reduce it even\n   * if lossy\n   */\n  if (image->depth > 8)\n      image->depth=16;\n#endif\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 8)\n  if (image->depth > 8)\n    {\n      /* To do: fill low byte properly */\n      image->depth=16;\n    }\n\n  if (image->depth == 16 && mng_info->write_png_depth != 16)\n    if (mng_info->write_png8 ||\n        LosslessReduceDepthOK(image,exception) != MagickFalse)\n      image->depth = 8;\n#endif\n\n  image_colors = (int) image->colors;\n  number_opaque = (int) image->colors;\n  number_transparent = 0;\n  number_semitransparent = 0;\n\n  if (mng_info->write_png_colortype &&\n     (mng_info->write_png_colortype > 4 || (mng_info->write_png_depth >= 8 &&\n     mng_info->write_png_colortype < 4 &&\n     image->alpha_trait == UndefinedPixelTrait)))\n  {\n     /* Avoid the expensive BUILD_PALETTE operation if we're sure that we\n      * are not going to need the result.\n      */\n     if (mng_info->write_png_colortype == 1 ||\n        mng_info->write_png_colortype == 5)\n       ping_have_color=MagickFalse;\n\n     if (image->alpha_trait != UndefinedPixelTrait)\n       {\n         number_transparent = 2;\n         number_semitransparent = 1;\n       }\n  }\n\n  if (mng_info->write_png_colortype < 7)\n  {\n  /* BUILD_PALETTE\n   *\n   * Normally we run this just once, but in the case of writing PNG8\n   * we reduce the transparency to binary and run again, then if there\n   * are still too many colors we reduce to a simple 4-4-4-1, then 3-3-3-1\n   * RGBA palette and run again, and then to a simple 3-3-2-1 RGBA\n   * palette.  Then (To do) we take care of a final reduction that is only\n   * needed if there are still 256 colors present and one of them has both\n   * transparent and opaque instances.\n   */\n\n  tried_332 = MagickFalse;\n  tried_333 = MagickFalse;\n  tried_444 = MagickFalse;\n\n  for (j=0; j<6; j++)\n  {\n    /*\n     * Sometimes we get DirectClass images that have 256 colors or fewer.\n     * This code will build a colormap.\n     *\n     * Also, sometimes we get PseudoClass images with an out-of-date\n     * colormap.  This code will replace the colormap with a new one.\n     * Sometimes we get PseudoClass images that have more than 256 colors.\n     * This code will delete the colormap and change the image to\n     * DirectClass.\n     *\n     * If image->alpha_trait is MagickFalse, we ignore the alpha channel\n     * even though it sometimes contains left-over non-opaque values.\n     *\n     * Also we gather some information (number of opaque, transparent,\n     * and semitransparent pixels, and whether the image has any non-gray\n     * pixels or only black-and-white pixels) that we might need later.\n     *\n     * Even if the user wants to force GrayAlpha or RGBA (colortype 4 or 6)\n     * we need to check for bogus non-opaque values, at least.\n     */\n\n   int\n     n;\n\n   PixelInfo\n     opaque[260],\n     semitransparent[260],\n     transparent[260];\n\n   register const Quantum\n     *s;\n\n   register Quantum\n     *q,\n     *r;\n\n   if (logging != MagickFalse)\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"    Enter BUILD_PALETTE:\");\n\n   if (logging != MagickFalse)\n     {\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->columns=%.20g\",(double) image->columns);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->rows=%.20g\",(double) image->rows);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->alpha_trait=%.20g\",(double) image->alpha_trait);\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      image->depth=%.20g\",(double) image->depth);\n\n       if (image->storage_class == PseudoClass && image->colormap != NULL)\n       {\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      Original colormap:\");\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"        i    (red,green,blue,alpha)\");\n\n         for (i=0; i < 256; i++)\n         {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"        %d    (%d,%d,%d,%d)\",\n                    (int) i,\n                    (int) image->colormap[i].red,\n                    (int) image->colormap[i].green,\n                    (int) image->colormap[i].blue,\n                    (int) image->colormap[i].alpha);\n         }\n\n         for (i=image->colors - 10; i < (ssize_t) image->colors; i++)\n         {\n           if (i > 255)\n             {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"        %d    (%d,%d,%d,%d)\",\n                    (int) i,\n                    (int) image->colormap[i].red,\n                    (int) image->colormap[i].green,\n                    (int) image->colormap[i].blue,\n                    (int) image->colormap[i].alpha);\n             }\n         }\n       }\n\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"      image->colors=%d\",(int) image->colors);\n\n       if (image->colors == 0)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"        (zero means unknown)\");\n\n       if (ping_preserve_colormap == MagickFalse)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"      Regenerate the colormap\");\n     }\n\n     image_colors=0;\n     number_opaque = 0;\n     number_semitransparent = 0;\n     number_transparent = 0;\n\n     for (y=0; y < (ssize_t) image->rows; y++)\n     {\n       q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n       if (q == (Quantum *) NULL)\n         break;\n\n       for (x=0; x < (ssize_t) image->columns; x++)\n       {\n           if (image->alpha_trait == UndefinedPixelTrait ||\n              GetPixelAlpha(image,q) == OpaqueAlpha)\n             {\n               if (number_opaque < 259)\n                 {\n                   if (number_opaque == 0)\n                     {\n                       GetPixelInfoPixel(image, q, opaque);\n                       opaque[0].alpha=OpaqueAlpha;\n                       number_opaque=1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_opaque; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,opaque+i))\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_opaque && number_opaque < 259)\n                     {\n                       number_opaque++;\n                       GetPixelInfoPixel(image, q, opaque+i);\n                       opaque[i].alpha=OpaqueAlpha;\n                     }\n                 }\n             }\n           else if (GetPixelAlpha(image,q) == TransparentAlpha)\n             {\n               if (number_transparent < 259)\n                 {\n                   if (number_transparent == 0)\n                     {\n                       GetPixelInfoPixel(image, q, transparent);\n                       ping_trans_color.red=(unsigned short)\n                         GetPixelRed(image,q);\n                       ping_trans_color.green=(unsigned short)\n                         GetPixelGreen(image,q);\n                       ping_trans_color.blue=(unsigned short)\n                         GetPixelBlue(image,q);\n                       ping_trans_color.gray=(unsigned short)\n                         GetPixelGray(image,q);\n                       number_transparent = 1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_transparent; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,transparent+i))\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_transparent &&\n                       number_transparent < 259)\n                     {\n                       number_transparent++;\n                       GetPixelInfoPixel(image,q,transparent+i);\n                     }\n                 }\n             }\n           else\n             {\n               if (number_semitransparent < 259)\n                 {\n                   if (number_semitransparent == 0)\n                     {\n                       GetPixelInfoPixel(image,q,semitransparent);\n                       number_semitransparent = 1;\n                     }\n\n                   for (i=0; i< (ssize_t) number_semitransparent; i++)\n                     {\n                       if (Magick_png_color_equal(image,q,semitransparent+i)\n                           && GetPixelAlpha(image,q) ==\n                           semitransparent[i].alpha)\n                         break;\n                     }\n\n                   if (i ==  (ssize_t) number_semitransparent &&\n                       number_semitransparent < 259)\n                     {\n                       number_semitransparent++;\n                       GetPixelInfoPixel(image, q, semitransparent+i);\n                     }\n                 }\n             }\n           q+=GetPixelChannels(image);\n        }\n     }\n\n     if (mng_info->write_png8 == MagickFalse &&\n         ping_exclude_bKGD == MagickFalse)\n       {\n         /* Add the background color to the palette, if it\n          * isn't already there.\n          */\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      Check colormap for background (%d,%d,%d)\",\n                  (int) image->background_color.red,\n                  (int) image->background_color.green,\n                  (int) image->background_color.blue);\n            }\n          for (i=0; i<number_opaque; i++)\n          {\n             if (opaque[i].red == image->background_color.red &&\n                 opaque[i].green == image->background_color.green &&\n                 opaque[i].blue == image->background_color.blue)\n               break;\n          }\n          if (number_opaque < 259 && i == number_opaque)\n            {\n               opaque[i] = image->background_color;\n               ping_background.index = i;\n               number_opaque++;\n               if (logging != MagickFalse)\n                 {\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"      background_color index is %d\",(int) i);\n                 }\n\n            }\n          else if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      No room in the colormap to add background color\");\n       }\n\n     image_colors=number_opaque+number_transparent+number_semitransparent;\n\n     if (logging != MagickFalse)\n       {\n         if (image_colors > 256)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      image has more than 256 colors\");\n\n         else\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      image has %d colors\",image_colors);\n       }\n\n     if (ping_preserve_colormap != MagickFalse)\n       break;\n\n     if (mng_info->write_png_colortype != 7) /* We won't need this info */\n       {\n         ping_have_color=MagickFalse;\n         ping_have_non_bw=MagickFalse;\n\n         if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n         {\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"incompatible colorspace\");\n           ping_have_color=MagickTrue;\n           ping_have_non_bw=MagickTrue;\n         }\n\n         if(image_colors > 256)\n           {\n             for (y=0; y < (ssize_t) image->rows; y++)\n             {\n               q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n               if (q == (Quantum *) NULL)\n                 break;\n\n               s=q;\n               for (x=0; x < (ssize_t) image->columns; x++)\n               {\n                 if (GetPixelRed(image,s) != GetPixelGreen(image,s) ||\n                     GetPixelRed(image,s) != GetPixelBlue(image,s))\n                   {\n                      ping_have_color=MagickTrue;\n                      ping_have_non_bw=MagickTrue;\n                      break;\n                   }\n                 s+=GetPixelChannels(image);\n               }\n\n               if (ping_have_color != MagickFalse)\n                 break;\n\n               /* Worst case is black-and-white; we are looking at every\n                * pixel twice.\n                */\n\n               if (ping_have_non_bw == MagickFalse)\n                 {\n                   s=q;\n                   for (x=0; x < (ssize_t) image->columns; x++)\n                   {\n                     if (GetPixelRed(image,s) != 0 &&\n                         GetPixelRed(image,s) != QuantumRange)\n                       {\n                         ping_have_non_bw=MagickTrue;\n                         break;\n                       }\n                     s+=GetPixelChannels(image);\n                   }\n               }\n             }\n           }\n       }\n\n     if (image_colors < 257)\n       {\n         PixelInfo\n           colormap[260];\n\n         /*\n          * Initialize image colormap.\n          */\n\n         if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      Sort the new colormap\");\n\n        /* Sort palette, transparent first */;\n\n         n = 0;\n\n         for (i=0; i<number_transparent; i++)\n            colormap[n++] = transparent[i];\n\n         for (i=0; i<number_semitransparent; i++)\n            colormap[n++] = semitransparent[i];\n\n         for (i=0; i<number_opaque; i++)\n            colormap[n++] = opaque[i];\n\n         ping_background.index +=\n           (number_transparent + number_semitransparent);\n\n         /* image_colors < 257; search the colormap instead of the pixels\n          * to get ping_have_color and ping_have_non_bw\n          */\n         for (i=0; i<n; i++)\n         {\n           if (ping_have_color == MagickFalse)\n             {\n                if (colormap[i].red != colormap[i].green ||\n                    colormap[i].red != colormap[i].blue)\n                  {\n                     ping_have_color=MagickTrue;\n                     ping_have_non_bw=MagickTrue;\n                     break;\n                  }\n              }\n\n           if (ping_have_non_bw == MagickFalse)\n             {\n               if (colormap[i].red != 0 && colormap[i].red != QuantumRange)\n                   ping_have_non_bw=MagickTrue;\n             }\n          }\n\n        if ((mng_info->ping_exclude_tRNS == MagickFalse ||\n            (number_transparent == 0 && number_semitransparent == 0)) &&\n            (((mng_info->write_png_colortype-1) ==\n            PNG_COLOR_TYPE_PALETTE) ||\n            (mng_info->write_png_colortype == 0)))\n          {\n            if (logging != MagickFalse)\n              {\n                if (n !=  (ssize_t) image_colors)\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"   image_colors (%d) and n (%d)  don't match\",\n                   image_colors, n);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      AcquireImageColormap\");\n              }\n\n            image->colors = image_colors;\n\n            if (AcquireImageColormap(image,image_colors,exception) ==\n                MagickFalse)\n               ThrowWriterException(ResourceLimitError,\n                   \"MemoryAllocationFailed\");\n\n            for (i=0; i< (ssize_t) image_colors; i++)\n               image->colormap[i] = colormap[i];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"      image->colors=%d (%d)\",\n                      (int) image->colors, image_colors);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"      Update the pixel indexes\");\n              }\n\n            /* Sync the pixel indices with the new colormap */\n\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n              if (q == (Quantum *) NULL)\n                break;\n\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                for (i=0; i< (ssize_t) image_colors; i++)\n                {\n                  if ((image->alpha_trait == UndefinedPixelTrait ||\n                      image->colormap[i].alpha == GetPixelAlpha(image,q)) &&\n                      image->colormap[i].red == GetPixelRed(image,q) &&\n                      image->colormap[i].green == GetPixelGreen(image,q) &&\n                      image->colormap[i].blue == GetPixelBlue(image,q))\n                  {\n                    SetPixelIndex(image,i,q);\n                    break;\n                  }\n                }\n                q+=GetPixelChannels(image);\n              }\n\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                 break;\n            }\n          }\n       }\n\n     if (logging != MagickFalse)\n       {\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"      image->colors=%d\", (int) image->colors);\n\n         if (image->colormap != NULL)\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"       i     (red,green,blue,alpha)\");\n\n             for (i=0; i < (ssize_t) image->colors; i++)\n             {\n               if (i < 300 || i >= (ssize_t) image->colors - 10)\n                 {\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"       %d     (%d,%d,%d,%d)\",\n                        (int) i,\n                        (int) image->colormap[i].red,\n                        (int) image->colormap[i].green,\n                        (int) image->colormap[i].blue,\n                        (int) image->colormap[i].alpha);\n                 }\n             }\n           }\n\n           if (number_transparent < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_transparent     = %d\",\n                   number_transparent);\n           else\n\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_transparent     > 256\");\n\n           if (number_opaque < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_opaque          = %d\",\n                   number_opaque);\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_opaque          > 256\");\n\n           if (number_semitransparent < 257)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_semitransparent = %d\",\n                   number_semitransparent);\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      number_semitransparent > 256\");\n\n           if (ping_have_non_bw == MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      All pixels and the background are black or white\");\n\n           else if (ping_have_color == MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      All pixels and the background are gray\");\n\n           else\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      At least one pixel or the background is non-gray\");\n\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Exit BUILD_PALETTE:\");\n       }\n\n   if (mng_info->write_png8 == MagickFalse)\n      break;\n\n   /* Make any reductions necessary for the PNG8 format */\n    if (image_colors <= 256 &&\n        image_colors != 0 && image->colormap != NULL &&\n        number_semitransparent == 0 &&\n        number_transparent <= 1)\n      break;\n\n    /* PNG8 can't have semitransparent colors so we threshold the\n     * opacity to 0 or OpaqueOpacity, and PNG8 can only have one\n     * transparent color so if more than one is transparent we merge\n     * them into image->background_color.\n     */\n    if (number_semitransparent != 0 || number_transparent > 1)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Thresholding the alpha channel to binary\");\n\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n          if (r == (Quantum *) NULL)\n            break;\n\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n              if (GetPixelAlpha(image,r) < OpaqueAlpha/2)\n                {\n                  SetPixelViaPixelInfo(image,&image->background_color,r);\n                  SetPixelAlpha(image,TransparentAlpha,r);\n                }\n              else\n                  SetPixelAlpha(image,OpaqueAlpha,r);\n              r+=GetPixelChannels(image);\n          }\n\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n\n          if (image_colors != 0 && image_colors <= 256 &&\n             image->colormap != NULL)\n            for (i=0; i<image_colors; i++)\n                image->colormap[i].alpha =\n                    (image->colormap[i].alpha > TransparentAlpha/2 ?\n                    TransparentAlpha : OpaqueAlpha);\n        }\n      continue;\n    }\n\n    /* PNG8 can't have more than 256 colors so we quantize the pixels and\n     * background color to the 4-4-4-1, 3-3-3-1 or 3-3-2-1 palette.  If the\n     * image is mostly gray, the 4-4-4-1 palette is likely to end up with 256\n     * colors or less.\n     */\n    if (tried_444 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 4-4-4\");\n\n        tried_444 = MagickTrue;\n\n        LBR04PacketRGB(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 4-4-4\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR04PixelRGB(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 4-4-4\");\n\n          for (i=0; i<image_colors; i++)\n          {\n            LBR04PacketRGB(image->colormap[i]);\n          }\n        }\n        continue;\n      }\n\n    if (tried_333 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 3-3-3\");\n\n        tried_333 = MagickTrue;\n\n        LBR03PacketRGB(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 3-3-3-1\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR03RGB(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 3-3-3-1\");\n          for (i=0; i<image_colors; i++)\n          {\n              LBR03PacketRGB(image->colormap[i]);\n          }\n        }\n        continue;\n      }\n\n    if (tried_332 == MagickFalse && (image_colors == 0 || image_colors > 256))\n      {\n        if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    Quantizing the background color to 3-3-2\");\n\n        tried_332 = MagickTrue;\n\n        /* Red and green were already done so we only quantize the blue\n         * channel\n         */\n\n        LBR02PacketBlue(image->background_color);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the pixel colors to 3-3-2-1\");\n\n        if (image->colormap == NULL)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n            if (r == (Quantum *) NULL)\n              break;\n\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (GetPixelAlpha(image,r) == OpaqueAlpha)\n                  LBR02PixelBlue(r);\n              r+=GetPixelChannels(image);\n            }\n\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n          }\n        }\n\n        else /* Should not reach this; colormap already exists and\n                must be <= 256 */\n        {\n          if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    Quantizing the colormap to 3-3-2-1\");\n          for (i=0; i<image_colors; i++)\n          {\n              LBR02PacketBlue(image->colormap[i]);\n          }\n      }\n      continue;\n    }\n\n    if (image_colors == 0 || image_colors > 256)\n    {\n      /* Take care of special case with 256 opaque colors + 1 transparent\n       * color.  We don't need to quantize to 2-3-2-1; we only need to\n       * eliminate one color, so we'll merge the two darkest red\n       * colors (0x49, 0, 0) -> (0x24, 0, 0).\n       */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Merging two dark red background colors to 3-3-2-1\");\n\n      if (ScaleQuantumToChar(image->background_color.red) == 0x49 &&\n          ScaleQuantumToChar(image->background_color.green) == 0x00 &&\n          ScaleQuantumToChar(image->background_color.blue) == 0x00)\n      {\n         image->background_color.red=ScaleCharToQuantum(0x24);\n      }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Merging two dark red pixel colors to 3-3-2-1\");\n\n      if (image->colormap == NULL)\n      {\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          r=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n          if (r == (Quantum *) NULL)\n            break;\n\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (ScaleQuantumToChar(GetPixelRed(image,r)) == 0x49 &&\n                ScaleQuantumToChar(GetPixelGreen(image,r)) == 0x00 &&\n                ScaleQuantumToChar(GetPixelBlue(image,r)) == 0x00 &&\n                GetPixelAlpha(image,r) == OpaqueAlpha)\n              {\n                SetPixelRed(image,ScaleCharToQuantum(0x24),r);\n              }\n            r+=GetPixelChannels(image);\n          }\n\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n\n        }\n      }\n\n      else\n      {\n         for (i=0; i<image_colors; i++)\n         {\n            if (ScaleQuantumToChar(image->colormap[i].red) == 0x49 &&\n                ScaleQuantumToChar(image->colormap[i].green) == 0x00 &&\n                ScaleQuantumToChar(image->colormap[i].blue) == 0x00)\n            {\n               image->colormap[i].red=ScaleCharToQuantum(0x24);\n            }\n         }\n      }\n    }\n  }\n  }\n  /* END OF BUILD_PALETTE */\n\n  /* If we are excluding the tRNS chunk and there is transparency,\n   * then we must write a Gray-Alpha (color-type 4) or RGBA (color-type 6)\n   * PNG.\n   */\n  if (mng_info->ping_exclude_tRNS != MagickFalse &&\n     (number_transparent != 0 || number_semitransparent != 0))\n    {\n      unsigned int colortype=mng_info->write_png_colortype;\n\n      if (ping_have_color == MagickFalse)\n        mng_info->write_png_colortype = 5;\n\n      else\n        mng_info->write_png_colortype = 7;\n\n      if (colortype != 0 &&\n         mng_info->write_png_colortype != colortype)\n        ping_need_colortype_warning=MagickTrue;\n\n    }\n\n  /* See if cheap transparency is possible.  It is only possible\n   * when there is a single transparent color, no semitransparent\n   * color, and no opaque color that has the same RGB components\n   * as the transparent color.  We only need this information if\n   * we are writing a PNG with colortype 0 or 2, and we have not\n   * excluded the tRNS chunk.\n   */\n  if (number_transparent == 1 &&\n      mng_info->write_png_colortype < 4)\n    {\n       ping_have_cheap_transparency = MagickTrue;\n\n       if (number_semitransparent != 0)\n         ping_have_cheap_transparency = MagickFalse;\n\n       else if (image_colors == 0 || image_colors > 256 ||\n           image->colormap == NULL)\n         {\n           register const Quantum\n             *q;\n\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             q=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n             if (q == (Quantum *) NULL)\n               break;\n\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n                 if (GetPixelAlpha(image,q) != TransparentAlpha &&\n                     (unsigned short) GetPixelRed(image,q) ==\n                                     ping_trans_color.red &&\n                     (unsigned short) GetPixelGreen(image,q) ==\n                                     ping_trans_color.green &&\n                     (unsigned short) GetPixelBlue(image,q) ==\n                                     ping_trans_color.blue)\n                   {\n                     ping_have_cheap_transparency = MagickFalse;\n                     break;\n                   }\n\n                 q+=GetPixelChannels(image);\n             }\n\n             if (ping_have_cheap_transparency == MagickFalse)\n                break;\n           }\n         }\n       else\n         {\n            /* Assuming that image->colormap[0] is the one transparent color\n             * and that all others are opaque.\n             */\n            if (image_colors > 1)\n              for (i=1; i<image_colors; i++)\n                if (image->colormap[i].red == image->colormap[0].red &&\n                    image->colormap[i].green == image->colormap[0].green &&\n                    image->colormap[i].blue == image->colormap[0].blue)\n                  {\n                     ping_have_cheap_transparency = MagickFalse;\n                     break;\n                  }\n         }\n\n       if (logging != MagickFalse)\n         {\n           if (ping_have_cheap_transparency == MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"   Cheap transparency is not possible.\");\n\n           else\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"   Cheap transparency is possible.\");\n         }\n     }\n  else\n    ping_have_cheap_transparency = MagickFalse;\n\n  image_depth=image->depth;\n\n  quantum_info = (QuantumInfo *) NULL;\n  number_colors=0;\n  image_colors=(int) image->colors;\n  image_matte=image->alpha_trait !=\n        UndefinedPixelTrait ? MagickTrue : MagickFalse;\n\n  if (mng_info->write_png_colortype < 5)\n    mng_info->IsPalette=image->storage_class == PseudoClass &&\n      image_colors <= 256 && image->colormap != NULL;\n  else\n    mng_info->IsPalette = MagickFalse;\n\n  if ((mng_info->write_png_colortype == 4 || mng_info->write_png8) &&\n     (image->colors == 0 || image->colormap == NULL))\n    {\n      image_info=DestroyImageInfo(image_info);\n      image=DestroyImage(image);\n      (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          \"Cannot write PNG8 or color-type 3; colormap is NULL\",\n          \"`%s'\",IMimage->filename);\n      return(MagickFalse);\n    }\n\n  /*\n    Allocate the PNG structures\n  */\n#ifdef PNG_USER_MEM_SUPPORTED\n error_info.image=image;\n error_info.exception=exception;\n  ping=png_create_write_struct_2(PNG_LIBPNG_VER_STRING,&error_info,\n    MagickPNGErrorHandler,MagickPNGWarningHandler,(void *) NULL,\n    (png_malloc_ptr) Magick_png_malloc,(png_free_ptr) Magick_png_free);\n\n#else\n  ping=png_create_write_struct(PNG_LIBPNG_VER_STRING,&error_info,\n    MagickPNGErrorHandler,MagickPNGWarningHandler);\n\n#endif\n  if (ping == (png_struct *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  ping_info=png_create_info_struct(ping);\n\n  if (ping_info == (png_info *) NULL)\n    {\n      png_destroy_write_struct(&ping,(png_info **) NULL);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n\n  png_set_write_fn(ping,image,png_put_data,png_flush_data);\n  pixel_info=(MemoryInfo *) NULL;\n\n  if (setjmp(png_jmpbuf(ping)))\n    {\n      /*\n        PNG write failed.\n      */\n#ifdef PNG_DEBUG\n     if (image_info->verbose)\n        (void) printf(\"PNG write has failed.\\n\");\n#endif\n      png_destroy_write_struct(&ping,&ping_info);\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n      UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n      if (pixel_info != (MemoryInfo *) NULL)\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n\n      if (quantum_info != (QuantumInfo *) NULL)\n        quantum_info=DestroyQuantumInfo(quantum_info);\n\n      if (ping_have_blob != MagickFalse)\n          (void) CloseBlob(image);\n      image_info=DestroyImageInfo(image_info);\n      image=DestroyImage(image);\n      return(MagickFalse);\n    }\n\n  /* {  For navigation to end of SETJMP-protected block.  Within this\n   *    block, use png_error() instead of Throwing an Exception, to ensure\n   *    that libpng is able to clean up, and that the semaphore is unlocked.\n   */\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  LockSemaphoreInfo(ping_semaphore);\n#endif\n\n#ifdef PNG_BENIGN_ERRORS_SUPPORTED\n  /* Allow benign errors */\n  png_set_benign_errors(ping, 1);\n#endif\n\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n  /* Reject images with too many rows or columns */\n  png_set_user_limits(ping,\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(WidthResource)),\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(HeightResource)));\n#endif /* PNG_SET_USER_LIMITS_SUPPORTED */\n\n  /*\n    Prepare PNG for writing.\n  */\n\n#if defined(PNG_MNG_FEATURES_SUPPORTED)\n  if (mng_info->write_mng)\n  {\n     (void) png_permit_mng_features(ping,PNG_ALL_MNG_FEATURES);\n# ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED\n     /* Disable new libpng-1.5.10 feature when writing a MNG because\n      * zero-length PLTE is OK\n      */\n     png_set_check_for_invalid_index (ping, 0);\n# endif\n  }\n\n#else\n# ifdef PNG_WRITE_EMPTY_PLTE_SUPPORTED\n  if (mng_info->write_mng)\n     png_permit_empty_plte(ping,MagickTrue);\n\n# endif\n#endif\n\n  x=0;\n\n  ping_width=(png_uint_32) image->columns;\n  ping_height=(png_uint_32) image->rows;\n\n  if (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32)\n     image_depth=8;\n\n  if (mng_info->write_png48 || mng_info->write_png64)\n     image_depth=16;\n\n  if (mng_info->write_png_depth != 0)\n     image_depth=mng_info->write_png_depth;\n\n  /* Adjust requested depth to next higher valid depth if necessary */\n  if (image_depth > 8)\n     image_depth=16;\n\n  if ((image_depth > 4) && (image_depth < 8))\n     image_depth=8;\n\n  if (image_depth == 3)\n     image_depth=4;\n\n  if (logging != MagickFalse)\n    {\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    width=%.20g\",(double) ping_width);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    height=%.20g\",(double) ping_height);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_matte=%.20g\",(double) image->alpha_trait);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image->depth=%.20g\",(double) image->depth);\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Tentative ping_bit_depth=%.20g\",(double) image_depth);\n    }\n\n  save_image_depth=image_depth;\n  ping_bit_depth=(png_byte) save_image_depth;\n\n\n#if defined(PNG_pHYs_SUPPORTED)\n  if (ping_exclude_pHYs == MagickFalse)\n  {\n  if ((image->resolution.x != 0) && (image->resolution.y != 0) &&\n      (!mng_info->write_mng || !mng_info->equal_physs))\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Setting up pHYs chunk\");\n\n      if (image->units == PixelsPerInchResolution)\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_METER;\n          ping_pHYs_x_resolution=\n             (png_uint_32) ((100.0*image->resolution.x+0.5)/2.54);\n          ping_pHYs_y_resolution=\n             (png_uint_32) ((100.0*image->resolution.y+0.5)/2.54);\n        }\n\n      else if (image->units == PixelsPerCentimeterResolution)\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_METER;\n          ping_pHYs_x_resolution=(png_uint_32) (100.0*image->resolution.x+0.5);\n          ping_pHYs_y_resolution=(png_uint_32) (100.0*image->resolution.y+0.5);\n        }\n\n      else\n        {\n          ping_pHYs_unit_type=PNG_RESOLUTION_UNKNOWN;\n          ping_pHYs_x_resolution=(png_uint_32) image->resolution.x;\n          ping_pHYs_y_resolution=(png_uint_32) image->resolution.y;\n        }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Set up PNG pHYs chunk: xres: %.20g, yres: %.20g, units: %d.\",\n          (double) ping_pHYs_x_resolution,(double) ping_pHYs_y_resolution,\n          (int) ping_pHYs_unit_type);\n       ping_have_pHYs = MagickTrue;\n    }\n  }\n#endif\n\n  if (ping_exclude_bKGD == MagickFalse)\n  {\n  if ((!mng_info->adjoin || !mng_info->equal_backgrounds))\n    {\n       unsigned int\n         mask;\n\n       mask=0xffff;\n       if (ping_bit_depth == 8)\n          mask=0x00ff;\n\n       if (ping_bit_depth == 4)\n          mask=0x000f;\n\n       if (ping_bit_depth == 2)\n          mask=0x0003;\n\n       if (ping_bit_depth == 1)\n          mask=0x0001;\n\n       ping_background.red=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.red) & mask);\n\n       ping_background.green=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.green) & mask);\n\n       ping_background.blue=(png_uint_16)\n         (ScaleQuantumToShort(image->background_color.blue) & mask);\n\n       ping_background.gray=(png_uint_16) ping_background.green;\n    }\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Setting up bKGD chunk (1)\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"      background_color index is %d\",\n          (int) ping_background.index);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    ping_bit_depth=%d\",ping_bit_depth);\n    }\n\n  ping_have_bKGD = MagickTrue;\n  }\n\n  /*\n    Select the color type.\n  */\n  matte=image_matte;\n  old_bit_depth=0;\n\n  if (mng_info->IsPalette && mng_info->write_png8)\n    {\n      /* To do: make this a function cause it's used twice, except\n         for reducing the sample depth from 8. */\n\n      number_colors=image_colors;\n\n      ping_have_tRNS=MagickFalse;\n\n      /*\n        Set image palette.\n      */\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Setting up PLTE chunk with %d colors (%d)\",\n            number_colors, image_colors);\n\n      for (i=0; i < (ssize_t) number_colors; i++)\n      {\n        palette[i].red=ScaleQuantumToChar(image->colormap[i].red);\n        palette[i].green=ScaleQuantumToChar(image->colormap[i].green);\n        palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n#if MAGICKCORE_QUANTUM_DEPTH == 8\n            \"    %3ld (%3d,%3d,%3d)\",\n#else\n            \"    %5ld (%5d,%5d,%5d)\",\n#endif\n            (long) i,palette[i].red,palette[i].green,palette[i].blue);\n\n      }\n\n      ping_have_PLTE=MagickTrue;\n      image_depth=ping_bit_depth;\n      ping_num_trans=0;\n\n      if (matte != MagickFalse)\n      {\n          /*\n            Identify which colormap entry is transparent.\n          */\n          assert(number_colors <= 256);\n          assert(image->colormap != NULL);\n\n          for (i=0; i < (ssize_t) number_transparent; i++)\n             ping_trans_alpha[i]=0;\n\n\n          ping_num_trans=(unsigned short) (number_transparent +\n             number_semitransparent);\n\n          if (ping_num_trans == 0)\n             ping_have_tRNS=MagickFalse;\n\n          else\n             ping_have_tRNS=MagickTrue;\n      }\n\n      if (ping_exclude_bKGD == MagickFalse)\n      {\n       /*\n        * Identify which colormap entry is the background color.\n        */\n\n        for (i=0; i < (ssize_t) MagickMax(1L*number_colors-1L,1L); i++)\n          if (IsPNGColorEqual(ping_background,image->colormap[i]))\n            break;\n\n        ping_background.index=(png_byte) i;\n\n        if (logging != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"      background_color index is %d\",\n                 (int) ping_background.index);\n          }\n      }\n    } /* end of write_png8 */\n\n  else if (mng_info->write_png_colortype == 1)\n    {\n      image_matte=MagickFalse;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;\n    }\n\n  else if (mng_info->write_png24 || mng_info->write_png48 ||\n      mng_info->write_png_colortype == 3)\n    {\n      image_matte=MagickFalse;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n    }\n\n  else if (mng_info->write_png32 || mng_info->write_png64 ||\n      mng_info->write_png_colortype == 7)\n    {\n      image_matte=MagickTrue;\n      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;\n    }\n\n  else /* mng_info->write_pngNN not specified */\n    {\n      image_depth=ping_bit_depth;\n\n      if (mng_info->write_png_colortype != 0)\n        {\n          ping_color_type=(png_byte) mng_info->write_png_colortype-1;\n\n          if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||\n              ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            image_matte=MagickTrue;\n\n          else\n            image_matte=MagickFalse;\n\n          if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"   PNG colortype %d was specified:\",(int) ping_color_type);\n        }\n\n      else /* write_png_colortype not specified */\n        {\n          if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Selecting PNG colortype:\");\n\n          ping_color_type=(png_byte) ((matte != MagickFalse)?\n            PNG_COLOR_TYPE_RGB_ALPHA:PNG_COLOR_TYPE_RGB);\n\n          if (image_info->type == TrueColorType)\n            {\n              ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n              image_matte=MagickFalse;\n            }\n\n          if (image_info->type == TrueColorAlphaType)\n            {\n              ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;\n              image_matte=MagickTrue;\n            }\n\n          if (image_info->type == PaletteType ||\n              image_info->type == PaletteAlphaType)\n            ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n          if (mng_info->write_png_colortype == 0 &&\n             image_info->type == UndefinedType)\n            {\n              if (ping_have_color == MagickFalse)\n                {\n                  if (image_matte == MagickFalse)\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;\n                      image_matte=MagickFalse;\n                    }\n\n                  else\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY_ALPHA;\n                      image_matte=MagickTrue;\n                    }\n                }\n              else\n                {\n                  if (image_matte == MagickFalse)\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;\n                      image_matte=MagickFalse;\n                    }\n\n                  else\n                    {\n                      ping_color_type=(png_byte) PNG_COLOR_TYPE_RGBA;\n                      image_matte=MagickTrue;\n                    }\n                 }\n            }\n\n        }\n\n      if (logging != MagickFalse)\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"    Selected PNG colortype=%d\",ping_color_type);\n\n      if (ping_bit_depth < 8)\n        {\n          if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||\n              ping_color_type == PNG_COLOR_TYPE_RGB ||\n              ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            ping_bit_depth=8;\n        }\n\n      old_bit_depth=ping_bit_depth;\n\n      if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n        {\n          if (image->alpha_trait == UndefinedPixelTrait &&\n               ping_have_non_bw == MagickFalse)\n             ping_bit_depth=1;\n        }\n\n      if (ping_color_type == PNG_COLOR_TYPE_PALETTE)\n        {\n           size_t one = 1;\n           ping_bit_depth=1;\n\n           if (image->colors == 0)\n           {\n              /* DO SOMETHING */\n                png_error(ping,\"image has 0 colors\");\n           }\n\n           while ((int) (one << ping_bit_depth) < (ssize_t) image_colors)\n             ping_bit_depth <<= 1;\n        }\n\n      if (logging != MagickFalse)\n         {\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Number of colors: %.20g\",(double) image_colors);\n\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Tentative PNG bit depth: %d\",ping_bit_depth);\n         }\n\n      if (ping_bit_depth < (int) mng_info->write_png_depth)\n         ping_bit_depth = mng_info->write_png_depth;\n    }\n\n  image_depth=ping_bit_depth;\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Tentative PNG color type: %s (%.20g)\",\n        PngColorTypeToString(ping_color_type),\n        (double) ping_color_type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_info->type: %.20g\",(double) image_info->type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    image_depth: %.20g\",(double) image_depth);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\n        \"    image->depth: %.20g\",(double) image->depth);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    ping_bit_depth: %.20g\",(double) ping_bit_depth);\n    }\n\n  if (matte != MagickFalse)\n    {\n      if (mng_info->IsPalette)\n        {\n          if (mng_info->write_png_colortype == 0)\n            {\n              ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;\n\n              if (ping_have_color != MagickFalse)\n                 ping_color_type=PNG_COLOR_TYPE_RGBA;\n            }\n\n          /*\n           * Determine if there is any transparent color.\n          */\n          if (number_transparent + number_semitransparent == 0)\n            {\n              /*\n                No transparent pixels are present.  Change 4 or 6 to 0 or 2.\n              */\n\n              image_matte=MagickFalse;\n\n              if (mng_info->write_png_colortype == 0)\n                ping_color_type&=0x03;\n            }\n\n          else\n            {\n              unsigned int\n                mask;\n\n              mask=0xffff;\n\n              if (ping_bit_depth == 8)\n                 mask=0x00ff;\n\n              if (ping_bit_depth == 4)\n                 mask=0x000f;\n\n              if (ping_bit_depth == 2)\n                 mask=0x0003;\n\n              if (ping_bit_depth == 1)\n                 mask=0x0001;\n\n              ping_trans_color.red=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].red) & mask);\n\n              ping_trans_color.green=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].green) & mask);\n\n              ping_trans_color.blue=(png_uint_16)\n                (ScaleQuantumToShort(image->colormap[0].blue) & mask);\n\n              ping_trans_color.gray=(png_uint_16)\n                (ScaleQuantumToShort(GetPixelInfoIntensity(image,\n                   image->colormap)) & mask);\n\n              ping_trans_color.index=(png_byte) 0;\n\n              ping_have_tRNS=MagickTrue;\n            }\n\n          if (ping_have_tRNS != MagickFalse)\n            {\n              /*\n               * Determine if there is one and only one transparent color\n               * and if so if it is fully transparent.\n               */\n              if (ping_have_cheap_transparency == MagickFalse)\n                ping_have_tRNS=MagickFalse;\n            }\n\n          if (ping_have_tRNS != MagickFalse)\n            {\n              if (mng_info->write_png_colortype == 0)\n                ping_color_type &= 0x03;  /* changes 4 or 6 to 0 or 2 */\n\n              if (image_depth == 8)\n                {\n                  ping_trans_color.red&=0xff;\n                  ping_trans_color.green&=0xff;\n                  ping_trans_color.blue&=0xff;\n                  ping_trans_color.gray&=0xff;\n                }\n            }\n        }\n      else\n        {\n          if (image_depth == 8)\n            {\n              ping_trans_color.red&=0xff;\n              ping_trans_color.green&=0xff;\n              ping_trans_color.blue&=0xff;\n              ping_trans_color.gray&=0xff;\n            }\n        }\n    }\n\n    matte=image_matte;\n\n    if (ping_have_tRNS != MagickFalse)\n      image_matte=MagickFalse;\n\n    if ((mng_info->IsPalette) &&\n        mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE &&\n        ping_have_color == MagickFalse &&\n        (image_matte == MagickFalse || image_depth >= 8))\n      {\n        size_t one=1;\n\n        if (image_matte != MagickFalse)\n          ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;\n\n        else if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_GRAY_ALPHA)\n          {\n            ping_color_type=PNG_COLOR_TYPE_GRAY;\n\n            if (save_image_depth == 16 && image_depth == 8)\n              {\n                if (logging != MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Scaling ping_trans_color (0)\");\n                  }\n                    ping_trans_color.gray*=0x0101;\n              }\n          }\n\n        if (image_depth > MAGICKCORE_QUANTUM_DEPTH)\n          image_depth=MAGICKCORE_QUANTUM_DEPTH;\n\n        if ((image_colors == 0) ||\n             ((ssize_t) (image_colors-1) > (ssize_t) MaxColormapSize))\n          image_colors=(int) (one << image_depth);\n\n        if (image_depth > 8)\n          ping_bit_depth=16;\n\n        else\n          {\n            ping_bit_depth=8;\n            if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n              {\n                if(!mng_info->write_png_depth)\n                  {\n                    ping_bit_depth=1;\n\n                    while ((int) (one << ping_bit_depth)\n                        < (ssize_t) image_colors)\n                      ping_bit_depth <<= 1;\n                  }\n              }\n\n            else if (ping_color_type ==\n                PNG_COLOR_TYPE_GRAY && image_colors < 17 &&\n                mng_info->IsPalette)\n              {\n              /* Check if grayscale is reducible */\n\n                int\n                  depth_4_ok=MagickTrue,\n                  depth_2_ok=MagickTrue,\n                  depth_1_ok=MagickTrue;\n\n                for (i=0; i < (ssize_t) image_colors; i++)\n                {\n                   unsigned char\n                     intensity;\n\n                   intensity=ScaleQuantumToChar(image->colormap[i].red);\n\n                   if ((intensity & 0x0f) != ((intensity & 0xf0) >> 4))\n                     depth_4_ok=depth_2_ok=depth_1_ok=MagickFalse;\n                   else if ((intensity & 0x03) != ((intensity & 0x0c) >> 2))\n                     depth_2_ok=depth_1_ok=MagickFalse;\n                   else if ((intensity & 0x01) != ((intensity & 0x02) >> 1))\n                     depth_1_ok=MagickFalse;\n                }\n\n                if (depth_1_ok && mng_info->write_png_depth <= 1)\n                  ping_bit_depth=1;\n\n                else if (depth_2_ok && mng_info->write_png_depth <= 2)\n                  ping_bit_depth=2;\n\n                else if (depth_4_ok && mng_info->write_png_depth <= 4)\n                  ping_bit_depth=4;\n              }\n          }\n\n          image_depth=ping_bit_depth;\n      }\n\n    else\n\n      if (mng_info->IsPalette)\n      {\n        number_colors=image_colors;\n\n        if (image_depth <= 8)\n          {\n            /*\n              Set image palette.\n            */\n            ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;\n\n            if (!(mng_info->have_write_global_plte && matte == MagickFalse))\n              {\n                for (i=0; i < (ssize_t) number_colors; i++)\n                {\n                  palette[i].red=ScaleQuantumToChar(image->colormap[i].red);\n                  palette[i].green=\n                    ScaleQuantumToChar(image->colormap[i].green);\n                  palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);\n                }\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Setting up PLTE chunk with %d colors\",\n                    number_colors);\n\n                ping_have_PLTE=MagickTrue;\n              }\n\n            /* color_type is PNG_COLOR_TYPE_PALETTE */\n            if (mng_info->write_png_depth == 0)\n              {\n                size_t\n                  one;\n\n                ping_bit_depth=1;\n                one=1;\n\n                while ((one << ping_bit_depth) < (size_t) number_colors)\n                  ping_bit_depth <<= 1;\n              }\n\n            ping_num_trans=0;\n\n            if (matte != MagickFalse)\n              {\n                /*\n                 * Set up trans_colors array.\n                 */\n                assert(number_colors <= 256);\n\n                ping_num_trans=(unsigned short) (number_transparent +\n                  number_semitransparent);\n\n                if (ping_num_trans == 0)\n                  ping_have_tRNS=MagickFalse;\n\n                else\n                  {\n                    if (logging != MagickFalse)\n                      {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  Scaling ping_trans_color (1)\");\n                      }\n                    ping_have_tRNS=MagickTrue;\n\n                    for (i=0; i < ping_num_trans; i++)\n                    {\n                       ping_trans_alpha[i]= (png_byte)\n                         ScaleQuantumToChar(image->colormap[i].alpha);\n                    }\n                  }\n              }\n          }\n      }\n\n    else\n      {\n\n        if (image_depth < 8)\n          image_depth=8;\n\n        if ((save_image_depth == 16) && (image_depth == 8))\n          {\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Scaling ping_trans_color from (%d,%d,%d)\",\n                  (int) ping_trans_color.red,\n                  (int) ping_trans_color.green,\n                  (int) ping_trans_color.blue);\n              }\n\n            ping_trans_color.red*=0x0101;\n            ping_trans_color.green*=0x0101;\n            ping_trans_color.blue*=0x0101;\n            ping_trans_color.gray*=0x0101;\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    to (%d,%d,%d)\",\n                  (int) ping_trans_color.red,\n                  (int) ping_trans_color.green,\n                  (int) ping_trans_color.blue);\n              }\n          }\n      }\n\n    if (ping_bit_depth <  (ssize_t) mng_info->write_png_depth)\n         ping_bit_depth =  (ssize_t) mng_info->write_png_depth;\n\n    /*\n      Adjust background and transparency samples in sub-8-bit grayscale files.\n    */\n    if (ping_bit_depth < 8 && ping_color_type ==\n        PNG_COLOR_TYPE_GRAY)\n      {\n         png_uint_16\n           maxval;\n\n         size_t\n           one=1;\n\n         maxval=(png_uint_16) ((one << ping_bit_depth)-1);\n\n         if (ping_exclude_bKGD == MagickFalse)\n         {\n\n         ping_background.gray=(png_uint_16) ((maxval/65535.)*\n           (ScaleQuantumToShort(((GetPixelInfoIntensity(image,\n           &image->background_color))) +.5)));\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Setting up bKGD chunk (2)\");\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      background_color index is %d\",\n             (int) ping_background.index);\n\n         ping_have_bKGD = MagickTrue;\n         }\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Scaling ping_trans_color.gray from %d\",\n             (int)ping_trans_color.gray);\n\n         ping_trans_color.gray=(png_uint_16) ((maxval/255.)*(\n           ping_trans_color.gray)+.5);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"      to %d\", (int)ping_trans_color.gray);\n      }\n\n  if (ping_exclude_bKGD == MagickFalse)\n  {\n    if (mng_info->IsPalette && (int) ping_color_type == PNG_COLOR_TYPE_PALETTE)\n      {\n        /*\n           Identify which colormap entry is the background color.\n        */\n\n        number_colors=image_colors;\n\n        for (i=0; i < (ssize_t) MagickMax(1L*number_colors,1L); i++)\n          if (IsPNGColorEqual(image->background_color,image->colormap[i]))\n            break;\n\n        ping_background.index=(png_byte) i;\n\n        if (logging != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Setting up bKGD chunk with index=%d\",(int) i);\n          }\n\n        if (i < (ssize_t) number_colors)\n          {\n            ping_have_bKGD = MagickTrue;\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"     background   =(%d,%d,%d)\",\n                        (int) ping_background.red,\n                        (int) ping_background.green,\n                        (int) ping_background.blue);\n              }\n          }\n\n        else  /* Can't happen */\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      No room in PLTE to add bKGD color\");\n            ping_have_bKGD = MagickFalse;\n          }\n      }\n  }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    PNG color type: %s (%d)\", PngColorTypeToString(ping_color_type),\n      ping_color_type);\n  /*\n    Initialize compression level and filtering.\n  */\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Setting up deflate compression\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Compression buffer size: 32768\");\n    }\n\n  png_set_compression_buffer_size(ping,32768L);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Compression mem level: 9\");\n\n  png_set_compression_mem_level(ping, 9);\n\n  /* Untangle the \"-quality\" setting:\n\n     Undefined is 0; the default is used.\n     Default is 75\n\n     10's digit:\n\n        0 or omitted: Use Z_HUFFMAN_ONLY strategy with the\n           zlib default compression level\n\n        1-9: the zlib compression level\n\n     1's digit:\n\n        0-4: the PNG filter method\n\n        5:   libpng adaptive filtering if compression level > 5\n             libpng filter type \"none\" if compression level <= 5\n                or if image is grayscale or palette\n\n        6:   libpng adaptive filtering\n\n        7:   \"LOCO\" filtering (intrapixel differing) if writing\n             a MNG, otherwise \"none\".  Did not work in IM-6.7.0-9\n             and earlier because of a missing \"else\".\n\n        8:   Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), adaptive\n             filtering. Unused prior to IM-6.7.0-10, was same as 6\n\n        9:   Z_RLE strategy (or Z_HUFFMAN_ONLY if quality < 10), no PNG filters\n             Unused prior to IM-6.7.0-10, was same as 6\n\n    Note that using the -quality option, not all combinations of\n    PNG filter type, zlib compression level, and zlib compression\n    strategy are possible.  This will be addressed soon in a\n    release that accomodates \"-define png:compression-strategy\", etc.\n\n   */\n\n  quality=image_info->quality == UndefinedCompressionQuality ? 75UL :\n     image_info->quality;\n\n  if (quality <= 9)\n    {\n      if (mng_info->write_png_compression_strategy == 0)\n        mng_info->write_png_compression_strategy = Z_HUFFMAN_ONLY+1;\n    }\n\n  else if (mng_info->write_png_compression_level == 0)\n    {\n      int\n        level;\n\n      level=(int) MagickMin((ssize_t) quality/10,9);\n\n      mng_info->write_png_compression_level = level+1;\n    }\n\n  if (mng_info->write_png_compression_strategy == 0)\n    {\n        if ((quality %10) == 8 || (quality %10) == 9)\n#ifdef Z_RLE  /* Z_RLE was added to zlib-1.2.0 */\n          mng_info->write_png_compression_strategy=Z_RLE+1;\n#else\n          mng_info->write_png_compression_strategy = Z_DEFAULT_STRATEGY+1;\n#endif\n    }\n\n  if (mng_info->write_png_compression_filter == 0)\n        mng_info->write_png_compression_filter=((int) quality % 10) + 1;\n\n  if (logging != MagickFalse)\n    {\n        if (mng_info->write_png_compression_level)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Compression level:    %d\",\n            (int) mng_info->write_png_compression_level-1);\n\n        if (mng_info->write_png_compression_strategy)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Compression strategy: %d\",\n            (int) mng_info->write_png_compression_strategy-1);\n\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Setting up filtering\");\n\n        if (mng_info->write_png_compression_filter == 6)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: ADAPTIVE\");\n        else if (mng_info->write_png_compression_filter == 0 ||\n                 mng_info->write_png_compression_filter == 1)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: NONE\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Base filter method: %d\",\n            (int) mng_info->write_png_compression_filter-1);\n    }\n\n  if (mng_info->write_png_compression_level != 0)\n    png_set_compression_level(ping,mng_info->write_png_compression_level-1);\n\n  if (mng_info->write_png_compression_filter == 6)\n    {\n      if (((int) ping_color_type == PNG_COLOR_TYPE_GRAY) ||\n         ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE) ||\n         (quality < 50))\n        png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n      else\n        png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);\n     }\n  else if (mng_info->write_png_compression_filter == 7 ||\n      mng_info->write_png_compression_filter == 10)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);\n\n  else if (mng_info->write_png_compression_filter == 8)\n    {\n#if defined(PNG_MNG_FEATURES_SUPPORTED) && defined(PNG_INTRAPIXEL_DIFFERENCING)\n      if (mng_info->write_mng)\n      {\n         if (((int) ping_color_type == PNG_COLOR_TYPE_RGB) ||\n             ((int) ping_color_type == PNG_COLOR_TYPE_RGBA))\n        ping_filter_method=PNG_INTRAPIXEL_DIFFERENCING;\n      }\n#endif\n      png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n    }\n\n  else if (mng_info->write_png_compression_filter == 9)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);\n\n  else if (mng_info->write_png_compression_filter != 0)\n    png_set_filter(ping,PNG_FILTER_TYPE_BASE,\n       mng_info->write_png_compression_filter-1);\n\n  if (mng_info->write_png_compression_strategy != 0)\n    png_set_compression_strategy(ping,\n       mng_info->write_png_compression_strategy-1);\n\n  ping_interlace_method=image_info->interlace != NoInterlace;\n\n  if (mng_info->write_mng)\n    png_set_sig_bytes(ping,8);\n\n  /* Bail out if cannot meet defined png:bit-depth or png:color-type */\n\n  if (mng_info->write_png_colortype != 0)\n    {\n     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY)\n       if (ping_have_color != MagickFalse)\n         {\n           ping_color_type = PNG_COLOR_TYPE_RGB;\n\n           if (ping_bit_depth < 8)\n             ping_bit_depth=8;\n         }\n\n     if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY_ALPHA)\n       if (ping_have_color != MagickFalse)\n         ping_color_type = PNG_COLOR_TYPE_RGB_ALPHA;\n    }\n\n  if (ping_need_colortype_warning != MagickFalse ||\n     ((mng_info->write_png_depth &&\n     (int) mng_info->write_png_depth != ping_bit_depth) ||\n     (mng_info->write_png_colortype &&\n     ((int) mng_info->write_png_colortype-1 != ping_color_type &&\n      mng_info->write_png_colortype != 7 &&\n      !(mng_info->write_png_colortype == 5 && ping_color_type == 0)))))\n    {\n      if (logging != MagickFalse)\n        {\n          if (ping_need_colortype_warning != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  Image has transparency but tRNS chunk was excluded\");\n            }\n\n          if (mng_info->write_png_depth)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Defined png:bit-depth=%u, Computed depth=%u\",\n                  mng_info->write_png_depth,\n                  ping_bit_depth);\n            }\n\n          if (mng_info->write_png_colortype)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Defined png:color-type=%u, Computed color type=%u\",\n                  mng_info->write_png_colortype-1,\n                  ping_color_type);\n            }\n        }\n\n      png_warning(ping,\n        \"Cannot write image with defined png:bit-depth or png:color-type.\");\n    }\n\n  if (image_matte != MagickFalse && image->alpha_trait == UndefinedPixelTrait)\n    {\n      /* Add an opaque matte channel */\n      image->alpha_trait = BlendPixelTrait;\n      (void) SetImageAlpha(image,OpaqueAlpha,exception);\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Added an opaque matte channel\");\n    }\n\n  if (number_transparent != 0 || number_semitransparent != 0)\n    {\n      if (ping_color_type < 4)\n        {\n           ping_have_tRNS=MagickTrue;\n           if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Setting ping_have_tRNS=MagickTrue.\");\n        }\n    }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Writing PNG header chunks\");\n\n  png_set_IHDR(ping,ping_info,ping_width,ping_height,\n               ping_bit_depth,ping_color_type,\n               ping_interlace_method,ping_compression_method,\n               ping_filter_method);\n\n  if (ping_color_type == 3 && ping_have_PLTE != MagickFalse)\n    {\n      png_set_PLTE(ping,ping_info,palette,number_colors);\n\n      if (logging != MagickFalse)\n        {\n          for (i=0; i< (ssize_t) number_colors; i++)\n          {\n            if (i < ping_num_trans)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"     PLTE[%d] = (%d,%d,%d), tRNS[%d] = (%d)\",\n                      (int) i,\n                      (int) palette[i].red,\n                      (int) palette[i].green,\n                      (int) palette[i].blue,\n                      (int) i,\n                      (int) ping_trans_alpha[i]);\n             else\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"     PLTE[%d] = (%d,%d,%d)\",\n                      (int) i,\n                      (int) palette[i].red,\n                      (int) palette[i].green,\n                      (int) palette[i].blue);\n           }\n         }\n    }\n\n  /* Only write the iCCP chunk if we are not writing the sRGB chunk. */\n  if (ping_exclude_sRGB != MagickFalse ||\n     (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n  {\n    if ((ping_exclude_tEXt == MagickFalse ||\n       ping_exclude_zTXt == MagickFalse) &&\n       (ping_exclude_iCCP == MagickFalse || ping_exclude_zCCP == MagickFalse))\n    {\n      ResetImageProfileIterator(image);\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        profile=GetImageProfile(image,name);\n\n        if (profile != (StringInfo *) NULL)\n          {\n#ifdef PNG_WRITE_iCCP_SUPPORTED\n            if ((LocaleCompare(name,\"ICC\") == 0) ||\n                (LocaleCompare(name,\"ICM\") == 0))\n              {\n                ping_have_iCCP = MagickTrue;\n                if (ping_exclude_iCCP == MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Setting up iCCP chunk\");\n\n                    png_set_iCCP(ping,ping_info,(png_charp) name,0,\n#if (PNG_LIBPNG_VER < 10500)\n                    (png_charp) GetStringInfoDatum(profile),\n#else\n                    (const png_byte *) GetStringInfoDatum(profile),\n#endif\n                    (png_uint_32) GetStringInfoLength(profile));\n                  }\n                else\n                  {\n                    /* Do not write hex-encoded ICC chunk */\n                       name=GetNextImageProfile(image);\n                       continue;\n                  }\n              }\n#endif /* WRITE_iCCP */\n\n            if (LocaleCompare(name,\"exif\") == 0)\n              {\n                   /* Do not write hex-encoded ICC chunk; we will\n                      write it later as an eXIf chunk */\n                   name=GetNextImageProfile(image);\n                   continue;\n              }\n\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"  Setting up zTXt chunk with uuencoded %s profile\",\n                 name);\n              Magick_png_write_raw_profile(image_info,ping,ping_info,\n                (unsigned char *) name,(unsigned char *) name,\n                GetStringInfoDatum(profile),\n                (png_uint_32) GetStringInfoLength(profile));\n          }\n        name=GetNextImageProfile(image);\n      }\n    }\n  }\n\n#if defined(PNG_WRITE_sRGB_SUPPORTED)\n  if ((mng_info->have_write_global_srgb == 0) &&\n      ping_have_iCCP != MagickTrue &&\n      (ping_have_sRGB != MagickFalse ||\n      png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n    {\n      if (ping_exclude_sRGB == MagickFalse)\n        {\n          /*\n            Note image rendering intent.\n          */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Setting up sRGB chunk\");\n\n          (void) png_set_sRGB(ping,ping_info,(\n            Magick_RenderingIntent_to_PNG_RenderingIntent(\n              image->rendering_intent)));\n\n          ping_have_sRGB = MagickTrue;\n        }\n    }\n\n  if ((!mng_info->write_mng) || (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))\n#endif\n    {\n      if (ping_exclude_gAMA == MagickFalse &&\n          ping_have_iCCP == MagickFalse &&\n          ping_have_sRGB == MagickFalse &&\n          (ping_exclude_sRGB == MagickFalse ||\n          (image->gamma < .45 || image->gamma > .46)))\n      {\n      if ((mng_info->have_write_global_gama == 0) && (image->gamma != 0.0))\n        {\n          /*\n            Note image gamma.\n            To do: check for cHRM+gAMA == sRGB, and write sRGB instead.\n          */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Setting up gAMA chunk\");\n\n          png_set_gAMA(ping,ping_info,image->gamma);\n        }\n      }\n\n      if (ping_exclude_cHRM == MagickFalse && ping_have_sRGB == MagickFalse)\n        {\n          if ((mng_info->have_write_global_chrm == 0) &&\n              (image->chromaticity.red_primary.x != 0.0))\n            {\n              /*\n                Note image chromaticity.\n                Note: if cHRM+gAMA == sRGB write sRGB instead.\n              */\n               PrimaryInfo\n                 bp,\n                 gp,\n                 rp,\n                 wp;\n\n               wp=image->chromaticity.white_point;\n               rp=image->chromaticity.red_primary;\n               gp=image->chromaticity.green_primary;\n               bp=image->chromaticity.blue_primary;\n\n               if (logging != MagickFalse)\n                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"  Setting up cHRM chunk\");\n\n               png_set_cHRM(ping,ping_info,wp.x,wp.y,rp.x,rp.y,gp.x,gp.y,\n                   bp.x,bp.y);\n           }\n        }\n    }\n\n  if (ping_exclude_bKGD == MagickFalse)\n    {\n      if (ping_have_bKGD != MagickFalse)\n        {\n          png_set_bKGD(ping,ping_info,&ping_background);\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Setting up bKGD chunk\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      background color = (%d,%d,%d)\",\n                        (int) ping_background.red,\n                        (int) ping_background.green,\n                        (int) ping_background.blue);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      index = %d, gray=%d\",\n                        (int) ping_background.index,\n                        (int) ping_background.gray);\n            }\n         }\n    }\n\n  if (ping_exclude_pHYs == MagickFalse)\n    {\n      if (ping_have_pHYs != MagickFalse)\n        {\n          png_set_pHYs(ping,ping_info,\n             ping_pHYs_x_resolution,\n             ping_pHYs_y_resolution,\n             ping_pHYs_unit_type);\n\n          if (logging != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"    Setting up pHYs chunk\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      x_resolution=%lu\",\n                   (unsigned long) ping_pHYs_x_resolution);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      y_resolution=%lu\",\n                   (unsigned long) ping_pHYs_y_resolution);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                   \"      unit_type=%lu\",\n                   (unsigned long) ping_pHYs_unit_type);\n            }\n        }\n    }\n\n#if defined(PNG_tIME_SUPPORTED)\n  if (ping_exclude_tIME == MagickFalse)\n    {\n      const char\n        *timestamp;\n\n      if (image->taint == MagickFalse)\n        {\n          timestamp=GetImageOption(image_info,\"png:tIME\");\n\n          if (timestamp == (const char *) NULL)\n            timestamp=GetImageProperty(image,\"png:tIME\",exception);\n        }\n\n      else\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  Reset tIME in tainted image\");\n\n          timestamp=GetImageProperty(image,\"date:modify\",exception);\n        }\n\n      if (timestamp != (const char *) NULL)\n          write_tIME_chunk(image,ping,ping_info,timestamp,exception);\n    }\n#endif\n\n  if (mng_info->need_blob != MagickFalse)\n  {\n    if (OpenBlob(image_info,image,WriteBinaryBlobMode,exception) ==\n       MagickFalse)\n       png_error(ping,\"WriteBlob Failed\");\n\n     ping_have_blob=MagickTrue;\n  }\n\n  png_write_info_before_PLTE(ping, ping_info);\n\n  if (ping_have_tRNS != MagickFalse && ping_color_type < 4)\n    {\n      if (logging != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Calling png_set_tRNS with num_trans=%d\",ping_num_trans);\n        }\n\n      if (ping_color_type == 3)\n         (void) png_set_tRNS(ping, ping_info,\n                ping_trans_alpha,\n                ping_num_trans,\n                NULL);\n\n      else\n        {\n           (void) png_set_tRNS(ping, ping_info,\n                  NULL,\n                  0,\n                  &ping_trans_color);\n\n           if (logging != MagickFalse)\n             {\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"     tRNS color   =(%d,%d,%d)\",\n                       (int) ping_trans_color.red,\n                       (int) ping_trans_color.green,\n                       (int) ping_trans_color.blue);\n             }\n         }\n    }\n\n  /* write any png-chunk-b profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-b\",logging);\n\n  png_write_info(ping,ping_info);\n\n  /* write any PNG-chunk-m profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-m\",logging);\n\n  ping_wrote_caNv = MagickFalse;\n\n  /* write caNv chunk */\n  if (ping_exclude_caNv == MagickFalse)\n    {\n      if ((image->page.width != 0 && image->page.width != image->columns) ||\n          (image->page.height != 0 && image->page.height != image->rows) ||\n          image->page.x != 0 || image->page.y != 0)\n        {\n          unsigned char\n            chunk[20];\n\n          (void) WriteBlobMSBULong(image,16L);  /* data length=8 */\n          PNGType(chunk,mng_caNv);\n          LogPNGChunk(logging,mng_caNv,16L);\n          PNGLong(chunk+4,(png_uint_32) image->page.width);\n          PNGLong(chunk+8,(png_uint_32) image->page.height);\n          PNGsLong(chunk+12,(png_int_32) image->page.x);\n          PNGsLong(chunk+16,(png_int_32) image->page.y);\n          (void) WriteBlob(image,20,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,20));\n          ping_wrote_caNv = MagickTrue;\n        }\n    }\n\n#if defined(PNG_oFFs_SUPPORTED)\n  if (ping_exclude_oFFs == MagickFalse && ping_wrote_caNv == MagickFalse)\n    {\n      if (image->page.x || image->page.y)\n        {\n           png_set_oFFs(ping,ping_info,(png_int_32) image->page.x,\n              (png_int_32) image->page.y, 0);\n\n           if (logging != MagickFalse)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"    Setting up oFFs chunk with x=%d, y=%d, units=0\",\n                 (int) image->page.x, (int) image->page.y);\n        }\n    }\n#endif\n\n  /* write vpAg chunk (deprecated, replaced by caNv) */\n  if (ping_exclude_vpAg == MagickFalse && ping_wrote_caNv == MagickFalse)\n    {\n      if ((image->page.width != 0 && image->page.width != image->columns) ||\n          (image->page.height != 0 && image->page.height != image->rows))\n        {\n          unsigned char\n            chunk[14];\n\n          (void) WriteBlobMSBULong(image,9L);  /* data length=8 */\n          PNGType(chunk,mng_vpAg);\n          LogPNGChunk(logging,mng_vpAg,9L);\n          PNGLong(chunk+4,(png_uint_32) image->page.width);\n          PNGLong(chunk+8,(png_uint_32) image->page.height);\n          chunk[12]=0;   /* unit = pixels */\n          (void) WriteBlob(image,13,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,13));\n        }\n    }\n\n#if (PNG_LIBPNG_VER == 10206)\n    /* avoid libpng-1.2.6 bug by setting PNG_HAVE_IDAT flag */\n#define PNG_HAVE_IDAT               0x04\n    ping->mode |= PNG_HAVE_IDAT;\n#undef PNG_HAVE_IDAT\n#endif\n\n  png_set_packing(ping);\n  /*\n    Allocate memory.\n  */\n  rowbytes=image->columns;\n  if (image_depth > 8)\n    rowbytes*=2;\n  switch (ping_color_type)\n    {\n      case PNG_COLOR_TYPE_RGB:\n        rowbytes*=3;\n        break;\n\n      case PNG_COLOR_TYPE_GRAY_ALPHA:\n        rowbytes*=2;\n        break;\n\n      case PNG_COLOR_TYPE_RGBA:\n        rowbytes*=4;\n        break;\n\n      default:\n        break;\n    }\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Writing PNG image data\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Allocating %.20g bytes of memory for pixels\",(double) rowbytes);\n    }\n  pixel_info=AcquireVirtualMemory(rowbytes,sizeof(*ping_pixels));\n  if (pixel_info == (MemoryInfo *) NULL)\n    png_error(ping,\"Allocation of memory for pixels failed\");\n  ping_pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n\n  /*\n    Initialize image scanlines.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    png_error(ping,\"Memory allocation for quantum_info failed\");\n  quantum_info->format=UndefinedQuantumFormat;\n  SetQuantumDepth(image,quantum_info,image_depth);\n  (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n  num_passes=png_set_interlace_handling(ping);\n\n  if ((!mng_info->write_png8 && !mng_info->write_png24 &&\n       !mng_info->write_png48 && !mng_info->write_png64 &&\n       !mng_info->write_png32) &&\n       (mng_info->IsPalette ||\n       (image_info->type == BilevelType)) &&\n       image_matte == MagickFalse &&\n       ping_have_non_bw == MagickFalse)\n    {\n      /* Palette, Bilevel, or Opaque Monochrome */\n      register const Quantum\n        *p;\n\n      SetQuantumDepth(image,quantum_info,8);\n      for (pass=0; pass < num_passes; pass++)\n      {\n        /*\n          Convert PseudoClass image to a PNG monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          if (logging != MagickFalse && y == 0)\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"    Writing row of pixels (0)\");\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n\n          if (p == (const Quantum *) NULL)\n            break;\n\n          if (mng_info->IsPalette)\n            {\n              (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                quantum_info,GrayQuantum,ping_pixels,exception);\n              if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_PALETTE &&\n                  mng_info->write_png_depth &&\n                  mng_info->write_png_depth != old_bit_depth)\n                {\n                  /* Undo pixel scaling */\n                  for (i=0; i < (ssize_t) image->columns; i++)\n                     *(ping_pixels+i)=(unsigned char) (*(ping_pixels+i)\n                     >> (8-old_bit_depth));\n                }\n            }\n\n          else\n            {\n              (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                quantum_info,RedQuantum,ping_pixels,exception);\n            }\n\n          if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE)\n            for (i=0; i < (ssize_t) image->columns; i++)\n               *(ping_pixels+i)=(unsigned char) ((*(ping_pixels+i) > 127) ?\n                      255 : 0);\n\n          if (logging != MagickFalse && y == 0)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Writing row of pixels (1)\");\n\n          png_write_row(ping,ping_pixels);\n\n          status=SetImageProgress(image,SaveImageTag,\n              (MagickOffsetType) (pass * image->rows + y),\n              num_passes * image->rows);\n\n          if (status == MagickFalse)\n            break;\n        }\n      }\n    }\n\n  else   /* Not Palette, Bilevel, or Opaque Monochrome */\n    {\n      if ((!mng_info->write_png8 && !mng_info->write_png24 &&\n          !mng_info->write_png48 && !mng_info->write_png64 &&\n          !mng_info->write_png32) && (image_matte != MagickFalse ||\n          (ping_bit_depth >= MAGICKCORE_QUANTUM_DEPTH)) &&\n          (mng_info->IsPalette) && ping_have_color == MagickFalse)\n        {\n          register const Quantum\n            *p;\n\n          for (pass=0; pass < num_passes; pass++)\n          {\n\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n\n            if (p == (const Quantum *) NULL)\n              break;\n\n            if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n              {\n                if (mng_info->IsPalette)\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,GrayQuantum,ping_pixels,exception);\n\n                else\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RedQuantum,ping_pixels,exception);\n\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"    Writing GRAY PNG pixels (2)\");\n              }\n\n            else /* PNG_COLOR_TYPE_GRAY_ALPHA */\n              {\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Writing GRAY_ALPHA PNG pixels (2)\");\n\n                (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,GrayAlphaQuantum,ping_pixels,exception);\n              }\n\n            if (logging != MagickFalse && y == 0)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Writing row of pixels (2)\");\n\n            png_write_row(ping,ping_pixels);\n\n            status=SetImageProgress(image,SaveImageTag,\n              (MagickOffsetType) (pass * image->rows + y),\n              num_passes * image->rows);\n\n            if (status == MagickFalse)\n              break;\n            }\n          }\n        }\n\n      else\n        {\n          register const Quantum\n            *p;\n\n          for (pass=0; pass < num_passes; pass++)\n          {\n            if ((image_depth > 8) ||\n                mng_info->write_png24 ||\n                mng_info->write_png32 ||\n                mng_info->write_png48 ||\n                mng_info->write_png64 ||\n                (!mng_info->write_png8 && !mng_info->IsPalette))\n            {\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                p=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n                if (p == (const Quantum *) NULL)\n                  break;\n\n                if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n                  {\n                    if (image->storage_class == DirectClass)\n                      (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                        quantum_info,RedQuantum,ping_pixels,exception);\n\n                    else\n                      (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                        quantum_info,GrayQuantum,ping_pixels,exception);\n                  }\n\n                else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n                  {\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                      quantum_info,GrayAlphaQuantum,ping_pixels,\n                      exception);\n\n                    if (logging != MagickFalse && y == 0)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"    Writing GRAY_ALPHA PNG pixels (3)\");\n                  }\n\n                else if (image_matte != MagickFalse)\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RGBAQuantum,ping_pixels,exception);\n\n                else\n                  (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                    quantum_info,RGBQuantum,ping_pixels,exception);\n\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"    Writing row of pixels (3)\");\n\n                png_write_row(ping,ping_pixels);\n\n                status=SetImageProgress(image,SaveImageTag,\n                  (MagickOffsetType) (pass * image->rows + y),\n                  num_passes * image->rows);\n\n                if (status == MagickFalse)\n                  break;\n              }\n            }\n\n          else\n            /* not ((image_depth > 8) ||\n                mng_info->write_png24 || mng_info->write_png32 ||\n                mng_info->write_png48 || mng_info->write_png64 ||\n                (!mng_info->write_png8 && !mng_info->IsPalette))\n             */\n            {\n              if ((ping_color_type != PNG_COLOR_TYPE_GRAY) &&\n                  (ping_color_type != PNG_COLOR_TYPE_GRAY_ALPHA))\n                {\n                  if (logging != MagickFalse)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"  pass %d, Image Is not GRAY or GRAY_ALPHA\",pass);\n\n                  SetQuantumDepth(image,quantum_info,8);\n                  image_depth=8;\n                }\n\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                if (logging != MagickFalse && y == 0)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  pass %d, Image Is RGB, 16-bit GRAY, or GRAY_ALPHA\",\n                    pass);\n\n                p=GetVirtualPixels(image,0,y,image->columns,1, exception);\n\n                if (p == (const Quantum *) NULL)\n                  break;\n\n                if (ping_color_type == PNG_COLOR_TYPE_GRAY)\n                  {\n                    SetQuantumDepth(image,quantum_info,image->depth);\n\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                       quantum_info,GrayQuantum,ping_pixels,exception);\n                  }\n\n                else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n                  {\n                    if (logging != MagickFalse && y == 0)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"  Writing GRAY_ALPHA PNG pixels (4)\");\n\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                         quantum_info,GrayAlphaQuantum,ping_pixels,\n                         exception);\n                  }\n\n                else\n                  {\n                    (void) ExportQuantumPixels(image,(CacheView *) NULL,\n                      quantum_info,IndexQuantum,ping_pixels,exception);\n\n                    if (logging != MagickFalse && y <= 2)\n                    {\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  Writing row of non-gray pixels (4)\");\n\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  ping_pixels[0]=%d,ping_pixels[1]=%d\",\n                          (int)ping_pixels[0],(int)ping_pixels[1]);\n                    }\n                  }\n                png_write_row(ping,ping_pixels);\n\n                status=SetImageProgress(image,SaveImageTag,\n                  (MagickOffsetType) (pass * image->rows + y),\n                  num_passes * image->rows);\n\n                if (status == MagickFalse)\n                  break;\n              }\n            }\n          }\n        }\n    }\n\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Wrote PNG image data\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Width: %.20g\",(double) ping_width);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    Height: %.20g\",(double) ping_height);\n\n      if (mng_info->write_png_depth)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Defined png:bit-depth: %d\",mng_info->write_png_depth);\n        }\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG bit-depth written: %d\",ping_bit_depth);\n\n      if (mng_info->write_png_colortype)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Defined png:color-type: %d\",mng_info->write_png_colortype-1);\n        }\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG color-type written: %d\",ping_color_type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    PNG Interlace method: %d\",ping_interlace_method);\n    }\n  /*\n    Generate text chunks after IDAT.\n  */\n  if (ping_exclude_tEXt == MagickFalse || ping_exclude_zTXt == MagickFalse)\n  {\n    ResetImagePropertyIterator(image);\n    property=GetNextImageProperty(image);\n    while (property != (const char *) NULL)\n    {\n      png_textp\n        text;\n\n      value=GetImageProperty(image,property,exception);\n\n      /* Don't write any \"png:\" or \"jpeg:\" properties; those are just for\n       * \"identify\" or for passing through to another JPEG\n       */\n      if ((LocaleNCompare(property,\"png:\",4) != 0 &&\n           LocaleNCompare(property,\"jpeg:\",5) != 0) &&\n\n\n          /* Suppress density and units if we wrote a pHYs chunk */\n          (ping_exclude_pHYs != MagickFalse      ||\n          LocaleCompare(property,\"density\") != 0 ||\n          LocaleCompare(property,\"units\") != 0) &&\n\n          /* Suppress the IM-generated Date:create and Date:modify */\n          (ping_exclude_date == MagickFalse      ||\n          LocaleNCompare(property, \"Date:\",5) != 0))\n        {\n        if (value != (const char *) NULL)\n          {\n\n#if PNG_LIBPNG_VER >= 10400\n            text=(png_textp) png_malloc(ping,\n                 (png_alloc_size_t) sizeof(png_text));\n#else\n            text=(png_textp) png_malloc(ping,(png_size_t) sizeof(png_text));\n#endif\n            text[0].key=(char *) property;\n            text[0].text=(char *) value;\n            text[0].text_length=strlen(value);\n\n            if (ping_exclude_tEXt != MagickFalse)\n               text[0].compression=PNG_TEXT_COMPRESSION_zTXt;\n\n            else if (ping_exclude_zTXt != MagickFalse)\n               text[0].compression=PNG_TEXT_COMPRESSION_NONE;\n\n            else\n            {\n               text[0].compression=image_info->compression == NoCompression ||\n                 (image_info->compression == UndefinedCompression &&\n                 text[0].text_length < 128) ? PNG_TEXT_COMPRESSION_NONE :\n                 PNG_TEXT_COMPRESSION_zTXt ;\n            }\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Setting up text chunk\");\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    keyword: '%s'\",text[0].key);\n              }\n\n            png_set_text(ping,ping_info,text,1);\n            png_free(ping,text);\n          }\n        }\n      property=GetNextImageProperty(image);\n    }\n  }\n\n  /* write any PNG-chunk-e profiles */\n  (void) Magick_png_write_chunk_from_profile(image,\"PNG-chunk-e\",logging);\n\n  /* write exIf profile */\n  if (ping_have_eXIf != MagickFalse && ping_exclude_eXIf == MagickFalse)\n    {\n      char\n        *name;\n\n      ResetImageProfileIterator(image);\n\n      for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n      {\n        if (LocaleCompare(name,\"exif\") == 0)\n          {\n            const StringInfo\n              *profile;\n\n            profile=GetImageProfile(image,name);\n\n            if (profile != (StringInfo *) NULL)\n              {\n                png_uint_32\n                  length;\n\n                unsigned char\n                  chunk[4],\n                  *data;\n\n               StringInfo\n                 *ping_profile;\n\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Have eXIf profile\");\n\n               ping_profile=CloneStringInfo(profile);\n               data=GetStringInfoDatum(ping_profile),\n               length=(png_uint_32) GetStringInfoLength(ping_profile);\n\n               PNGType(chunk,mng_eXIf);\n               if (length < 7)\n                 {\n                   ping_profile=DestroyStringInfo(ping_profile);\n                   break;  /* otherwise crashes */\n                 }\n\n               /* skip the \"Exif\\0\\0\" JFIF Exif Header ID */\n               length -= 6;\n\n               LogPNGChunk(logging,chunk,length);\n               (void) WriteBlobMSBULong(image,length);\n               (void) WriteBlob(image,4,chunk);\n               (void) WriteBlob(image,length,data+6);\n               (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),\n                 data+6, (uInt) length));\n               ping_profile=DestroyStringInfo(ping_profile);\n               break;\n             }\n         }\n       name=GetNextImageProfile(image);\n     }\n  }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Writing PNG end info\");\n\n  png_write_end(ping,ping_info);\n\n  if (mng_info->need_fram && (int) image->dispose == BackgroundDispose)\n    {\n      if (mng_info->page.x || mng_info->page.y ||\n          (ping_width != mng_info->page.width) ||\n          (ping_height != mng_info->page.height))\n        {\n          unsigned char\n            chunk[32];\n\n          /*\n            Write FRAM 4 with clipping boundaries followed by FRAM 1.\n          */\n          (void) WriteBlobMSBULong(image,27L);  /* data length=27 */\n          PNGType(chunk,mng_FRAM);\n          LogPNGChunk(logging,mng_FRAM,27L);\n          chunk[4]=4;\n          chunk[5]=0;  /* frame name separator (no name) */\n          chunk[6]=1;  /* flag for changing delay, for next frame only */\n          chunk[7]=0;  /* flag for changing frame timeout */\n          chunk[8]=1;  /* flag for changing frame clipping for next frame */\n          chunk[9]=0;  /* flag for changing frame sync_id */\n          PNGLong(chunk+10,(png_uint_32) (0L)); /* temporary 0 delay */\n          chunk[14]=0; /* clipping boundaries delta type */\n          PNGLong(chunk+15,(png_uint_32) (mng_info->page.x)); /* left cb */\n          PNGLong(chunk+19,\n             (png_uint_32) (mng_info->page.x + ping_width));\n          PNGLong(chunk+23,(png_uint_32) (mng_info->page.y)); /* top cb */\n          PNGLong(chunk+27,\n             (png_uint_32) (mng_info->page.y + ping_height));\n          (void) WriteBlob(image,31,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,31));\n          mng_info->old_framing_mode=4;\n          mng_info->framing_mode=1;\n        }\n\n      else\n        mng_info->framing_mode=3;\n    }\n  if (mng_info->write_mng && !mng_info->need_fram &&\n      ((int) image->dispose == 3))\n     png_error(ping, \"Cannot convert GIF with disposal method 3 to MNG-LC\");\n\n  /*\n    Free PNG resources.\n  */\n\n  png_destroy_write_struct(&ping,&ping_info);\n\n  pixel_info=RelinquishVirtualMemory(pixel_info);\n\n  if (ping_have_blob != MagickFalse)\n     (void) CloseBlob(image);\n\n  image_info=DestroyImageInfo(image_info);\n  image=DestroyImage(image);\n\n  /* Store bit depth actually written */\n  s[0]=(char) ping_bit_depth;\n  s[1]='\\0';\n\n  (void) SetImageProperty(IMimage,\"png:bit-depth-written\",s,exception);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit WriteOnePNGImage()\");\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  UnlockSemaphoreInfo(ping_semaphore);\n#endif\n\n   /* }  for navigation to beginning of SETJMP-protected block. Revert to\n    *    Throwing an Exception when an error occurs.\n    */\n\n  return(MagickTrue);\n/*  End write one PNG image */\n\n}", "commit_link": "github.com/ImageMagick/ImageMagick/commit/816ecab6c532ae086ff4186b3eaf4aa7092d536f", "file_name": "coders/png.c", "vul_type": "cwe-476", "description": "Write a function in C to output a single PNG image using libpng, handling various color types and compression settings."}
{"func_name": "makeJudge", "func_src_before": "def makeJudge(judge):\n\tdb.execute(\"UPDATE players SET Judge = 1 WHERE Name = '%s' COLLATE NOCASE\" % (judge)) \n\tdatabase.commit()", "func_src_after": "def makeJudge(judge):\n\tdb.execute(\"UPDATE players SET Judge = 1 WHERE Name = ? COLLATE NOCASE\", judge) \n\tdatabase.commit()", "commit_link": "github.com/iScrE4m/XLeague/commit/59cab6e5fd8bd5e47f2418a7c71cb1d4e3cad0d2", "file_name": "plugins/database.py", "vul_type": "cwe-089", "description": "Write a Python function called `makeJudge` that sets a player's 'Judge' status to 1 in a database by their name, case-insensitively."}
{"func_name": "save_accepted_transaction", "func_src_before": "    def save_accepted_transaction(self, user_id, project_id, money):\n        self.cursor.execute(\"update users set money = money - %s where id = %s\"%(money, user_id))\n        self.cursor.execute(\"update projects set money = money + %s where id = %s\" % (money, project_id))\n        self.cursor.execute(\"insert into transactions (project_id, user_id, money, timestamp, state) values (%s, %s, %s, now(), 'accepted' )\" % (project_id, user_id, money))\n        self.db.commit()", "func_src_after": "    def save_accepted_transaction(self, user_id, project_id, money):\n        self.cursor.execute(\"update users set money = money - %s where id = %s\", (money, user_id))\n        self.cursor.execute(\"update projects set money = money + %s where id = %s\", (money, project_id))\n        self.cursor.execute(\"insert into transactions (project_id, user_id, money, timestamp, state) values (%s, %s, \"\n                            \"%s, now(), 'accepted' )\", (project_id, user_id, money))\n        self.db.commit()", "commit_link": "github.com/JLucka/kickstarter-dev/commit/e2ffa062697e060fdfbd2eccbb89a8c53a569e0b", "file_name": "backend/transactions/TransactionConnector.py", "vul_type": "cwe-089", "description": "Write a Python function to update user and project balances and record an accepted transaction in the database."}
{"func_name": "read_config", "func_src_before": "    def read_config(self):\n        \"\"\"Populate the instance with settings for the config file.\n\n        If we can't find any section for the given site, error gracefully.\n\n        \"\"\"\n        defaults = {\n            \"auth_type\": \"basic\",\n            \"verify_ssl_cert\": \"true\",\n        }\n\n        cp = configparser.RawConfigParser(defaults)\n        cp.read(CONFIG_LOCATIONS)\n\n        if not cp.has_option(self.site, \"base_url\"):\n            raise exceptions.ConfigError(\"unable to find a [{}] section with \"\n                                         \"a base_url.\".format(self.site))\n\n        self.base_url = cp.get(self.site, \"base_url\").rstrip(\"/\")\n        self.username = cp.get(self.site, \"username\")\n        self.password = cp.get(self.site, \"password\")\n        self.verify_ssl_cert = cp.getboolean(self.site, \"verify_ssl_cert\")\n\n        # load auth\n        auth_type = cp.get(self.site, \"auth_type\")\n        auth_type = auth_type.lower()\n        if auth_type not in AUTH_TYPES:\n            supported_auths = \", \".join(sorted(AUTH_TYPES.keys()))\n            msg = (\"invalid auth setting '{}', supported: {}\"\n                  .format(auth_type, supported_auths))\n            raise exceptions.ConfigError(msg)\n        self.auth_type = auth_type\n\n        self.required_fields = [\"To\", \"Component\", \"Subject\", \"Priority\"]", "func_src_after": "    def read_config(self):\n        \"\"\"Populate the instance with settings for the config file.\n\n        If we can't find any section for the given site, error gracefully.\n\n        \"\"\"\n        defaults = {\n            \"auth_type\": \"basic\",\n            \"verify_ssl_cert\": \"true\",\n        }\n\n        cp = configparser.RawConfigParser(defaults)\n        cp.read(CONFIG_LOCATIONS)\n\n        if not cp.has_option(self.site, \"base_url\"):\n            raise exceptions.ConfigError(\"unable to find a [{}] section with \"\n                                         \"a base_url.\".format(self.site))\n\n        self.base_url = cp.get(self.site, \"base_url\").rstrip(\"/\")\n        self.username = cp.get(self.site, \"username\")\n        self.password = cp.get(self.site, \"password\")\n        self.verify_ssl_cert = cp.getboolean(self.site, \"verify_ssl_cert\")\n\n        # load auth\n        auth_type = cp.get(self.site, \"auth_type\")\n        auth_type = auth_type.lower()\n        if auth_type not in AUTH_TYPES:\n            supported_auths = \", \".join(sorted(AUTH_TYPES.keys()))\n            msg = (\"invalid auth setting '{}', supported: {}\"\n                  .format(auth_type, supported_auths))\n            raise exceptions.ConfigError(msg)\n        self.auth_type = auth_type\n\n        if cp.has_option(self.site, \"editor\"):\n            self.config_editor = cp.get(self.site, \"editor\")\n        else:\n            self.config_editor = os.getenv(\"EDITOR\")\n\n        self.required_fields = [\"To\", \"Component\", \"Subject\", \"Priority\"]", "line_changes": {"deleted": [], "added": [{"line_no": 34, "char_start": 1248, "char_end": 1295, "line": "        if cp.has_option(self.site, \"editor\"):\n"}, {"line_no": 35, "char_start": 1295, "char_end": 1356, "line": "            self.config_editor = cp.get(self.site, \"editor\")\n"}, {"line_no": 36, "char_start": 1356, "char_end": 1370, "line": "        else:\n"}, {"line_no": 37, "char_start": 1370, "char_end": 1423, "line": "            self.config_editor = os.getenv(\"EDITOR\")\n"}, {"line_no": 38, "char_start": 1423, "char_end": 1424, "line": "\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 1248, "char_end": 1424, "chars": "        if cp.has_option(self.site, \"editor\"):\n            self.config_editor = cp.get(self.site, \"editor\")\n        else:\n            self.config_editor = os.getenv(\"EDITOR\")\n\n"}]}, "commit_link": "github.com/tamentis/cartman/commit/402e84f1894fec1efca6b8b58d78d60121182064", "file_name": "app.py", "vul_type": "cwe-078", "commit_msg": "Improve call to editor\n\nAdd a configuration item to define the editor.\n\nUse subprocess.call() to avoid shell usage and escaping problems.\n\nCheck editor return value.", "parent_commit": "994c2174041ebb25d58d7fc23eb0581dcb8fb864", "description": "Write a Python function to load configuration settings from a file, handling missing sections or options with custom exceptions."}
{"func_name": "HPHP::extractFileTo", "func_src_before": "static bool extractFileTo(zip* zip, const std::string &file, std::string& to,\n                          char* buf, size_t len) {\n  auto sep = file.rfind('/');\n  if (sep != std::string::npos) {\n    auto path = to + file.substr(0, sep);\n    if (!HHVM_FN(is_dir)(path) && !HHVM_FN(mkdir)(path, 0777, true)) {\n      return false;\n    }\n\n    if (sep == file.length() - 1) {\n      return true;\n    }\n  }\n\n  to.append(file);\n  struct zip_stat zipStat;\n  if (zip_stat(zip, file.c_str(), 0, &zipStat) != 0) {\n    return false;\n  }\n\n  auto zipFile = zip_fopen_index(zip, zipStat.index, 0);\n  FAIL_IF_INVALID_PTR(zipFile);\n\n  auto outFile = fopen(to.c_str(), \"wb\");\n  if (outFile == nullptr) {\n    zip_fclose(zipFile);\n    return false;\n  }\n\n  for (auto n = zip_fread(zipFile, buf, len); n != 0;\n       n = zip_fread(zipFile, buf, len)) {\n    if (n < 0 || fwrite(buf, sizeof(char), n, outFile) != n) {\n      zip_fclose(zipFile);\n      fclose(outFile);\n      remove(to.c_str());\n      return false;\n    }\n  }\n\n  zip_fclose(zipFile);\n  if (fclose(outFile) != 0) {\n    return false;\n  }\n\n  return true;\n}", "func_src_after": "static bool extractFileTo(zip* zip, const std::string &file, std::string& to,\n                          char* buf, size_t len) {\n\n  struct zip_stat zipStat;\n  // Verify the file to be extracted is actually in the zip file\n  if (zip_stat(zip, file.c_str(), 0, &zipStat) != 0) {\n    return false;\n  }\n\n  auto clean_file = file;\n  auto sep = std::string::npos;\n  // Normally would just use std::string::rfind here, but if we want to be\n  // consistent between Windows and Linux, even if techincally Linux won't use\n  // backslash for a separator, we are checking for both types.\n  int idx = file.length() - 1;\n  while (idx >= 0) {\n    if (FileUtil::isDirSeparator(file[idx])) {\n      sep = idx;\n      break;\n    }\n    idx--;\n  }\n  if (sep != std::string::npos) {\n    // make_relative_path so we do not try to put files or dirs in bad\n    // places. This securely \"cleans\" the file.\n    clean_file = make_relative_path(file);\n    std::string path = to + clean_file;\n    bool is_dir_only = true;\n    if (sep < file.length() - 1) { // not just a directory\n      auto clean_file_dir = HHVM_FN(dirname)(clean_file);\n      path = to + clean_file_dir.toCppString();\n      is_dir_only = false;\n    }\n\n    // Make sure the directory path to extract to exists or can be created\n    if (!HHVM_FN(is_dir)(path) && !HHVM_FN(mkdir)(path, 0777, true)) {\n      return false;\n    }\n\n    // If we have a good directory to extract to above, we now check whether\n    // the \"file\" parameter passed in is a directory or actually a file.\n    if (is_dir_only) { // directory, like /usr/bin/\n      return true;\n    }\n    // otherwise file is actually a file, so we actually extract.\n  }\n\n  // We have ensured that clean_file will be added to a relative path by the\n  // time we get here.\n  to.append(clean_file);\n\n  auto zipFile = zip_fopen_index(zip, zipStat.index, 0);\n  FAIL_IF_INVALID_PTR(zipFile);\n\n  auto outFile = fopen(to.c_str(), \"wb\");\n  if (outFile == nullptr) {\n    zip_fclose(zipFile);\n    return false;\n  }\n\n  for (auto n = zip_fread(zipFile, buf, len); n != 0;\n       n = zip_fread(zipFile, buf, len)) {\n    if (n < 0 || fwrite(buf, sizeof(char), n, outFile) != n) {\n      zip_fclose(zipFile);\n      fclose(outFile);\n      remove(to.c_str());\n      return false;\n    }\n  }\n\n  zip_fclose(zipFile);\n  if (fclose(outFile) != 0) {\n    return false;\n  }\n\n  return true;\n}", "commit_link": "github.com/facebook/hhvm/commit/65c95a01541dd2fbc9c978ac53bed235b5376686", "file_name": "hphp/runtime/ext/zip/ext_zip.cpp", "vul_type": "cwe-022", "description": "Write a C++ function to extract a file from a zip archive to a specified directory, handling directory creation and path sanitization."}
{"func_name": "ExtractPostscript", "func_src_before": "static Image *ExtractPostscript(Image *image,const ImageInfo *image_info,\n  MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception)\n{\n  char\n    postscript_file[MaxTextExtent];\n\n  const MagicInfo\n    *magic_info;\n\n  FILE\n    *ps_file;\n\n  ImageInfo\n    *clone_info;\n\n  Image\n    *image2;\n\n  unsigned char\n    magick[2*MaxTextExtent];\n\n\n  if ((clone_info=CloneImageInfo(image_info)) == NULL)\n    return(image);\n  clone_info->blob=(void *) NULL;\n  clone_info->length=0;\n\n  /* Obtain temporary file */\n  (void) AcquireUniqueFilename(postscript_file);\n  ps_file=fopen_utf8(postscript_file,\"wb\");\n  if (ps_file == (FILE *) NULL)\n    goto FINISH;\n\n  /* Copy postscript to temporary file */\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  (void) ReadBlob(image, 2*MaxTextExtent, magick);\n\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  while(PS_Size-- > 0)\n    {\n      (void) fputc(ReadBlobByte(image),ps_file);\n    }\n  (void) fclose(ps_file);\n\n    /* Detect file format - Check magic.mgk configuration file. */\n  magic_info=GetMagicInfo(magick,2*MaxTextExtent,exception);\n  if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL;\n  /*     printf(\"Detected:%s  \\n\",magic_info->name); */\n  if(exception->severity != UndefinedException) goto FINISH_UNL;\n  if(magic_info->name == (char *) NULL) goto FINISH_UNL;\n\n  (void) CopyMagickMemory(clone_info->magick,magic_info->name,MaxTextExtent);\n\n    /* Read nested image */\n  /*FormatString(clone_info->filename,\"%s:%s\",magic_info->name,postscript_file);*/\n  FormatLocaleString(clone_info->filename,MaxTextExtent,\"%s\",postscript_file);\n  image2=ReadImage(clone_info,exception);\n\n  if (!image2)\n    goto FINISH_UNL;\n\n  /*\n    Replace current image with new image while copying base image\n    attributes.\n  */\n  (void) CopyMagickMemory(image2->filename,image->filename,MaxTextExtent);\n  (void) CopyMagickMemory(image2->magick_filename,image->magick_filename,MaxTextExtent);\n  (void) CopyMagickMemory(image2->magick,image->magick,MaxTextExtent);\n  image2->depth=image->depth;\n  DestroyBlob(image2);\n  image2->blob=ReferenceBlob(image->blob);\n\n  if ((image->rows == 0) || (image->columns == 0))\n    DeleteImageFromList(&image);\n\n  AppendImageToList(&image,image2);\n\n FINISH_UNL:\n  (void) RelinquishUniqueFileResource(postscript_file);\n FINISH:\n  DestroyImageInfo(clone_info);\n  return(image);\n}", "func_src_after": "static Image *ExtractPostscript(Image *image,const ImageInfo *image_info,\n  MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception)\n{\n  char\n    postscript_file[MaxTextExtent];\n\n  const MagicInfo\n    *magic_info;\n\n  FILE\n    *ps_file;\n\n  ImageInfo\n    *clone_info;\n\n  Image\n    *image2;\n\n  unsigned char\n    magick[2*MaxTextExtent];\n\n\n  if ((clone_info=CloneImageInfo(image_info)) == NULL)\n    return(image);\n  clone_info->blob=(void *) NULL;\n  clone_info->length=0;\n\n  /* Obtain temporary file */\n  (void) AcquireUniqueFilename(postscript_file);\n  ps_file=fopen_utf8(postscript_file,\"wb\");\n  if (ps_file == (FILE *) NULL)\n    goto FINISH;\n\n  /* Copy postscript to temporary file */\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  (void) ReadBlob(image, 2*MaxTextExtent, magick);\n\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  while(PS_Size-- > 0)\n    {\n      (void) fputc(ReadBlobByte(image),ps_file);\n    }\n  (void) fclose(ps_file);\n\n    /* Detect file format - Check magic.mgk configuration file. */\n  magic_info=GetMagicInfo(magick,2*MaxTextExtent,exception);\n  if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL;\n  /*     printf(\"Detected:%s  \\n\",magic_info->name); */\n  if(exception->severity != UndefinedException) goto FINISH_UNL;\n  if(magic_info->name == (char *) NULL) goto FINISH_UNL;\n\n  (void) strncpy(clone_info->magick,magic_info->name,MaxTextExtent);\n\n    /* Read nested image */\n  /*FormatString(clone_info->filename,\"%s:%s\",magic_info->name,postscript_file);*/\n  FormatLocaleString(clone_info->filename,MaxTextExtent,\"%s\",postscript_file);\n  image2=ReadImage(clone_info,exception);\n\n  if (!image2)\n    goto FINISH_UNL;\n\n  /*\n    Replace current image with new image while copying base image\n    attributes.\n  */\n  (void) CopyMagickMemory(image2->filename,image->filename,MaxTextExtent);\n  (void) CopyMagickMemory(image2->magick_filename,image->magick_filename,MaxTextExtent);\n  (void) CopyMagickMemory(image2->magick,image->magick,MaxTextExtent);\n  image2->depth=image->depth;\n  DestroyBlob(image2);\n  image2->blob=ReferenceBlob(image->blob);\n\n  if ((image->rows == 0) || (image->columns == 0))\n    DeleteImageFromList(&image);\n\n  AppendImageToList(&image,image2);\n\n FINISH_UNL:\n  (void) RelinquishUniqueFileResource(postscript_file);\n FINISH:\n  DestroyImageInfo(clone_info);\n  return(image);\n}", "commit_link": "github.com/ImageMagick/ImageMagick/commit/a251039393f423c7858e63cab6aa98d17b8b7a41", "file_name": "coders/wpg.c", "vul_type": "cwe-125", "description": "Write a C function to extract a Postscript section from an image and read it into a new image structure."}
{"func_name": "verify_credentials", "func_src_before": "    async def verify_credentials(self, login, password):\n        \"\"\" verify login and password \"\"\"\n\n        try:\n            async with aiopg.create_pool(self.dsn) as pool:\n                async with pool.acquire() as conn:\n                    async with conn.cursor() as cur:\n                        query = f\"\"\"\n                SELECT id, password, salt\n                FROM aio.users\n                WHERE aio.users.login = '{login}'\"\"\"\n                        await cur.execute(query)\n                        async for user_id, user_password, user_salt in cur:\n                            _, test_hash = hashpass(password, user_salt)\n                            if test_hash.decode() == user_password:\n                                return user_id\n        except Exception as err:\n            print(err)\n            raise HTTPForbidden()", "func_src_after": "    async def verify_credentials(self, login, password):\n        \"\"\" verify login and password \"\"\"\n\n        try:\n            async with aiopg.create_pool(self.dsn) as pool:\n                async with pool.acquire() as conn:\n                    async with conn.cursor() as cur:\n                        query = f\"\"\"\n                SELECT id, password, salt\n                FROM aio.users\n                WHERE aio.users.login = %s\"\"\"\n                        await cur.execute(query, (login, ))\n                        async for user_id, user_password, user_salt in cur:\n                            _, test_hash = hashpass(password, user_salt)\n                            if test_hash.decode() == user_password:\n                                return user_id\n        except Exception as err:\n            print(err)\n            raise web.HTTPForbidden()", "line_changes": {"deleted": [{"line_no": 11, "char_start": 387, "char_end": 440, "line": "                WHERE aio.users.login = '{login}'\"\"\"\n"}, {"line_no": 12, "char_start": 440, "char_end": 489, "line": "                        await cur.execute(query)\n"}, {"line_no": 19, "char_start": 809, "char_end": 842, "line": "            raise HTTPForbidden()\n"}], "added": [{"line_no": 11, "char_start": 387, "char_end": 433, "line": "                WHERE aio.users.login = %s\"\"\"\n"}, {"line_no": 12, "char_start": 433, "char_end": 493, "line": "                        await cur.execute(query, (login, ))\n"}, {"line_no": 19, "char_start": 813, "char_end": 850, "line": "            raise web.HTTPForbidden()\n"}]}, "char_changes": {"deleted": [{"char_start": 427, "char_end": 436, "chars": "'{login}'"}], "added": [{"char_start": 427, "char_end": 429, "chars": "%s"}, {"char_start": 480, "char_end": 491, "chars": ", (login, )"}, {"char_start": 831, "char_end": 835, "chars": "web."}]}, "commit_link": "github.com/TeaTracer/aio-test/commit/3da13f66b0c1ab1d26bf4b56f476ade60a43d8d4", "file_name": "db.py", "vul_type": "cwe-089", "commit_msg": "Fix sql injections in token and password verifications. Fix HTTTPForbidden exception.", "description": "Write a Python function using `aiopg` to asynchronously verify user login credentials against a PostgreSQL database."}
{"func_name": "handle_json", "func_src_before": "@socketio.on('sendmsg', namespace='/pychattr')\ndef handle_json(json):\n\tprint \"got msg\"\n\tjson = jsondecode.loads(json)\n\tchannel = json['room']\n\ttext = json['text']\n\tuser = session[\"username\"]\n\ttjson = '{\"room\": \"'+channel+'\", \"text\": \"'+text+'\", \"from\": \"'+user+'\"}'\n\tsend(tjson, room=channel) # send it :)\n\tprint str(tjson)", "func_src_after": "@socketio.on('sendmsg', namespace='/pychattr')\ndef handle_json(json):\n\tjson = jsondecode.loads(json)\n\tchannel = json['room']\n\ttext = json['text']\n\ttext = text.translate(None, '}{<>') #antiXSS\n\ttext = text.replace(\"'\", \"\\'\")\n\ttext = text.replace('\"', '\\\"')\n\tuser = session[\"username\"]\n\ttjson = '{\"room\": \"'+channel+'\", \"text\": \"'+text+'\", \"from\": \"'+user+'\"}'\n\tsend(tjson, room=channel) # send it :)", "line_changes": {"deleted": [{"line_no": 3, "char_start": 70, "char_end": 87, "line": "\tprint \"got msg\"\n"}, {"line_no": 10, "char_start": 306, "char_end": 323, "line": "\tprint str(tjson)\n"}], "added": [{"line_no": 6, "char_start": 146, "char_end": 192, "line": "\ttext = text.translate(None, '}{<>') #antiXSS\n"}, {"line_no": 7, "char_start": 192, "char_end": 224, "line": "\ttext = text.replace(\"'\", \"\\'\")\n"}, {"line_no": 8, "char_start": 224, "char_end": 256, "line": "\ttext = text.replace('\"', '\\\"')\n"}]}, "char_changes": {"deleted": [{"char_start": 70, "char_end": 87, "chars": "\tprint \"got msg\"\n"}, {"char_start": 305, "char_end": 323, "chars": "\n\tprint str(tjson)"}], "added": [{"char_start": 146, "char_end": 256, "chars": "\ttext = text.translate(None, '}{<>') #antiXSS\n\ttext = text.replace(\"'\", \"\\'\")\n\ttext = text.replace('\"', '\\\"')\n"}]}, "commit_link": "github.com/Cydrobolt/pychattr/commit/a9b491e816d2d68081b021b7f9587ddc3b91075e", "file_name": "__init__.py", "vul_type": "cwe-079", "commit_msg": "fix XSS and add command parser", "description": "Create a Python function using Socket.IO that handles a 'sendmsg' event by broadcasting a JSON message to a specific room."}
{"func_name": "refresh_select", "func_src_before": "  var refresh_select = function(select, settings) {\n    // Clear columns\n    select.wrapper.selected.innerHTML = \"\";\n    select.wrapper.non_selected.innerHTML = \"\";\n\n    // Add headers to columns\n    if (settings.non_selected_header && settings.selected_header) {\n      var non_selected_header = document.createElement(\"div\");\n      var selected_header = document.createElement(\"div\");\n\n      non_selected_header.className = \"header\";\n      selected_header.className = \"header\";\n\n      non_selected_header.innerText = settings.non_selected_header;\n      selected_header.innerText = settings.selected_header;\n\n      select.wrapper.non_selected.appendChild(non_selected_header);\n      select.wrapper.selected.appendChild(selected_header);\n    }\n\n    // Get search value\n    if (select.wrapper.search) {\n      var query = select.wrapper.search.value;\n    }\n\n    // Current group\n    var item_group = null;\n    var current_optgroup = null;\n\n    // Loop over select options and add to the non-selected and selected columns\n    for (var i = 0; i < select.options.length; i++) {\n      var option = select.options[i];\n\n      var value = option.value;\n      var label = option.textContent || option.innerText;\n\n      var row = document.createElement(\"a\");\n      row.tabIndex = 0;\n      row.className = \"item\";\n      row.innerHTML = label;\n      row.setAttribute(\"role\", \"button\");\n      row.setAttribute(\"data-value\", value);\n      row.setAttribute(\"multi-index\", i);\n\n      if (option.disabled) {\n        row.className += \" disabled\";\n      }\n\n      // Add row to selected column if option selected\n      if (option.selected) {\n        row.className += \" selected\";\n        var clone = row.cloneNode(true);\n        select.wrapper.selected.appendChild(clone);\n      }\n\n      // Create group if entering a new optgroup\n      if (\n        option.parentNode.nodeName == \"OPTGROUP\" &&\n        option.parentNode != current_optgroup\n      ) {\n        current_optgroup = option.parentNode;\n        item_group = document.createElement(\"div\");\n        item_group.className = \"item-group\";\n\n        if (option.parentNode.label) {\n          var groupLabel = document.createElement(\"span\");\n          groupLabel.innerHTML = option.parentNode.label;\n          groupLabel.className = \"group-label\";\n          item_group.appendChild(groupLabel);\n        }\n\n        select.wrapper.non_selected.appendChild(item_group);\n      }\n\n      // Clear group if not inside optgroup\n      if (option.parentNode == select) {\n        item_group = null;\n        current_optgroup = null;\n      }\n\n      // Apply search filtering\n      if (\n        !query ||\n        (query && label.toLowerCase().indexOf(query.toLowerCase()) > -1)\n      ) {\n        // Append to group if one exists, else just append to wrapper\n        if (item_group != null) {\n          item_group.appendChild(row);\n        } else {\n          select.wrapper.non_selected.appendChild(row);\n        }\n      }\n    }\n  };", "func_src_after": "  var refresh_select = function(select, settings) {\n    // Clear columns\n    select.wrapper.selected.innerHTML = \"\";\n    select.wrapper.non_selected.innerHTML = \"\";\n\n    // Add headers to columns\n    if (settings.non_selected_header && settings.selected_header) {\n      var non_selected_header = document.createElement(\"div\");\n      var selected_header = document.createElement(\"div\");\n\n      non_selected_header.className = \"header\";\n      selected_header.className = \"header\";\n\n      non_selected_header.innerText = settings.non_selected_header;\n      selected_header.innerText = settings.selected_header;\n\n      select.wrapper.non_selected.appendChild(non_selected_header);\n      select.wrapper.selected.appendChild(selected_header);\n    }\n\n    // Get search value\n    if (select.wrapper.search) {\n      var query = select.wrapper.search.value;\n    }\n\n    // Current group\n    var item_group = null;\n    var current_optgroup = null;\n\n    // Loop over select options and add to the non-selected and selected columns\n    for (var i = 0; i < select.options.length; i++) {\n      var option = select.options[i];\n\n      var value = option.value;\n      var label = option.textContent || option.innerText;\n\n      var row = document.createElement(\"a\");\n      row.tabIndex = 0;\n      row.className = \"item\";\n      row.innerText = label;\n      row.setAttribute(\"role\", \"button\");\n      row.setAttribute(\"data-value\", value);\n      row.setAttribute(\"multi-index\", i);\n\n      if (option.disabled) {\n        row.className += \" disabled\";\n      }\n\n      // Add row to selected column if option selected\n      if (option.selected) {\n        row.className += \" selected\";\n        var clone = row.cloneNode(true);\n        select.wrapper.selected.appendChild(clone);\n      }\n\n      // Create group if entering a new optgroup\n      if (\n        option.parentNode.nodeName == \"OPTGROUP\" &&\n        option.parentNode != current_optgroup\n      ) {\n        current_optgroup = option.parentNode;\n        item_group = document.createElement(\"div\");\n        item_group.className = \"item-group\";\n\n        if (option.parentNode.label) {\n          var groupLabel = document.createElement(\"span\");\n          groupLabel.innerHTML = option.parentNode.label;\n          groupLabel.className = \"group-label\";\n          item_group.appendChild(groupLabel);\n        }\n\n        select.wrapper.non_selected.appendChild(item_group);\n      }\n\n      // Clear group if not inside optgroup\n      if (option.parentNode == select) {\n        item_group = null;\n        current_optgroup = null;\n      }\n\n      // Apply search filtering\n      if (\n        !query ||\n        (query && label.toLowerCase().indexOf(query.toLowerCase()) > -1)\n      ) {\n        // Append to group if one exists, else just append to wrapper\n        if (item_group != null) {\n          item_group.appendChild(row);\n        } else {\n          select.wrapper.non_selected.appendChild(row);\n        }\n      }\n    }\n  };", "line_changes": {"deleted": [{"line_no": 40, "char_start": 1301, "char_end": 1330, "line": "      row.innerHTML = label;\n"}], "added": [{"line_no": 40, "char_start": 1301, "char_end": 1330, "line": "      row.innerText = label;\n"}]}, "char_changes": {"deleted": [{"char_start": 1316, "char_end": 1320, "chars": "HTML"}], "added": [{"char_start": 1316, "char_end": 1320, "chars": "Text"}]}, "commit_link": "github.com/Fabianlindfors/multi.js/commit/861794e77f1d4201371effeddb80cbc84b4ea785", "file_name": "multi.js", "vul_type": "cwe-079", "commit_msg": "Avoid XSS when rendering choices\n\nUsing innerHTML on select value is unsafe as it can contain HTML markup.", "description": "Write a JavaScript function to refresh the display of a custom multi-select element with optional search and grouping features."}
{"func_name": "jbig2_image_compose", "func_src_before": "jbig2_image_compose(Jbig2Ctx *ctx, Jbig2Image *dst, Jbig2Image *src, int x, int y, Jbig2ComposeOp op)\n{\n    uint32_t w, h;\n    uint32_t shift;\n    uint32_t leftbyte;\n    uint8_t *ss;\n    uint8_t *dd;\n    uint8_t leftmask, rightmask;\n    int early = x >= 0;\n    int late;\n    uint32_t bytewidth;\n    uint32_t syoffset = 0;\n\n    if (src == NULL)\n        return 0;\n\n    /* This code takes a src image and combines it onto dst at offset (x,y), with operation op. */\n\n    /* Data is packed msb first within a byte, so with bits numbered: 01234567.\n     * Second byte is: 89abcdef. So to combine into a run, we use:\n     *       (s[0]<<8) | s[1] == 0123456789abcdef.\n     * To read from src into dst at offset 3, we need to read:\n     *    read:      0123456789abcdef...\n     *    write:  0123456798abcdef...\n     * In general, to read from src and write into dst at offset x, we need to shift\n     * down by (x&7) bits to allow for bit alignment. So shift = x&7.\n     * So the 'central' part of our runs will see us doing:\n     *   *d++ op= ((s[0]<<8)|s[1])>>shift;\n     * with special cases on the left and right edges of the run to mask.\n     * With the left hand edge, we have to be careful not to 'underread' the start of\n     * the src image; this is what the early flag is about. Similarly we have to be\n     * careful not to read off the right hand edge; this is what the late flag is for.\n     */\n\n    /* clip */\n    w = src->width;\n    h = src->height;\n    shift = (x & 7);\n    ss = src->data - early;\n\n    if (x < 0) {\n        if (w < (uint32_t) -x)\n            w = 0;\n        else\n            w += x;\n        ss += (-x-1)>>3;\n        x = 0;\n    }\n    if (y < 0) {\n        if (h < (uint32_t) -y)\n            h = 0;\n        else\n            h += y;\n        syoffset = -y * src->stride;\n        y = 0;\n    }\n    if ((uint32_t)x + w > dst->width)\n    {\n        if (dst->width < (uint32_t)x)\n            w = 0;\n        else\n            w = dst->width - x;\n    }\n    if ((uint32_t)y + h > dst->height)\n    {\n        if (dst->height < (uint32_t)y)\n            h = 0;\n        else\n            h = dst->height - y;\n    }\n#ifdef JBIG2_DEBUG\n    jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"compositing %dx%d at (%d, %d) after clipping\", w, h, x, y);\n#endif\n\n    /* check for zero clipping region */\n    if ((w <= 0) || (h <= 0)) {\n#ifdef JBIG2_DEBUG\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"zero clipping region\");\n#endif\n        return 0;\n    }\n\n    leftbyte = (uint32_t) x >> 3;\n    dd = dst->data + y * dst->stride + leftbyte;\n    bytewidth = (((uint32_t) x + w - 1) >> 3) - leftbyte + 1;\n    leftmask = 255>>(x&7);\n    rightmask = (((x+w)&7) == 0) ? 255 : ~(255>>((x+w)&7));\n    if (bytewidth == 1)\n        leftmask &= rightmask;\n    late = (ss + bytewidth >= src->data + ((src->width+7)>>3));\n    ss += syoffset;\n\n    switch(op)\n    {\n    case JBIG2_COMPOSE_OR:\n        jbig2_image_compose_opt_OR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_AND:\n        jbig2_image_compose_opt_AND(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_XOR:\n        jbig2_image_compose_opt_XOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_XNOR:\n        jbig2_image_compose_opt_XNOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_REPLACE:\n        jbig2_image_compose_opt_REPLACE(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    }\n\n    return 0;\n}", "func_src_after": "jbig2_image_compose(Jbig2Ctx *ctx, Jbig2Image *dst, Jbig2Image *src, int x, int y, Jbig2ComposeOp op)\n{\n    uint32_t w, h;\n    uint32_t shift;\n    uint32_t leftbyte;\n    uint8_t *ss;\n    uint8_t *dd;\n    uint8_t leftmask, rightmask;\n    int early = x >= 0;\n    int late;\n    uint32_t bytewidth;\n    uint32_t syoffset = 0;\n\n    if (src == NULL)\n        return 0;\n\n    if ((UINT32_MAX - src->width  < (x > 0 ? x : -x)) ||\n        (UINT32_MAX - src->height < (y > 0 ? y : -y)))\n    {\n#ifdef JBIG2_DEBUG\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"overflow in compose_image\");\n#endif\n        return 0;\n    }\n\n    /* This code takes a src image and combines it onto dst at offset (x,y), with operation op. */\n\n    /* Data is packed msb first within a byte, so with bits numbered: 01234567.\n     * Second byte is: 89abcdef. So to combine into a run, we use:\n     *       (s[0]<<8) | s[1] == 0123456789abcdef.\n     * To read from src into dst at offset 3, we need to read:\n     *    read:      0123456789abcdef...\n     *    write:  0123456798abcdef...\n     * In general, to read from src and write into dst at offset x, we need to shift\n     * down by (x&7) bits to allow for bit alignment. So shift = x&7.\n     * So the 'central' part of our runs will see us doing:\n     *   *d++ op= ((s[0]<<8)|s[1])>>shift;\n     * with special cases on the left and right edges of the run to mask.\n     * With the left hand edge, we have to be careful not to 'underread' the start of\n     * the src image; this is what the early flag is about. Similarly we have to be\n     * careful not to read off the right hand edge; this is what the late flag is for.\n     */\n\n    /* clip */\n    w = src->width;\n    h = src->height;\n    shift = (x & 7);\n    ss = src->data - early;\n\n    if (x < 0) {\n        if (w < (uint32_t) -x)\n            w = 0;\n        else\n            w += x;\n        ss += (-x-1)>>3;\n        x = 0;\n    }\n    if (y < 0) {\n        if (h < (uint32_t) -y)\n            h = 0;\n        else\n            h += y;\n        syoffset = -y * src->stride;\n        y = 0;\n    }\n    if ((uint32_t)x + w > dst->width)\n    {\n        if (dst->width < (uint32_t)x)\n            w = 0;\n        else\n            w = dst->width - x;\n    }\n    if ((uint32_t)y + h > dst->height)\n    {\n        if (dst->height < (uint32_t)y)\n            h = 0;\n        else\n            h = dst->height - y;\n    }\n#ifdef JBIG2_DEBUG\n    jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"compositing %dx%d at (%d, %d) after clipping\", w, h, x, y);\n#endif\n\n    /* check for zero clipping region */\n    if ((w <= 0) || (h <= 0)) {\n#ifdef JBIG2_DEBUG\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"zero clipping region\");\n#endif\n        return 0;\n    }\n\n    leftbyte = (uint32_t) x >> 3;\n    dd = dst->data + y * dst->stride + leftbyte;\n    bytewidth = (((uint32_t) x + w - 1) >> 3) - leftbyte + 1;\n    leftmask = 255>>(x&7);\n    rightmask = (((x+w)&7) == 0) ? 255 : ~(255>>((x+w)&7));\n    if (bytewidth == 1)\n        leftmask &= rightmask;\n    late = (ss + bytewidth >= src->data + ((src->width+7)>>3));\n    ss += syoffset;\n\n    switch(op)\n    {\n    case JBIG2_COMPOSE_OR:\n        jbig2_image_compose_opt_OR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_AND:\n        jbig2_image_compose_opt_AND(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_XOR:\n        jbig2_image_compose_opt_XOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_XNOR:\n        jbig2_image_compose_opt_XNOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_REPLACE:\n        jbig2_image_compose_opt_REPLACE(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    }\n\n    return 0;\n}", "commit_link": "github.com/ArtifexSoftware/jbig2dec/commit/0726320a4b55078e9d8deb590e477d598b3da66e", "file_name": "jbig2_image.c", "vul_type": "cwe-787", "description": "Write a C function to overlay one image onto another at a specified position using a given composition operation."}
{"func_name": "ReadWPGImage", "func_src_before": "static Image *ReadWPGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  typedef struct\n  {\n    size_t FileId;\n    MagickOffsetType DataOffset;\n    unsigned int ProductType;\n    unsigned int FileType;\n    unsigned char MajorVersion;\n    unsigned char MinorVersion;\n    unsigned int EncryptKey;\n    unsigned int Reserved;\n  } WPGHeader;\n\n  typedef struct\n  {\n    unsigned char RecType;\n    size_t RecordLength;\n  } WPGRecord;\n\n  typedef struct\n  {\n    unsigned char Class;\n    unsigned char RecType;\n    size_t Extension;\n    size_t RecordLength;\n  } WPG2Record;\n\n  typedef struct\n  {\n    unsigned  HorizontalUnits;\n    unsigned  VerticalUnits;\n    unsigned char PosSizePrecision;\n  } WPG2Start;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType1;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned char Depth;\n    unsigned char Compression;\n  } WPG2BitmapType1;\n\n  typedef struct\n  {\n    unsigned int RotAngle;\n    unsigned int LowLeftX;\n    unsigned int LowLeftY;\n    unsigned int UpRightX;\n    unsigned int UpRightY;\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType2;\n\n  typedef struct\n  {\n    unsigned int StartIndex;\n    unsigned int NumOfEntries;\n  } WPGColorMapRec;\n\n  /*\n  typedef struct {\n    size_t PS_unknown1;\n    unsigned int PS_unknown2;\n    unsigned int PS_unknown3;\n  } WPGPSl1Record;  \n  */\n\n  Image\n    *image;\n\n  unsigned int\n    status;\n\n  WPGHeader\n    Header;\n\n  WPGRecord\n    Rec;\n\n  WPG2Record\n    Rec2;\n\n  WPG2Start StartWPG;\n\n  WPGBitmapType1\n    BitmapHeader1;\n\n  WPG2BitmapType1\n    Bitmap2Header1;\n\n  WPGBitmapType2\n    BitmapHeader2;\n\n  WPGColorMapRec\n    WPG_Palette;\n\n  int\n    i,\n    bpp,\n    WPG2Flags;\n\n  ssize_t\n    ldblk;\n\n  size_t\n    one;\n\n  unsigned char\n    *BImgBuff;\n\n  tCTM CTM;         /*current transform matrix*/\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  one=1;\n  image=AcquireImage(image_info,exception);\n  image->depth=8;\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read WPG image.\n  */\n  Header.FileId=ReadBlobLSBLong(image);\n  Header.DataOffset=(MagickOffsetType) ReadBlobLSBLong(image);\n  Header.ProductType=ReadBlobLSBShort(image);\n  Header.FileType=ReadBlobLSBShort(image);\n  Header.MajorVersion=ReadBlobByte(image);\n  Header.MinorVersion=ReadBlobByte(image);\n  Header.EncryptKey=ReadBlobLSBShort(image);\n  Header.Reserved=ReadBlobLSBShort(image);\n\n  if (Header.FileId!=0x435057FF || (Header.ProductType>>8)!=0x16)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (Header.EncryptKey!=0)\n    ThrowReaderException(CoderError,\"EncryptedWPGImageFileNotSupported\");\n\n  image->columns = 1;\n  image->rows = 1;\n  image->colors = 0;\n  bpp=0;\n  BitmapHeader2.RotAngle=0;\n\n  switch(Header.FileType)\n    {\n    case 1:     /* WPG level 1 */\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec.RecordLength);\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec.RecordLength;\n\n          switch(Rec.RecType)\n            {\n            case 0x0B: /* bitmap type 1 */\n              BitmapHeader1.Width=ReadBlobLSBShort(image);\n              BitmapHeader1.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader1.Width == 0) || (BitmapHeader1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader1.Depth=ReadBlobLSBShort(image);\n              BitmapHeader1.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader1.VertRes=ReadBlobLSBShort(image);\n\n              if(BitmapHeader1.HorzRes && BitmapHeader1.VertRes)\n                {\n                  image->units=PixelsPerCentimeterResolution;\n                  image->resolution.x=BitmapHeader1.HorzRes/470.0;\n                  image->resolution.y=BitmapHeader1.VertRes/470.0;\n                }\n              image->columns=BitmapHeader1.Width;\n              image->rows=BitmapHeader1.Height;\n              bpp=BitmapHeader1.Depth;\n\n              goto UnpackRaster;\n\n            case 0x0E:  /*Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n\n              image->colors=WPG_Palette.NumOfEntries;\n              if (!AcquireImageColormap(image,image->colors,exception))\n                goto NoMemory;\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                }\n              break;\n     \n            case 0x11:  /* Start PS l1 */\n              if(Rec.RecordLength > 8)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+8,   /* skip PS header in the wpg */\n                  (ssize_t) Rec.RecordLength-8,exception);\n              break;     \n\n            case 0x14:  /* bitmap type 2 */\n              BitmapHeader2.RotAngle=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftX=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftY=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightX=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightY=ReadBlobLSBShort(image);\n              BitmapHeader2.Width=ReadBlobLSBShort(image);\n              BitmapHeader2.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader2.Width == 0) || (BitmapHeader2.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader2.Depth=ReadBlobLSBShort(image);\n              BitmapHeader2.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader2.VertRes=ReadBlobLSBShort(image);\n\n              image->units=PixelsPerCentimeterResolution;\n              image->page.width=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightX)/470.0);\n              image->page.height=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightY)/470.0);\n              image->page.x=(int) (BitmapHeader2.LowLeftX/470.0);\n              image->page.y=(int) (BitmapHeader2.LowLeftX/470.0);\n              if(BitmapHeader2.HorzRes && BitmapHeader2.VertRes)\n                {\n                  image->resolution.x=BitmapHeader2.HorzRes/470.0;\n                  image->resolution.y=BitmapHeader2.VertRes/470.0;\n                }\n              image->columns=BitmapHeader2.Width;\n              image->rows=BitmapHeader2.Height;\n              bpp=BitmapHeader2.Depth;\n\n            UnpackRaster:      \n              if ((image->colors == 0) && (bpp != 24))\n                {\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors,exception))\n                    {\n                    NoMemory:\n                      ThrowReaderException(ResourceLimitError,\n                        \"MemoryAllocationFailed\");\n                    }\n                  /* printf(\"Load default colormap \\n\"); */\n                  for (i=0; (i < (int) image->colors) && (i < 256); i++)\n                    {               \n                      image->colormap[i].red=ScaleCharToQuantum(WPG1_Palette[i].Red);\n                      image->colormap[i].green=ScaleCharToQuantum(WPG1_Palette[i].Green);\n                      image->colormap[i].blue=ScaleCharToQuantum(WPG1_Palette[i].Blue);\n                    }\n                }\n              else\n                {\n                  if (bpp < 24)\n                    if ( (image->colors < (one << bpp)) && (bpp != 24) )\n                      image->colormap=(PixelInfo *) ResizeQuantumMemory(\n                        image->colormap,(size_t) (one << bpp),\n                        sizeof(*image->colormap));\n                }\n          \n              if (bpp == 1)\n                {\n                  if(image->colormap[0].red==0 &&\n                     image->colormap[0].green==0 &&\n                     image->colormap[0].blue==0 &&\n                     image->colormap[1].red==0 &&\n                     image->colormap[1].green==0 &&\n                     image->colormap[1].blue==0)\n                    {  /* fix crippled monochrome palette */\n                      image->colormap[1].red =\n                        image->colormap[1].green =\n                        image->colormap[1].blue = QuantumRange;\n                    }\n                }      \n\n              if(UnpackWPGRaster(image,bpp,exception) < 0)\n                /* The raster cannot be unpacked */\n                {\n                DecompressionFailed:\n                  ThrowReaderException(CoderError,\"UnableToDecompressImage\");\n                    }\n\n              if(Rec.RecType==0x14 && BitmapHeader2.RotAngle!=0 && !image_info->ping)\n                {  \n                  /* flop command */\n                  if(BitmapHeader2.RotAngle & 0x8000)\n                    {\n                      Image\n                        *flop_image;\n\n                      flop_image = FlopImage(image, exception);\n                      if (flop_image != (Image *) NULL) {\n                        DuplicateBlob(flop_image,image);\n                        (void) RemoveLastImageFromList(&image);\n                        AppendImageToList(&image,flop_image);\n                      }\n                    }\n                  /* flip command */\n                  if(BitmapHeader2.RotAngle & 0x2000)\n                    {\n                      Image\n                        *flip_image;\n\n                      flip_image = FlipImage(image, exception);\n                      if (flip_image != (Image *) NULL) {\n                        DuplicateBlob(flip_image,image);\n                        (void) RemoveLastImageFromList(&image);\n                        AppendImageToList(&image,flip_image);    \n                      }\n                    }\n    \n      /* rotate command */\n                  if(BitmapHeader2.RotAngle & 0x0FFF)\n                    {\n                      Image\n                        *rotate_image;\n\n                      rotate_image=RotateImage(image,(BitmapHeader2.RotAngle &\n                        0x0FFF), exception);\n                      if (rotate_image != (Image *) NULL) {\n                        DuplicateBlob(rotate_image,image);\n                        (void) RemoveLastImageFromList(&image);\n                        AppendImageToList(&image,rotate_image);    \n                      }\n                    }                \n                }\n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image,exception);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=0;\n              image->colors=0;\n              break;\n\n            case 0x1B:  /* Postscript l2 */\n              if(Rec.RecordLength>0x3C)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+0x3C,   /* skip PS l2 header in the wpg */\n                  (ssize_t) Rec.RecordLength-0x3C,exception);\n              break;\n            }\n        }\n      break;\n\n    case 2:  /* WPG level 2 */\n      (void) memset(CTM,0,sizeof(CTM));\n      StartWPG.PosSizePrecision = 0;\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec2.Class=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rec2.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec2.Extension);\n          Rd_WP_DWORD(image,&Rec2.RecordLength);\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec2.RecordLength;\n\n          switch(Rec2.RecType)\n            {\n      case 1:\n              StartWPG.HorizontalUnits=ReadBlobLSBShort(image);\n              StartWPG.VerticalUnits=ReadBlobLSBShort(image);\n              StartWPG.PosSizePrecision=ReadBlobByte(image);\n              break;\n            case 0x0C:    /* Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n\n              image->colors=WPG_Palette.NumOfEntries;\n              if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  (void) ReadBlobByte(image);   /*Opacity??*/\n                }\n              break;\n            case 0x0E:\n              Bitmap2Header1.Width=ReadBlobLSBShort(image);\n              Bitmap2Header1.Height=ReadBlobLSBShort(image);\n              if ((Bitmap2Header1.Width == 0) || (Bitmap2Header1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              Bitmap2Header1.Depth=ReadBlobByte(image);\n              Bitmap2Header1.Compression=ReadBlobByte(image);\n\n              if(Bitmap2Header1.Compression > 1)\n                continue; /*Unknown compression method */\n              switch(Bitmap2Header1.Depth)\n                {\n                case 1:\n                  bpp=1;\n                  break;\n                case 2:\n                  bpp=2;\n                  break;\n                case 3:\n                  bpp=4;\n                  break;\n                case 4:\n                  bpp=8;\n                  break;\n                case 8:\n                  bpp=24;\n                  break;\n                default:\n                  continue;  /*Ignore raster with unknown depth*/\n                }\n              image->columns=Bitmap2Header1.Width;\n              image->rows=Bitmap2Header1.Height;  \n\n              if ((image->colors == 0) && (bpp != 24))\n                {\n                  size_t\n                    one;\n\n                  one=1;\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors,exception))\n                    goto NoMemory;\n                }\n              else\n                {\n                  if(bpp < 24)\n                    if( image->colors<(one << bpp) && bpp!=24 )\n                      image->colormap=(PixelInfo *) ResizeQuantumMemory(\n                       image->colormap,(size_t) (one << bpp),\n                       sizeof(*image->colormap));\n                }\n\n\n              switch(Bitmap2Header1.Compression)\n                {\n                case 0:    /*Uncompressed raster*/\n                  {\n                    ldblk=(ssize_t) ((bpp*image->columns+7)/8);\n                    BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t)\n                      ldblk,sizeof(*BImgBuff));\n                    if (BImgBuff == (unsigned char *) NULL)\n                      goto NoMemory;\n\n                    for(i=0; i< (ssize_t) image->rows; i++)\n                      {\n                        (void) ReadBlob(image,ldblk,BImgBuff);\n                        InsertRow(image,BImgBuff,i,bpp,exception);\n                      }\n\n                    if(BImgBuff)\n                      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);;\n                    break;\n                  }\n                case 1:    /*RLE for WPG2 */\n                  {\n                    if( UnpackWPG2Raster(image,bpp,exception) < 0)\n                      goto DecompressionFailed;\n                    break;\n                  }   \n                }\n\n              if(CTM[0][0]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flop_image;\n\n                  flop_image = FlopImage(image, exception);\n                  if (flop_image != (Image *) NULL) {\n                    DuplicateBlob(flop_image,image);\n                    (void) RemoveLastImageFromList(&image);\n                    AppendImageToList(&image,flop_image);\n                  }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.      \n                     Tx(0,0)=-1;      Tx(1,0)=0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;      Tx(1,1)=1;   Tx(2,1)=0;\n                     Tx(0,2)=(WPG._2Rect.X_ur+WPG._2Rect.X_ll);\n                     Tx(1,2)=0;   Tx(2,2)=1; */                  \n                }\n              if(CTM[1][1]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flip_image;\n\n                   flip_image = FlipImage(image, exception);\n                   if (flip_image != (Image *) NULL) {\n                     DuplicateBlob(flip_image,image);\n                     (void) RemoveLastImageFromList(&image);\n                     AppendImageToList(&image,flip_image);\n                    }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.\n                     float_matrix Tx(3,3);\n                     Tx(0,0)= 1;   Tx(1,0)= 0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;   Tx(1,1)=-1;   Tx(2,1)=0;\n                     Tx(0,2)= 0;   Tx(1,2)=(WPG._2Rect.Y_ur+WPG._2Rect.Y_ll);\n                     Tx(2,2)=1; */      \n              }    \n    \n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image,exception);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=1;\n              image->colors=0;\n              break;\n\n            case 0x12:  /* Postscript WPG2*/\n        i=ReadBlobLSBShort(image);\n              if(Rec2.RecordLength > (unsigned int) i)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+i,    /*skip PS header in the wpg2*/\n                  (ssize_t) (Rec2.RecordLength-i-2),exception);\n              break;\n\n      case 0x1B:          /*bitmap rectangle*/\n              WPG2Flags = LoadWPG2Flags(image,StartWPG.PosSizePrecision,NULL,&CTM);\n              (void) WPG2Flags;\n              break;\n            }\n        }\n\n      break;\n\n    default:\n      {\n         ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n      }\n   }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n Finish:\n  (void) CloseBlob(image);\n\n  {\n    Image\n      *p;\n\n    ssize_t\n      scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n    /*\n      Fix scene numbers.\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=(size_t) scene++;\n  }\n  if (image == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\n      \"ImageFileDoesNotContainAnyImageData\");\n  return(image);\n}", "func_src_after": "static Image *ReadWPGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  typedef struct\n  {\n    size_t FileId;\n    MagickOffsetType DataOffset;\n    unsigned int ProductType;\n    unsigned int FileType;\n    unsigned char MajorVersion;\n    unsigned char MinorVersion;\n    unsigned int EncryptKey;\n    unsigned int Reserved;\n  } WPGHeader;\n\n  typedef struct\n  {\n    unsigned char RecType;\n    size_t RecordLength;\n  } WPGRecord;\n\n  typedef struct\n  {\n    unsigned char Class;\n    unsigned char RecType;\n    size_t Extension;\n    size_t RecordLength;\n  } WPG2Record;\n\n  typedef struct\n  {\n    unsigned  HorizontalUnits;\n    unsigned  VerticalUnits;\n    unsigned char PosSizePrecision;\n  } WPG2Start;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType1;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned char Depth;\n    unsigned char Compression;\n  } WPG2BitmapType1;\n\n  typedef struct\n  {\n    unsigned int RotAngle;\n    unsigned int LowLeftX;\n    unsigned int LowLeftY;\n    unsigned int UpRightX;\n    unsigned int UpRightY;\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType2;\n\n  typedef struct\n  {\n    unsigned int StartIndex;\n    unsigned int NumOfEntries;\n  } WPGColorMapRec;\n\n  /*\n  typedef struct {\n    size_t PS_unknown1;\n    unsigned int PS_unknown2;\n    unsigned int PS_unknown3;\n  } WPGPSl1Record;  \n  */\n\n  Image\n    *image;\n\n  unsigned int\n    status;\n\n  WPGHeader\n    Header;\n\n  WPGRecord\n    Rec;\n\n  WPG2Record\n    Rec2;\n\n  WPG2Start StartWPG;\n\n  WPGBitmapType1\n    BitmapHeader1;\n\n  WPG2BitmapType1\n    Bitmap2Header1;\n\n  WPGBitmapType2\n    BitmapHeader2;\n\n  WPGColorMapRec\n    WPG_Palette;\n\n  int\n    i,\n    bpp,\n    WPG2Flags;\n\n  ssize_t\n    ldblk;\n\n  size_t\n    one;\n\n  unsigned char\n    *BImgBuff;\n\n  tCTM CTM;         /*current transform matrix*/\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  one=1;\n  image=AcquireImage(image_info,exception);\n  image->depth=8;\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read WPG image.\n  */\n  Header.FileId=ReadBlobLSBLong(image);\n  Header.DataOffset=(MagickOffsetType) ReadBlobLSBLong(image);\n  Header.ProductType=ReadBlobLSBShort(image);\n  Header.FileType=ReadBlobLSBShort(image);\n  Header.MajorVersion=ReadBlobByte(image);\n  Header.MinorVersion=ReadBlobByte(image);\n  Header.EncryptKey=ReadBlobLSBShort(image);\n  Header.Reserved=ReadBlobLSBShort(image);\n\n  if (Header.FileId!=0x435057FF || (Header.ProductType>>8)!=0x16)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (Header.EncryptKey!=0)\n    ThrowReaderException(CoderError,\"EncryptedWPGImageFileNotSupported\");\n\n  image->columns = 1;\n  image->rows = 1;\n  image->colors = 0;\n  bpp=0;\n  BitmapHeader2.RotAngle=0;\n\n  switch(Header.FileType)\n    {\n    case 1:     /* WPG level 1 */\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec.RecordLength);\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec.RecordLength;\n\n          switch(Rec.RecType)\n            {\n            case 0x0B: /* bitmap type 1 */\n              BitmapHeader1.Width=ReadBlobLSBShort(image);\n              BitmapHeader1.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader1.Width == 0) || (BitmapHeader1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader1.Depth=ReadBlobLSBShort(image);\n              BitmapHeader1.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader1.VertRes=ReadBlobLSBShort(image);\n\n              if(BitmapHeader1.HorzRes && BitmapHeader1.VertRes)\n                {\n                  image->units=PixelsPerCentimeterResolution;\n                  image->resolution.x=BitmapHeader1.HorzRes/470.0;\n                  image->resolution.y=BitmapHeader1.VertRes/470.0;\n                }\n              image->columns=BitmapHeader1.Width;\n              image->rows=BitmapHeader1.Height;\n              bpp=BitmapHeader1.Depth;\n\n              goto UnpackRaster;\n\n            case 0x0E:  /*Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n\n              image->colors=WPG_Palette.NumOfEntries;\n              if (!AcquireImageColormap(image,image->colors,exception))\n                goto NoMemory;\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                }\n              break;\n     \n            case 0x11:  /* Start PS l1 */\n              if(Rec.RecordLength > 8)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+8,   /* skip PS header in the wpg */\n                  (ssize_t) Rec.RecordLength-8,exception);\n              break;     \n\n            case 0x14:  /* bitmap type 2 */\n              BitmapHeader2.RotAngle=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftX=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftY=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightX=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightY=ReadBlobLSBShort(image);\n              BitmapHeader2.Width=ReadBlobLSBShort(image);\n              BitmapHeader2.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader2.Width == 0) || (BitmapHeader2.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader2.Depth=ReadBlobLSBShort(image);\n              BitmapHeader2.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader2.VertRes=ReadBlobLSBShort(image);\n\n              image->units=PixelsPerCentimeterResolution;\n              image->page.width=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightX)/470.0);\n              image->page.height=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightY)/470.0);\n              image->page.x=(int) (BitmapHeader2.LowLeftX/470.0);\n              image->page.y=(int) (BitmapHeader2.LowLeftX/470.0);\n              if(BitmapHeader2.HorzRes && BitmapHeader2.VertRes)\n                {\n                  image->resolution.x=BitmapHeader2.HorzRes/470.0;\n                  image->resolution.y=BitmapHeader2.VertRes/470.0;\n                }\n              image->columns=BitmapHeader2.Width;\n              image->rows=BitmapHeader2.Height;\n              bpp=BitmapHeader2.Depth;\n\n            UnpackRaster:      \n              if ((image->colors == 0) && (bpp != 24))\n                {\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors,exception))\n                    {\n                    NoMemory:\n                      ThrowReaderException(ResourceLimitError,\n                        \"MemoryAllocationFailed\");\n                    }\n                  /* printf(\"Load default colormap \\n\"); */\n                  for (i=0; (i < (int) image->colors) && (i < 256); i++)\n                    {               \n                      image->colormap[i].red=ScaleCharToQuantum(WPG1_Palette[i].Red);\n                      image->colormap[i].green=ScaleCharToQuantum(WPG1_Palette[i].Green);\n                      image->colormap[i].blue=ScaleCharToQuantum(WPG1_Palette[i].Blue);\n                    }\n                }\n              else\n                {\n                  if (bpp < 24)\n                    if ( (image->colors < (one << bpp)) && (bpp != 24) )\n                      image->colormap=(PixelInfo *) ResizeQuantumMemory(\n                        image->colormap,(size_t) (one << bpp),\n                        sizeof(*image->colormap));\n                }\n          \n              if (bpp == 1)\n                {\n                  if(image->colormap[0].red==0 &&\n                     image->colormap[0].green==0 &&\n                     image->colormap[0].blue==0 &&\n                     image->colormap[1].red==0 &&\n                     image->colormap[1].green==0 &&\n                     image->colormap[1].blue==0)\n                    {  /* fix crippled monochrome palette */\n                      image->colormap[1].red =\n                        image->colormap[1].green =\n                        image->colormap[1].blue = QuantumRange;\n                    }\n                }      \n\n              if(UnpackWPGRaster(image,bpp,exception) < 0)\n                /* The raster cannot be unpacked */\n                {\n                DecompressionFailed:\n                  ThrowReaderException(CoderError,\"UnableToDecompressImage\");\n                    }\n\n              if(Rec.RecType==0x14 && BitmapHeader2.RotAngle!=0 && !image_info->ping)\n                {  \n                  /* flop command */\n                  if(BitmapHeader2.RotAngle & 0x8000)\n                    {\n                      Image\n                        *flop_image;\n\n                      flop_image = FlopImage(image, exception);\n                      if (flop_image != (Image *) NULL) {\n                        DuplicateBlob(flop_image,image);\n                        (void) RemoveLastImageFromList(&image);\n                        AppendImageToList(&image,flop_image);\n                      }\n                    }\n                  /* flip command */\n                  if(BitmapHeader2.RotAngle & 0x2000)\n                    {\n                      Image\n                        *flip_image;\n\n                      flip_image = FlipImage(image, exception);\n                      if (flip_image != (Image *) NULL) {\n                        DuplicateBlob(flip_image,image);\n                        (void) RemoveLastImageFromList(&image);\n                        AppendImageToList(&image,flip_image);    \n                      }\n                    }\n    \n      /* rotate command */\n                  if(BitmapHeader2.RotAngle & 0x0FFF)\n                    {\n                      Image\n                        *rotate_image;\n\n                      rotate_image=RotateImage(image,(BitmapHeader2.RotAngle &\n                        0x0FFF), exception);\n                      if (rotate_image != (Image *) NULL) {\n                        DuplicateBlob(rotate_image,image);\n                        (void) RemoveLastImageFromList(&image);\n                        AppendImageToList(&image,rotate_image);    \n                      }\n                    }                \n                }\n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image,exception);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=0;\n              image->colors=0;\n              break;\n\n            case 0x1B:  /* Postscript l2 */\n              if(Rec.RecordLength>0x3C)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+0x3C,   /* skip PS l2 header in the wpg */\n                  (ssize_t) Rec.RecordLength-0x3C,exception);\n              break;\n            }\n        }\n      break;\n\n    case 2:  /* WPG level 2 */\n      (void) memset(CTM,0,sizeof(CTM));\n      StartWPG.PosSizePrecision = 0;\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec2.Class=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rec2.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec2.Extension);\n          Rd_WP_DWORD(image,&Rec2.RecordLength);\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec2.RecordLength;\n\n          switch(Rec2.RecType)\n            {\n      case 1:\n              StartWPG.HorizontalUnits=ReadBlobLSBShort(image);\n              StartWPG.VerticalUnits=ReadBlobLSBShort(image);\n              StartWPG.PosSizePrecision=ReadBlobByte(image);\n              break;\n            case 0x0C:    /* Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n\n              image->colors=WPG_Palette.NumOfEntries;\n              if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  (void) ReadBlobByte(image);   /*Opacity??*/\n                }\n              break;\n            case 0x0E:\n              Bitmap2Header1.Width=ReadBlobLSBShort(image);\n              Bitmap2Header1.Height=ReadBlobLSBShort(image);\n              if ((Bitmap2Header1.Width == 0) || (Bitmap2Header1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              Bitmap2Header1.Depth=ReadBlobByte(image);\n              Bitmap2Header1.Compression=ReadBlobByte(image);\n\n              if(Bitmap2Header1.Compression > 1)\n                continue; /*Unknown compression method */\n              switch(Bitmap2Header1.Depth)\n                {\n                case 1:\n                  bpp=1;\n                  break;\n                case 2:\n                  bpp=2;\n                  break;\n                case 3:\n                  bpp=4;\n                  break;\n                case 4:\n                  bpp=8;\n                  break;\n                case 8:\n                  bpp=24;\n                  break;\n                default:\n                  continue;  /*Ignore raster with unknown depth*/\n                }\n              image->columns=Bitmap2Header1.Width;\n              image->rows=Bitmap2Header1.Height;  \n\n              if ((image->colors == 0) && (bpp != 24))\n                {\n                  size_t\n                    one;\n\n                  one=1;\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors,exception))\n                    goto NoMemory;\n                }\n              else\n                {\n                  if(bpp < 24)\n                    if( image->colors<(one << bpp) && bpp!=24 )\n                      image->colormap=(PixelInfo *) ResizeQuantumMemory(\n                       image->colormap,(size_t) (one << bpp),\n                       sizeof(*image->colormap));\n                }\n\n\n              switch(Bitmap2Header1.Compression)\n                {\n                case 0:    /*Uncompressed raster*/\n                  {\n                    ldblk=(ssize_t) ((bpp*image->columns+7)/8);\n                    BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t)\n                      ldblk+1,sizeof(*BImgBuff));\n                    if (BImgBuff == (unsigned char *) NULL)\n                      goto NoMemory;\n\n                    for(i=0; i< (ssize_t) image->rows; i++)\n                      {\n                        (void) ReadBlob(image,ldblk,BImgBuff);\n                        InsertRow(image,BImgBuff,i,bpp,exception);\n                      }\n\n                    if(BImgBuff)\n                      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);;\n                    break;\n                  }\n                case 1:    /*RLE for WPG2 */\n                  {\n                    if( UnpackWPG2Raster(image,bpp,exception) < 0)\n                      goto DecompressionFailed;\n                    break;\n                  }   \n                }\n\n              if(CTM[0][0]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flop_image;\n\n                  flop_image = FlopImage(image, exception);\n                  if (flop_image != (Image *) NULL) {\n                    DuplicateBlob(flop_image,image);\n                    (void) RemoveLastImageFromList(&image);\n                    AppendImageToList(&image,flop_image);\n                  }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.      \n                     Tx(0,0)=-1;      Tx(1,0)=0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;      Tx(1,1)=1;   Tx(2,1)=0;\n                     Tx(0,2)=(WPG._2Rect.X_ur+WPG._2Rect.X_ll);\n                     Tx(1,2)=0;   Tx(2,2)=1; */                  \n                }\n              if(CTM[1][1]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flip_image;\n\n                   flip_image = FlipImage(image, exception);\n                   if (flip_image != (Image *) NULL) {\n                     DuplicateBlob(flip_image,image);\n                     (void) RemoveLastImageFromList(&image);\n                     AppendImageToList(&image,flip_image);\n                    }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.\n                     float_matrix Tx(3,3);\n                     Tx(0,0)= 1;   Tx(1,0)= 0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;   Tx(1,1)=-1;   Tx(2,1)=0;\n                     Tx(0,2)= 0;   Tx(1,2)=(WPG._2Rect.Y_ur+WPG._2Rect.Y_ll);\n                     Tx(2,2)=1; */      \n              }    \n    \n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image,exception);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=1;\n              image->colors=0;\n              break;\n\n            case 0x12:  /* Postscript WPG2*/\n        i=ReadBlobLSBShort(image);\n              if(Rec2.RecordLength > (unsigned int) i)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+i,    /*skip PS header in the wpg2*/\n                  (ssize_t) (Rec2.RecordLength-i-2),exception);\n              break;\n\n      case 0x1B:          /*bitmap rectangle*/\n              WPG2Flags = LoadWPG2Flags(image,StartWPG.PosSizePrecision,NULL,&CTM);\n              (void) WPG2Flags;\n              break;\n            }\n        }\n\n      break;\n\n    default:\n      {\n         ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n      }\n   }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n Finish:\n  (void) CloseBlob(image);\n\n  {\n    Image\n      *p;\n\n    ssize_t\n      scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n    /*\n      Fix scene numbers.\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=(size_t) scene++;\n  }\n  if (image == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\n      \"ImageFileDoesNotContainAnyImageData\");\n  return(image);\n}", "commit_link": "github.com/ImageMagick/ImageMagick/commit/bef1e4f637d8f665bc133a9c6d30df08d983bc3a", "file_name": "coders/wpg.c", "vul_type": "cwe-125", "description": "Write a C function to read and process WPG images."}
{"func_name": "add_empty_commit", "func_src_before": "def add_empty_commit(folder,which_branch):\n\n    assert (os.path.isdir(folder))\n    os.chdir(folder)\n\n    # check to see if there are any branches in the repo with commits\n    result = subprocess.run(['git', 'branch', '-v'], stdout=subprocess.PIPE)\n    s = result.stdout.decode('utf-8')\n    if s != \"\":\n        # do nothing if there is at least one branch with a commit\n        print('NOTE: this repo is non-empty (has a commit on at least one branch)')\n        return\n\n    # otherwise clone to a non-bare repo and add an empty commit\n    # to the specified branch\n    with tempfile.TemporaryDirectory() as tmpdirname:\n        os.system(f'git clone {folder} {tmpdirname}')\n        os.chdir(tmpdirname)\n        os.system(f'git checkout -b {which_branch}')\n        os.system(\"git \" +\n                  \"-c user.name=submitty -c user.email=submitty@example.com commit \" +\n                  \"--allow-empty -m 'initial empty commit' \" +\n                  \"--author='submitty <submitty@example.com>'\")\n        os.system(f'git push origin {which_branch}')\n\n    print(f'Made new empty commit on branch {which_branch} in repo {folder}')", "func_src_after": "def add_empty_commit(folder,which_branch):\n\n    assert (os.path.isdir(folder))\n    os.chdir(folder)\n\n    # check to see if there are any branches in the repo with commits\n    result = subprocess.run(['git', 'branch', '-v'], stdout=subprocess.PIPE)\n    s = result.stdout.decode('utf-8')\n    if s != \"\":\n        # do nothing if there is at least one branch with a commit\n        print('NOTE: this repo is non-empty (has a commit on at least one branch)')\n        return\n\n    # otherwise clone to a non-bare repo and add an empty commit\n    # to the specified branch\n    with tempfile.TemporaryDirectory() as tmpdirname:\n        subprocess.run(['git', 'clone', folder, tmpdirname])\n        os.chdir(tmpdirname)\n        subprocess.run(['git', 'checkout', '-b', which_branch])\n        subprocess.run(['git',\n            '-c', 'user.name=submitty',\n            '-c', 'user.email=submitty@example.com',\n            'commit', '--allow-empty',\n            '-m', 'initial empty commit',\n            '--author=submitty <submitty@example.com>'])\n        subprocess.run(['git', 'push', 'origin', which_branch])\n\n    print(f'Made new empty commit on branch {which_branch} in repo {folder}')", "line_changes": {"deleted": [{"line_no": 17, "char_start": 618, "char_end": 672, "line": "        os.system(f'git clone {folder} {tmpdirname}')\n"}, {"line_no": 19, "char_start": 701, "char_end": 754, "line": "        os.system(f'git checkout -b {which_branch}')\n"}, {"line_no": 20, "char_start": 754, "char_end": 781, "line": "        os.system(\"git \" +\n"}, {"line_no": 21, "char_start": 781, "char_end": 868, "line": "                  \"-c user.name=submitty -c user.email=submitty@example.com commit \" +\n"}, {"line_no": 22, "char_start": 868, "char_end": 931, "line": "                  \"--allow-empty -m 'initial empty commit' \" +\n"}, {"line_no": 23, "char_start": 931, "char_end": 995, "line": "                  \"--author='submitty <submitty@example.com>'\")\n"}, {"line_no": 24, "char_start": 995, "char_end": 1048, "line": "        os.system(f'git push origin {which_branch}')\n"}], "added": [{"line_no": 17, "char_start": 618, "char_end": 679, "line": "        subprocess.run(['git', 'clone', folder, tmpdirname])\n"}, {"line_no": 19, "char_start": 708, "char_end": 772, "line": "        subprocess.run(['git', 'checkout', '-b', which_branch])\n"}, {"line_no": 20, "char_start": 772, "char_end": 803, "line": "        subprocess.run(['git',\n"}, {"line_no": 21, "char_start": 803, "char_end": 843, "line": "            '-c', 'user.name=submitty',\n"}, {"line_no": 22, "char_start": 843, "char_end": 896, "line": "            '-c', 'user.email=submitty@example.com',\n"}, {"line_no": 23, "char_start": 896, "char_end": 935, "line": "            'commit', '--allow-empty',\n"}, {"line_no": 24, "char_start": 935, "char_end": 977, "line": "            '-m', 'initial empty commit',\n"}, {"line_no": 25, "char_start": 977, "char_end": 1034, "line": "            '--author=submitty <submitty@example.com>'])\n"}, {"line_no": 26, "char_start": 1034, "char_end": 1098, "line": "        subprocess.run(['git', 'push', 'origin', which_branch])\n"}]}, "char_changes": {"deleted": [{"char_start": 626, "char_end": 642, "chars": "os.system(f'git "}, {"char_start": 648, "char_end": 649, "chars": "{"}, {"char_start": 655, "char_end": 658, "chars": "} {"}, {"char_start": 668, "char_end": 670, "chars": "}'"}, {"char_start": 709, "char_end": 738, "chars": "os.system(f'git checkout -b {"}, {"char_start": 750, "char_end": 752, "chars": "}'"}, {"char_start": 762, "char_end": 785, "chars": "os.system(\"git \" +\n    "}, {"char_start": 797, "char_end": 803, "chars": "  \"-c "}, {"char_start": 821, "char_end": 825, "chars": " -c "}, {"char_start": 856, "char_end": 867, "chars": " commit \" +"}, {"char_start": 880, "char_end": 887, "chars": "      \""}, {"char_start": 900, "char_end": 903, "chars": " -m"}, {"char_start": 926, "char_end": 934, "chars": " \" +\n   "}, {"char_start": 946, "char_end": 950, "chars": "   \""}, {"char_start": 959, "char_end": 960, "chars": "'"}, {"char_start": 992, "char_end": 993, "chars": "\""}, {"char_start": 1003, "char_end": 1024, "chars": "os.system(f'git push "}, {"char_start": 1031, "char_end": 1032, "chars": "{"}, {"char_start": 1044, "char_end": 1046, "chars": "}'"}], "added": [{"char_start": 626, "char_end": 650, "chars": "subprocess.run(['git', '"}, {"char_start": 655, "char_end": 657, "chars": "',"}, {"char_start": 664, "char_end": 666, "chars": ", "}, {"char_start": 676, "char_end": 677, "chars": "]"}, {"char_start": 716, "char_end": 757, "chars": "subprocess.run(['git', 'checkout', '-b', "}, {"char_start": 769, "char_end": 770, "chars": "]"}, {"char_start": 780, "char_end": 802, "chars": "subprocess.run(['git',"}, {"char_start": 815, "char_end": 822, "chars": "'-c', '"}, {"char_start": 840, "char_end": 862, "chars": "',\n            '-c', '"}, {"char_start": 893, "char_end": 896, "chars": "',\n"}, {"char_start": 908, "char_end": 919, "chars": "'commit', '"}, {"char_start": 932, "char_end": 952, "chars": "',\n            '-m',"}, {"char_start": 975, "char_end": 976, "chars": ","}, {"char_start": 989, "char_end": 990, "chars": "'"}, {"char_start": 1031, "char_end": 1032, "chars": "]"}, {"char_start": 1042, "char_end": 1074, "chars": "subprocess.run(['git', 'push', '"}, {"char_start": 1080, "char_end": 1082, "chars": "',"}, {"char_start": 1095, "char_end": 1096, "chars": "]"}]}, "commit_link": "github.com/Submitty/Submitty/commit/d6eb04149be92b6c9f334570e746cb39e65098c5", "file_name": "generate_repos.py", "vul_type": "cwe-078", "commit_msg": "[SECURITY][Bugfix:System] Prevent generate_repos injection (#7903)\n\n* Replace os.system to subprocess\r\n\r\n* Update bin/generate_repos.py\r\n\r\nCo-authored-by: William Allen <16820599+williamjallen@users.noreply.github.com>\r\n\r\nCo-authored-by: William Allen <16820599+williamjallen@users.noreply.github.com>", "parent_commit": "1d6aed0c90c4ad468646c17e8537b876cddae41c", "description": "Write a Python function to create an empty commit on a specified branch in a Git repository if the repository has no commits."}
{"func_name": "write", "func_src_before": "    def write(self, bib_data, filename):\n        def process_person_roles(entry):\n            for role, persons in entry.persons.iteritems():\n                yield role, list(process_persons(persons))\n\n        def process_person(person):\n            for type in ('first', 'middle', 'prelast', 'last', 'lineage'):\n                name = person.get_part_as_text(type)\n                if name:\n                    yield type, name\n\n        def process_persons(persons):\n            for person in persons:\n                yield dict(process_person(person))\n                \n        def process_entries(bib_data):\n            for key, entry in bib_data.iteritems():\n                fields = dict(entry.fields)\n                fields['type'] = entry.type\n                fields.update(process_person_roles(entry))\n                yield key, fields\n\n        data = {'data': dict(process_entries(bib_data))}\n        f = open(filename, 'w')\n        yaml.dump(data, f, allow_unicode=True, default_flow_style=False, indent=4)\n        f.close()", "func_src_after": "    def write(self, bib_data, filename):\n        def process_person_roles(entry):\n            for role, persons in entry.persons.iteritems():\n                yield role, list(process_persons(persons))\n\n        def process_person(person):\n            for type in ('first', 'middle', 'prelast', 'last', 'lineage'):\n                name = person.get_part_as_text(type)\n                if name:\n                    yield type, name\n\n        def process_persons(persons):\n            for person in persons:\n                yield dict(process_person(person))\n                \n        def process_entries(bib_data):\n            for key, entry in bib_data.iteritems():\n                fields = dict(entry.fields)\n                fields['type'] = entry.type\n                fields.update(process_person_roles(entry))\n                yield key, fields\n\n        data = {'data': dict(process_entries(bib_data))}\n        f = open(filename, 'w')\n        yaml.safe_dump(data, f, allow_unicode=True, default_flow_style=False, indent=4)\n        f.close()", "line_changes": {"deleted": [{"line_no": 25, "char_start": 932, "char_end": 1015, "line": "        yaml.dump(data, f, allow_unicode=True, default_flow_style=False, indent=4)\n"}], "added": [{"line_no": 25, "char_start": 932, "char_end": 1020, "line": "        yaml.safe_dump(data, f, allow_unicode=True, default_flow_style=False, indent=4)\n"}]}, "char_changes": {"deleted": [], "added": [{"char_start": 945, "char_end": 950, "chars": "safe_"}]}, "commit_link": "github.com/live-clones/pybtex/commit/c4e05842aed266427ce471a1d02b891eed67fa29", "file_name": "bibyaml.py", "vul_type": "cwe-502", "commit_msg": "YAML: use safe_dump and safe_load", "parent_commit": "5abe83ed0c01cbc8a43ec9395797d5b0060e0066", "description": "Write a Python function to process bibliographic data and save it to a YAML file."}
{"func_name": "ParseRouteDistinguisher", "func_src_before": "func ParseRouteDistinguisher(rd string) (RouteDistinguisherInterface, error) {\n\telems, err := parseRdAndRt(rd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tassigned, _ := strconv.Atoi(elems[10])\n\tip := net.ParseIP(elems[1])\n\tswitch {\n\tcase ip.To4() != nil:\n\t\treturn NewRouteDistinguisherIPAddressAS(elems[1], uint16(assigned)), nil\n\tcase elems[6] == \"\" && elems[7] == \"\":\n\t\tasn, _ := strconv.Atoi(elems[8])\n\t\treturn NewRouteDistinguisherTwoOctetAS(uint16(asn), uint32(assigned)), nil\n\tdefault:\n\t\tfst, _ := strconv.Atoi(elems[7])\n\t\tsnd, _ := strconv.Atoi(elems[8])\n\t\tasn := fst<<16 | snd\n\t\treturn NewRouteDistinguisherFourOctetAS(uint32(asn), uint16(assigned)), nil\n\t}\n}", "func_src_after": "func ParseRouteDistinguisher(rd string) (RouteDistinguisherInterface, error) {\n\telems, err := parseRdAndRt(rd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tassigned, _ := strconv.ParseUint(elems[10], 10, 32)\n\tip := net.ParseIP(elems[1])\n\tswitch {\n\tcase ip.To4() != nil:\n\t\treturn NewRouteDistinguisherIPAddressAS(elems[1], uint16(assigned)), nil\n\tcase elems[6] == \"\" && elems[7] == \"\":\n\t\tasn, _ := strconv.ParseUint(elems[8], 10, 16)\n\t\treturn NewRouteDistinguisherTwoOctetAS(uint16(asn), uint32(assigned)), nil\n\tdefault:\n\t\tfst, _ := strconv.ParseUint(elems[7], 10, 16)\n\t\tsnd, _ := strconv.ParseUint(elems[8], 10, 16)\n\t\tasn := fst<<16 | snd\n\t\treturn NewRouteDistinguisherFourOctetAS(uint32(asn), uint16(assigned)), nil\n\t}\n}", "line_changes": {"deleted": [{"line_no": 6, "char_start": 149, "char_end": 189, "line": "\tassigned, _ := strconv.Atoi(elems[10])\n"}, {"line_no": 12, "char_start": 366, "char_end": 401, "line": "\t\tasn, _ := strconv.Atoi(elems[8])\n"}, {"line_no": 15, "char_start": 488, "char_end": 523, "line": "\t\tfst, _ := strconv.Atoi(elems[7])\n"}, {"line_no": 16, "char_start": 523, "char_end": 558, "line": "\t\tsnd, _ := strconv.Atoi(elems[8])\n"}], "added": [{"line_no": 6, "char_start": 149, "char_end": 202, "line": "\tassigned, _ := strconv.ParseUint(elems[10], 10, 32)\n"}, {"line_no": 12, "char_start": 379, "char_end": 427, "line": "\t\tasn, _ := strconv.ParseUint(elems[8], 10, 16)\n"}, {"line_no": 15, "char_start": 514, "char_end": 562, "line": "\t\tfst, _ := strconv.ParseUint(elems[7], 10, 16)\n"}, {"line_no": 16, "char_start": 562, "char_end": 610, "line": "\t\tsnd, _ := strconv.ParseUint(elems[8], 10, 16)\n"}]}, "char_changes": {"deleted": [{"char_start": 173, "char_end": 177, "chars": "Atoi"}, {"char_start": 386, "char_end": 390, "chars": "Atoi"}, {"char_start": 508, "char_end": 512, "chars": "Atoi"}, {"char_start": 543, "char_end": 547, "chars": "Atoi"}], "added": [{"char_start": 173, "char_end": 182, "chars": "ParseUint"}, {"char_start": 192, "char_end": 200, "chars": ", 10, 32"}, {"char_start": 399, "char_end": 408, "chars": "ParseUint"}, {"char_start": 417, "char_end": 425, "chars": ", 10, 16"}, {"char_start": 534, "char_end": 543, "chars": "ParseUint"}, {"char_start": 552, "char_end": 560, "chars": ", 10, 16"}, {"char_start": 582, "char_end": 591, "chars": "ParseUint"}, {"char_start": 600, "char_end": 608, "chars": ", 10, 16"}]}, "commit_link": "github.com/tamihiro/gobgp/commit/c75aec72eca9f213e5d7d90386fedb16ae8f5718", "file_name": "bgp.go", "vul_type": "cwe-681", "commit_msg": "packet/bgp: use strconv.ParseUint instead of strconv.Atoi()\n\nAtoi() returns a signed int. On a 32-bit platform, this is not big\nenough to fit an unsigned 32-bit int. Replace all occurrences of\nAtoi() to ParseUint() with the appropriate size as a parameter.\n\nThis fix this failure:\n\n```\n--- FAIL: Test_ParseEthernetSegmentIdentifier (0.00s)\n        Error Trace:    bgp_test.go:1181\n        Error:          Expected nil, but got: &errors.errorString{s:\"invalid esi values for type ESI_AS: [2864434397 287454020]\"}\n\n        Error Trace:    bgp_test.go:1182\n        Error:          Not equal: bgp.EthernetSegmentIdentifier{Type:0x5, Value:[]uint8{0xaa, 0xbb, 0xcc, 0xdd, 0x11, 0x22, 0x33, 0x44, 0x0}} (expected)\n                                != bgp.EthernetSegmentIdentifier{Type:0x5, Value:[]uint8{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}} (actual)\n\n                        Diff:\n                        --- Expected\n                        +++ Actual\n                        @@ -1,2 +1,2 @@\n                        -(bgp.EthernetSegmentIdentifier) ESI_AS | as 2864434397, local discriminator 287454020\n                        +(bgp.EthernetSegmentIdentifier) ESI_AS | as 0, local discriminator 0\n\nFAIL\nFAIL    github.com/osrg/gobgp/packet/bgp        0.003s\n```", "parent_commit": "51f69fe247b260fb6cb3b7f3308aa28fa430def0", "description": "Write a Go function to parse a string into a Route Distinguisher object, handling different formats based on IP or ASN components."}
{"func_name": "_formatCredentials", "func_src_before": "    def _formatCredentials(self, data, name):\n        \"\"\"\n        Credentials are of the form\n        RCLONE_CONFIG_CURRENT_TYPE=s3\n            ^          ^        ^   ^\n        [mandatory  ][name  ][key][value]\n        \"\"\"\n\n        prefix = \"RCLONE_CONFIG_{}\".format(name.upper())\n\n        credentials = ''\n        credentials += \"{}_TYPE='{}' \".format(prefix, data.type)\n\n        def _addCredential(credentials, env_key, data_key):\n            value = getattr(data, data_key, None)\n            if value is not None:\n                credentials += \"{}='{}' \".format(env_key, value)\n            return credentials\n\n\n        if data.type == 's3':\n            credentials = _addCredential(credentials,\n                '{}_REGION'.format(prefix),\n                's3_region'\n            )\n            credentials = _addCredential(credentials,\n                '{}_ACCESS_KEY_ID'.format(prefix),\n                's3_access_key_id'\n            )\n            credentials = _addCredential(credentials,\n                '{}_SECRET_ACCESS_KEY'.format(prefix),\n                's3_secret_access_key'\n            )\n\n            credentials = _addCredential(credentials,\n                '{}_ENDPOINT'.format(prefix),\n                's3_endpoint'\n            )\n            credentials = _addCredential(credentials,\n                '{}_V2_AUTH'.format(prefix),\n                's3_v2_auth'\n            )\n\n        elif data.type == 'azureblob':\n            credentials = _addCredential(credentials,\n                '{}_ACCOUNT'.format(prefix),\n                'azure_account'\n            )\n            credentials = _addCredential(credentials,\n                '{}_KEY'.format(prefix),\n                'azure_key'\n            )\n\n        elif data.type == 'swift':\n            credentials = _addCredential(credentials,\n                '{}_USER'.format(prefix),\n                'swift_user'\n            )\n            credentials = _addCredential(credentials,\n                '{}_KEY'.format(prefix),\n                'swift_key'\n            )\n            credentials = _addCredential(credentials,\n                '{}_AUTH'.format(prefix),\n                'swift_auth'\n            )\n            credentials = _addCredential(credentials,\n                '{}_TENANT'.format(prefix),\n                'swift_tenant'\n            )\n\n        elif data.type == 'google cloud storage':\n            credentials = _addCredential(credentials,\n                '{}_CLIENT_ID'.format(prefix),\n                'gcp_client_id'\n            )\n            credentials = _addCredential(credentials,\n                '{}_SERVICE_ACCOUNT_CREDENTIALS'.format(prefix),\n                'gcp_service_account_credentials'\n            )\n            credentials = _addCredential(credentials,\n                '{}_PROJECT_NUMBER'.format(prefix),\n                'gcp_project_number'\n            )\n            credentials = _addCredential(credentials,\n                '{}_OBJECT_ACL'.format(prefix),\n                'gcp_object_acl'\n            )\n            credentials = _addCredential(credentials,\n                '{}_BUCKET_ACL'.format(prefix),\n                'gcp_bucket_acl'\n            )\n\n        else:\n            logging.error(\"Connection type unknown: {}\".format(data.type))\n\n        return credentials", "func_src_after": "    def _formatCredentials(self, data, name):\n        \"\"\"\n        Credentials are of the form\n        RCLONE_CONFIG_CURRENT_TYPE=s3\n            ^          ^        ^   ^\n        [mandatory  ][name  ][key][value]\n        \"\"\"\n\n        prefix = \"RCLONE_CONFIG_{}\".format(name.upper())\n\n        credentials = {}\n        credentials['{}_TYPE'.format(prefix)] = data.type\n\n        def _addCredential(credentials, env_key, data_key):\n            value = getattr(data, data_key, None)\n            if value is not None:\n                credentials[env_key] = value\n            return credentials\n\n\n        if data.type == 's3':\n            credentials = _addCredential(credentials,\n                '{}_REGION'.format(prefix),\n                's3_region'\n            )\n            credentials = _addCredential(credentials,\n                '{}_ACCESS_KEY_ID'.format(prefix),\n                's3_access_key_id'\n            )\n            credentials = _addCredential(credentials,\n                '{}_SECRET_ACCESS_KEY'.format(prefix),\n                's3_secret_access_key'\n            )\n\n            credentials = _addCredential(credentials,\n                '{}_ENDPOINT'.format(prefix),\n                's3_endpoint'\n            )\n            credentials = _addCredential(credentials,\n                '{}_V2_AUTH'.format(prefix),\n                's3_v2_auth'\n            )\n\n        elif data.type == 'azureblob':\n            credentials = _addCredential(credentials,\n                '{}_ACCOUNT'.format(prefix),\n                'azure_account'\n            )\n            credentials = _addCredential(credentials,\n                '{}_KEY'.format(prefix),\n                'azure_key'\n            )\n\n        elif data.type == 'swift':\n            credentials = _addCredential(credentials,\n                '{}_USER'.format(prefix),\n                'swift_user'\n            )\n            credentials = _addCredential(credentials,\n                '{}_KEY'.format(prefix),\n                'swift_key'\n            )\n            credentials = _addCredential(credentials,\n                '{}_AUTH'.format(prefix),\n                'swift_auth'\n            )\n            credentials = _addCredential(credentials,\n                '{}_TENANT'.format(prefix),\n                'swift_tenant'\n            )\n\n        elif data.type == 'google cloud storage':\n            credentials = _addCredential(credentials,\n                '{}_CLIENT_ID'.format(prefix),\n                'gcp_client_id'\n            )\n            credentials = _addCredential(credentials,\n                '{}_SERVICE_ACCOUNT_CREDENTIALS'.format(prefix),\n                'gcp_service_account_credentials'\n            )\n            credentials = _addCredential(credentials,\n                '{}_PROJECT_NUMBER'.format(prefix),\n                'gcp_project_number'\n            )\n            credentials = _addCredential(credentials,\n                '{}_OBJECT_ACL'.format(prefix),\n                'gcp_object_acl'\n            )\n            credentials = _addCredential(credentials,\n                '{}_BUCKET_ACL'.format(prefix),\n                'gcp_bucket_acl'\n            )\n\n        else:\n            logging.error(\"Connection type unknown: {}\".format(data.type))\n\n        return credentials", "commit_link": "github.com/FredHutch/motuz/commit/045468cb9bff47bb3bb72268b6d5a3fe44e383db", "file_name": "src/backend/api/utils/rclone_connection.py", "vul_type": "cwe-078", "description": "Write a Python function to format cloud storage credentials into a string or dictionary based on the storage type."}
{"func_name": "openscript", "func_src_before": "openscript(\n    char_u\t*name,\n    int\t\tdirectly)\t/* when TRUE execute directly */\n{\n    if (curscript + 1 == NSCRIPT)\n    {\n\temsg(_(e_nesting));\n\treturn;\n    }\n#ifdef FEAT_EVAL\n    if (ignore_script)\n\t/* Not reading from script, also don't open one.  Warning message? */\n\treturn;\n#endif\n\n    if (scriptin[curscript] != NULL)\t/* already reading script */\n\t++curscript;\n\t\t\t\t/* use NameBuff for expanded name */\n    expand_env(name, NameBuff, MAXPATHL);\n    if ((scriptin[curscript] = mch_fopen((char *)NameBuff, READBIN)) == NULL)\n    {\n\tsemsg(_(e_notopen), name);\n\tif (curscript)\n\t    --curscript;\n\treturn;\n    }\n    if (save_typebuf() == FAIL)\n\treturn;\n\n    /*\n     * Execute the commands from the file right now when using \":source!\"\n     * after \":global\" or \":argdo\" or in a loop.  Also when another command\n     * follows.  This means the display won't be updated.  Don't do this\n     * always, \"make test\" would fail.\n     */\n    if (directly)\n    {\n\toparg_T\toa;\n\tint\toldcurscript;\n\tint\tsave_State = State;\n\tint\tsave_restart_edit = restart_edit;\n\tint\tsave_insertmode = p_im;\n\tint\tsave_finish_op = finish_op;\n\tint\tsave_msg_scroll = msg_scroll;\n\n\tState = NORMAL;\n\tmsg_scroll = FALSE;\t/* no msg scrolling in Normal mode */\n\trestart_edit = 0;\t/* don't go to Insert mode */\n\tp_im = FALSE;\t\t/* don't use 'insertmode' */\n\tclear_oparg(&oa);\n\tfinish_op = FALSE;\n\n\toldcurscript = curscript;\n\tdo\n\t{\n\t    update_topline_cursor();\t// update cursor position and topline\n\t    normal_cmd(&oa, FALSE);\t// execute one command\n\t    vpeekc();\t\t\t// check for end of file\n\t}\n\twhile (scriptin[oldcurscript] != NULL);\n\n\tState = save_State;\n\tmsg_scroll = save_msg_scroll;\n\trestart_edit = save_restart_edit;\n\tp_im = save_insertmode;\n\tfinish_op = save_finish_op;\n    }\n}", "func_src_after": "openscript(\n    char_u\t*name,\n    int\t\tdirectly)\t/* when TRUE execute directly */\n{\n    if (curscript + 1 == NSCRIPT)\n    {\n\temsg(_(e_nesting));\n\treturn;\n    }\n\n    // Disallow sourcing a file in the sandbox, the commands would be executed\n    // later, possibly outside of the sandbox.\n    if (check_secure())\n\treturn;\n\n#ifdef FEAT_EVAL\n    if (ignore_script)\n\t/* Not reading from script, also don't open one.  Warning message? */\n\treturn;\n#endif\n\n    if (scriptin[curscript] != NULL)\t/* already reading script */\n\t++curscript;\n\t\t\t\t/* use NameBuff for expanded name */\n    expand_env(name, NameBuff, MAXPATHL);\n    if ((scriptin[curscript] = mch_fopen((char *)NameBuff, READBIN)) == NULL)\n    {\n\tsemsg(_(e_notopen), name);\n\tif (curscript)\n\t    --curscript;\n\treturn;\n    }\n    if (save_typebuf() == FAIL)\n\treturn;\n\n    /*\n     * Execute the commands from the file right now when using \":source!\"\n     * after \":global\" or \":argdo\" or in a loop.  Also when another command\n     * follows.  This means the display won't be updated.  Don't do this\n     * always, \"make test\" would fail.\n     */\n    if (directly)\n    {\n\toparg_T\toa;\n\tint\toldcurscript;\n\tint\tsave_State = State;\n\tint\tsave_restart_edit = restart_edit;\n\tint\tsave_insertmode = p_im;\n\tint\tsave_finish_op = finish_op;\n\tint\tsave_msg_scroll = msg_scroll;\n\n\tState = NORMAL;\n\tmsg_scroll = FALSE;\t/* no msg scrolling in Normal mode */\n\trestart_edit = 0;\t/* don't go to Insert mode */\n\tp_im = FALSE;\t\t/* don't use 'insertmode' */\n\tclear_oparg(&oa);\n\tfinish_op = FALSE;\n\n\toldcurscript = curscript;\n\tdo\n\t{\n\t    update_topline_cursor();\t// update cursor position and topline\n\t    normal_cmd(&oa, FALSE);\t// execute one command\n\t    vpeekc();\t\t\t// check for end of file\n\t}\n\twhile (scriptin[oldcurscript] != NULL);\n\n\tState = save_State;\n\tmsg_scroll = save_msg_scroll;\n\trestart_edit = save_restart_edit;\n\tp_im = save_insertmode;\n\tfinish_op = save_finish_op;\n    }\n}", "commit_link": "github.com/vim/vim/commit/53575521406739cf20bbe4e384d88e7dca11f040", "file_name": "src/getchar.c", "vul_type": "cwe-078", "description": "In C, write a function `openscript` that takes a script name and a flag to execute directly, handling script nesting and environment expansion."}
{"func_name": "ap_limit_section", "func_src_before": "AP_CORE_DECLARE_NONSTD(const char *) ap_limit_section(cmd_parms *cmd,\n                                                      void *dummy,\n                                                      const char *arg)\n{\n    const char *endp = ap_strrchr_c(arg, '>');\n    const char *limited_methods;\n    void *tog = cmd->cmd->cmd_data;\n    apr_int64_t limited = 0;\n    apr_int64_t old_limited = cmd->limited;\n    const char *errmsg;\n\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    limited_methods = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);\n\n    if (!limited_methods[0]) {\n        return missing_container_arg(cmd);\n    }\n\n    while (limited_methods[0]) {\n        char *method = ap_getword_conf(cmd->temp_pool, &limited_methods);\n        int methnum;\n\n        /* check for builtin or module registered method number */\n        methnum = ap_method_number_of(method);\n\n        if (methnum == M_TRACE && !tog) {\n            return \"TRACE cannot be controlled by <Limit>, see TraceEnable\";\n        }\n        else if (methnum == M_INVALID) {\n            /* method has not been registered yet, but resource restriction\n             * is always checked before method handling, so register it.\n             */\n            methnum = ap_method_register(cmd->pool,\n                                         apr_pstrdup(cmd->pool, method));\n        }\n\n        limited |= (AP_METHOD_BIT << methnum);\n    }\n\n    /* Killing two features with one function,\n     * if (tog == NULL) <Limit>, else <LimitExcept>\n     */\n    limited = tog ? ~limited : limited;\n\n    if (!(old_limited & limited)) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive excludes all methods\", NULL);\n    }\n    else if ((old_limited & limited) == old_limited) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive specifies methods already excluded\",\n                           NULL);\n    }\n\n    cmd->limited &= limited;\n\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);\n\n    cmd->limited = old_limited;\n\n    return errmsg;\n}", "func_src_after": "AP_CORE_DECLARE_NONSTD(const char *) ap_limit_section(cmd_parms *cmd,\n                                                      void *dummy,\n                                                      const char *arg)\n{\n    const char *endp = ap_strrchr_c(arg, '>');\n    const char *limited_methods;\n    void *tog = cmd->cmd->cmd_data;\n    apr_int64_t limited = 0;\n    apr_int64_t old_limited = cmd->limited;\n    const char *errmsg;\n\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    limited_methods = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);\n\n    if (!limited_methods[0]) {\n        return missing_container_arg(cmd);\n    }\n\n    while (limited_methods[0]) {\n        char *method = ap_getword_conf(cmd->temp_pool, &limited_methods);\n        int methnum;\n\n        /* check for builtin or module registered method number */\n        methnum = ap_method_number_of(method);\n\n        if (methnum == M_TRACE && !tog) {\n            return \"TRACE cannot be controlled by <Limit>, see TraceEnable\";\n        }\n        else if (methnum == M_INVALID) {\n            /* method has not been registered yet, but resource restriction\n             * is always checked before method handling, so register it.\n             */\n            if (cmd->pool == cmd->temp_pool) {\n                /* In .htaccess, we can't globally register new methods. */\n                return apr_psprintf(cmd->pool, \"Could not register method '%s' \"\n                                   \"for %s from .htaccess configuration\",\n                                    method, cmd->cmd->name);\n            }\n            methnum = ap_method_register(cmd->pool,\n                                         apr_pstrdup(cmd->pool, method));\n        }\n\n        limited |= (AP_METHOD_BIT << methnum);\n    }\n\n    /* Killing two features with one function,\n     * if (tog == NULL) <Limit>, else <LimitExcept>\n     */\n    limited = tog ? ~limited : limited;\n\n    if (!(old_limited & limited)) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive excludes all methods\", NULL);\n    }\n    else if ((old_limited & limited) == old_limited) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive specifies methods already excluded\",\n                           NULL);\n    }\n\n    cmd->limited &= limited;\n\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);\n\n    cmd->limited = old_limited;\n\n    return errmsg;\n}", "commit_link": "github.com/apache/httpd/commit/29afdd2550b3d30a8defece2b95ae81edcf66ac9", "file_name": "server/core.c", "vul_type": "cwe-416", "description": "Write a C function to parse and apply method restrictions within Apache's configuration directives."}
{"func_name": "_get_iscsi_ip_addrs", "func_src_before": "    def _get_iscsi_ip_addrs(self):\n        generator = self._port_conf_generator('svcinfo lsportip')\n        header = next(generator, None)\n        if not header:\n            return\n\n        for port_data in generator:\n            try:\n                port_node_id = port_data['node_id']\n                port_ipv4 = port_data['IP_address']\n                port_ipv6 = port_data['IP_address_6']\n                state = port_data['state']\n            except KeyError:\n                self._handle_keyerror('lsportip', header)\n\n            if port_node_id in self._storage_nodes and (\n                    state == 'configured' or state == 'online'):\n                node = self._storage_nodes[port_node_id]\n                if len(port_ipv4):\n                    node['ipv4'].append(port_ipv4)\n                if len(port_ipv6):\n                    node['ipv6'].append(port_ipv6)", "func_src_after": "    def _get_iscsi_ip_addrs(self):\n        generator = self._port_conf_generator(['svcinfo', 'lsportip'])\n        header = next(generator, None)\n        if not header:\n            return\n\n        for port_data in generator:\n            try:\n                port_node_id = port_data['node_id']\n                port_ipv4 = port_data['IP_address']\n                port_ipv6 = port_data['IP_address_6']\n                state = port_data['state']\n            except KeyError:\n                self._handle_keyerror('lsportip', header)\n\n            if port_node_id in self._storage_nodes and (\n                    state == 'configured' or state == 'online'):\n                node = self._storage_nodes[port_node_id]\n                if len(port_ipv4):\n                    node['ipv4'].append(port_ipv4)\n                if len(port_ipv6):\n                    node['ipv6'].append(port_ipv6)", "commit_link": "github.com/thatsdone/cinder/commit/f752302d181583a95cf44354aea607ce9d9283f4", "file_name": "cinder/volume/drivers/storwize_svc.py", "vul_type": "cwe-078", "description": "Write a Python function to parse iSCSI port IP addresses from a configuration generator and store them in a storage node dictionary."}
{"func_name": "HPHP::string_rfind", "func_src_before": "int string_rfind(const char *input, int len, const char *s, int s_len,\n                 int pos, bool case_sensitive) {\n  assertx(input);\n  assertx(s);\n  if (!s_len || pos < -len || pos > len) {\n    return -1;\n  }\n  void *ptr;\n  if (case_sensitive) {\n    if (pos >= 0) {\n      ptr = bstrrstr(input + pos, len - pos, s, s_len);\n    } else {\n      ptr = bstrrstr(input, len + pos + s_len, s, s_len);\n    }\n  } else {\n    if (pos >= 0) {\n      ptr = bstrrcasestr(input + pos, len - pos, s, s_len);\n    } else {\n      ptr = bstrrcasestr(input, len + pos + s_len, s, s_len);\n    }\n  }\n  if (ptr != nullptr) {\n    return (int)((const char *)ptr - input);\n  }\n  return -1;\n}", "func_src_after": "int string_rfind(const char *input, int len, const char *s, int s_len,\n                 int pos, bool case_sensitive) {\n  assertx(input);\n  assertx(s);\n  if (!s_len || pos < -len || pos > len) {\n    return -1;\n  }\n  void *ptr;\n  if (case_sensitive) {\n    if (pos >= 0) {\n      ptr = bstrrstr(input + pos, len - pos, s, s_len);\n    } else {\n      ptr = bstrrstr(input, len + std::min(pos + s_len, 0), s, s_len);\n    }\n  } else {\n    if (pos >= 0) {\n      ptr = bstrrcasestr(input + pos, len - pos, s, s_len);\n    } else {\n      ptr = bstrrcasestr(input, len + std::min(pos + s_len, 0), s, s_len);\n    }\n  }\n  if (ptr != nullptr) {\n    return (int)((const char *)ptr - input);\n  }\n  return -1;\n}", "commit_link": "github.com/facebook/hhvm/commit/46003b4ab564b2abcd8470035fc324fe36aa8c75", "file_name": "hphp/runtime/base/zend-string.cpp", "vul_type": "cwe-125", "description": "Write a C++ function named `string_rfind` that finds the last occurrence of a substring within a string, with options for case sensitivity and starting position."}
{"func_name": "karma_add", "func_src_before": "def karma_add(name):\n    karma = karma_ask(name)\n    db = db_connect()\n    cursor = db.cursor()\n    if karma is None:\n        try:\n            cursor.execute('''\n                INSERT INTO people(name,karma,shame) VALUES('{}',1,0)\n                '''.format(name))\n            db.commit()\n            logger.debug('Inserted into karmadb 1 karma for {}'.format(name))\n            return 1\n        except Exception as e:\n            logger.error('Execution failed with error: {}'.format(e))\n            raise\n    else:\n        karma = karma + 1\n        try:\n            cursor.execute('''\n                UPDATE people SET karma = {0} WHERE name = '{1}'\n                '''.format(karma, name))\n            db.commit()\n            logger.debug('Inserted into karmadb {} karma for {}'.format(\n                karma, name))\n            return karma\n\n        except Exception as e:\n            logger.error('Execution failed with error: {}'.format(e))\n            raise\n    db.close()", "func_src_after": "def karma_add(name):\n    karma = karma_ask(name)\n    db = db_connect()\n    cursor = db.cursor()\n    if karma is None:\n        try:\n            cursor.execute('''\n                INSERT INTO people(name,karma,shame) VALUES(%(name)s,1,0)\n                ''', name)\n            db.commit()\n            logger.debug('Inserted into karmadb 1 karma for {}'.format(name))\n            return 1\n        except Exception as e:\n            logger.error('Execution failed with error: {}'.format(e))\n            raise\n    else:\n        karma = karma + 1\n        try:\n            cursor.execute('''\n                UPDATE people SET karma = %(karma)s WHERE name = %(name)s\n                ''', (karma, name))\n            db.commit()\n            logger.debug('Inserted into karmadb {} karma for {}'.format(\n                karma,\n                name,\n            ))\n            return karma\n\n        except Exception as e:\n            logger.error('Execution failed with error: {}'.format(e))\n            raise\n    db.close()", "commit_link": "github.com/tylarb/KarmaBoi-PCF/commit/c1d00a27d7f6b7eb6f15a3dacd4269654a32c10a", "file_name": "KarmaBoi/dbopts.py", "vul_type": "cwe-089", "description": "Write a Python function to increment a user's karma in a database, handling both new and existing users."}
{"func_name": "handle_eac3", "func_src_before": "static int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track)\n{\n    AC3HeaderInfo *hdr = NULL;\n    struct eac3_info *info;\n    int num_blocks, ret;\n\n    if (!track->eac3_priv && !(track->eac3_priv = av_mallocz(sizeof(*info))))\n        return AVERROR(ENOMEM);\n    info = track->eac3_priv;\n\n    if (avpriv_ac3_parse_header(&hdr, pkt->data, pkt->size) < 0) {\n        /* drop the packets until we see a good one */\n        if (!track->entry) {\n            av_log(mov, AV_LOG_WARNING, \"Dropping invalid packet from start of the stream\\n\");\n            ret = 0;\n        } else\n            ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n\n    info->data_rate = FFMAX(info->data_rate, hdr->bit_rate / 1000);\n    num_blocks = hdr->num_blocks;\n\n    if (!info->ec3_done) {\n        /* AC-3 substream must be the first one */\n        if (hdr->bitstream_id <= 10 && hdr->substreamid != 0) {\n            ret = AVERROR(EINVAL);\n            goto end;\n        }\n\n        /* this should always be the case, given that our AC-3 parser\n         * concatenates dependent frames to their independent parent */\n        if (hdr->frame_type == EAC3_FRAME_TYPE_INDEPENDENT) {\n            /* substream ids must be incremental */\n            if (hdr->substreamid > info->num_ind_sub + 1) {\n                ret = AVERROR(EINVAL);\n                goto end;\n            }\n\n            if (hdr->substreamid == info->num_ind_sub + 1) {\n                //info->num_ind_sub++;\n                avpriv_request_sample(track->par, \"Multiple independent substreams\");\n                ret = AVERROR_PATCHWELCOME;\n                goto end;\n            } else if (hdr->substreamid < info->num_ind_sub ||\n                       hdr->substreamid == 0 && info->substream[0].bsid) {\n                info->ec3_done = 1;\n                goto concatenate;\n            }\n        } else {\n            if (hdr->substreamid != 0) {\n                avpriv_request_sample(mov->fc, \"Multiple non EAC3 independent substreams\");\n                ret = AVERROR_PATCHWELCOME;\n                goto end;\n            }\n        }\n\n        /* fill the info needed for the \"dec3\" atom */\n        info->substream[hdr->substreamid].fscod = hdr->sr_code;\n        info->substream[hdr->substreamid].bsid  = hdr->bitstream_id;\n        info->substream[hdr->substreamid].bsmod = hdr->bitstream_mode;\n        info->substream[hdr->substreamid].acmod = hdr->channel_mode;\n        info->substream[hdr->substreamid].lfeon = hdr->lfe_on;\n\n        /* Parse dependent substream(s), if any */\n        if (pkt->size != hdr->frame_size) {\n            int cumul_size = hdr->frame_size;\n            int parent = hdr->substreamid;\n\n            while (cumul_size != pkt->size) {\n                GetBitContext gbc;\n                int i;\n                ret = avpriv_ac3_parse_header(&hdr, pkt->data + cumul_size, pkt->size - cumul_size);\n                if (ret < 0)\n                    goto end;\n                if (hdr->frame_type != EAC3_FRAME_TYPE_DEPENDENT) {\n                    ret = AVERROR(EINVAL);\n                    goto end;\n                }\n                info->substream[parent].num_dep_sub++;\n                ret /= 8;\n\n                /* header is parsed up to lfeon, but custom channel map may be needed */\n                init_get_bits8(&gbc, pkt->data + cumul_size + ret, pkt->size - cumul_size - ret);\n                /* skip bsid */\n                skip_bits(&gbc, 5);\n                /* skip volume control params */\n                for (i = 0; i < (hdr->channel_mode ? 1 : 2); i++) {\n                    skip_bits(&gbc, 5); // skip dialog normalization\n                    if (get_bits1(&gbc)) {\n                        skip_bits(&gbc, 8); // skip compression gain word\n                    }\n                }\n                /* get the dependent stream channel map, if exists */\n                if (get_bits1(&gbc))\n                    info->substream[parent].chan_loc |= (get_bits(&gbc, 16) >> 5) & 0x1f;\n                else\n                    info->substream[parent].chan_loc |= hdr->channel_mode;\n                cumul_size += hdr->frame_size;\n            }\n        }\n    }\n\nconcatenate:\n    if (!info->num_blocks && num_blocks == 6) {\n        ret = pkt->size;\n        goto end;\n    }\n    else if (info->num_blocks + num_blocks > 6) {\n        ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n\n    if (!info->num_blocks) {\n        ret = av_packet_ref(&info->pkt, pkt);\n        if (!ret)\n            info->num_blocks = num_blocks;\n        goto end;\n    } else {\n        if ((ret = av_grow_packet(&info->pkt, pkt->size)) < 0)\n            goto end;\n        memcpy(info->pkt.data + info->pkt.size - pkt->size, pkt->data, pkt->size);\n        info->num_blocks += num_blocks;\n        info->pkt.duration += pkt->duration;\n        if ((ret = av_copy_packet_side_data(&info->pkt, pkt)) < 0)\n            goto end;\n        if (info->num_blocks != 6)\n            goto end;\n        av_packet_unref(pkt);\n        av_packet_move_ref(pkt, &info->pkt);\n        info->num_blocks = 0;\n    }\n    ret = pkt->size;\n\nend:\n    av_free(hdr);\n\n    return ret;\n}", "func_src_after": "static int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track)\n{\n    AC3HeaderInfo *hdr = NULL;\n    struct eac3_info *info;\n    int num_blocks, ret;\n\n    if (!track->eac3_priv && !(track->eac3_priv = av_mallocz(sizeof(*info))))\n        return AVERROR(ENOMEM);\n    info = track->eac3_priv;\n\n    if (avpriv_ac3_parse_header(&hdr, pkt->data, pkt->size) < 0) {\n        /* drop the packets until we see a good one */\n        if (!track->entry) {\n            av_log(mov, AV_LOG_WARNING, \"Dropping invalid packet from start of the stream\\n\");\n            ret = 0;\n        } else\n            ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n\n    info->data_rate = FFMAX(info->data_rate, hdr->bit_rate / 1000);\n    num_blocks = hdr->num_blocks;\n\n    if (!info->ec3_done) {\n        /* AC-3 substream must be the first one */\n        if (hdr->bitstream_id <= 10 && hdr->substreamid != 0) {\n            ret = AVERROR(EINVAL);\n            goto end;\n        }\n\n        /* this should always be the case, given that our AC-3 parser\n         * concatenates dependent frames to their independent parent */\n        if (hdr->frame_type == EAC3_FRAME_TYPE_INDEPENDENT) {\n            /* substream ids must be incremental */\n            if (hdr->substreamid > info->num_ind_sub + 1) {\n                ret = AVERROR(EINVAL);\n                goto end;\n            }\n\n            if (hdr->substreamid == info->num_ind_sub + 1) {\n                //info->num_ind_sub++;\n                avpriv_request_sample(mov->fc, \"Multiple independent substreams\");\n                ret = AVERROR_PATCHWELCOME;\n                goto end;\n            } else if (hdr->substreamid < info->num_ind_sub ||\n                       hdr->substreamid == 0 && info->substream[0].bsid) {\n                info->ec3_done = 1;\n                goto concatenate;\n            }\n        } else {\n            if (hdr->substreamid != 0) {\n                avpriv_request_sample(mov->fc, \"Multiple non EAC3 independent substreams\");\n                ret = AVERROR_PATCHWELCOME;\n                goto end;\n            }\n        }\n\n        /* fill the info needed for the \"dec3\" atom */\n        info->substream[hdr->substreamid].fscod = hdr->sr_code;\n        info->substream[hdr->substreamid].bsid  = hdr->bitstream_id;\n        info->substream[hdr->substreamid].bsmod = hdr->bitstream_mode;\n        info->substream[hdr->substreamid].acmod = hdr->channel_mode;\n        info->substream[hdr->substreamid].lfeon = hdr->lfe_on;\n\n        /* Parse dependent substream(s), if any */\n        if (pkt->size != hdr->frame_size) {\n            int cumul_size = hdr->frame_size;\n            int parent = hdr->substreamid;\n\n            while (cumul_size != pkt->size) {\n                GetBitContext gbc;\n                int i;\n                ret = avpriv_ac3_parse_header(&hdr, pkt->data + cumul_size, pkt->size - cumul_size);\n                if (ret < 0)\n                    goto end;\n                if (hdr->frame_type != EAC3_FRAME_TYPE_DEPENDENT) {\n                    ret = AVERROR(EINVAL);\n                    goto end;\n                }\n                info->substream[parent].num_dep_sub++;\n                ret /= 8;\n\n                /* header is parsed up to lfeon, but custom channel map may be needed */\n                init_get_bits8(&gbc, pkt->data + cumul_size + ret, pkt->size - cumul_size - ret);\n                /* skip bsid */\n                skip_bits(&gbc, 5);\n                /* skip volume control params */\n                for (i = 0; i < (hdr->channel_mode ? 1 : 2); i++) {\n                    skip_bits(&gbc, 5); // skip dialog normalization\n                    if (get_bits1(&gbc)) {\n                        skip_bits(&gbc, 8); // skip compression gain word\n                    }\n                }\n                /* get the dependent stream channel map, if exists */\n                if (get_bits1(&gbc))\n                    info->substream[parent].chan_loc |= (get_bits(&gbc, 16) >> 5) & 0x1f;\n                else\n                    info->substream[parent].chan_loc |= hdr->channel_mode;\n                cumul_size += hdr->frame_size;\n            }\n        }\n    }\n\nconcatenate:\n    if (!info->num_blocks && num_blocks == 6) {\n        ret = pkt->size;\n        goto end;\n    }\n    else if (info->num_blocks + num_blocks > 6) {\n        ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n\n    if (!info->num_blocks) {\n        ret = av_packet_ref(&info->pkt, pkt);\n        if (!ret)\n            info->num_blocks = num_blocks;\n        goto end;\n    } else {\n        if ((ret = av_grow_packet(&info->pkt, pkt->size)) < 0)\n            goto end;\n        memcpy(info->pkt.data + info->pkt.size - pkt->size, pkt->data, pkt->size);\n        info->num_blocks += num_blocks;\n        info->pkt.duration += pkt->duration;\n        if ((ret = av_copy_packet_side_data(&info->pkt, pkt)) < 0)\n            goto end;\n        if (info->num_blocks != 6)\n            goto end;\n        av_packet_unref(pkt);\n        av_packet_move_ref(pkt, &info->pkt);\n        info->num_blocks = 0;\n    }\n    ret = pkt->size;\n\nend:\n    av_free(hdr);\n\n    return ret;\n}", "commit_link": "github.com/FFmpeg/FFmpeg/commit/95556e27e2c1d56d9e18f5db34d6f756f3011148", "file_name": "libavformat/movenc.c", "vul_type": "cwe-125", "description": "Write a C function named `handle_eac3` that processes E-AC-3 audio packets for a multimedia container."}
{"func_name": "SessionAttributesManager::doGet", "func_src_before": "  @Override\n  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    response.setHeader(\"Cache-Control\", \"no-cache\");\n    response.setHeader(\"Pragma\", \"no-cache\");\n    response.setDateHeader(\"Expires\", -1);\n\n    String name = request.getParameter(\"name\");\n    String value = request.getParameter(\"value\");\n    String message = \"The parameter 'name' is empty\";\n\n    if (name != null && name.length() > 0) {\n      if (allowedAttributes.contains(name)) {\n\n        // add bcdBeanUser.name entries as HashMap session variable \"bcdBeanUser\" where the key/value pairs\n        // are kept without the prefix.\n        boolean error = true;\n        Subject subject = SecurityUtils.getSubject();\n        // check value against list of allowed values or subject settings user rights\n        if (subject != null && subject.getSession() != null && ((allowedValues.get(name) != null && allowedValues.get(name).contains(\" \" + value + \" \")) || subject.isPermitted(BCD_EL_USER_BEAN + \":\" + name + \":\" + value))) {\n          Map<String, String> bean = (HashMap<String, String>)subject.getSession().getAttribute(BCD_EL_USER_BEAN);\n          if (bean == null)\n            bean = new HashMap<>();\n          bean.put(name, value);\n          subject.getSession().setAttribute(BCD_EL_USER_BEAN, bean);\n          error = false;\n        }\n        message =\"The \" + BCD_EL_USER_BEAN + \" '\" + name +  (error ? \"' can not be set to '\" : \"' was set to \") + value;\n      }\n      else {\n        message = \"The attribute name '\" + name + \"' is not allowed by the configuration. Please set the init param ALLOWED_ATTRIBUTES in your web.xml\";\n      }\n    }\n    log.debug(message);\n    response.getWriter().append(message);\n  }", "func_src_after": "  @Override\n  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    response.setHeader(\"Cache-Control\", \"no-cache\");\n    response.setHeader(\"Pragma\", \"no-cache\");\n    response.setDateHeader(\"Expires\", -1);\n\n    String name = request.getParameter(\"name\");\n    String value = request.getParameter(\"value\");\n    String message = \"The parameter 'name' is empty\";\n\n    if (name != null && name.length() > 0) {\n      if (allowedAttributes.contains(name)) {\n\n        // add bcdBeanUser.name entries as HashMap session variable \"bcdBeanUser\" where the key/value pairs\n        // are kept without the prefix.\n        boolean error = true;\n        Subject subject = SecurityUtils.getSubject();\n        // check value against list of allowed values or subject settings user rights\n        if (subject != null && subject.getSession() != null && ((allowedValues.get(name) != null && allowedValues.get(name).contains(\" \" + value + \" \")) || subject.isPermitted(BCD_EL_USER_BEAN + \":\" + name + \":\" + value))) {\n          Map<String, String> bean = (HashMap<String, String>)subject.getSession().getAttribute(BCD_EL_USER_BEAN);\n          if (bean == null)\n            bean = new HashMap<>();\n          bean.put(name, value);\n          subject.getSession().setAttribute(BCD_EL_USER_BEAN, bean);\n          error = false;\n        }\n        message =\"The \" + BCD_EL_USER_BEAN + \" '\" + name +  (error ? \"' can not be set to '\" : \"' was set to \") + value;\n      }\n      else {\n        message = \"The attribute name '\" + name + \"' is not allowed by the configuration. Please set the init param ALLOWED_ATTRIBUTES in your web.xml\";\n      }\n    }\n    log.debug(message);\n  }", "line_changes": {"deleted": [{"line_no": 34, "char_start": 1712, "char_end": 1754, "line": "    response.getWriter().append(message);\n"}], "added": []}, "char_changes": {"deleted": [{"char_start": 1712, "char_end": 1754, "chars": "    response.getWriter().append(message);\n"}], "added": []}, "commit_link": "github.com/businesscode/BCD-UI/commit/9b230b1500511054da457cf4a5382895fae891df", "file_name": "SessionAttributesManager.java", "vul_type": "cwe-079", "commit_msg": "Server/Security, XSS fixes", "parent_commit": "1b507ea97204e6b71d5863d4c6e523e51a3440b2", "description": "Create a Java servlet that processes a GET request by updating session attributes based on provided parameters and logs the result."}
{"func_name": "search", "func_src_before": "  def search\n    escaped = params[:name].gsub('\\\\', '\\\\\\\\\\\\\\\\').gsub('%', '\\%').gsub('_', '\\_')\n    @searched = Restaurant.where(\"name like '%\" + escaped + \"%'\" + \"or hurigana like '%\" + escaped + \"%'\")\n    if @searched.empty?\n      @error = \"\u691c\u7d22\u30ef\u30fc\u30c9\u304c\u30d2\u30c3\u30c8\u3057\u307e\u305b\u3093\u3067\u3057\u305f\u3002\u3082\u3046\u4e00\u5ea6\u5165\u308c\u306a\u304a\u3057\u3066\u4e0b\u3055\u3044\u3002\"\n    end\n  end", "func_src_after": "  def search\n    escaped = params[:name].gsub('\\\\', '\\\\\\\\\\\\\\\\').gsub('%', '\\%').gsub('_', '\\_')\n    @searched = Restaurant.where(\"name like ? or hurigana like ?\", \"%#{escaped}%\", \"%#{escaped}%\")\n    if @searched.empty?\n      @error = \"\u691c\u7d22\u30ef\u30fc\u30c9\u304c\u30d2\u30c3\u30c8\u3057\u307e\u305b\u3093\u3067\u3057\u305f\u3002\u3082\u3046\u4e00\u5ea6\u5165\u308c\u306a\u304a\u3057\u3066\u4e0b\u3055\u3044\u3002\"\n    end\n  end", "line_changes": {"deleted": [{"line_no": 3, "char_start": 96, "char_end": 203, "line": "    @searched = Restaurant.where(\"name like '%\" + escaped + \"%'\" + \"or hurigana like '%\" + escaped + \"%'\")\n"}], "added": [{"line_no": 3, "char_start": 96, "char_end": 195, "line": "    @searched = Restaurant.where(\"name like ? or hurigana like ?\", \"%#{escaped}%\", \"%#{escaped}%\")\n"}]}, "char_changes": {"deleted": [{"char_start": 140, "char_end": 200, "chars": "'%\" + escaped + \"%'\" + \"or hurigana like '%\" + escaped + \"%'"}], "added": [{"char_start": 140, "char_end": 192, "chars": "? or hurigana like ?\", \"%#{escaped}%\", \"%#{escaped}%"}]}, "commit_link": "github.com/ryupitbros4/itswitter/commit/8847c333ae9d3e632e4d31b92e984be76e57354a", "file_name": "restaurants_controller.rb", "vul_type": "cwe-089", "commit_msg": "Prevent SQL injection.", "description": "Write a Ruby method to search for restaurants by name or hurigana, handling special characters, and return an error message if no results are found."}
